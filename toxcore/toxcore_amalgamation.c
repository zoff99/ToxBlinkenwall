
/*
 * Copyright © 2023 Zoff
 *
 * This file is part of Tox, the free peer to peer instant messenger.
 *
 * Tox is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Tox is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Tox.  If not, see <http://www.gnu.org/licenses/>.
 */


/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2021 The TokTok team.
 */

/**
 * C language compatibility macros for varying compiler support.
 */
#ifndef C_TOXCORE_TOXCORE_CCOMPAT_H
#define C_TOXCORE_TOXCORE_CCOMPAT_H

#include <stddef.h>  // NULL, size_t


//!TOKSTYLE-

// Variable length arrays.
// VLA(type, name, size) allocates a variable length array with automatic
// storage duration. VLA_SIZE(name) evaluates to the runtime size of that array
// in bytes.
//
// If C99 VLAs are not available, an emulation using alloca (stack allocation
// "function") is used. Note the semantic difference: alloca'd memory does not
// get freed at the end of the declaration's scope. Do not use VLA() in loops or
// you may run out of stack space.
#if !defined(DISABLE_VLA) && !defined(_MSC_VER) && defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
// C99 VLAs.
#define ALLOC_VLA(type, name, size) type name[size]
#define SIZEOF_VLA sizeof
#else

// Emulation using alloca.
#ifdef _WIN32
#include <malloc.h>
#elif defined(__COMPCERT__)
// TODO(iphydf): This leaks memory like crazy, so compcert is useless for now.
// Once we're rid of VLAs, we can remove this and compcert becomes useful.
#define alloca malloc
#include <stdlib.h>
#elif defined(__linux__)
#include <alloca.h>
#else
#include <stdlib.h>
#if !defined(alloca) && defined(__GNUC__)
#define alloca __builtin_alloca
#endif
#endif

#define ALLOC_VLA(type, name, size)                       \
    const size_t name##_vla_size = (size) * sizeof(type); \
    type *const name = (type *)alloca(name##_vla_size)
#define SIZEOF_VLA(name) name##_vla_size

#endif

#ifdef MAX_VLA_SIZE
#include <assert.h>
#define VLA(type, name, size)    \
    ALLOC_VLA(type, name, size); \
    assert((size_t)(size) * sizeof(type) <= MAX_VLA_SIZE)
#else
#define VLA ALLOC_VLA
#endif

#if !defined(__cplusplus) || __cplusplus < 201103L
#define nullptr NULL
#ifndef static_assert
#ifdef __GNUC__
// We'll just assume gcc and clang support C11 _Static_assert.
#define static_assert _Static_assert
#else // !__GNUC__
#define STATIC_ASSERT_(cond, msg, line) typedef int static_assert_##line[(cond) ? 1 : -1]
#define STATIC_ASSERT(cond, msg, line) STATIC_ASSERT_(cond, msg, line)
#define static_assert(cond, msg) STATIC_ASSERT(cond, msg, __LINE__)
#endif // !__GNUC__
#endif // !static_assert
#endif // !__cplusplus

#ifdef __GNUC__
#define GNU_PRINTF(f, a) __attribute__((__format__(__printf__, f, a)))
#else
#define GNU_PRINTF(f, a)
#endif

//!TOKSTYLE+

#endif // C_TOXCORE_TOXCORE_CCOMPAT_H
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2022 The TokTok team.
 */

/**
 * printf and nonnull attributes for GCC/Clang and Cimple.
 */
#ifndef C_TOXCORE_TOXCORE_ATTRIBUTES_H
#define C_TOXCORE_TOXCORE_ATTRIBUTES_H

/* No declarations here. */

//!TOKSTYLE-

#ifdef __GNUC__
#define GNU_PRINTF(f, a) __attribute__((__format__(__printf__, f, a)))
#else
#define GNU_PRINTF(f, a)
#endif

#if defined(__GNUC__) && defined(_DEBUG) && !defined(__OPTIMIZE__)
#define non_null(...) __attribute__((__nonnull__(__VA_ARGS__)))
#else
#define non_null(...)
#endif

#define nullable(...)

//!TOKSTYLE+

#endif // C_TOXCORE_TOXCORE_ATTRIBUTES_H
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2018 The TokTok team.
 * Copyright © 2013 Tox project.
 */

/**
 * Logger abstraction backed by callbacks for writing.
 */
#ifndef C_TOXCORE_TOXCORE_LOGGER_H
#define C_TOXCORE_TOXCORE_LOGGER_H

#include <stdint.h>
#include <stdarg.h>
#include <pthread.h>


#ifdef __cplusplus
extern "C" {
#endif

#ifdef MUTEXLOCKINGDEBUG
/*
 * hook mutex function so we can nicely log them (to the NULL logger!)
 */
#define pthread_mutex_lock(MTX) my_pthread_mutex_lock(MTX, #MTX, __FILE__, __LINE__, __func__)
#define pthread_mutex_unlock(MTX) my_pthread_mutex_unlock(MTX, #MTX, __FILE__, __LINE__, __func__)

int my_pthread_mutex_lock(pthread_mutex_t *mutex, const char *mutex_name, const char *file, int line, const char *func);
int my_pthread_mutex_unlock(pthread_mutex_t *mutex, const char *mutex_name, const char *file, int line, const char *func);
#endif

#ifndef MIN_LOGGER_LEVEL
#define MIN_LOGGER_LEVEL LOGGER_LEVEL_INFO
#endif

// NOTE: Don't forget to update build system files after modifying the enum.
typedef enum Logger_Level {
    LOGGER_LEVEL_TRACE,
    LOGGER_LEVEL_DEBUG,
    LOGGER_LEVEL_INFO,
    LOGGER_LEVEL_WARNING,
    LOGGER_LEVEL_ERROR,
} Logger_Level;

typedef struct Logger Logger;

typedef void logger_cb(void *context, Logger_Level level, const char *file, int line,
                       const char *func, const char *message, void *userdata);

/**
 * Creates a new logger with logging disabled (callback is NULL) by default.
 */
Logger *logger_new(void);

/**
 * Frees all resources associated with the logger.
 */
nullable(1)
void logger_kill(Logger *log);

/**
 * Sets the logger callback. Disables logging if set to NULL.
 * The context parameter is passed to the callback as first argument.
 */
non_null(1) nullable(2, 3, 4)
void logger_callback_log(Logger *log, logger_cb *function, void *context, void *userdata);

/** @brief Main write function. If logging is disabled, this does nothing.
 *
 * If the logger is NULL and `NDEBUG` is not defined, this writes to stderr.
 * This behaviour should not be used in production code, but can be useful for
 * temporarily debugging a function that does not have a logger available. It's
 * essentially `fprintf(stderr, ...)`, but with source location.
 *
 * If `NDEBUG` is defined, the NULL logger does nothing.
 */
non_null(3, 5, 6) nullable(1) GNU_PRINTF(6, 7)
void logger_write(
    const Logger *log, Logger_Level level, const char *file, int line, const char *func,
    const char *format, ...);

void logger_api_write(const Logger *log, Logger_Level level, const char *file, int line, const char *func,
                      const char *format, va_list args) GNU_PRINTF(6, 0);

/**
 * ==================================================================================================
 * toxcore public api call to logger, used by ToxAV
 */
#ifndef TOX_DEFINED
#define TOX_DEFINED
typedef struct Tox Tox;
#endif /* TOX_DEFINED */

void tox_logmsg(const Tox *tox, Logger_Level level, const char *file, int line, const char *func, const char *fmt,
                ...) GNU_PRINTF(6, 7);

#define LOGGER_API_TRACE(tox, ...)   LOGGER_API_WRITE(tox, LOGGER_LEVEL_TRACE  , __VA_ARGS__)
#define LOGGER_API_DEBUG(tox, ...)   LOGGER_API_WRITE(tox, LOGGER_LEVEL_DEBUG  , __VA_ARGS__)
#define LOGGER_API_INFO(tox, ...)    LOGGER_API_WRITE(tox, LOGGER_LEVEL_INFO   , __VA_ARGS__)
#define LOGGER_API_WARNING(tox, ...) LOGGER_API_WRITE(tox, LOGGER_LEVEL_WARNING, __VA_ARGS__)
#define LOGGER_API_ERROR(tox, ...)   LOGGER_API_WRITE(tox, LOGGER_LEVEL_ERROR  , __VA_ARGS__)

#define LOGGER_API_WRITE(tox, level, ...) \
    do { \
        if (level >= MIN_LOGGER_LEVEL) { \
            tox_logmsg(tox, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
        } \
    } while (0)

/**
 * ==================================================================================================
 */

#define LOGGER_WRITE(log, level, ...)                                            \
    do {                                                                         \
        if (level >= MIN_LOGGER_LEVEL) {                                         \
            logger_write(log, level, __FILE__, __LINE__, __func__, __VA_ARGS__); \
        }                                                                        \
    } while (0)

/* To log with an logger */
#define LOGGER_TRACE(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_TRACE, __VA_ARGS__)
#define LOGGER_DEBUG(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_DEBUG, __VA_ARGS__)
#define LOGGER_INFO(log, ...)    LOGGER_WRITE(log, LOGGER_LEVEL_INFO, __VA_ARGS__)
#define LOGGER_WARNING(log, ...) LOGGER_WRITE(log, LOGGER_LEVEL_WARNING, __VA_ARGS__)
#define LOGGER_ERROR(log, ...)   LOGGER_WRITE(log, LOGGER_LEVEL_ERROR, __VA_ARGS__)

#define LOGGER_FATAL(log, ...)          \
    do {                                \
        LOGGER_ERROR(log, __VA_ARGS__); \
        abort();                        \
    } while (0)

#define LOGGER_ASSERT(log, cond, ...)              \
    do {                                           \
        if (!(cond)) {                             \
            LOGGER_ERROR(log, "Assertion failed"); \
            LOGGER_FATAL(log, __VA_ARGS__);        \
        }                                          \
    } while (0)

#ifdef __cplusplus
}  // extern "C"
#endif

#endif // C_TOXCORE_TOXCORE_LOGGER_H
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2020 The TokTok team.
 * Copyright © 2014 Tox project.
 */
#ifndef C_TOXCORE_TOXCORE_MONO_TIME_H
#define C_TOXCORE_TOXCORE_MONO_TIME_H

#include <stdbool.h>
#include <stdint.h>


#ifdef __cplusplus
extern "C" {
#endif

/**
 * The timer portion of the toxcore event loop.
 *
 * We update the time exactly once per tox_iterate call. Programs built on lower
 * level APIs such as the DHT bootstrap node must update the time manually in
 * each iteration.
 *
 * Time is kept per Tox instance, not globally, even though "time" as a concept
 * is global. This is because by definition `mono_time` represents the time at
 * the start of an iteration, and also by definition the time when all network
 * events for the current iteration occurred. This affects mainly two situations:
 *
 * 1. Two timers started in the same iteration: e.g. two timers set to expire in
 *    10 seconds will both expire at the same time, i.e. about 10 seconds later.
 *    If the time were global, `mono_time` would be a random number that is
 *    either the time at the start of an iteration, or 1 second later (since the
 *    timer resolution is 1 second). This can happen when one update happens at
 *    e.g. 10:00:00.995 and a few milliseconds later a concurrently running
 *    instance updates the time at 10:00:01.005, making one timer expire a
 *    second after the other.
 * 2. One timer based on an event: if we want to encode a behaviour of a timer
 *    expiring e.g. 10 seconds after a network event occurred, we simply start a
 *    timer in the event handler. If a concurrent instance updates the time
 *    underneath us, it may instead expire 9 seconds after the event.
 *
 * Both these situations cause incorrect behaviour randomly. In practice,
 * toxcore is somewhat robust against strange timer behaviour, but the
 * implementation should at least theoretically match the specification.
 */
typedef struct Mono_Time Mono_Time;

typedef uint64_t mono_time_current_time_cb(void *user_data);

nullable(1, 2)
Mono_Time *mono_time_new(mono_time_current_time_cb *current_time_callback, void *user_data);

nullable(1)
void mono_time_free(Mono_Time *mono_time);

/**
 * Update mono_time; subsequent calls to mono_time_get or mono_time_is_timeout
 * will use the time at the call to mono_time_update.
 */
non_null()
void mono_time_update(Mono_Time *mono_time);

/**
 * Return unix time since epoch in seconds.
 */
non_null()
uint64_t mono_time_get(const Mono_Time *mono_time);

/**
 * Return true iff timestamp is at least timeout seconds in the past.
 */
non_null()
bool mono_time_is_timeout(const Mono_Time *mono_time, uint64_t timestamp, uint64_t timeout);

/**
 * Return current monotonic time in milliseconds (ms). The starting point is
 * unspecified.
 */
non_null()
uint64_t current_time_monotonic(Mono_Time *mono_time);

/**
 * Override implementation of `current_time_monotonic()` (for tests).
 *
 * The caller is obligated to ensure that `current_time_monotonic()` continues
 * to increase monotonically.
 */
non_null(1) nullable(2, 3)
void mono_time_set_current_time_callback(Mono_Time *mono_time,
        mono_time_current_time_cb *current_time_callback, void *user_data);

#ifdef __cplusplus
}
#endif

#endif // C_TOXCORE_TOXCORE_MONO_TIME_H
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2018 The TokTok team.
 * Copyright © 2013 Tox project.
 */

/** @file
 * @brief Functions for the core crypto.
 */
#ifndef C_TOXCORE_TOXCORE_CRYPTO_CORE_H
#define C_TOXCORE_TOXCORE_CRYPTO_CORE_H

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>


#ifdef __cplusplus
extern "C" {
#endif

/**
 * The number of bytes in a signature.
 */
#define CRYPTO_SIGNATURE_SIZE          64

/**
 * The number of bytes in a Tox public key used for signatures.
 */
#define CRYPTO_SIGN_PUBLIC_KEY_SIZE    32

/**
 * The number of bytes in a Tox secret key used for signatures.
 */
#define CRYPTO_SIGN_SECRET_KEY_SIZE    64

/**
 * @brief The number of bytes in a Tox public key used for encryption.
 */
#define CRYPTO_PUBLIC_KEY_SIZE         32

/**
 * @brief The number of bytes in a Tox secret key used for encryption.
 */
#define CRYPTO_SECRET_KEY_SIZE         32

/**
 * @brief The number of bytes in a shared key computed from public and secret keys.
 */
#define CRYPTO_SHARED_KEY_SIZE         32

/**
 * @brief The number of bytes in a symmetric key.
 */
#define CRYPTO_SYMMETRIC_KEY_SIZE      CRYPTO_SHARED_KEY_SIZE

/**
 * @brief The number of bytes needed for the MAC (message authentication code) in an
 *   encrypted message.
 */
#define CRYPTO_MAC_SIZE                16

/**
 * @brief The number of bytes in a nonce used for encryption/decryption.
 */
#define CRYPTO_NONCE_SIZE              24

/**
 * @brief The number of bytes in a SHA256 hash.
 */
#define CRYPTO_SHA256_SIZE             32

/**
 * @brief The number of bytes in a SHA512 hash.
 */
#define CRYPTO_SHA512_SIZE             64

typedef void crypto_random_bytes_cb(void *obj, uint8_t *bytes, size_t length);
typedef uint32_t crypto_random_uniform_cb(void *obj, uint32_t upper_bound);

typedef struct Random_Funcs {
    crypto_random_bytes_cb *random_bytes;
    crypto_random_uniform_cb *random_uniform;
} Random_Funcs;

typedef struct Random {
    const Random_Funcs *funcs;
    void *obj;
} Random;

const Random *system_random(void);

/**
 * @brief The number of bytes in an encryption public key used by DHT group chats.
 */
#define ENC_PUBLIC_KEY_SIZE            CRYPTO_PUBLIC_KEY_SIZE

/**
 * @brief The number of bytes in an encryption secret key used by DHT group chats.
 */
#define ENC_SECRET_KEY_SIZE            CRYPTO_SECRET_KEY_SIZE

/**
 * @brief The number of bytes in a signature public key.
 */
#define SIG_PUBLIC_KEY_SIZE            CRYPTO_SIGN_PUBLIC_KEY_SIZE

/**
 * @brief The number of bytes in a signature secret key.
 */
#define SIG_SECRET_KEY_SIZE            CRYPTO_SIGN_SECRET_KEY_SIZE

/**
 * @brief The number of bytes in a DHT group chat public key identifier.
 */
#define CHAT_ID_SIZE                   SIG_PUBLIC_KEY_SIZE

/**
 * @brief The number of bytes in an extended public key used by DHT group chats.
 */
#define EXT_PUBLIC_KEY_SIZE            (ENC_PUBLIC_KEY_SIZE + SIG_PUBLIC_KEY_SIZE)

/**
 * @brief The number of bytes in an extended secret key used by DHT group chats.
 */
#define EXT_SECRET_KEY_SIZE            (ENC_SECRET_KEY_SIZE + SIG_SECRET_KEY_SIZE)

/**
 * @brief The number of bytes in an HMAC authenticator.
 */
#define CRYPTO_HMAC_SIZE               32

/**
 * @brief The number of bytes in an HMAC secret key.
 */
#define CRYPTO_HMAC_KEY_SIZE           32

/**
 * @brief A `bzero`-like function which won't be optimised away by the compiler.
 *
 * Some compilers will inline `bzero` or `memset` if they can prove that there
 * will be no reads to the written data. Use this function if you want to be
 * sure the memory is indeed zeroed.
 */
non_null()
void crypto_memzero(void *data, size_t length);

/**
 * @brief Compute a SHA256 hash (32 bytes).
 */
non_null()
void crypto_sha256(uint8_t *hash, const uint8_t *data, size_t length);

/**
 * @brief Compute a SHA512 hash (64 bytes).
 */
non_null()
void crypto_sha512(uint8_t *hash, const uint8_t *data, size_t length);

/**
 * @brief Compute an HMAC authenticator (32 bytes).
 *
 * @param auth Resulting authenticator.
 * @param key Secret key, as generated by `new_hmac_key()`.
 */
non_null()
void crypto_hmac(uint8_t auth[CRYPTO_HMAC_SIZE], const uint8_t key[CRYPTO_HMAC_KEY_SIZE], const uint8_t *data,
                 size_t length);

/**
 * @brief Verify an HMAC authenticator.
 */
non_null()
bool crypto_hmac_verify(const uint8_t auth[CRYPTO_HMAC_SIZE], const uint8_t key[CRYPTO_HMAC_KEY_SIZE],
                        const uint8_t *data, size_t length);

/**
 * @brief Compare 2 public keys of length @ref CRYPTO_PUBLIC_KEY_SIZE, not vulnerable to
 * timing attacks.
 *
 * @retval true if both mem locations of length are equal
 * @retval false if they are not
 */
non_null()
bool pk_equal(const uint8_t pk1[CRYPTO_PUBLIC_KEY_SIZE], const uint8_t pk2[CRYPTO_PUBLIC_KEY_SIZE]);

/**
 * @brief Copy a public key from `src` to `dest`.
 */
non_null()
void pk_copy(uint8_t dest[CRYPTO_PUBLIC_KEY_SIZE], const uint8_t src[CRYPTO_PUBLIC_KEY_SIZE]);

/**
 * @brief Compare 2 SHA512 checksums of length CRYPTO_SHA512_SIZE, not vulnerable to
 * timing attacks.
 *
 * @return true if both mem locations of length are equal, false if they are not.
 */
non_null()
bool crypto_sha512_eq(const uint8_t *cksum1, const uint8_t *cksum2);

/**
 * @brief Compare 2 SHA256 checksums of length CRYPTO_SHA256_SIZE, not vulnerable to
 * timing attacks.
 *
 * @return true if both mem locations of length are equal, false if they are not.
 */
non_null()
bool crypto_sha256_eq(const uint8_t *cksum1, const uint8_t *cksum2);

/**
 * @brief Return a random 8 bit integer.
 */
non_null()
uint8_t random_u08(const Random *rng);

/**
 * @brief Return a random 16 bit integer.
 */
non_null()
uint16_t random_u16(const Random *rng);

/**
 * @brief Return a random 32 bit integer.
 */
non_null()
uint32_t random_u32(const Random *rng);

/**
 * @brief Return a random 64 bit integer.
 */
non_null()
uint64_t random_u64(const Random *rng);

/**
 * @brief Return a random 32 bit integer between 0 and upper_bound (excluded).
 *
 * On libsodium builds this function guarantees a uniform distribution of possible outputs.
 * On vanilla NACL builds this function is equivalent to `random() % upper_bound`.
 */
non_null()
uint32_t random_range_u32(const Random *rng, uint32_t upper_bound);

/** @brief Cryptographically signs a message using the supplied secret key and puts the resulting signature
 * in the supplied buffer.
 *
 * @param signature The buffer for the resulting signature, which must have room for at
 *   least CRYPTO_SIGNATURE_SIZE bytes.
 * @param message The message being signed.
 * @param message_length The length in bytes of the message being signed.
 * @param secret_key The secret key used to create the signature. The key should be
 *   produced by either `create_extended_keypair` or the libsodium function `crypto_sign_keypair`.
 *
 * @retval true on success.
 */
non_null()
bool crypto_signature_create(uint8_t *signature, const uint8_t *message, uint64_t message_length,
                             const uint8_t *secret_key);

/** @brief Verifies that the given signature was produced by a given message and public key.
 *
 * @param signature The signature we wish to verify.
 * @param message The message we wish to verify.
 * @param message_length The length of the message.
 * @param public_key The public key counterpart of the secret key that was used to
 *   create the signature.
 *
 * @retval true on success.
 */
non_null()
bool crypto_signature_verify(const uint8_t *signature, const uint8_t *message, uint64_t message_length,
                             const uint8_t *public_key);

/**
 * @brief Fill the given nonce with random bytes.
 */
non_null()
void random_nonce(const Random *rng, uint8_t *nonce);

/**
 * @brief Fill an array of bytes with random values.
 */
non_null()
void random_bytes(const Random *rng, uint8_t *bytes, size_t length);

/**
 * @brief Check if a Tox public key CRYPTO_PUBLIC_KEY_SIZE is valid or not.
 *
 * This should only be used for input validation.
 *
 * @return false if it isn't, true if it is.
 */
non_null()
bool public_key_valid(const uint8_t *public_key);

/** @brief Creates an extended keypair: curve25519 and ed25519 for encryption and signing
 *   respectively. The Encryption keys are derived from the signature keys.
 *
 * @param pk The buffer where the public key will be stored. Must have room for EXT_PUBLIC_KEY_SIZE bytes.
 * @param sk The buffer where the secret key will be stored. Must have room for EXT_SECRET_KEY_SIZE bytes.
 *
 * @retval true on success.
 */
non_null()
bool create_extended_keypair(uint8_t *pk, uint8_t *sk);

/** Functions for groupchat extended keys */
non_null() const uint8_t *get_enc_key(const uint8_t *key);
non_null() const uint8_t *get_sig_pk(const uint8_t *key);
non_null() void set_sig_pk(uint8_t *key, const uint8_t *sig_pk);
non_null() const uint8_t *get_sig_sk(const uint8_t *key);
non_null() const uint8_t *get_chat_id(const uint8_t *key);

/**
 * @brief Generate a new random keypair.
 *
 * Every call to this function is likely to generate a different keypair.
 */
non_null()
int32_t crypto_new_keypair(const Random *rng, uint8_t *public_key, uint8_t *secret_key);

/**
 * @brief Derive the public key from a given secret key.
 */
non_null()
void crypto_derive_public_key(uint8_t *public_key, const uint8_t *secret_key);

/**
 * @brief Encrypt message to send from secret key to public key.
 *
 * Encrypt plain text of the given length to encrypted of
 * `length + CRYPTO_MAC_SIZE` using the public key (@ref CRYPTO_PUBLIC_KEY_SIZE
 * bytes) of the receiver and the secret key of the sender and a
 * @ref CRYPTO_NONCE_SIZE byte nonce.
 *
 * @retval -1 if there was a problem.
 * @return length of encrypted data if everything was fine.
 */
non_null()
int32_t encrypt_data(const uint8_t *public_key, const uint8_t *secret_key, const uint8_t *nonce, const uint8_t *plain,
                     size_t length, uint8_t *encrypted);

/**
 * @brief Decrypt message from public key to secret key.
 *
 * Decrypt encrypted text of the given @p length to plain text of the given
 * `length - CRYPTO_MAC_SIZE` using the public key (@ref CRYPTO_PUBLIC_KEY_SIZE
 * bytes) of the sender, the secret key of the receiver and a
 * @ref CRYPTO_NONCE_SIZE byte nonce.
 *
 * @retval -1 if there was a problem (decryption failed).
 * @return length of plain text data if everything was fine.
 */
non_null()
int32_t decrypt_data(const uint8_t *public_key, const uint8_t *secret_key, const uint8_t *nonce,
                     const uint8_t *encrypted, size_t length, uint8_t *plain);

/**
 * @brief Fast encrypt/decrypt operations.
 *
 * Use if this is not a one-time communication. @ref encrypt_precompute does the
 * shared-key generation once so it does not have to be performed on every
 * encrypt/decrypt.
 */
non_null()
int32_t encrypt_precompute(const uint8_t *public_key, const uint8_t *secret_key, uint8_t *shared_key);

/**
 * @brief Encrypt message with precomputed shared key.
 *
 * Encrypts plain of length length to encrypted of length + @ref CRYPTO_MAC_SIZE
 * using a shared key @ref CRYPTO_SYMMETRIC_KEY_SIZE big and a @ref CRYPTO_NONCE_SIZE
 * byte nonce.
 *
 * @retval -1 if there was a problem.
 * @return length of encrypted data if everything was fine.
 */
non_null()
int32_t encrypt_data_symmetric(const uint8_t *shared_key, const uint8_t *nonce, const uint8_t *plain, size_t length,
                               uint8_t *encrypted);

/**
 * @brief Decrypt message with precomputed shared key.
 *
 * Decrypts encrypted of length length to plain of length
 * `length - CRYPTO_MAC_SIZE` using a shared key @ref CRYPTO_SHARED_KEY_SIZE
 * big and a @ref CRYPTO_NONCE_SIZE byte nonce.
 *
 * @retval -1 if there was a problem (decryption failed).
 * @return length of plain data if everything was fine.
 */
non_null()
int32_t decrypt_data_symmetric(const uint8_t *shared_key, const uint8_t *nonce, const uint8_t *encrypted, size_t length,
                               uint8_t *plain);

/**
 * @brief Increment the given nonce by 1 in big endian (rightmost byte incremented
 * first).
 */
non_null()
void increment_nonce(uint8_t *nonce);

/**
 * @brief Increment the given nonce by a given number.
 *
 * The number should be in host byte order.
 */
non_null()
void increment_nonce_number(uint8_t *nonce, uint32_t increment);

/**
 * @brief Fill a key @ref CRYPTO_SYMMETRIC_KEY_SIZE big with random bytes.
 *
 * This does the same as `new_symmetric_key` but without giving the Random object implicitly.
 * It is as safe as `new_symmetric_key`.
 */
non_null()
void new_symmetric_key_implicit_random(uint8_t *key);

/**
 * @brief Fill a key @ref CRYPTO_SYMMETRIC_KEY_SIZE big with random bytes.
 */
non_null()
void new_symmetric_key(const Random *rng, uint8_t *key);

/**
 * @brief Locks `length` bytes of memory pointed to by `data`.
 *
 * This will attempt to prevent the specified memory region from being swapped
 * to disk.
 *
 * @return true on success.
 */
non_null()
bool crypto_memlock(void *data, size_t length);

/**
 * @brief Unlocks `length` bytes of memory pointed to by `data`.
 *
 * This allows the specified memory region to be swapped to disk.
 *
 * This function call has the side effect of zeroing the specified memory region
 * whether or not it succeeds. Therefore it should only be used once the memory
 * is no longer in use.
 *
 * @return true on success.
 */
non_null()
bool crypto_memunlock(void *data, size_t length);

/**
 * @brief Generate a random secret HMAC key.
 */
non_null()
void new_hmac_key(const Random *rng, uint8_t key[CRYPTO_HMAC_KEY_SIZE]);

#ifdef __cplusplus
}  // extern "C"
#endif

#endif // C_TOXCORE_TOXCORE_CRYPTO_CORE_H
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2018 The TokTok team.
 * Copyright © 2013 Tox project.
 */

/**
 * Datatypes, functions and includes for the core networking.
 */
#ifndef C_TOXCORE_TOXCORE_NETWORK_H
#define C_TOXCORE_TOXCORE_NETWORK_H

#include <stdbool.h>    // bool
#include <stddef.h>     // size_t
#include <stdint.h>     // uint*_t


#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Wrapper for sockaddr_storage and size.
 */
typedef struct Network_Addr Network_Addr;

typedef int net_close_cb(void *obj, int sock);
typedef int net_accept_cb(void *obj, int sock);
typedef int net_bind_cb(void *obj, int sock, const Network_Addr *addr);
typedef int net_listen_cb(void *obj, int sock, int backlog);
typedef int net_recvbuf_cb(void *obj, int sock);
typedef int net_recv_cb(void *obj, int sock, uint8_t *buf, size_t len);
typedef int net_recvfrom_cb(void *obj, int sock, uint8_t *buf, size_t len, Network_Addr *addr);
typedef int net_send_cb(void *obj, int sock, const uint8_t *buf, size_t len);
typedef int net_sendto_cb(void *obj, int sock, const uint8_t *buf, size_t len, const Network_Addr *addr);
typedef int net_socket_cb(void *obj, int domain, int type, int proto);
typedef int net_socket_nonblock_cb(void *obj, int sock, bool nonblock);
typedef int net_getsockopt_cb(void *obj, int sock, int level, int optname, void *optval, size_t *optlen);
typedef int net_setsockopt_cb(void *obj, int sock, int level, int optname, const void *optval, size_t optlen);
typedef int net_getaddrinfo_cb(void *obj, int family, Network_Addr **addrs);
typedef int net_freeaddrinfo_cb(void *obj, Network_Addr *addrs);

/** @brief Functions wrapping POSIX network functions.
 *
 * Refer to POSIX man pages for documentation of what these functions are
 * expected to do when providing alternative Network implementations.
 */
typedef struct Network_Funcs {
    net_close_cb *close;
    net_accept_cb *accept;
    net_bind_cb *bind;
    net_listen_cb *listen;
    net_recvbuf_cb *recvbuf;
    net_recv_cb *recv;
    net_recvfrom_cb *recvfrom;
    net_send_cb *send;
    net_sendto_cb *sendto;
    net_socket_cb *socket;
    net_socket_nonblock_cb *socket_nonblock;
    net_getsockopt_cb *getsockopt;
    net_setsockopt_cb *setsockopt;
    net_getaddrinfo_cb *getaddrinfo;
    net_freeaddrinfo_cb *freeaddrinfo;
} Network_Funcs;

typedef struct Network {
    const Network_Funcs *funcs;
    void *obj;
} Network;

const Network *system_network(void);

typedef struct Family {
    uint8_t value;
} Family;

bool net_family_is_unspec(Family family);
bool net_family_is_ipv4(Family family);
bool net_family_is_ipv6(Family family);
bool net_family_is_tcp_server(Family family);
bool net_family_is_tcp_client(Family family);
bool net_family_is_tcp_ipv4(Family family);
bool net_family_is_tcp_ipv6(Family family);
bool net_family_is_tox_tcp_ipv4(Family family);
bool net_family_is_tox_tcp_ipv6(Family family);

Family net_family_unspec(void);
Family net_family_ipv4(void);
Family net_family_ipv6(void);
Family net_family_tcp_server(void);
Family net_family_tcp_client(void);
Family net_family_tcp_ipv4(void);
Family net_family_tcp_ipv6(void);
Family net_family_tox_tcp_ipv4(void);
Family net_family_tox_tcp_ipv6(void);

#define MAX_UDP_PACKET_SIZE 2048

#ifdef USE_TEST_NETWORK
typedef enum Net_Packet_Type {
    NET_PACKET_PING_REQUEST         = 0x05, /* Ping request packet ID. */
    NET_PACKET_PING_RESPONSE        = 0x06, /* Ping response packet ID. */
    NET_PACKET_GET_NODES            = 0x07, /* Get nodes request packet ID. */
    NET_PACKET_SEND_NODES_IPV6      = 0x08, /* Send nodes response packet ID for other addresses. */
    NET_PACKET_COOKIE_REQUEST       = 0x1c, /* Cookie request packet */
    NET_PACKET_COOKIE_RESPONSE      = 0x1d, /* Cookie response packet */
    NET_PACKET_CRYPTO_HS            = 0x1e, /* Crypto handshake packet */
    NET_PACKET_CRYPTO_DATA          = 0x1f, /* Crypto data packet */
    NET_PACKET_CRYPTO               = 0x24, /* Encrypted data packet ID. */
    NET_PACKET_LAN_DISCOVERY        = 0x25, /* LAN discovery packet ID. */

    NET_PACKET_GC_HANDSHAKE         = 0x62, /* Group chat handshake packet ID */
    NET_PACKET_GC_LOSSLESS          = 0x63, /* Group chat lossless packet ID */
    NET_PACKET_GC_LOSSY             = 0x64, /* Group chat lossy packet ID */

    /* See: `docs/Prevent_Tracking.txt` and `onion.{c,h}` */
    NET_PACKET_ONION_SEND_INITIAL   = 0x8f,
    NET_PACKET_ONION_SEND_1         = 0x90,
    NET_PACKET_ONION_SEND_2         = 0x91,

    NET_PACKET_ANNOUNCE_REQUEST     = 0x92,
    NET_PACKET_ANNOUNCE_RESPONSE    = 0x93,
    NET_PACKET_ONION_DATA_REQUEST   = 0x94,
    NET_PACKET_ONION_DATA_RESPONSE  = 0x95,

    NET_PACKET_ANNOUNCE_REQUEST_OLD = 0x96, /* TODO: DEPRECATE */
    NET_PACKET_ANNOUNCE_RESPONSE_OLD = 0x97, /* TODO: DEPRECATE */

    NET_PACKET_ONION_RECV_3         = 0x9b,
    NET_PACKET_ONION_RECV_2         = 0x9c,
    NET_PACKET_ONION_RECV_1         = 0x9d,

    NET_PACKET_FORWARD_REQUEST      = 0x9e,
    NET_PACKET_FORWARDING           = 0x9f,
    NET_PACKET_FORWARD_REPLY        = 0xa0,

    NET_PACKET_DATA_SEARCH_REQUEST     = 0xa1,
    NET_PACKET_DATA_SEARCH_RESPONSE    = 0xa2,
    NET_PACKET_DATA_RETRIEVE_REQUEST   = 0xa3,
    NET_PACKET_DATA_RETRIEVE_RESPONSE  = 0xa4,
    NET_PACKET_STORE_ANNOUNCE_REQUEST  = 0xa5,
    NET_PACKET_STORE_ANNOUNCE_RESPONSE = 0xa6,

    BOOTSTRAP_INFO_PACKET_ID        = 0xf1, /* Only used for bootstrap nodes */

    NET_PACKET_MAX                  = 0xff, /* This type must remain within a single uint8. */
} Net_Packet_Type;
#else
typedef enum Net_Packet_Type {
    NET_PACKET_PING_REQUEST         = 0x00, /* Ping request packet ID. */
    NET_PACKET_PING_RESPONSE        = 0x01, /* Ping response packet ID. */
    NET_PACKET_GET_NODES            = 0x02, /* Get nodes request packet ID. */
    NET_PACKET_SEND_NODES_IPV6      = 0x04, /* Send nodes response packet ID for other addresses. */
    NET_PACKET_COOKIE_REQUEST       = 0x18, /* Cookie request packet */
    NET_PACKET_COOKIE_RESPONSE      = 0x19, /* Cookie response packet */
    NET_PACKET_CRYPTO_HS            = 0x1a, /* Crypto handshake packet */
    NET_PACKET_CRYPTO_DATA          = 0x1b, /* Crypto data packet */
    NET_PACKET_CRYPTO               = 0x20, /* Encrypted data packet ID. */
    NET_PACKET_LAN_DISCOVERY        = 0x21, /* LAN discovery packet ID. */

    NET_PACKET_GC_HANDSHAKE         = 0x5a, /* Group chat handshake packet ID */
    NET_PACKET_GC_LOSSLESS          = 0x5b, /* Group chat lossless packet ID */
    NET_PACKET_GC_LOSSY             = 0x5c, /* Group chat lossy packet ID */

    /* See: `docs/Prevent_Tracking.txt` and `onion.{c,h}` */
    NET_PACKET_ONION_SEND_INITIAL   = 0x80,
    NET_PACKET_ONION_SEND_1         = 0x81,
    NET_PACKET_ONION_SEND_2         = 0x82,

    NET_PACKET_ANNOUNCE_REQUEST_OLD  = 0x83, /* TODO: DEPRECATE */
    NET_PACKET_ANNOUNCE_RESPONSE_OLD = 0x84, /* TODO: DEPRECATE */

    NET_PACKET_ONION_DATA_REQUEST   = 0x85,
    NET_PACKET_ONION_DATA_RESPONSE  = 0x86,
    NET_PACKET_ANNOUNCE_REQUEST     = 0x87,
    NET_PACKET_ANNOUNCE_RESPONSE    = 0x88,

    NET_PACKET_ONION_RECV_3         = 0x8c,
    NET_PACKET_ONION_RECV_2         = 0x8d,
    NET_PACKET_ONION_RECV_1         = 0x8e,

    NET_PACKET_FORWARD_REQUEST      = 0x90,
    NET_PACKET_FORWARDING           = 0x91,
    NET_PACKET_FORWARD_REPLY        = 0x92,

    NET_PACKET_DATA_SEARCH_REQUEST     = 0x93,
    NET_PACKET_DATA_SEARCH_RESPONSE    = 0x94,
    NET_PACKET_DATA_RETRIEVE_REQUEST   = 0x95,
    NET_PACKET_DATA_RETRIEVE_RESPONSE  = 0x96,
    NET_PACKET_STORE_ANNOUNCE_REQUEST  = 0x97,
    NET_PACKET_STORE_ANNOUNCE_RESPONSE = 0x98,

    BOOTSTRAP_INFO_PACKET_ID        = 0xf0, /* Only used for bootstrap nodes */

    NET_PACKET_MAX                  = 0xff, /* This type must remain within a single uint8. */
} Net_Packet_Type;
#endif // test network


#define TOX_PORTRANGE_FROM 33445
#define TOX_PORTRANGE_TO   33545
#define TOX_PORT_DEFAULT   TOX_PORTRANGE_FROM

/** Redefinitions of variables for safe transfer over wire. */
#define TOX_AF_UNSPEC 0
#define TOX_AF_INET 2
#define TOX_AF_INET6 10
#define TOX_TCP_INET 130
#define TOX_TCP_INET6 138

#define TOX_SOCK_STREAM 1
#define TOX_SOCK_DGRAM 2

#define TOX_PROTO_TCP 1
#define TOX_PROTO_UDP 2

/** TCP related */
#define TCP_CLIENT_FAMILY (TOX_AF_INET6 + 1)
#define TCP_INET (TOX_AF_INET6 + 2)
#define TCP_INET6 (TOX_AF_INET6 + 3)
#define TCP_SERVER_FAMILY (TOX_AF_INET6 + 4)

#define SIZE_IP4 4
#define SIZE_IP6 16
#define SIZE_IP (1 + SIZE_IP6)
#define SIZE_PORT 2
#define SIZE_IPPORT (SIZE_IP + SIZE_PORT)

typedef union IP4 {
    uint32_t uint32;
    uint16_t uint16[2];
    uint8_t uint8[4];
} IP4;

IP4 get_ip4_loopback(void);
extern const IP4 ip4_broadcast;

typedef union IP6 {
    uint8_t uint8[16];
    uint16_t uint16[8];
    uint32_t uint32[4];
    uint64_t uint64[2];
} IP6;

IP6 get_ip6_loopback(void);
extern const IP6 ip6_broadcast;

typedef union IP_Union {
    IP4 v4;
    IP6 v6;
} IP_Union;

typedef struct IP {
    Family family;
    IP_Union ip;
} IP;

typedef struct IP_Port {
    IP ip;
    uint16_t port;
} IP_Port;

extern const IP_Port empty_ip_port;

typedef struct Socket {
    int sock;
} Socket;

non_null()
Socket net_socket(const Network *ns, Family domain, int type, int protocol);

/**
 * Check if socket is valid.
 *
 * @return true if valid, false otherwise.
 */
bool sock_valid(Socket sock);

extern const Socket net_invalid_socket;

/**
 * Calls send(sockfd, buf, len, MSG_NOSIGNAL).
 */
non_null()
int net_send(const Network *ns, const Logger *log, Socket sock, const uint8_t *buf, size_t len, const IP_Port *ip_port);
/**
 * Calls recv(sockfd, buf, len, MSG_NOSIGNAL).
 */
non_null()
int net_recv(const Network *ns, const Logger *log, Socket sock, uint8_t *buf, size_t len, const IP_Port *ip_port);
/**
 * Calls listen(sockfd, backlog).
 */
non_null()
int net_listen(const Network *ns, Socket sock, int backlog);
/**
 * Calls accept(sockfd, nullptr, nullptr).
 */
non_null()
Socket net_accept(const Network *ns, Socket sock);

/**
 * return the size of data in the tcp recv buffer.
 * return 0 on failure.
 */
non_null()
uint16_t net_socket_data_recv_buffer(const Network *ns, Socket sock);

/** Convert values between host and network byte order. */
uint32_t net_htonl(uint32_t hostlong);
uint16_t net_htons(uint16_t hostshort);
uint32_t net_ntohl(uint32_t hostlong);
uint16_t net_ntohs(uint16_t hostshort);

non_null()
size_t net_pack_bool(uint8_t *bytes, bool v);
non_null()
size_t net_pack_u16(uint8_t *bytes, uint16_t v);
non_null()
size_t net_pack_u32(uint8_t *bytes, uint32_t v);
non_null()
size_t net_pack_u64(uint8_t *bytes, uint64_t v);

non_null()
size_t net_unpack_bool(const uint8_t *bytes, bool *v);
non_null()
size_t net_unpack_u16(const uint8_t *bytes, uint16_t *v);
non_null()
size_t net_unpack_u32(const uint8_t *bytes, uint32_t *v);
non_null()
size_t net_unpack_u64(const uint8_t *bytes, uint64_t *v);

/** Does the IP6 struct a contain an IPv4 address in an IPv6 one? */
non_null()
bool ipv6_ipv4_in_v6(const IP6 *a);

#define TOX_ENABLE_IPV6_DEFAULT true

#define TOX_INET6_ADDRSTRLEN 66
#define TOX_INET_ADDRSTRLEN 22

/** this would be TOX_INET6_ADDRSTRLEN, but it might be too short for the error message */
#define IP_NTOA_LEN 96 // TODO(irungentoo): magic number. Why not INET6_ADDRSTRLEN ?

typedef struct Ip_Ntoa {
    char buf[IP_NTOA_LEN];
} Ip_Ntoa;

/** @brief Converts IP into a string.
 *
 * Writes error message into the buffer on error.
 *
 * @param ip_str contains a buffer of the required size.
 *
 * @return Pointer to the buffer inside `ip_str` containing the IP string.
 */
non_null()
const char *net_ip_ntoa(const IP *ip, Ip_Ntoa *ip_str);

/**
 * Parses IP structure into an address string.
 *
 * @param ip IP of TOX_AF_INET or TOX_AF_INET6 families.
 * @param length length of the address buffer.
 *   Must be at least TOX_INET_ADDRSTRLEN for TOX_AF_INET
 *   and TOX_INET6_ADDRSTRLEN for TOX_AF_INET6
 *
 * @param address dotted notation (IPv4: quad, IPv6: 16) or colon notation (IPv6).
 *
 * @return true on success, false on failure.
 */
non_null()
bool ip_parse_addr(const IP *ip, char *address, size_t length);

/**
 * Directly parses the input into an IP structure.
 *
 * Tries IPv4 first, then IPv6.
 *
 * @param address dotted notation (IPv4: quad, IPv6: 16) or colon notation (IPv6).
 * @param to family and the value is set on success.
 *
 * @return true on success, false on failure.
 */
non_null()
bool addr_parse_ip(const char *address, IP *to);

/**
 * Compares two IPAny structures.
 *
 * Unset means unequal.
 *
 * @return false when not equal or when uninitialized.
 */
nullable(1, 2)
bool ip_equal(const IP *a, const IP *b);

/**
 * Compares two IPAny_Port structures.
 *
 * Unset means unequal.
 *
 * @return false when not equal or when uninitialized.
 */
nullable(1, 2)
bool ipport_equal(const IP_Port *a, const IP_Port *b);

/** nulls out ip */
non_null()
void ip_reset(IP *ip);
/** nulls out ip_port */
non_null()
void ipport_reset(IP_Port *ipport);
/** nulls out ip, sets family according to flag */
non_null()
void ip_init(IP *ip, bool ipv6enabled);
/** checks if ip is valid */
non_null()
bool ip_isset(const IP *ip);
/** checks if ip is valid */
non_null()
bool ipport_isset(const IP_Port *ipport);
/** copies an ip structure (careful about direction) */
non_null()
void ip_copy(IP *target, const IP *source);
/** copies an ip_port structure (careful about direction) */
non_null()
void ipport_copy(IP_Port *target, const IP_Port *source);

/**
 * Resolves string into an IP address
 *
 * @param address a hostname (or something parseable to an IP address)
 * @param to to.family MUST be initialized, either set to a specific IP version
 *   (TOX_AF_INET/TOX_AF_INET6) or to the unspecified TOX_AF_UNSPEC (0), if both
 *   IP versions are acceptable
 * @param extra can be NULL and is only set in special circumstances, see returns
 *
 * Returns in `*to` a matching address (IPv6 or IPv4)
 * Returns in `*extra`, if not NULL, an IPv4 address, if `to->family` was TOX_AF_UNSPEC
 *
 * @return true on success, false on failure
 */
non_null(1, 2, 3) nullable(4)
bool addr_resolve_or_parse_ip(const Network *ns, const char *address, IP *to, IP *extra);

/** @brief Function to receive data, ip and port of sender is put into ip_port.
 * Packet data is put into data.
 * Packet length is put into length.
 */
typedef int packet_handler_cb(void *object, const IP_Port *ip_port, const uint8_t *data, uint16_t len, void *userdata);

typedef struct Networking_Core Networking_Core;

non_null()
Family net_family(const Networking_Core *net);
non_null()
uint16_t net_port(const Networking_Core *net);

/** Close the socket. */
non_null()
void kill_sock(const Network *ns, Socket sock);

/**
 * Set socket as nonblocking
 *
 * @return true on success, false on failure.
 */
non_null()
bool set_socket_nonblock(const Network *ns, Socket sock);

/**
 * Set socket to not emit SIGPIPE
 *
 * @return true on success, false on failure.
 */
non_null()
bool set_socket_nosigpipe(const Network *ns, Socket sock);

/**
 * Enable SO_REUSEADDR on socket.
 *
 * @return true on success, false on failure.
 */
non_null()
bool set_socket_reuseaddr(const Network *ns, Socket sock);

/**
 * Set socket to dual (IPv4 + IPv6 socket)
 *
 * @return true on success, false on failure.
 */
non_null()
bool set_socket_dualstack(const Network *ns, Socket sock);

/* Basic network functions: */

/**
 * An outgoing network packet.
 *
 * Use `send_packet` to send it to an IP/port endpoint.
 */
typedef struct Packet {
    const uint8_t *data;
    uint16_t length;
} Packet;

/**
 * Function to send a network packet to a given IP/port.
 */
non_null()
int send_packet(const Networking_Core *net, const IP_Port *ip_port, Packet packet);

/**
 * Function to send packet(data) of length length to ip_port.
 *
 * @deprecated Use send_packet instead.
 */
non_null()
int sendpacket(const Networking_Core *net, const IP_Port *ip_port, const uint8_t *data, uint16_t length);

/** Function to call when packet beginning with byte is received. */
non_null(1) nullable(3, 4)
void networking_registerhandler(Networking_Core *net, uint8_t byte, packet_handler_cb *cb, void *object);

/** Call this several times a second. */
non_null(1) nullable(2)
void networking_poll(const Networking_Core *net, void *userdata);

/** @brief Connect a socket to the address specified by the ip_port.
 *
 * Return true on success.
 * Return false on failure.
 */
non_null()
bool net_connect(const Logger *log, Socket sock, const IP_Port *ip_port);

/** @brief High-level getaddrinfo implementation.
 *
 * Given node, which identifies an Internet host, `net_getipport()` fills an array
 * with one or more IP_Port structures, each of which contains an Internet
 * address that can be specified by calling `net_connect()`, the port is ignored.
 *
 * Skip all addresses with socktype != type (use type = -1 to get all addresses)
 * To correctly deallocate array memory use `net_freeipport()`
 *
 * return number of elements in res array
 * and -1 on error.
 */
non_null()
int32_t net_getipport(const char *node, IP_Port **res, int tox_type);

/** Deallocates memory allocated by net_getipport */
nullable(1)
void net_freeipport(IP_Port *ip_ports);

/**
 * @return true on success, false on failure.
 */
non_null()
bool bind_to_port(const Network *ns, Socket sock, Family family, uint16_t port);

/** @brief Get the last networking error code.
 *
 * Similar to Unix's errno, but cross-platform, as not all platforms use errno
 * to indicate networking errors.
 *
 * Note that different platforms may return different codes for the same error,
 * so you likely shouldn't be checking the value returned by this function
 * unless you know what you are doing, you likely just want to use it in
 * combination with `net_new_strerror()` to print the error.
 *
 * return platform-dependent network error code, if any.
 */
int net_error(void);

/** @brief Get a text explanation for the error code from `net_error()`.
 *
 * return NULL on failure.
 * return pointer to a NULL-terminated string describing the error code on
 * success. The returned string must be freed using `net_kill_strerror()`.
 */
char *net_new_strerror(int error);

/** @brief Frees the string returned by `net_new_strerror()`.
 * It's valid to pass NULL as the argument, the function does nothing in this
 * case.
 */
non_null()
void net_kill_strerror(char *strerror);

/** @brief Initialize networking.
 * Bind to ip and port.
 * ip must be in network order EX: 127.0.0.1 = (7F000001).
 * port is in host byte order (this means don't worry about it).
 *
 * @return Networking_Core object if no problems
 * @retval NULL if there are problems.
 *
 * If error is non NULL it is set to 0 if no issues, 1 if socket related error, 2 if other.
 */
non_null(1, 2, 3) nullable(6)
Networking_Core *new_networking_ex(
        const Logger *log, const Network *ns, const IP *ip,
        uint16_t port_from, uint16_t port_to, unsigned int *error);

non_null()
Networking_Core *new_networking_no_udp(const Logger *log, const Network *ns);

/** Function to cleanup networking stuff (doesn't do much right now). */
nullable(1)
void kill_networking(Networking_Core *net);

#ifdef __cplusplus
}  // extern "C"
#endif

#endif
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2018 The TokTok team.
 * Copyright © 2013 Tox project.
 */

/** @file
 * @brief An implementation of the DHT as seen in docs/updates/DHT.md
 */
#ifndef C_TOXCORE_TOXCORE_DHT_H
#define C_TOXCORE_TOXCORE_DHT_H

#include <stdbool.h>


#ifdef __cplusplus
extern "C" {
#endif

/* Encryption and signature keys definition */
#define ENC_PUBLIC_KEY_SIZE CRYPTO_PUBLIC_KEY_SIZE
#define ENC_SECRET_KEY_SIZE CRYPTO_SECRET_KEY_SIZE
#define SIG_PUBLIC_KEY_SIZE CRYPTO_SIGN_PUBLIC_KEY_SIZE
#define SIG_SECRET_KEY_SIZE CRYPTO_SIGN_SECRET_KEY_SIZE

/* Size of the group chat_id */
#define CHAT_ID_SIZE SIG_PUBLIC_KEY_SIZE

/* Extended keys for group chats */
#define EXT_SECRET_KEY_SIZE (ENC_SECRET_KEY_SIZE + SIG_SECRET_KEY_SIZE)
#define EXT_PUBLIC_KEY_SIZE (ENC_PUBLIC_KEY_SIZE + SIG_PUBLIC_KEY_SIZE)


/* Maximum size of a signature (may be smaller) */
#define SIGNATURE_SIZE CRYPTO_SIGNATURE_SIZE
/** Maximum number of clients stored per friend. */
#define MAX_FRIEND_CLIENTS 8

#define LCLIENT_NODES MAX_FRIEND_CLIENTS
#define LCLIENT_LENGTH 128

/** A list of the clients mathematically closest to ours. */
#define LCLIENT_LIST (LCLIENT_LENGTH * LCLIENT_NODES)

#define MAX_CLOSE_TO_BOOTSTRAP_NODES 8

/** The max number of nodes to send with send nodes. */
#define MAX_SENT_NODES 4

/** Ping timeout in seconds */
#define PING_TIMEOUT 5

/** size of DHT ping arrays. */
#define DHT_PING_ARRAY_SIZE 512

/** Ping interval in seconds for each node in our lists. */
#define PING_INTERVAL 60

/** The number of seconds for a non responsive node to become bad. */
#define PINGS_MISSED_NODE_GOES_BAD 1
#define PING_ROUNDTRIP 2
#define BAD_NODE_TIMEOUT (PING_INTERVAL + PINGS_MISSED_NODE_GOES_BAD * (PING_INTERVAL + PING_ROUNDTRIP))

/**
 * The number of "fake" friends to add.
 *
 * (for optimization purposes and so our paths for the onion part are more random)
 */
#define DHT_FAKE_FRIEND_NUMBER 2

/** Maximum packet size for a DHT request packet. */
#define MAX_CRYPTO_REQUEST_SIZE 1024

#define CRYPTO_PACKET_FRIEND_REQ    32  // Friend request crypto packet ID.
#define CRYPTO_PACKET_DHTPK         156
#define CRYPTO_PACKET_NAT_PING      254 // NAT ping crypto packet ID.

/* Max size of a packed node for IPV4 and IPV6 respectively */
#define PACKED_NODE_SIZE_IP4 (1 + SIZE_IP4 + sizeof(uint16_t) + CRYPTO_PUBLIC_KEY_SIZE)
#define PACKED_NODE_SIZE_IP6 (1 + SIZE_IP6 + sizeof(uint16_t) + CRYPTO_PUBLIC_KEY_SIZE)

/**
 * This define can eventually be removed; it is necessary if a significant
 * proportion of dht nodes do not implement the dht announcements protocol.
 */
#define CHECK_ANNOUNCE_NODE

/**
 * @brief Create a request to peer.
 *
 * Packs the data and sender public key and encrypts the packet.
 *
 * @param[in] send_public_key public key of the sender.
 * @param[in] send_secret_key secret key of the sender.
 * @param[out] packet an array of @ref MAX_CRYPTO_REQUEST_SIZE big.
 * @param[in] recv_public_key public key of the receiver.
 * @param[in] data represents the data we send with the request.
 * @param[in] data_length the length of the data.
 * @param[in] request_id the id of the request (32 = friend request, 254 = ping request).
 *
 * @attention Constraints:
 * @code
 * sizeof(packet) >= MAX_CRYPTO_REQUEST_SIZE
 * @endcode
 *
 * @retval -1 on failure.
 * @return the length of the created packet on success.
 */
non_null()
int create_request(const Random *rng, const uint8_t *send_public_key, const uint8_t *send_secret_key,
                   uint8_t *packet, const uint8_t *recv_public_key,
                   const uint8_t *data, uint32_t data_length, uint8_t request_id);

/**
 * @brief Decrypts and unpacks a DHT request packet.
 *
 * Puts the senders public key in the request in @p public_key, the data from
 * the request in @p data.
 *
 * @param[in] self_public_key public key of the receiver (us).
 * @param[in] self_secret_key secret key of the receiver (us).
 * @param[out] public_key public key of the sender, copied from the input packet.
 * @param[out] data decrypted request data, copied from the input packet, must
 *   have room for @ref MAX_CRYPTO_REQUEST_SIZE bytes.
 * @param[in] packet is the request packet.
 * @param[in] packet_length length of the packet.
 *
 * @attention Constraints:
 * @code
 * sizeof(data) >= MAX_CRYPTO_REQUEST_SIZE
 * @endcode
 *
 * @retval -1 if not valid request.
 * @return the length of the unpacked data.
 */
non_null()
int handle_request(
    const uint8_t *self_public_key, const uint8_t *self_secret_key, uint8_t *public_key, uint8_t *data,
    uint8_t *request_id, const uint8_t *packet, uint16_t packet_length);

typedef struct IPPTs {
    IP_Port     ip_port;
    uint64_t    timestamp;
} IPPTs;

typedef struct IPPTsPng {
    IP_Port     ip_port;
    uint64_t    timestamp;
    uint64_t    last_pinged;

    /* Returned by this node */
    IP_Port     ret_ip_port;
    uint64_t    ret_timestamp;
    /* true if this ip_port is ours */
    bool        ret_ip_self;
} IPPTsPng;

typedef struct Client_data {
    uint8_t     public_key[CRYPTO_PUBLIC_KEY_SIZE];
    IPPTsPng    assoc4;
    IPPTsPng    assoc6;

#ifdef CHECK_ANNOUNCE_NODE
    /* Responded to data search? */
    bool        announce_node;
#endif
} Client_data;

/*----------------------------------------------------------------------------------*/

typedef struct NAT {
    /* true if currently hole punching */
    bool        hole_punching;
    uint32_t    punching_index;
    uint32_t    tries;
    uint32_t    punching_index2;

    uint64_t    punching_timestamp;
    uint64_t    recv_nat_ping_timestamp;
    uint64_t    nat_ping_id;
    uint64_t    nat_ping_timestamp;
} NAT;

typedef struct Node_format {
    uint8_t     public_key[CRYPTO_PUBLIC_KEY_SIZE];
    IP_Port     ip_port;
} Node_format;

extern const Node_format empty_node_format;

typedef struct DHT_Friend DHT_Friend;

non_null() const uint8_t *dht_friend_public_key(const DHT_Friend *dht_friend);
non_null() const Client_data *dht_friend_client(const DHT_Friend *dht_friend, size_t index);

/** @return packet size of packed node with ip_family on success.
 * @retval -1 on failure.
 */
int packed_node_size(Family ip_family);

/** @brief Pack an IP_Port structure into data of max size length.
 *
 * Packed_length is the offset of data currently packed.
 *
 * @return size of packed IP_Port data on success.
 * @retval -1 on failure.
 */
non_null()
int pack_ip_port(const Logger *logger, uint8_t *data, uint16_t length, const IP_Port *ip_port);

/** @brief Encrypt plain and write resulting DHT packet into packet with max size length.
 *
 * @return size of packet on success.
 * @retval -1 on failure.
 */
non_null()
int dht_create_packet(const Random *rng,
                      const uint8_t public_key[CRYPTO_PUBLIC_KEY_SIZE],
                      const uint8_t *shared_key, const uint8_t type,
                      const uint8_t *plain, size_t plain_length,
                      uint8_t *packet, size_t length);

/** @brief Unpack IP_Port structure from data of max size length into ip_port.
 *
 * len_processed is the offset of data currently unpacked.
 *
 * @return size of unpacked ip_port on success.
 * @retval -1 on failure.
 */
non_null()
int unpack_ip_port(IP_Port *ip_port, const uint8_t *data, uint16_t length, bool tcp_enabled);

/** @brief Pack number of nodes into data of maxlength length.
 *
 * @return length of packed nodes on success.
 * @retval -1 on failure.
 */
non_null()
int pack_nodes(const Logger *logger, uint8_t *data, uint16_t length, const Node_format *nodes, uint16_t number);

/** @brief Unpack data of length into nodes of size max_num_nodes.
 * Put the length of the data processed in processed_data_len.
 * tcp_enabled sets if TCP nodes are expected (true) or not (false).
 *
 * @return number of unpacked nodes on success.
 * @retval -1 on failure.
 */
non_null(1, 4) nullable(3)
int unpack_nodes(Node_format *nodes, uint16_t max_num_nodes, uint16_t *processed_data_len, const uint8_t *data,
                 uint16_t length, bool tcp_enabled);

/*----------------------------------------------------------------------------------*/

typedef int cryptopacket_handler_cb(void *object, const IP_Port *ip_port, const uint8_t *source_pubkey,
                                    const uint8_t *data, uint16_t len, void *userdata);

typedef struct DHT DHT;

non_null() const uint8_t *dht_get_self_public_key(const DHT *dht);
non_null() const uint8_t *dht_get_self_secret_key(const DHT *dht);
non_null() void dht_set_self_public_key(DHT *dht, const uint8_t *key);
non_null() void dht_set_self_secret_key(DHT *dht, const uint8_t *key);

non_null() Networking_Core *dht_get_net(const DHT *dht);
non_null() struct Ping *dht_get_ping(const DHT *dht);
non_null() const Client_data *dht_get_close_clientlist(const DHT *dht);
non_null() const Client_data *dht_get_close_client(const DHT *dht, uint32_t client_num);
non_null() uint16_t dht_get_num_friends(const DHT *dht);

non_null() DHT_Friend *dht_get_friend(DHT *dht, uint32_t friend_num);
non_null() const uint8_t *dht_get_friend_public_key(const DHT *dht, uint32_t friend_num);

/*----------------------------------------------------------------------------------*/

/**
 * Copy shared_key to encrypt/decrypt DHT packet from public_key into shared_key
 * for packets that we receive.
 */
non_null()
const uint8_t *dht_get_shared_key_recv(DHT *dht, const uint8_t *public_key);

/**
 * Copy shared_key to encrypt/decrypt DHT packet from public_key into shared_key
 * for packets that we send.
 */
non_null()
const uint8_t *dht_get_shared_key_sent(DHT *dht, const uint8_t *public_key);

/**
 * Sends a getnodes request to `ip_port` with the public key `public_key` for nodes
 * that are close to `client_id`.
 *
 * @retval true on success.
 */
non_null()
bool dht_getnodes(DHT *dht, const IP_Port *ip_port, const uint8_t *public_key, const uint8_t *client_id);

typedef void dht_ip_cb(void *object, int32_t number, const IP_Port *ip_port);

typedef void dht_get_nodes_response_cb(const DHT *dht, const Node_format *node, void *user_data);

/** Sets the callback to be triggered on a getnodes response. */
non_null(1) nullable(2)
void dht_callback_get_nodes_response(DHT *dht, dht_get_nodes_response_cb *function);

/** @brief Add a new friend to the friends list.
 * @param public_key must be CRYPTO_PUBLIC_KEY_SIZE bytes long.
 *
 * @param ip_callback is the callback of a function that will be called when the ip address
 * is found along with arguments data and number.
 * @param data User data for the callback
 * @param number Will be passed to ip_callback
 *
 * @param lock_token will be set to a non zero number that must be passed to `dht_delfriend()`
 * to properly remove the callback.
 *
 * @retval 0 if success.
 * @retval -1 if failure (friends list is full).
 */
non_null(1, 2, 6) nullable(3, 4)
int dht_addfriend(DHT *dht, const uint8_t *public_key, dht_ip_cb *ip_callback,
                  void *data, int32_t number, uint32_t *lock_token);

/** @brief Delete a friend from the friends list.
 * public_key must be CRYPTO_PUBLIC_KEY_SIZE bytes long.
 * @param dht The DHT object
 * @param public_key The public key of the friend
 * @param lock_token The token received by dht_addfriend(...)
 *
 * @retval 0 if success.
 * @retval -1 if failure (public_key not in friends list).
 */
non_null()
int dht_delfriend(DHT *dht, const uint8_t *public_key, uint32_t lock_token);

/** @brief Get ip of friend.
 *
 * @param public_key must be CRYPTO_PUBLIC_KEY_SIZE bytes long.
 *
 * @retval -1 if public_key does NOT refer to a friend
 * @retval  0 if public_key refers to a friend and we failed to find the friend (yet)
 * @retval  1 if public_key refers to a friend and we found him
 */
non_null()
int dht_getfriendip(const DHT *dht, const uint8_t *public_key, IP_Port *ip_port);

/** @brief Compares pk1 and pk2 with pk.
 *
 * @retval 0 if both are same distance.
 * @retval 1 if pk1 is closer.
 * @retval 2 if pk2 is closer.
 */
non_null()
int id_closest(const uint8_t *pk, const uint8_t *pk1, const uint8_t *pk2);

/** Return index of first unequal bit number between public keys pk1 and pk2. */
non_null()
unsigned int bit_by_bit_cmp(const uint8_t *pk1, const uint8_t *pk2);

/**
 * Add node to the node list making sure only the nodes closest to cmp_pk are in the list.
 *
 * @return true iff the node was added to the list.
 */
non_null()
bool add_to_list(
    Node_format *nodes_list, uint32_t length, const uint8_t *pk, const IP_Port *ip_port, const uint8_t *cmp_pk);

/** Return 1 if node can be added to close list, 0 if it can't. */
non_null()
bool node_addable_to_close_list(DHT *dht, const uint8_t *public_key, const IP_Port *ip_port);

#ifdef CHECK_ANNOUNCE_NODE
/** Set node as announce node. */
non_null()
void set_announce_node(DHT *dht, const uint8_t *public_key);
#endif

/**
 * Get the (maximum MAX_SENT_NODES) closest nodes to public_key we know
 * and put them in nodes_list (must be MAX_SENT_NODES big).
 *
 * sa_family = family (IPv4 or IPv6) (0 if we don't care)?
 * is_LAN = return some LAN ips (true or false)
 * want_announce: return only nodes which implement the dht announcements protocol.
 *
 * @return the number of nodes returned.
 */
non_null()
int get_close_nodes(const DHT *dht, const uint8_t *public_key, Node_format *nodes_list, Family sa_family,
                    bool is_LAN, bool want_announce);


/** @brief Put up to max_num nodes in nodes from the random friends.
 *
 * Important: this function relies on the first two DHT friends *not* being real
 * friends to avoid leaking information about real friends into the onion paths.
 *
 * @return the number of nodes.
 */
non_null()
uint16_t randfriends_nodes(const DHT *dht, Node_format *nodes, uint16_t max_num);

/** @brief Put up to max_num nodes in nodes from the closelist.
 *
 * @return the number of nodes.
 */
non_null()
uint16_t closelist_nodes(const DHT *dht, Node_format *nodes, uint16_t max_num);

/** Run this function at least a couple times per second (It's the main loop). */
non_null()
void do_dht(DHT *dht);

/*
 *  Use these two functions to bootstrap the client.
 */
/**
 * @brief Sends a "get nodes" request to the given node with ip, port and public_key
 *   to setup connections
 */
non_null()
bool dht_bootstrap(DHT *dht, const IP_Port *ip_port, const uint8_t *public_key);

/** @brief Resolves address into an IP address.
 *
 * If successful, sends a "get nodes" request to the given node with ip, port
 * and public_key to setup connections
 *
 * @param address can be a hostname or an IP address (IPv4 or IPv6).
 * @param ipv6enabled if false, the resolving sticks STRICTLY to IPv4 addresses.
 *   Otherwise, the resolving looks for IPv6 addresses first, then IPv4 addresses.
 *
 * @retval 1 if the address could be converted into an IP address
 * @retval 0 otherwise
 */
non_null()
int dht_bootstrap_from_address(DHT *dht, const char *address, bool ipv6enabled,
                               uint16_t port, const uint8_t *public_key);

/** @brief Start sending packets after DHT loaded_friends_list and loaded_clients_list are set.
 *
 * @retval 0 if successful
 * @retval -1 otherwise
 */
non_null()
int dht_connect_after_load(DHT *dht);

/* ROUTING FUNCTIONS */

/** @brief Send the given packet to node with public_key.
 *
 * @return number of bytes sent.
 * @retval -1 if failure.
 */
non_null()
int route_packet(const DHT *dht, const uint8_t *public_key, const uint8_t *packet, uint16_t length);

/**
 * Send the following packet to everyone who tells us they are connected to friend_id.
 *
 * @return ip for friend.
 * @return number of nodes the packet was sent to. (Only works if more than (MAX_FRIEND_CLIENTS / 4).
 */
non_null()
uint32_t route_to_friend(const DHT *dht, const uint8_t *friend_id, const Packet *packet);

/** Function to handle crypto packets. */
non_null(1) nullable(3, 4)
void cryptopacket_registerhandler(DHT *dht, uint8_t byte, cryptopacket_handler_cb *cb, void *object);

/* SAVE/LOAD functions */

/** Get the size of the DHT (for saving). */
non_null()
uint32_t dht_size(const DHT *dht);

/** Save the DHT in data where data is an array of size `dht_size()`. */
non_null()
void dht_save(const DHT *dht, uint8_t *data);

/** @brief Load the DHT from data of size size.
 *
 * @retval -1 if failure.
 * @retval 0 if success.
 */
non_null()
int dht_load(DHT *dht, const uint8_t *data, uint32_t length);

/** Initialize DHT. */
non_null()
DHT *new_dht(const Logger *log, const Random *rng, const Network *ns, Mono_Time *mono_time, Networking_Core *net,
             bool hole_punching_enabled, bool lan_discovery_enabled);

nullable(1)
void kill_dht(DHT *dht);

/**
 * @retval false if we are not connected to the DHT.
 * @retval true if we are.
 */
non_null()
bool dht_isconnected(const DHT *dht);

/**
 * @retval false if we are not connected or only connected to lan peers with the DHT.
 * @retval true if we are.
 */
non_null()
bool dht_non_lan_connected(const DHT *dht);

/** @brief Attempt to add client with ip_port and public_key to the friends client list
 * and close_clientlist.
 *
 * @return 1+ if the item is used in any list, 0 else
 */
non_null()
uint32_t addto_lists(DHT *dht, const IP_Port *ip_port, const uint8_t *public_key);

/** @brief Copies our own ip_port structure to `dest`.
 *
 * WAN addresses take priority over LAN addresses.
 *
 * This function will zero the `dest` buffer before use.
 *
 * @retval 0 if our ip port can't be found (this usually means we're not connected to the DHT).
 * @retval 1 if IP is a WAN address.
 * @retval 2 if IP is a LAN address.
 */
non_null()
unsigned int ipport_self_copy(const DHT *dht, IP_Port *dest);

#ifdef __cplusplus
}  // extern "C"
#endif

#endif
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2022 The TokTok team.
 */

#ifndef C_TOXCORE_TOXCORE_SHARED_KEY_CACHE_H
#define C_TOXCORE_TOXCORE_SHARED_KEY_CACHE_H

#include <stdint.h>     // uint*_t


/**
 * This implements a cache for shared keys, since key generation is expensive.
 */

typedef struct Shared_Key_Cache Shared_Key_Cache;

/**
 * @brief Initializes a new shared key cache.
 * @param time Time object for retrieving current time.
 * @param self_secret_key Our own secret key of length CRYPTO_SECRET_KEY_SIZE,
 * it must not change during the lifetime of the cache.
 * @param timeout Number of milliseconds, after which a key should be evicted.
 * @param keys_per_slot There are 256 slots, this controls how many keys are stored per slot and the size of the cache.
 * @return nullptr on error.
 */
non_null()
Shared_Key_Cache *shared_key_cache_new(const Mono_Time *time,
                                       const uint8_t *self_secret_key,
                                       uint64_t timeout, uint8_t keys_per_slot);

/**
 * @brief Deletes the cache and frees all resources.
 * @param cache Cache to delete or nullptr.
 */
nullable(1)
void shared_key_cache_free(Shared_Key_Cache *cache);

/**
 * @brief Looks up a key from the cache or computes it if it didn't exist yet.
 * @param cache Cache to perform the lookup on.
 * @param public_key Public key, used for the lookup and computation.
 *
 * @return The shared key of length CRYPTO_SHARED_KEY_SIZE, matching the public key and our secret key.
 * @return nullptr on error.
 */
non_null()
const uint8_t* shared_key_cache_lookup(Shared_Key_Cache *cache, const uint8_t public_key[CRYPTO_PUBLIC_KEY_SIZE]);

#endif // C_TOXCORE_TOXCORE_SHARED_KEY_CACHE_H
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2018 The TokTok team.
 * Copyright © 2013 Tox project.
 */

/**
 * Implementation of the onion part of docs/Prevent_Tracking.txt
 */
#ifndef C_TOXCORE_TOXCORE_ONION_H
#define C_TOXCORE_TOXCORE_ONION_H


typedef int onion_recv_1_cb(void *object, const IP_Port *dest, const uint8_t *data, uint16_t length);

typedef struct Onion {
    const Logger *log;
    const Mono_Time *mono_time;
    const Random *rng;
    DHT *dht;
    Networking_Core *net;
    uint8_t secret_symmetric_key[CRYPTO_SYMMETRIC_KEY_SIZE];
    uint64_t timestamp;

    Shared_Key_Cache *shared_keys_1;
    Shared_Key_Cache *shared_keys_2;
    Shared_Key_Cache *shared_keys_3;

    onion_recv_1_cb *recv_1_function;
    void *callback_object;
} Onion;

#define ONION_MAX_PACKET_SIZE 1400

#define ONION_RETURN_1 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
#define ONION_RETURN_2 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_1)
#define ONION_RETURN_3 (CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE + ONION_RETURN_2)

#define ONION_SEND_BASE (CRYPTO_PUBLIC_KEY_SIZE + SIZE_IPPORT + CRYPTO_MAC_SIZE)
#define ONION_SEND_3 (CRYPTO_NONCE_SIZE + ONION_SEND_BASE + ONION_RETURN_2)
#define ONION_SEND_2 (CRYPTO_NONCE_SIZE + ONION_SEND_BASE*2 + ONION_RETURN_1)
#define ONION_SEND_1 (CRYPTO_NONCE_SIZE + ONION_SEND_BASE*3)

#define ONION_MAX_DATA_SIZE (ONION_MAX_PACKET_SIZE - (ONION_SEND_1 + 1))
#define ONION_RESPONSE_MAX_DATA_SIZE (ONION_MAX_PACKET_SIZE - (1 + ONION_RETURN_3))

#define ONION_PATH_LENGTH 3

typedef struct Onion_Path {
    uint8_t shared_key1[CRYPTO_SHARED_KEY_SIZE];
    uint8_t shared_key2[CRYPTO_SHARED_KEY_SIZE];
    uint8_t shared_key3[CRYPTO_SHARED_KEY_SIZE];

    uint8_t public_key1[CRYPTO_PUBLIC_KEY_SIZE];
    uint8_t public_key2[CRYPTO_PUBLIC_KEY_SIZE];
    uint8_t public_key3[CRYPTO_PUBLIC_KEY_SIZE];

    IP_Port     ip_port1;
    uint8_t     node_public_key1[CRYPTO_PUBLIC_KEY_SIZE];

    IP_Port     ip_port2;
    uint8_t     node_public_key2[CRYPTO_PUBLIC_KEY_SIZE];

    IP_Port     ip_port3;
    uint8_t     node_public_key3[CRYPTO_PUBLIC_KEY_SIZE];

    uint32_t path_num;
} Onion_Path;

/** @brief Create a new onion path.
 *
 * Create a new onion path out of nodes (nodes is a list of ONION_PATH_LENGTH nodes)
 *
 * new_path must be an empty memory location of at least Onion_Path size.
 *
 * return -1 on failure.
 * return 0 on success.
 */
non_null()
int create_onion_path(const Random *rng, const DHT *dht, Onion_Path *new_path, const Node_format *nodes);

/** @brief Dump nodes in onion path to nodes of length num_nodes.
 *
 * return -1 on failure.
 * return 0 on success.
 */
non_null()
int onion_path_to_nodes(Node_format *nodes, unsigned int num_nodes, const Onion_Path *path);

/** @brief Create a onion packet.
 *
 * Use Onion_Path path to create packet for data of length to dest.
 * Maximum length of data is ONION_MAX_DATA_SIZE.
 * packet should be at least ONION_MAX_PACKET_SIZE big.
 *
 * return -1 on failure.
 * return length of created packet on success.
 */
non_null()
int create_onion_packet(const Random *rng, uint8_t *packet, uint16_t max_packet_length,
                        const Onion_Path *path, const IP_Port *dest,
                        const uint8_t *data, uint16_t length);


/** @brief Create a onion packet to be sent over tcp.
 *
 * Use Onion_Path path to create packet for data of length to dest.
 * Maximum length of data is ONION_MAX_DATA_SIZE.
 * packet should be at least ONION_MAX_PACKET_SIZE big.
 *
 * return -1 on failure.
 * return length of created packet on success.
 */
non_null()
int create_onion_packet_tcp(const Random *rng, uint8_t *packet, uint16_t max_packet_length,
                            const Onion_Path *path, const IP_Port *dest,
                            const uint8_t *data, uint16_t length);

/** @brief Create and send a onion response sent initially to dest with.
 * Maximum length of data is ONION_RESPONSE_MAX_DATA_SIZE.
 *
 * return -1 on failure.
 * return 0 on success.
 */
non_null()
int send_onion_response(const Networking_Core *net, const IP_Port *dest, const uint8_t *data, uint16_t length,
                        const uint8_t *ret);

/** @brief Function to handle/send received decrypted versions of the packet created by create_onion_packet.
 *
 * return 0 on success.
 * return 1 on failure.
 *
 * Used to handle these packets that are received in a non traditional way (by TCP for example).
 *
 * Source family must be set to something else than TOX_AF_INET6 or TOX_AF_INET so that the callback gets called
 * when the response is received.
 */
non_null()
int onion_send_1(const Onion *onion, const uint8_t *plain, uint16_t len, const IP_Port *source, const uint8_t *nonce);

/** Set the callback to be called when the dest ip_port doesn't have TOX_AF_INET6 or TOX_AF_INET as the family. */
non_null(1) nullable(2, 3)
void set_callback_handle_recv_1(Onion *onion, onion_recv_1_cb *function, void *object);

non_null()
Onion *new_onion(const Logger *log, const Mono_Time *mono_time, const Random *rng, DHT *dht);

nullable(1)
void kill_onion(Onion *onion);


#endif
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2019-2022 The TokTok team.
 */

#ifndef C_TOXCORE_TOXCORE_FORWARDING_H
#define C_TOXCORE_TOXCORE_FORWARDING_H


#ifdef __cplusplus
extern "C" {
#endif

#define SENDBACK_IPPORT 0
#define SENDBACK_FORWARD 1
#define SENDBACK_TCP 2

#define MAX_SENDBACK_SIZE (0xff - 1)
#define MAX_FORWARD_DATA_SIZE (MAX_UDP_PACKET_SIZE - (1 + 1 + MAX_SENDBACK_SIZE))

#define MAX_FORWARD_CHAIN_LENGTH 4

#define MAX_PACKED_IPPORT_SIZE (1 + SIZE_IP6 + sizeof(uint16_t))

typedef struct Forwarding Forwarding;

non_null()
DHT *forwarding_get_dht(Forwarding *forwarding);

/**
 * @brief Send data to forwarder for forwarding via chain of dht nodes.
 * Destination is last key in the chain.
 *
 * @param data Must be of length at most MAX_FORWARD_DATA_SIZE.
 * @param chain_length Number of intermediate nodes in chain.
 *   Must be at least 1 and at most MAX_FORWARD_CHAIN_LENGTH.
 * @param chain_keys Public keys of chain nodes. Must be of length
 *   `chain_length * CRYPTO_PUBLIC_KEY_SIZE`.
 *
 * @return true on success, false otherwise.
 */
non_null()
bool send_forward_request(Networking_Core *net, const IP_Port *forwarder,
                          const uint8_t *chain_keys, uint16_t chain_length,
                          const uint8_t *data, uint16_t data_length);

/** Returns size of packet written by create_forward_chain_packet. */
uint16_t forward_chain_packet_size(uint16_t chain_length, uint16_t data_length);

/**
 * @brief Create forward request packet for forwarding data via chain of dht nodes.
 * Destination is last key in the chain.
 *
 * @param data Must be of length at most MAX_FORWARD_DATA_SIZE.
 * @param chain_length Number of intermediate nodes in chain.
 *   Must be at least 1 and at most MAX_FORWARD_CHAIN_LENGTH.
 * @param chain_keys Public keys of chain nodes. Must be of length
 *   `chain_length * CRYPTO_PUBLIC_KEY_SIZE`.
 * @param packet Must be of size at least
 *   `forward_chain_packet_size(chain_length, data_length)` bytes.
 *
 * @return true on success, false otherwise.
 */
non_null()
bool create_forward_chain_packet(const uint8_t *chain_keys, uint16_t chain_length,
                                 const uint8_t *data, uint16_t data_length,
                                 uint8_t *packet);

/**
 * @brief Send reply to forwarded packet via forwarder.
 * @param sendback Must be of size at most MAX_SENDBACK_SIZE.
 * @param data Must be of size at most MAX_FORWARD_DATA_SIZE.
 *
 * @return true on success, false otherwise.
 */
non_null()
bool forward_reply(Networking_Core *net, const IP_Port *forwarder,
                   const uint8_t *sendback, uint16_t sendback_length,
                   const uint8_t *data, uint16_t length);


/**
 * @brief Set callback to handle a forwarded request.
 * To reply to the packet, callback should use `forward_reply()` to send a reply
 * forwarded via forwarder, passing the provided sendback.
 */
typedef void forwarded_request_cb(void *object, const IP_Port *forwarder, const uint8_t *sendback,
                                  uint16_t sendback_length, const uint8_t *data,
                                  uint16_t length, void *userdata);
non_null(1) nullable(2, 3)
void set_callback_forwarded_request(Forwarding *forwarding, forwarded_request_cb *function, void *object);

/** @brief Set callback to handle a forwarded response. */
typedef void forwarded_response_cb(void *object, const uint8_t *data, uint16_t length, void *userdata);
non_null(1) nullable(2, 3)
void set_callback_forwarded_response(Forwarding *forwarding, forwarded_response_cb *function, void *object);

/** @brief Send forwarding packet to dest with given sendback data and data. */
non_null(1, 2, 5) nullable(3)
bool send_forwarding(const Forwarding *forwarding, const IP_Port *dest,
                     const uint8_t *sendback_data, uint16_t sendback_data_len,
                     const uint8_t *data, uint16_t length);

typedef bool forward_reply_cb(void *object, const uint8_t *sendback_data, uint16_t sendback_data_len,
                              const uint8_t *data, uint16_t length);

/**
 * @brief Set callback to handle a forward reply with an otherwise unhandled
 * sendback.
 */
non_null(1) nullable(2, 3)
void set_callback_forward_reply(Forwarding *forwarding, forward_reply_cb *function, void *object);

non_null()
Forwarding *new_forwarding(const Logger *log, const Random *rng, const Mono_Time *mono_time, DHT *dht);

nullable(1)
void kill_forwarding(Forwarding *forwarding);

#ifdef __cplusplus
}  // extern "C"
#endif

#endif
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2018 The TokTok team.
 * Copyright © 2014 Tox project.
 */

/**
 * Implementation of the TCP relay client part of Tox.
 */
#ifndef C_TOXCORE_TOXCORE_TCP_CLIENT_H
#define C_TOXCORE_TOXCORE_TCP_CLIENT_H


#define TCP_CONNECTION_TIMEOUT 10

typedef enum TCP_Proxy_Type {
    TCP_PROXY_NONE,
    TCP_PROXY_HTTP,
    TCP_PROXY_SOCKS5,
} TCP_Proxy_Type;

typedef struct TCP_Proxy_Info {
    IP_Port ip_port;
    uint8_t proxy_type; // a value from TCP_PROXY_TYPE
} TCP_Proxy_Info;

typedef enum TCP_Client_Status {
    TCP_CLIENT_NO_STATUS,
    TCP_CLIENT_PROXY_HTTP_CONNECTING,
    TCP_CLIENT_PROXY_SOCKS5_CONNECTING,
    TCP_CLIENT_PROXY_SOCKS5_UNCONFIRMED,
    TCP_CLIENT_CONNECTING,
    TCP_CLIENT_UNCONFIRMED,
    TCP_CLIENT_CONFIRMED,
    TCP_CLIENT_DISCONNECTED,
} TCP_Client_Status;

typedef struct TCP_Client_Connection TCP_Client_Connection;

non_null()
const uint8_t *tcp_con_public_key(const TCP_Client_Connection *con);
non_null()
IP_Port tcp_con_ip_port(const TCP_Client_Connection *con);
non_null()
TCP_Client_Status tcp_con_status(const TCP_Client_Connection *con);

non_null()
void *tcp_con_custom_object(const TCP_Client_Connection *con);
non_null()
uint32_t tcp_con_custom_uint(const TCP_Client_Connection *con);
non_null()
void tcp_con_set_custom_object(TCP_Client_Connection *con, void *object);
non_null()
void tcp_con_set_custom_uint(TCP_Client_Connection *con, uint32_t value);

/** Create new TCP connection to ip_port/public_key */
non_null(1, 2, 3, 4, 5, 6, 7, 8) nullable(9)
TCP_Client_Connection *new_TCP_connection(
        const Logger *logger, const Mono_Time *mono_time, const Random *rng, const Network *ns, const IP_Port *ip_port,
        const uint8_t *public_key, const uint8_t *self_public_key, const uint8_t *self_secret_key,
        const TCP_Proxy_Info *proxy_info);

/** Run the TCP connection */
non_null(1, 2, 3) nullable(4)
void do_TCP_connection(const Logger *logger, const Mono_Time *mono_time,
                       TCP_Client_Connection *tcp_connection, void *userdata);

/** Kill the TCP connection */
nullable(1)
void kill_TCP_connection(TCP_Client_Connection *tcp_connection);

typedef int tcp_onion_response_cb(void *object, const uint8_t *data, uint16_t length, void *userdata);

/**
 * @retval 1 on success.
 * @retval 0 if could not send packet.
 * @retval -1 on failure (connection must be killed).
 */
non_null()
int send_onion_request(const Logger *logger, TCP_Client_Connection *con, const uint8_t *data, uint16_t length);
non_null()
void onion_response_handler(TCP_Client_Connection *con, tcp_onion_response_cb *onion_callback, void *object);

non_null()
int send_forward_request_tcp(const Logger *logger, TCP_Client_Connection *con, const IP_Port *dest, const uint8_t *data,
                             uint16_t length);
non_null()
void forwarding_handler(TCP_Client_Connection *con, forwarded_response_cb *forwarded_response_callback, void *object);

typedef int tcp_routing_response_cb(void *object, uint8_t connection_id, const uint8_t *public_key);
typedef int tcp_routing_status_cb(void *object, uint32_t number, uint8_t connection_id, uint8_t status);

/**
 * @retval 1 on success.
 * @retval 0 if could not send packet.
 * @retval -1 on failure (connection must be killed).
 */
non_null()
int send_routing_request(const Logger *logger, TCP_Client_Connection *con, const uint8_t *public_key);
non_null()
void routing_response_handler(TCP_Client_Connection *con, tcp_routing_response_cb *response_callback, void *object);
non_null()
void routing_status_handler(TCP_Client_Connection *con, tcp_routing_status_cb *status_callback, void *object);

/**
 * @retval 1 on success.
 * @retval 0 if could not send packet.
 * @retval -1 on failure (connection must be killed).
 */
non_null()
int send_disconnect_request(const Logger *logger, TCP_Client_Connection *con, uint8_t con_id);

/** @brief Set the number that will be used as an argument in the callbacks related to con_id.
 *
 * When not set by this function, the number is -1.
 *
 * return 0 on success.
 * return -1 on failure.
 */
non_null()
int set_tcp_connection_number(TCP_Client_Connection *con, uint8_t con_id, uint32_t number);

typedef int tcp_routing_data_cb(void *object, uint32_t number, uint8_t connection_id, const uint8_t *data,
                                uint16_t length, void *userdata);

/**
 * @retval 1 on success.
 * @retval 0 if could not send packet.
 * @retval -1 on failure.
 */
non_null()
int send_data(const Logger *logger, TCP_Client_Connection *con, uint8_t con_id, const uint8_t *data, uint16_t length);
non_null()
void routing_data_handler(TCP_Client_Connection *con, tcp_routing_data_cb *data_callback, void *object);

typedef int tcp_oob_data_cb(void *object, const uint8_t *public_key, const uint8_t *data, uint16_t length,
                            void *userdata);

/**
 * @retval 1 on success.
 * @retval 0 if could not send packet.
 * @retval -1 on failure.
 */
non_null()
int send_oob_packet(const Logger *logger, TCP_Client_Connection *con, const uint8_t *public_key, const uint8_t *data,
                    uint16_t length);
non_null()
void oob_data_handler(TCP_Client_Connection *con, tcp_oob_data_cb *oob_data_callback, void *object);


#endif
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2018 The TokTok team.
 * Copyright © 2015 Tox project.
 */

/**
 * Handles TCP relay connections between two Tox clients.
 */
#ifndef C_TOXCORE_TOXCORE_TCP_CONNECTION_H
#define C_TOXCORE_TOXCORE_TCP_CONNECTION_H

#include <stdbool.h>


#define TCP_CONN_NONE 0
#define TCP_CONN_VALID 1

/** NOTE: only used by TCP_con */
#define TCP_CONN_CONNECTED 2

/** Connection is not connected but can be quickly reconnected in case it is needed. */
#define TCP_CONN_SLEEPING 3

#define TCP_CONNECTIONS_STATUS_NONE 0
#define TCP_CONNECTIONS_STATUS_REGISTERED 1
#define TCP_CONNECTIONS_STATUS_ONLINE 2

#define MAX_FRIEND_TCP_CONNECTIONS 6

/** Time until connection to friend gets killed (if it doesn't get locked within that time) */
#define TCP_CONNECTION_ANNOUNCE_TIMEOUT TCP_CONNECTION_TIMEOUT

/** @brief The amount of recommended connections for each friend
 * NOTE: Must be at most (MAX_FRIEND_TCP_CONNECTIONS / 2)
 */
#define RECOMMENDED_FRIEND_TCP_CONNECTIONS (MAX_FRIEND_TCP_CONNECTIONS / 2)

/** Number of TCP connections used for onion purposes. */
#define NUM_ONION_TCP_CONNECTIONS RECOMMENDED_FRIEND_TCP_CONNECTIONS

typedef struct TCP_Conn_to {
    uint32_t tcp_connection;
    uint8_t status;
    uint8_t connection_id;
} TCP_Conn_to;

typedef struct TCP_Connection_to {
    uint8_t status;
    uint8_t public_key[CRYPTO_PUBLIC_KEY_SIZE]; /* The dht public key of the peer */

    TCP_Conn_to connections[MAX_FRIEND_TCP_CONNECTIONS];

    int id; /* id used in callbacks. */
} TCP_Connection_to;

typedef struct TCP_con {
    uint8_t status;
    TCP_Client_Connection *connection;
    uint64_t connected_time;
    uint32_t lock_count;
    uint32_t sleep_count;
    bool onion;

    /* Only used when connection is sleeping. */
    IP_Port ip_port;
    uint8_t relay_pk[CRYPTO_PUBLIC_KEY_SIZE];
    bool unsleep; /* set to 1 to unsleep connection. */
} TCP_con;

typedef struct TCP_Connections TCP_Connections;

non_null()
const uint8_t *tcp_connections_public_key(const TCP_Connections *tcp_c);

non_null()
uint32_t tcp_connections_count(const TCP_Connections *tcp_c);

/** @brief Returns the number of connected TCP relays. */
non_null()
uint32_t tcp_connected_relays_count(const TCP_Connections *tcp_c);

/** @brief Returns true if we know of a valid TCP relay with the passed public key. */
non_null()
bool tcp_relay_is_valid(const TCP_Connections *tcp_c, const uint8_t *relay_pk);

/** @brief Send a packet to the TCP connection.
 *
 * return -1 on failure.
 * return 0 on success.
 */
non_null()
int send_packet_tcp_connection(const TCP_Connections *tcp_c, int connections_number, const uint8_t *packet,
                               uint16_t length);

/** @brief Return a TCP connection number for use in send_tcp_onion_request.
 *
 * TODO(irungentoo): This number is just the index of an array that the elements
 * can change without warning.
 *
 * return TCP connection number on success.
 * return -1 on failure.
 */
non_null()
int get_random_tcp_onion_conn_number(const TCP_Connections *tcp_c);

/** @brief Put IP_Port of a random onion TCP connection in ip_port.
 *
 * return true on success.
 * return false on failure.
 */
non_null()
bool tcp_get_random_conn_ip_port(const TCP_Connections *tcp_c, IP_Port *ip_port);

/** @brief Send an onion packet via the TCP relay corresponding to tcp_connections_number.
 *
 * return 0 on success.
 * return -1 on failure.
 */
non_null()
int tcp_send_onion_request(TCP_Connections *tcp_c, unsigned int tcp_connections_number, const uint8_t *data,
                           uint16_t length);

/** @brief Set if we want TCP_connection to allocate some connection for onion use.
 *
 * If status is 1, allocate some connections. if status is 0, don't.
 *
 * return 0 on success.
 * return -1 on failure.
 */
non_null()
int set_tcp_onion_status(TCP_Connections *tcp_c, bool status);

/**
 * Send a forward request to the TCP relay with IP_Port tcp_forwarder,
 * requesting to forward data via a chain of dht nodes starting with dht_node.
 * A chain_length of 0 means that dht_node is the final destination of data.
 *
 * return 0 on success.
 * return -1 on failure.
 */
non_null()
int tcp_send_forward_request(const Logger *logger, TCP_Connections *tcp_c, const IP_Port *tcp_forwarder,
                             const IP_Port *dht_node,
                             const uint8_t *chain_keys, uint16_t chain_length,
                             const uint8_t *data, uint16_t data_length);

/** @brief Send an oob packet via the TCP relay corresponding to tcp_connections_number.
 *
 * return 0 on success.
 * return -1 on failure.
 */
non_null()
int tcp_send_oob_packet(const TCP_Connections *tcp_c, unsigned int tcp_connections_number, const uint8_t *public_key,
                        const uint8_t *packet, uint16_t length);

typedef int tcp_data_cb(void *object, int id, const uint8_t *data, uint16_t length, void *userdata);

non_null()
int tcp_send_oob_packet_using_relay(const TCP_Connections *tcp_c, const uint8_t *relay_pk, const uint8_t *public_key,
                                    const uint8_t *packet, uint16_t length);

/** @brief Set the callback for TCP data packets. */
non_null()
void set_packet_tcp_connection_callback(TCP_Connections *tcp_c, tcp_data_cb *tcp_data_callback, void *object);

typedef int tcp_onion_cb(void *object, const uint8_t *data, uint16_t length, void *userdata);

/** @brief Set the callback for TCP onion packets. */
non_null(1) nullable(2, 3)
void set_onion_packet_tcp_connection_callback(TCP_Connections *tcp_c, tcp_onion_cb *tcp_onion_callback, void *object);

/** @brief Set the callback for TCP forwarding packets. */
non_null(1) nullable(2, 3)
void set_forwarding_packet_tcp_connection_callback(TCP_Connections *tcp_c,
        forwarded_response_cb *tcp_forwarded_response_callback,
        void *object);


typedef int tcp_oob_cb(void *object, const uint8_t *public_key, unsigned int tcp_connections_number,
                       const uint8_t *data, uint16_t length, void *userdata);

/** @brief Set the callback for TCP oob data packets. */
non_null()
void set_oob_packet_tcp_connection_callback(TCP_Connections *tcp_c, tcp_oob_cb *tcp_oob_callback, void *object);

/** @brief Encode tcp_connections_number as a custom ip_port.
 *
 * return ip_port.
 */
IP_Port tcp_connections_number_to_ip_port(unsigned int tcp_connections_number);

/** @brief Decode ip_port created by tcp_connections_number_to_ip_port to tcp_connections_number.
 *
 * return true on success.
 * return false if ip_port is invalid.
 */
non_null()
bool ip_port_to_tcp_connections_number(const IP_Port *ip_port, unsigned int *tcp_connections_number);

/** @brief Create a new TCP connection to public_key.
 *
 * public_key must be the counterpart to the secret key that the other peer used with `new_tcp_connections()`.
 *
 * id is the id in the callbacks for that connection.
 *
 * return connections_number on success.
 * return -1 on failure.
 */
non_null()
int new_tcp_connection_to(TCP_Connections *tcp_c, const uint8_t *public_key, int id);

/**
 * @retval 0 on success.
 * @retval -1 on failure.
 */
non_null()
int kill_tcp_connection_to(TCP_Connections *tcp_c, int connections_number);

/** @brief Set connection status.
 *
 * status of 1 means we are using the connection.
 * status of 0 means we are not using it.
 *
 * Unused tcp connections will be disconnected from but kept in case they are needed.
 *
 * return 0 on success.
 * return -1 on failure.
 */
non_null()
int set_tcp_connection_to_status(const TCP_Connections *tcp_c, int connections_number, bool status);

/**
 * @return number of online tcp relays tied to the connection on success.
 * @retval 0 on failure.
 */
non_null()
uint32_t tcp_connection_to_online_tcp_relays(const TCP_Connections *tcp_c, int connections_number);

/** @brief Add a TCP relay tied to a connection.
 *
 * NOTE: This can only be used during the tcp_oob_callback.
 *
 * return 0 on success.
 * return -1 on failure.
 */
non_null()
int add_tcp_number_relay_connection(const TCP_Connections *tcp_c, int connections_number,
                                    unsigned int tcp_connections_number);

/** @brief Add a TCP relay tied to a connection.
 *
 * This should be called with the same relay by two peers who want to create a TCP connection with each other.
 *
 * return 0 on success.
 * return -1 on failure.
 */
non_null()
int add_tcp_relay_connection(TCP_Connections *tcp_c, int connections_number, const IP_Port *ip_port,
                             const uint8_t *relay_pk);

/** @brief Add a TCP relay to the TCP_Connections instance.
 *
 * return 0 on success.
 * return -1 on failure.
 */
non_null()
int add_tcp_relay_global(TCP_Connections *tcp_c, const IP_Port *ip_port, const uint8_t *relay_pk);

/** @brief Copy a maximum of max_num TCP relays we are connected to to tcp_relays.
 *
 * NOTE that the family of the copied ip ports will be set to TCP_INET or TCP_INET6.
 *
 * return number of relays copied to tcp_relays on success.
 * return 0 on failure.
 */
non_null()
uint32_t tcp_copy_connected_relays(const TCP_Connections *tcp_c, Node_format *tcp_relays, uint16_t max_num);

/** @brief Copy a maximum of `max_num` TCP relays we are connected to starting at idx.
 *
 * @param idx is the index in the TCP relay array for `tcp_c` designated.
 *   If idx is greater than the array length a modulo operation is performed.
 *
 * Returns the number of relays successfully copied.
 */
non_null()
uint32_t tcp_copy_connected_relays_index(const TCP_Connections *tcp_c, Node_format *tcp_relays, uint16_t max_num,
        uint32_t idx);

/** @brief Returns a new TCP_Connections object associated with the secret_key.
 *
 * In order for others to connect to this instance `new_tcp_connection_to()` must be called with the
 * public_key associated with secret_key.
 *
 * Returns NULL on failure.
 */
non_null()
TCP_Connections *new_tcp_connections(
        const Logger *logger, const Random *rng, const Network *ns, Mono_Time *mono_time,
        const uint8_t *secret_key, const TCP_Proxy_Info *proxy_info);

non_null()
int kill_tcp_relay_connection(TCP_Connections *tcp_c, int tcp_connections_number);

non_null(1, 2) nullable(3)
void do_tcp_connections(const Logger *logger, TCP_Connections *tcp_c, void *userdata);

nullable(1)
void kill_tcp_connections(TCP_Connections *tcp_c);

non_null()
char *tcp_copy_all_connected_relays(const TCP_Connections *tcp_c, char* relays_report_string, uint16_t max_num, uint32_t* num);

non_null()
TCP_Connection_to *get_connection(const TCP_Connections *tcp_c, int connections_number);

non_null()
TCP_con *get_tcp_connection(const TCP_Connections *tcp_c, int tcp_connections_number);

#endif
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2018 The TokTok team.
 * Copyright © 2013 Tox project.
 */

/**
 * Functions for the core network crypto.
 */
#ifndef C_TOXCORE_TOXCORE_NET_CRYPTO_H
#define C_TOXCORE_TOXCORE_NET_CRYPTO_H

#include <pthread.h>


/*** Crypto payloads. */

/*** Ranges. */

/** Packets in this range are reserved for net_crypto events_alloc use. */
#define PACKET_ID_RANGE_RESERVED_START 0
#define PACKET_ID_RANGE_RESERVED_END 15
/** Packets in this range are reserved for Messenger use. */
#define PACKET_ID_RANGE_LOSSLESS_START 16
#define PACKET_ID_RANGE_LOSSLESS_NORMAL_START 16
#define PACKET_ID_RANGE_LOSSLESS_NORMAL_END 159
/** Packets in this range can be used for anything. */
#define PACKET_ID_RANGE_LOSSLESS_CUSTOM_START 160
#define PACKET_ID_RANGE_LOSSLESS_CUSTOM_END 191
#define PACKET_ID_RANGE_LOSSLESS_END 191
/** Packets in this range are reserved for AV use. */
#define PACKET_ID_RANGE_LOSSY_START 192
#define PACKET_ID_RANGE_LOSSY_AV_START 192
#define PACKET_ID_RANGE_LOSSY_AV_SIZE 8
#define PACKET_ID_RANGE_LOSSY_AV_END 199
/** Packets in this range can be used for anything. */
#define PACKET_ID_RANGE_LOSSY_CUSTOM_START 200
#define PACKET_ID_RANGE_LOSSY_CUSTOM_END 254
#define PACKET_ID_RANGE_LOSSY_END 254

/*** Messages. */

#define PACKET_ID_PADDING 0 // Denotes padding
#define PACKET_ID_REQUEST 1 // Used to request unreceived packets
#define PACKET_ID_KILL    2 // Used to kill connection

#define PACKET_ID_ONLINE 24
#define PACKET_ID_OFFLINE 25
#define PACKET_ID_NICKNAME 48
#define PACKET_ID_STATUSMESSAGE 49
#define PACKET_ID_USERSTATUS 50
#define PACKET_ID_TYPING 51
#define PACKET_ID_MESSAGE 64
#define PACKET_ID_ACTION 65 // PACKET_ID_MESSAGE + MESSAGE_ACTION
#define PACKET_ID_HIGH_LEVEL_ACK 66 // MSG V3
#define PACKET_ID_MSI 69    // Used by AV to setup calls and etc
#define PACKET_ID_FILE_SENDREQUEST 80
#define PACKET_ID_FILE_CONTROL 81
#define PACKET_ID_FILE_DATA 82
#define PACKET_ID_INVITE_GROUPCHAT 95
#define PACKET_ID_INVITE_CONFERENCE 96
#define PACKET_ID_ONLINE_PACKET 97
#define PACKET_ID_DIRECT_CONFERENCE 98
#define PACKET_ID_MESSAGE_CONFERENCE 99
#define PACKET_ID_REJOIN_CONFERENCE 100
#define PACKET_ID_LOSSY_CONFERENCE 199

/** Maximum size of receiving and sending packet buffers. */
#define CRYPTO_PACKET_BUFFER_SIZE 32768 // Must be a power of 2

/** Minimum packet rate per second. */
#define CRYPTO_PACKET_MIN_RATE 4.0

/** Minimum packet queue max length. */
#define CRYPTO_MIN_QUEUE_LENGTH 64

/** Maximum total size of packets that net_crypto sends. */
#define MAX_CRYPTO_PACKET_SIZE (uint16_t)1400

#define CRYPTO_DATA_PACKET_MIN_SIZE (uint16_t)(1 + sizeof(uint16_t) + (sizeof(uint32_t) + sizeof(uint32_t)) + CRYPTO_MAC_SIZE)

/** Max size of data in packets */
#define MAX_CRYPTO_DATA_SIZE (uint16_t)(MAX_CRYPTO_PACKET_SIZE - CRYPTO_DATA_PACKET_MIN_SIZE)

/** Interval in ms between sending cookie request/handshake packets. */
#define CRYPTO_SEND_PACKET_INTERVAL 1000

/**
 * The maximum number of times we try to send the cookie request and handshake
 * before giving up.
 */
#define MAX_NUM_SENDPACKET_TRIES 8

/** The timeout of no received UDP packets before the direct UDP connection is considered dead. */
#define UDP_DIRECT_TIMEOUT 8

#define MAX_TCP_CONNECTIONS 64
#define MAX_TCP_RELAYS_PEER 4

/** All packets will be padded a number of bytes based on this number. */
#define CRYPTO_MAX_PADDING 8

/**
 * Base current transfer speed on last CONGESTION_QUEUE_ARRAY_SIZE number of points taken
 * at the dT defined in net_crypto.c
 */
#define CONGESTION_QUEUE_ARRAY_SIZE 12
#define CONGESTION_LAST_SENT_ARRAY_SIZE (CONGESTION_QUEUE_ARRAY_SIZE * 2)

/** Default connection ping in ms. */
#define DEFAULT_PING_CONNECTION 1000
#define DEFAULT_TCP_PING_CONNECTION 500

typedef struct Net_Crypto Net_Crypto;

non_null() const uint8_t *nc_get_self_public_key(const Net_Crypto *c);
non_null() const uint8_t *nc_get_self_secret_key(const Net_Crypto *c);
non_null() TCP_Connections *nc_get_tcp_c(const Net_Crypto *c);
non_null() DHT *nc_get_dht(const Net_Crypto *c);

typedef struct New_Connection {
    IP_Port source;
    uint8_t public_key[CRYPTO_PUBLIC_KEY_SIZE]; /* The real public key of the peer. */
    uint8_t dht_public_key[CRYPTO_PUBLIC_KEY_SIZE]; /* The dht public key of the peer. */
    uint8_t recv_nonce[CRYPTO_NONCE_SIZE]; /* Nonce of received packets. */
    uint8_t peersessionpublic_key[CRYPTO_PUBLIC_KEY_SIZE]; /* The public key of the peer. */
    uint8_t *cookie;
    uint8_t cookie_length;
} New_Connection;

typedef int connection_status_cb(void *object, int id, bool status, void *userdata);
typedef int connection_data_cb(void *object, int id, const uint8_t *data, uint16_t length, void *userdata);
typedef int connection_lossy_data_cb(void *object, int id, const uint8_t *data, uint16_t length, void *userdata);
typedef void dht_pk_cb(void *data, int32_t number, const uint8_t *dht_public_key, void *userdata);
typedef int new_connection_cb(void *object, const New_Connection *n_c);

/** @brief Set function to be called when someone requests a new connection to us.
 *
 * The set function should return -1 on failure and 0 on success.
 *
 * n_c is only valid for the duration of the function call.
 */
non_null()
void new_connection_handler(Net_Crypto *c, new_connection_cb *new_connection_callback, void *object);

/** @brief Accept a crypto connection.
 *
 * return -1 on failure.
 * return connection id on success.
 */
non_null()
int accept_crypto_connection(Net_Crypto *c, const New_Connection *n_c);

/** @brief Create a crypto connection.
 * If one to that real public key already exists, return it.
 *
 * return -1 on failure.
 * return connection id on success.
 */
non_null()
int new_crypto_connection(Net_Crypto *c, const uint8_t *real_public_key, const uint8_t *dht_public_key);

/** @brief Set the direct ip of the crypto connection.
 *
 * Connected is 0 if we are not sure we are connected to that person, 1 if we are sure.
 *
 * return -1 on failure.
 * return 0 on success.
 */
non_null()
int set_direct_ip_port(Net_Crypto *c, int crypt_connection_id, const IP_Port *ip_port, bool connected);

/** @brief Set function to be called when connection with crypt_connection_id goes connects/disconnects.
 *
 * The set function should return -1 on failure and 0 on success.
 * Note that if this function is set, the connection will clear itself on disconnect.
 * Object and id will be passed to this function untouched.
 * status is 1 if the connection is going online, 0 if it is going offline.
 *
 * return -1 on failure.
 * return 0 on success.
 */
non_null()
int connection_status_handler(const Net_Crypto *c, int crypt_connection_id,
                              connection_status_cb *connection_status_callback, void *object, int id);

/** @brief Set function to be called when connection with crypt_connection_id receives a lossless data packet of length.
 *
 * The set function should return -1 on failure and 0 on success.
 * Object and id will be passed to this function untouched.
 *
 * return -1 on failure.
 * return 0 on success.
 */
non_null()
int connection_data_handler(const Net_Crypto *c, int crypt_connection_id,
                            connection_data_cb *connection_data_callback, void *object, int id);


/** @brief Set function to be called when connection with crypt_connection_id receives a lossy data packet of length.
 *
 * The set function should return -1 on failure and 0 on success.
 * Object and id will be passed to this function untouched.
 *
 * return -1 on failure.
 * return 0 on success.
 */
non_null()
int connection_lossy_data_handler(const Net_Crypto *c, int crypt_connection_id,
                                  connection_lossy_data_cb *connection_lossy_data_callback, void *object, int id);

/** @brief Set the function for this friend that will be callbacked with object and number if
 * the friend sends us a different dht public key than we have associated to him.
 *
 * If this function is called, the connection should be recreated with the new public key.
 *
 * object and number will be passed as argument to this function.
 *
 * return -1 on failure.
 * return 0 on success.
 */
non_null()
int nc_dht_pk_callback(const Net_Crypto *c, int crypt_connection_id,
                       dht_pk_cb *function, void *object, uint32_t number);

/**
 * @return the number of packet slots left in the sendbuffer.
 * @retval 0 if failure.
 */
non_null()
uint32_t crypto_num_free_sendqueue_slots(const Net_Crypto *c, int crypt_connection_id);

/**
 * @retval 1 if max speed was reached for this connection (no more data can be physically through the pipe).
 * @retval 0 if it wasn't reached.
 */
non_null()
bool max_speed_reached(Net_Crypto *c, int crypt_connection_id);

/** @brief Sends a lossless cryptopacket.
 *
 * return -1 if data could not be put in packet queue.
 * return positive packet number if data was put into the queue.
 *
 * The first byte of data must be in the PACKET_ID_RANGE_LOSSLESS.
 *
 * congestion_control: should congestion control apply to this packet?
 */
non_null()
int64_t write_cryptpacket(Net_Crypto *c, int crypt_connection_id,
                          const uint8_t *data, uint16_t length, bool congestion_control);

/** @brief Check if packet_number was received by the other side.
 *
 * packet_number must be a valid packet number of a packet sent on this connection.
 *
 * return -1 on failure.
 * return 0 on success.
 *
 * Note: The condition `buffer_end - buffer_start < packet_number - buffer_start` is
 * a trick which handles situations `buffer_end >= buffer_start` and
 * `buffer_end < buffer_start` (when buffer_end overflowed) both correctly.
 *
 * It CANNOT be simplified to `packet_number < buffer_start`, as it will fail
 * when `buffer_end < buffer_start`.
 */
non_null()
int cryptpacket_received(const Net_Crypto *c, int crypt_connection_id, uint32_t packet_number);

/** @brief Sends a lossy cryptopacket.
 *
 * return -1 on failure.
 * return 0 on success.
 *
 * The first byte of data must be in the PACKET_ID_RANGE_LOSSY.
 */
non_null()
int send_lossy_cryptpacket(Net_Crypto *c, int crypt_connection_id, const uint8_t *data, uint16_t length);

/** @brief Add a tcp relay, associating it to a crypt_connection_id.
 *
 * return 0 if it was added.
 * return -1 if it wasn't.
 */
non_null()
int add_tcp_relay_peer(Net_Crypto *c, int crypt_connection_id, const IP_Port *ip_port,
                       const uint8_t *public_key);

/** @brief Add a tcp relay to the array.
 *
 * return 0 if it was added.
 * return -1 if it wasn't.
 */
non_null()
int add_tcp_relay(Net_Crypto *c, const IP_Port *ip_port, const uint8_t *public_key);

/** @brief Return a random TCP connection number for use in send_tcp_onion_request.
 *
 * TODO(irungentoo): This number is just the index of an array that the elements can
 * change without warning.
 *
 * return TCP connection number on success.
 * return -1 on failure.
 */
non_null()
int get_random_tcp_con_number(Net_Crypto *c);

/** @brief Put IP_Port of a random onion TCP connection in ip_port.
 *
 * return true on success.
 * return false on failure.
 */
non_null()
bool get_random_tcp_conn_ip_port(Net_Crypto *c, IP_Port *ip_port);

/** @brief Send an onion packet via the TCP relay corresponding to tcp_connections_number.
 *
 * return 0 on success.
 * return -1 on failure.
 */
non_null()
int send_tcp_onion_request(Net_Crypto *c, unsigned int tcp_connections_number,
                           const uint8_t *data, uint16_t length);

/**
 * Send a forward request to the TCP relay with IP_Port tcp_forwarder,
 * requesting to forward data via a chain of dht nodes starting with dht_node.
 * A chain_length of 0 means that dht_node is the final destination of data.
 *
 * return 0 on success.
 * return -1 on failure.
 */
non_null()
int send_tcp_forward_request(const Logger *logger, Net_Crypto *c, const IP_Port *tcp_forwarder, const IP_Port *dht_node,
                             const uint8_t *chain_keys, uint16_t chain_length,
                             const uint8_t *data, uint16_t data_length);

/** @brief Copy a maximum of num random TCP relays we are connected to to tcp_relays.
 *
 * NOTE that the family of the copied ip ports will be set to TCP_INET or TCP_INET6.
 *
 * return number of relays copied to tcp_relays on success.
 * return 0 on failure.
 */
non_null()
unsigned int copy_connected_tcp_relays(Net_Crypto *c, Node_format *tcp_relays, uint16_t num);

/**
 * Copy a maximum of `max_num` TCP relays we are connected to starting at the index in the TCP relay array
 * for `tcp_c` designated by `idx`. If idx is greater than the array length a modulo operation is performed.
 *
 * Returns the number of relays successfully copied.
 */
non_null()
uint32_t copy_connected_tcp_relays_index(Net_Crypto *c, Node_format *tcp_relays, uint16_t num, uint32_t idx);

/** @brief Kill a crypto connection.
 *
 * return -1 on failure.
 * return 0 on success.
 */
non_null()
int crypto_kill(Net_Crypto *c, int crypt_connection_id);

/**
 * @retval true if connection is valid, false otherwise
 *
 * sets direct_connected to 1 if connection connects directly to other, 0 if it isn't.
 * sets online_tcp_relays to the number of connected tcp relays this connection has.
 */
non_null(1, 3) nullable(4)
bool crypto_connection_status(
    const Net_Crypto *c, int crypt_connection_id, bool *direct_connected, uint32_t *online_tcp_relays);

/** @brief Generate our public and private keys.
 * Only call this function the first time the program starts.
 */
non_null()
void new_keys(Net_Crypto *c);

/** @brief Save the public and private keys to the keys array.
 * Length must be CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_SECRET_KEY_SIZE.
 *
 * TODO(irungentoo): Save only secret key.
 */
non_null()
void save_keys(const Net_Crypto *c, uint8_t *keys);

/** @brief Load the secret key.
 * Length must be CRYPTO_SECRET_KEY_SIZE.
 */
non_null()
void load_secret_key(Net_Crypto *c, const uint8_t *sk);

/** @brief Create new instance of Net_Crypto.
 * Sets all the global connection variables to their default values.
 */
non_null()
Net_Crypto *new_net_crypto(const Logger *log, const Random *rng, const Network *ns, Mono_Time *mono_time, DHT *dht, const TCP_Proxy_Info *proxy_info);

/** return the optimal interval in ms for running do_net_crypto. */
non_null()
uint32_t crypto_run_interval(const Net_Crypto *c);

/** Main loop. */
non_null(1) nullable(2)
void do_net_crypto(Net_Crypto *c, void *userdata);

nullable(1)
void kill_net_crypto(Net_Crypto *c);

non_null()
char *copy_all_connected_relays(Net_Crypto *c, char* relays_report_string, uint16_t max_num, uint32_t* num);

non_null()
char *copy_all_udp_connections(Net_Crypto *c, char *connections_report_string, uint16_t max_num, uint32_t* num);

void copy_friend_ip_port(Net_Crypto *c, const int crypt_conn_id, char *report_string, bool direct_connected);

non_null()
char *udp_copy_all_connected(IP_Port conn_ip_port, char *connections_report_string, uint16_t max_num, uint32_t* num);

#endif
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2018 The TokTok team.
 * Copyright © 2013 Tox project.
 */

/**
 * Implementation of the client part of docs/Prevent_Tracking.txt (The part that
 * uses the onion stuff to connect to the friend)
 */
#ifndef C_TOXCORE_TOXCORE_ONION_CLIENT_H
#define C_TOXCORE_TOXCORE_ONION_CLIENT_H

#include <stdbool.h>


#define MAX_ONION_CLIENTS 8
#define MAX_ONION_CLIENTS_ANNOUNCE 12 // Number of nodes to announce ourselves to.
#define ONION_NODE_PING_INTERVAL 15
#define ONION_NODE_TIMEOUT ONION_NODE_PING_INTERVAL

/** The interval in seconds at which to tell our friends where we are */
#define ONION_DHTPK_SEND_INTERVAL 30
#define DHT_DHTPK_SEND_INTERVAL 20

#define NUMBER_ONION_PATHS 6

/**
 * The timeout the first time the path is added and
 * then for all the next consecutive times
 */
#define ONION_PATH_FIRST_TIMEOUT 4
#define ONION_PATH_TIMEOUT 10
#define ONION_PATH_MAX_LIFETIME 1200
#define ONION_PATH_MAX_NO_RESPONSE_USES 4

#define MAX_STORED_PINGED_NODES 9
#define MIN_NODE_PING_TIME 10

#define ONION_NODE_MAX_PINGS 3

#define MAX_PATH_NODES 32

#define GCA_MAX_DATA_LENGTH GCA_PUBLIC_ANNOUNCE_MAX_SIZE

/**
 * If no announce response packets are received within this interval tox will
 * be considered offline. We give time for a node to be pinged often enough
 * that it times out, which leads to the network being thoroughly tested as it
 * is replaced.
 */
#define ONION_OFFLINE_TIMEOUT (ONION_NODE_PING_INTERVAL * (ONION_NODE_MAX_PINGS+2))

/** Onion data packet ids. */
#define ONION_DATA_FRIEND_REQ CRYPTO_PACKET_FRIEND_REQ
#define ONION_DATA_DHTPK CRYPTO_PACKET_DHTPK

typedef struct Onion_Client Onion_Client;

non_null()
DHT *onion_get_dht(const Onion_Client *onion_c);
non_null()
Net_Crypto *onion_get_net_crypto(const Onion_Client *onion_c);

/** @brief Add a node to the path_nodes bootstrap array.
 *
 * If a node with the given public key was already in the bootstrap array, this function has no
 * effect and returns successfully. There is currently no way to update the IP/port for a bootstrap
 * node, so if it changes, the Onion_Client must be recreated.
 *
 * @param onion_c The onion client object.
 * @param ip_port IP/port for the bootstrap node.
 * @param public_key DHT public key for the bootstrap node.
 *
 * @retval false on failure
 * @retval true on success
 */
non_null()
bool onion_add_bs_path_node(Onion_Client *onion_c, const IP_Port *ip_port, const uint8_t *public_key);

/** @brief Put up to max_num nodes in nodes.
 *
 * return the number of nodes.
 */
non_null()
uint16_t onion_backup_nodes(const Onion_Client *onion_c, Node_format *nodes, uint16_t max_num);

/** @brief Get the friend_num of a friend.
 *
 * return -1 on failure.
 * return friend number on success.
 */
non_null()
int onion_friend_num(const Onion_Client *onion_c, const uint8_t *public_key);

/** @brief Add a friend who we want to connect to.
 *
 * return -1 on failure.
 * return the friend number on success or if the friend was already added.
 */
non_null()
int onion_addfriend(Onion_Client *onion_c, const uint8_t *public_key);

/** @brief Delete a friend.
 *
 * return -1 on failure.
 * return the deleted friend number on success.
 */
non_null()
int onion_delfriend(Onion_Client *onion_c, int friend_num);

/** @brief Set if friend is online or not.
 *
 * NOTE: This function is there and should be used so that we don't send
 * useless packets to the friend if they are online.
 *
 * return -1 on failure.
 * return 0 on success.
 */
non_null()
int onion_set_friend_online(Onion_Client *onion_c, int friend_num, bool is_online);

/** @brief Get the ip of friend friendnum and put it in ip_port
 *
 * @retval -1 if public_key does NOT refer to a friend
 * @retval  0 if public_key refers to a friend and we failed to find the friend (yet)
 * @retval  1 if public_key refers to a friend and we found them
 */
non_null()
int onion_getfriendip(const Onion_Client *onion_c, int friend_num, IP_Port *ip_port);

typedef int recv_tcp_relay_cb(void *object, uint32_t number, const IP_Port *ip_port, const uint8_t *public_key);

/** @brief Set the function for this friend that will be callbacked with object and number
 * when that friend gives us one of the TCP relays they are connected to.
 *
 * object and number will be passed as argument to this function.
 *
 * return -1 on failure.
 * return 0 on success.
 */
non_null()
int recv_tcp_relay_handler(Onion_Client *onion_c, int friend_num,
                           recv_tcp_relay_cb *callback, void *object, uint32_t number);

typedef void onion_dht_pk_cb(void *data, int32_t number, const uint8_t *dht_public_key, void *userdata);

/** @brief Set the function for this friend that will be callbacked with object and number
 * when that friend gives us their DHT temporary public key.
 *
 * object and number will be passed as argument to this function.
 *
 * return -1 on failure.
 * return 0 on success.
 */
non_null()
int onion_dht_pk_callback(Onion_Client *onion_c, int friend_num, onion_dht_pk_cb *function, void *object,
                          uint32_t number);

/** @brief Set a friend's DHT public key.
 *
 * return -1 on failure.
 * return 0 on success.
 */
non_null()
int onion_set_friend_DHT_pubkey(Onion_Client *onion_c, int friend_num, const uint8_t *dht_key);

/** @brief Copy friends DHT public key into dht_key.
 *
 * return 0 on failure (no key copied).
 * return 1 on success (key copied).
 */
non_null()
unsigned int onion_getfriend_DHT_pubkey(const Onion_Client *onion_c, int friend_num, uint8_t *dht_key);

#define ONION_DATA_IN_RESPONSE_MIN_SIZE (CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_MAC_SIZE)
#define ONION_CLIENT_MAX_DATA_SIZE (MAX_DATA_REQUEST_SIZE - ONION_DATA_IN_RESPONSE_MIN_SIZE)

/** @brief Send data of length length to friendnum.
 * Maximum length of data is ONION_CLIENT_MAX_DATA_SIZE.
 * This data will be received by the friend using the Onion_Data_Handlers callbacks.
 *
 * Even if this function succeeds, the friend might not receive any data.
 *
 * return the number of packets sent on success
 * return -1 on failure.
 */
non_null()
int send_onion_data(Onion_Client *onion_c, int friend_num, const uint8_t *data, uint16_t length);

typedef int oniondata_handler_cb(void *object, const uint8_t *source_pubkey, const uint8_t *data,
                                 uint16_t len, void *userdata);

/** Function to call when onion data packet with contents beginning with byte is received. */
non_null(1) nullable(3, 4)
void oniondata_registerhandler(Onion_Client *onion_c, uint8_t byte, oniondata_handler_cb *cb, void *object);

typedef bool onion_group_announce_cb(Onion_Client *onion_c, uint32_t sendback_num, const uint8_t *data,
                                     size_t data_length, void *user_data);

/** Function to call when the onion gets a group announce response. */
non_null(1) nullable(2, 3)
void onion_group_announce_register(Onion_Client *onion_c, onion_group_announce_cb *func, void *user_data);

non_null()
void do_onion_client(Onion_Client *onion_c);

non_null()
Onion_Client *new_onion_client(const Logger *logger, const Random *rng, const Mono_Time *mono_time, Net_Crypto *c);

nullable(1)
void kill_onion_client(Onion_Client *onion_c);


typedef enum Onion_Connection_Status {
    /** We are not connected to the network. */
    ONION_CONNECTION_STATUS_NONE = 0,
    /** We are connected with TCP only. */
    ONION_CONNECTION_STATUS_TCP = 1,
    /** We are also connected with UDP. */
    ONION_CONNECTION_STATUS_UDP = 2,
} Onion_Connection_Status;

non_null()
Onion_Connection_Status onion_connection_status(const Onion_Client *onion_c, bool lan_only_is_online);

typedef struct Onion_Friend Onion_Friend;

non_null() uint16_t onion_get_friend_count(const Onion_Client *const onion_c);
non_null() Onion_Friend *onion_get_friend(const Onion_Client *const onion_c, uint16_t friend_num);
non_null() const uint8_t *onion_friend_get_gc_public_key(const Onion_Friend *const onion_friend);
non_null() const uint8_t *onion_friend_get_gc_public_key_num(const Onion_Client *const onion_c, uint32_t num);
non_null() void onion_friend_set_gc_public_key(Onion_Friend *const onion_friend, const uint8_t *public_key);
non_null(1) nullable(2)
void onion_friend_set_gc_data(Onion_Friend *const onion_friend, const uint8_t *gc_data, uint16_t gc_data_length);
non_null() bool onion_friend_is_groupchat(const Onion_Friend *const onion_friend);

#endif
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2018 The TokTok team.
 * Copyright © 2014 Tox project.
 */

#ifndef C_TOXCORE_TOXCORE_TCP_COMMON_H
#define C_TOXCORE_TOXCORE_TCP_COMMON_H


typedef struct TCP_Priority_List TCP_Priority_List;
struct TCP_Priority_List {
    TCP_Priority_List *next;
    uint16_t size;
    uint16_t sent;
    uint8_t *data;
};

nullable(1)
void wipe_priority_list(TCP_Priority_List *p);

#define NUM_RESERVED_PORTS 16
#define NUM_CLIENT_CONNECTIONS (256 - NUM_RESERVED_PORTS)

#ifdef USE_TEST_NETWORK
#define TCP_PACKET_FORWARD_REQUEST 11
#define TCP_PACKET_FORWARDING 10
#define TCP_PACKET_ROUTING_REQUEST  9
#define TCP_PACKET_ROUTING_RESPONSE 8
#define TCP_PACKET_CONNECTION_NOTIFICATION 7
#define TCP_PACKET_DISCONNECT_NOTIFICATION 6
#define TCP_PACKET_PING 5
#define TCP_PACKET_PONG 4
#define TCP_PACKET_OOB_SEND 3
#define TCP_PACKET_OOB_RECV 2
#define TCP_PACKET_ONION_REQUEST  1
#define TCP_PACKET_ONION_RESPONSE 0
#else
#define TCP_PACKET_ROUTING_REQUEST  0
#define TCP_PACKET_ROUTING_RESPONSE 1
#define TCP_PACKET_CONNECTION_NOTIFICATION 2
#define TCP_PACKET_DISCONNECT_NOTIFICATION 3
#define TCP_PACKET_PING 4
#define TCP_PACKET_PONG 5
#define TCP_PACKET_OOB_SEND 6
#define TCP_PACKET_OOB_RECV 7
#define TCP_PACKET_ONION_REQUEST  8
#define TCP_PACKET_ONION_RESPONSE 9
#define TCP_PACKET_FORWARD_REQUEST 10
#define TCP_PACKET_FORWARDING 11
#endif  // test network

#define TCP_HANDSHAKE_PLAIN_SIZE (CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE)
#define TCP_SERVER_HANDSHAKE_SIZE (CRYPTO_NONCE_SIZE + TCP_HANDSHAKE_PLAIN_SIZE + CRYPTO_MAC_SIZE)
#define TCP_CLIENT_HANDSHAKE_SIZE (CRYPTO_PUBLIC_KEY_SIZE + TCP_SERVER_HANDSHAKE_SIZE)
#define TCP_MAX_OOB_DATA_LENGTH 1024

/** frequency to ping connected nodes and timeout in seconds */
#define TCP_PING_FREQUENCY 30
#define TCP_PING_TIMEOUT 10

#define MAX_PACKET_SIZE 2048

typedef struct TCP_Connection {
    const Random *rng;
    const Network *ns;
    Socket sock;
    IP_Port ip_port;  // for debugging.
    uint8_t sent_nonce[CRYPTO_NONCE_SIZE]; /* Nonce of sent packets. */
    uint8_t shared_key[CRYPTO_SHARED_KEY_SIZE];
    uint8_t last_packet[2 + MAX_PACKET_SIZE];
    uint16_t last_packet_length;
    uint16_t last_packet_sent;

    TCP_Priority_List *priority_queue_start;
    TCP_Priority_List *priority_queue_end;
} TCP_Connection;

/**
 * @retval 0 if pending data was sent completely
 * @retval -1 if it wasn't
 */
non_null()
int send_pending_data_nonpriority(const Logger *logger, TCP_Connection *con);

/**
 * @retval 0 if pending data was sent completely
 * @retval -1 if it wasn't
 */
non_null()
int send_pending_data(const Logger *logger, TCP_Connection *con);

/**
 * @retval 1 on success.
 * @retval 0 if could not send packet.
 * @retval -1 on failure (connection must be killed).
 */
non_null()
int write_packet_TCP_secure_connection(
        const Logger *logger, TCP_Connection *con, const uint8_t *data, uint16_t length,
        bool priority);

/** @brief Read length bytes from socket.
 *
 * return length on success
 * return -1 on failure/no data in buffer.
 */
non_null()
int read_TCP_packet(
        const Logger *logger, const Network *ns, Socket sock, uint8_t *data, uint16_t length, const IP_Port *ip_port);

/**
 * @return length of received packet on success.
 * @retval 0 if could not read any packet.
 * @retval -1 on failure (connection must be killed).
 */
non_null()
int read_packet_TCP_secure_connection(
        const Logger *logger, const Network *ns, Socket sock, uint16_t *next_packet_length,
        const uint8_t *shared_key, uint8_t *recv_nonce, uint8_t *data,
        uint16_t max_len, const IP_Port *ip_port);

#endif
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2018 The TokTok team.
 * Copyright © 2014 Tox project.
 */

/**
 * Implementation of the TCP relay server part of Tox.
 */
#ifndef C_TOXCORE_TOXCORE_TCP_SERVER_H
#define C_TOXCORE_TOXCORE_TCP_SERVER_H


#define MAX_INCOMING_CONNECTIONS 256

#define TCP_MAX_BACKLOG MAX_INCOMING_CONNECTIONS

#define ARRAY_ENTRY_SIZE 6

typedef enum TCP_Status {
    TCP_STATUS_NO_STATUS,
    TCP_STATUS_CONNECTED,
    TCP_STATUS_UNCONFIRMED,
    TCP_STATUS_CONFIRMED,
} TCP_Status;

typedef struct TCP_Server TCP_Server;

non_null()
const uint8_t *tcp_server_public_key(const TCP_Server *tcp_server);
non_null()
size_t tcp_server_listen_count(const TCP_Server *tcp_server);

/** Create new TCP server instance. */
non_null(1, 2, 3, 6, 7) nullable(8, 9)
TCP_Server *new_TCP_server(const Logger *logger, const Random *rng, const Network *ns,
                           bool ipv6_enabled, uint16_t num_sockets, const uint16_t *ports,
                           const uint8_t *secret_key, Onion *onion, Forwarding *forwarding);

/** Run the TCP_server */
non_null()
void do_TCP_server(TCP_Server *tcp_server, const Mono_Time *mono_time);

/** Kill the TCP server */
nullable(1)
void kill_TCP_server(TCP_Server *tcp_server);


#endif
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2020 The TokTok team.
 * Copyright © 2015 Tox project.
 */

/**
 * An implementation of massive text only group chats.
 */

#ifndef C_TOXCORE_TOXCORE_GROUP_MODERATION_H
#define C_TOXCORE_TOXCORE_GROUP_MODERATION_H

#include <stdbool.h>
#include <stdint.h>


#ifdef __cplusplus
extern "C" {
#endif

#define MOD_MODERATION_HASH_SIZE CRYPTO_SHA256_SIZE
#define MOD_LIST_ENTRY_SIZE SIG_PUBLIC_KEY_SIZE
#define MOD_SANCTION_HASH_SIZE CRYPTO_SHA256_SIZE

#define TIME_STAMP_SIZE sizeof(uint64_t)

/* The packed size of a Mod_Sanction_Creds */
#define MOD_SANCTIONS_CREDS_SIZE (sizeof(uint32_t) + MOD_SANCTION_HASH_SIZE + sizeof(uint16_t) +\
                                       SIG_PUBLIC_KEY_SIZE + SIGNATURE_SIZE)

/* The packed size of a Mod_Sanction */
#define MOD_SANCTION_PACKED_SIZE (SIG_PUBLIC_KEY_SIZE + TIME_STAMP_SIZE + 1 + ENC_PUBLIC_KEY_SIZE + SIGNATURE_SIZE)

/* The max size of a groupchat packet with 100 bytes reserved for header data */
#define MAX_PACKET_SIZE_NO_HEADERS 49900

/* The maximum possible number of moderators that can be sent in a group packet sequence. */
#define MOD_MAX_NUM_MODERATORS_LIMIT (((MAX_PACKET_SIZE_NO_HEADERS) / (MOD_LIST_ENTRY_SIZE)))

/* The maximum number of moderators that we allow in a group: 100 */
#define MOD_MAX_NUM_MODERATORS       ((MOD_MAX_NUM_MODERATORS_LIMIT / 16) + 3)

/* The maximum number of sanctions that be sent in a group packet sequence. */
#define MOD_MAX_NUM_SANCTIONS_LIMIT  (((MAX_PACKET_SIZE_NO_HEADERS - (MOD_SANCTIONS_CREDS_SIZE)) / (MOD_SANCTION_PACKED_SIZE)))

/* The maximum number of sanctions that we allow in a group: 30 */
#define MOD_MAX_NUM_SANCTIONS        (MOD_MAX_NUM_SANCTIONS_LIMIT / 12)

typedef enum Mod_Sanction_Type {
    SA_OBSERVER = 0x00,
    SA_INVALID  = 0x01,
} Mod_Sanction_Type;

typedef struct Mod_Sanction_Creds {
    uint32_t    version;
    uint8_t     hash[MOD_SANCTION_HASH_SIZE];    // hash of all sanctions list signatures + version
    uint16_t    checksum;  // a sum of the hash
    uint8_t     sig_pk[SIG_PUBLIC_KEY_SIZE];    // Last mod to have modified the sanctions list
    uint8_t     sig[SIGNATURE_SIZE];    // signature of hash, signed by sig_pk
} Mod_Sanction_Creds;

/** Holds data pertaining to a peer who has been sanctioned. */
typedef struct Mod_Sanction {
    uint8_t     setter_public_sig_key[SIG_PUBLIC_KEY_SIZE];

    // TODO(Jfreegman): This timestamp can potentially be used to track a user across
    // different group chats if they're a moderator and set many sanctions across the
    // different groups. This should be addressed in the future.
    uint64_t    time_set;

    uint8_t     type;
    uint8_t     target_public_enc_key[ENC_PUBLIC_KEY_SIZE];

    /* Signature of all above packed data signed by the owner of public_sig_key */
    uint8_t     signature[SIGNATURE_SIZE];
} Mod_Sanction;

typedef struct Moderation {
    const       Logger *log;

    Mod_Sanction *sanctions;
    uint16_t    num_sanctions;

    Mod_Sanction_Creds sanctions_creds;

    uint8_t     **mod_list;  // array of public signature keys of all the mods
    uint16_t    num_mods;

    // copies from parent/sibling chat/shared state objects
    uint8_t     founder_public_sig_key[SIG_PUBLIC_KEY_SIZE];
    uint8_t     self_public_sig_key[SIG_PUBLIC_KEY_SIZE];
    uint8_t     self_secret_sig_key[SIG_SECRET_KEY_SIZE];
    uint32_t    shared_state_version;
} Moderation;

/** @brief Returns the size in bytes of the packed moderation list. */
non_null()
uint16_t mod_list_packed_size(const Moderation *moderation);

/** @brief Unpacks data into the moderator list.
 *
 * @param data should contain num_mods entries of size MOD_LIST_ENTRY_SIZE.
 *
 * Returns length of unpacked data on success.
 * Returns -1 on failure.
 */
non_null()
int mod_list_unpack(Moderation *moderation, const uint8_t *data, uint16_t length, uint16_t num_mods);

/** @brief Packs moderator list into data.
 * @param data must have room for the number of bytes returned by `mod_list_packed_size`.
 */
non_null()
void mod_list_pack(const Moderation *moderation, uint8_t *data);

/** @brief Creates a new moderator list hash and puts it in `hash`.
 *
 * @param hash must have room for at least MOD_MODERATION_HASH_SIZE bytes.
 *
 * If num_mods is 0 the hash is zeroed.
 *
 * Returns true on sucess.
 */
non_null()
bool mod_list_make_hash(const Moderation *moderation, uint8_t *hash);

/** @brief Puts a sha256 hash of `packed_mod_list` of `length` bytes in `hash`.
 *
 * @param hash must have room for at least MOD_MODERATION_HASH_SIZE bytes.
 */
non_null()
void mod_list_get_data_hash(uint8_t *hash, const uint8_t *packed_mod_list, uint16_t length);

/** @brief Removes moderator at index-th position in the moderator list.
 *
 * Returns true on success.
 */
non_null()
bool mod_list_remove_index(Moderation *moderation, uint16_t index);

/** @brief Removes public_sig_key from the moderator list.
 *
 * Returns true on success.
 */
non_null()
bool mod_list_remove_entry(Moderation *moderation, const uint8_t *public_sig_key);

/** @brief Adds a mod to the moderator list.
 *
 * @param mod_data must be MOD_LIST_ENTRY_SIZE bytes.
 *
 * Returns true on success.
 */
non_null()
bool mod_list_add_entry(Moderation *moderation, const uint8_t *mod_data);

/** @return true if the public signature key belongs to a moderator or the founder */
non_null()
bool mod_list_verify_sig_pk(const Moderation *moderation, const uint8_t *sig_pk);

/** @brief Frees all memory associated with the moderator list and sets num_mods to 0. */
nullable(1)
void mod_list_cleanup(Moderation *moderation);

/** @brief Returns the size in bytes of num_sanctions packed sanctions. */
uint16_t sanctions_list_packed_size(uint16_t num_sanctions);

/** @brief Packs sanctions into data. Additionally packs the sanctions credentials into creds.
 *
 * @param data The byte array being packed. Must have room for the number of bytes returned
 *   by `sanctions_list_packed_size`.
 * @param length The size of the byte array.
 * @param sanctions The sanctions list.
 * @param num_sanctions The number of sanctions in the sanctions list. This value must be the same
 *   value used when calling `sanctions_list_packed_size`.
 * @param creds The credentials object to fill.
 *
 * @retval The length of packed data on success.
 * @retval -1 on failure.
 */
non_null(1) nullable(3, 5)
int sanctions_list_pack(uint8_t *data, uint16_t length, const Mod_Sanction *sanctions, uint16_t num_sanctions,
                        const Mod_Sanction_Creds *creds);

/** @brief Unpacks sanctions and new sanctions credentials.
 *
 * @param sanctions The sanctions array the sanctions data is unpacked into.
 * @param creds The creds object the creds data is unpacked into.
 * @param max_sanctions The maximum number of sanctions that the sanctions array can hold.
 * @param data The packed data array.
 * @param length The size of the packed data.
 * @param processed_data_len If non-null, will contain the number of processed bytes on success.
 *
 * @retval The number of unpacked entries on success.
 * @retval -1 on failure.
 */
non_null(1, 2, 4) nullable(6)
int sanctions_list_unpack(Mod_Sanction *sanctions, Mod_Sanction_Creds *creds, uint16_t max_sanctions,
                          const uint8_t *data, uint16_t length, uint16_t *processed_data_len);

/** @brief Packs sanction list credentials into data.
 *
 * @param data must have room for MOD_SANCTIONS_CREDS_SIZE bytes.
 *
 * Returns length of packed data.
 */
non_null()
uint16_t sanctions_creds_pack(const Mod_Sanction_Creds *creds, uint8_t *data);

/** @brief Unpacks sanctions credentials into creds from data.
 *
 * @param data must have room for MOD_SANCTIONS_CREDS_SIZE bytes.
 *
 * Returns the length of the data processed.
 */
non_null()
uint16_t sanctions_creds_unpack(Mod_Sanction_Creds *creds, const uint8_t *data);

/** @brief Updates sanction list credentials.
 *
 * Increment version, replace sig_pk with your own, update hash to reflect new
 * sanction list, and sign new hash signature.
 *
 * Returns true on success.
 */
non_null()
bool sanctions_list_make_creds(Moderation *moderation);

/** @brief Validates all sanctions list entries as well as the list itself.
 *
 * Returns true if all entries are valid.
 * Returns false if one or more entries are invalid.
 */
non_null()
bool sanctions_list_check_integrity(const Moderation *moderation, const Mod_Sanction_Creds *creds,
                                    const Mod_Sanction *sanctions, uint16_t num_sanctions);

/** @brief Adds an entry to the sanctions list.
 *
 * The entry is first validated and the resulting new sanction list is
 * compared against the new credentials.
 *
 * Entries must be unique.
 *
 * Returns true on success.
 */
non_null(1, 2) nullable(3)
bool sanctions_list_add_entry(Moderation *moderation, const Mod_Sanction *sanction, const Mod_Sanction_Creds *creds);

/** @brief Creates a new sanction entry for `public_key` where type is one of Mod_Sanction_Type.
 *
 * New entry is signed and placed in the sanctions list.
 *
 * Returns true on success.
 */
non_null()
bool sanctions_list_make_entry(Moderation *moderation, const uint8_t *public_key, Mod_Sanction *sanction,
                               uint8_t type);

/** @return true if public key is in the observer list. */
non_null()
bool sanctions_list_is_observer(const Moderation *moderation, const uint8_t *public_key);

/** @return true if sanction already exists in the sanctions list. */
non_null()
bool sanctions_list_entry_exists(const Moderation *moderation, const Mod_Sanction *sanction);

/** @brief Removes observer entry for public key from sanction list.
 *
 * If creds is NULL we make new credentials (this should only be done by a moderator or founder)
 *
 * Returns false on failure or if entry was not found.
 */
non_null(1, 2) nullable(3)
bool sanctions_list_remove_observer(Moderation *moderation, const uint8_t *public_key,
                                    const Mod_Sanction_Creds *creds);

/** @brief Replaces all sanctions list signatures made by public_sig_key with the caller's.
 *
 * This is called whenever the founder demotes a moderator.
 *
 * Returns the number of entries re-signed.
 */
non_null()
uint16_t sanctions_list_replace_sig(Moderation *moderation, const uint8_t *public_sig_key);

non_null()
void sanctions_list_cleanup(Moderation *moderation);

#ifdef __cplusplus
}  // extern "C"
#endif

#endif // C_TOXCORE_TOXCORE_GROUP_MODERATION_H
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2022 The TokTok team.
 */

/**
 * Common groupchat data structures.
 */

#ifndef GROUP_COMMON_H
#define GROUP_COMMON_H

#include <stdbool.h>
#include <stdint.h>


#define MAX_GC_PART_MESSAGE_SIZE 128
#define MAX_GC_NICK_SIZE 128
#define MAX_GC_TOPIC_SIZE 512
#define MAX_GC_GROUP_NAME_SIZE 48
#define GC_MESSAGE_PSEUDO_ID_SIZE 4
#define GROUP_MAX_MESSAGE_LENGTH  1372

#define MAX_GC_MESSAGE_SIZE       GROUP_MAX_MESSAGE_LENGTH
#define MAX_GC_MESSAGE_RAW_SIZE   (MAX_GC_MESSAGE_SIZE + GC_MESSAGE_PSEUDO_ID_SIZE)
#define MAX_GC_CUSTOM_PACKET_SIZE 40000 // 1373
#define MAX_GC_PASSWORD_SIZE 32
#define MAX_GC_SAVED_INVITES 10
#define MAX_GC_PEERS_DEFAULT 100
#define MAX_GC_SAVED_TIMEOUTS 12
#define GC_MAX_SAVED_PEERS 100
#define GC_SAVED_PEER_SIZE (ENC_PUBLIC_KEY_SIZE + sizeof(Node_format) + sizeof(IP_Port))

/* Max size of a packet chunk. Packets larger than this must be split up. */
#define MAX_GC_PACKET_CHUNK_SIZE 1372 // 500

/* Max size of a complete encrypted packet including headers. */
#define MAX_GC_PACKET_SIZE (500 * 100) // (MAX_GC_PACKET_CHUNK_SIZE * 100)

/* Max number of messages to store in the send/recv arrays */
#define GCC_BUFFER_SIZE 8192

/** Self UDP status. Must correspond to return values from `ipport_self_copy()`. */
typedef enum Self_UDP_Status {
    SELF_UDP_STATUS_NONE = 0x00,
    SELF_UDP_STATUS_WAN  = 0x01,
    SELF_UDP_STATUS_LAN  = 0x02,
} Self_UDP_Status;

/** Group exit types. */
typedef enum Group_Exit_Type {
    GC_EXIT_TYPE_QUIT              = 0x00,  // Peer left the group
    GC_EXIT_TYPE_TIMEOUT           = 0x01,  // Peer connection timed out
    GC_EXIT_TYPE_DISCONNECTED      = 0x02,  // Peer diconnected from group
    GC_EXIT_TYPE_SELF_DISCONNECTED = 0x03,  // Self disconnected from group
    GC_EXIT_TYPE_KICKED            = 0x04,  // Peer was kicked from the group
    GC_EXIT_TYPE_SYNC_ERR          = 0x05,  // Peer failed to sync with the group
    GC_EXIT_TYPE_NO_CALLBACK       = 0x06,  // The peer exit callback should not be triggered
} Group_Exit_Type;

typedef struct GC_Exit_Info {
    uint8_t  part_message[MAX_GC_PART_MESSAGE_SIZE];
    uint16_t length;
    Group_Exit_Type exit_type;
} GC_Exit_Info;

typedef struct GC_PeerAddress {
    uint8_t     public_key[EXT_PUBLIC_KEY_SIZE];
    IP_Port     ip_port;
} GC_PeerAddress;

typedef struct GC_Message_Array_Entry {
    uint8_t *data;
    uint16_t data_length;
    uint8_t  packet_type;
    uint64_t message_id;
    uint64_t time_added;
    uint64_t last_send_try;
} GC_Message_Array_Entry;

typedef struct GC_Connection {
    uint64_t send_message_id;   /* message_id of the next message we send to peer */

    uint16_t send_array_start;   /* send_array index of oldest item */
    GC_Message_Array_Entry *send_array;

    uint64_t received_message_id;   /* message_id of peer's last message to us */
    GC_Message_Array_Entry *recv_array;

    uint64_t    last_chunk_id;  /* The message ID of the last packet fragment we received */

    GC_PeerAddress   addr;   /* holds peer's extended real public key and ip_port */
    uint32_t    public_key_hash;   /* Jenkins one at a time hash of peer's real encryption public key */

    uint8_t     session_public_key[ENC_PUBLIC_KEY_SIZE];   /* self session public key for this peer */
    uint8_t     session_secret_key[ENC_SECRET_KEY_SIZE];   /* self session secret key for this peer */
    uint8_t     session_shared_key[CRYPTO_SHARED_KEY_SIZE];  /* made with our session sk and peer's session pk */

    int         tcp_connection_num;
    uint64_t    last_sent_tcp_relays_time;  /* the last time we attempted to send this peer our tcp relays */
    uint16_t    tcp_relay_share_index;
    uint64_t    last_received_direct_time;   /* the last time we received a direct UDP packet from this connection */
    uint64_t    last_sent_ip_time;  /* the last time we sent our ip info to this peer in a ping packet */

    Node_format connected_tcp_relays[MAX_FRIEND_TCP_CONNECTIONS];
    uint16_t    tcp_relays_count;

    uint64_t    last_received_packet_time;  /* The last time we successfully processed any packet from this peer */
    uint64_t    last_requested_packet_time;  /* The last time we requested a missing packet from this peer */
    uint64_t    last_sent_ping_time;
    uint64_t    last_sync_response;  /* the last time we sent this peer a sync response */
    uint8_t     oob_relay_pk[CRYPTO_PUBLIC_KEY_SIZE];
    bool        self_is_closer; /* true if we're "closer" to the chat_id than this peer (uses real pk's) */

    bool        confirmed;  /* true if this peer has given us their info */
    bool        handshaked;  /* true if we've successfully handshaked with this peer */
    uint16_t    handshake_attempts;
    uint64_t    last_handshake_request;
    uint64_t    last_handshake_response;
    uint8_t     pending_handshake_type;
    bool        is_pending_handshake_response;
    bool        is_oob_handshake;

    uint64_t    last_key_rotation;  /* the last time we rotated session keys for this peer */
    bool        pending_key_rotation_request;

    bool        pending_delete;  /* true if this peer has been marked for deletion */
    GC_Exit_Info exit_info;
} GC_Connection;

/***
 * Group roles. Roles are hierarchical in that each role has a set of privileges plus
 * all the privileges of the roles below it.
 */
typedef enum Group_Role {
    /** Group creator. All-powerful. Cannot be demoted or kicked. */
    GR_FOUNDER   = 0x00,

    /**
     * May promote or demote peers below them to any role below them.
     * May also kick peers below them and set the topic.
     */
    GR_MODERATOR = 0x01,

    /** may interact normally with the group. */
    GR_USER      = 0x02,

    /** May not interact with the group but may observe. */
    GR_OBSERVER  = 0x03,
} Group_Role;

typedef enum Group_Peer_Status {
    GS_NONE    = 0x00,
    GS_AWAY    = 0x01,
    GS_BUSY    = 0x02,
} Group_Peer_Status;

/**
 * Group voice states. The state determines which Group Roles have permission to speak.
 */
typedef enum Group_Voice_State {
    /** Every group role except Observers may speak. */
    GV_ALL       = 0x00,

    /** Only Moderators and the Founder may speak. */
    GV_MODS      = 0x01,

    /** Only the Founder may speak. */
    GV_FOUNDER   = 0x02,
} Group_Voice_State;

/** Group connection states. */
typedef enum GC_Conn_State {
    CS_NONE         = 0x00,  // Indicates a group is not initialized
    CS_DISCONNECTED = 0x01,  // Not receiving or sending any packets
    CS_CONNECTING   = 0x02,  // Attempting to establish a connection with peers in the group
    CS_CONNECTED    = 0x03,  // Has successfully received a sync response from a peer in the group
} GC_Conn_State;

/** Group privacy states. */
typedef enum Group_Privacy_State {
    GI_PUBLIC   = 0x00,  // Anyone with the chat ID may join the group
    GI_PRIVATE  = 0x01,  // Peers may only join the group via a friend invite
} Group_Privacy_State;

/** Handshake join types. */
typedef enum Group_Handshake_Join_Type {
    HJ_PUBLIC = 0x00,   // Indicates the group was joined via the DHT
    HJ_PRIVATE = 0x01,  // Indicates the group was joined via private friend invite
} Group_Handshake_Join_Type;

typedef struct GC_SavedPeerInfo {
    uint8_t     public_key[ENC_PUBLIC_KEY_SIZE];
    Node_format tcp_relay;
    IP_Port     ip_port;
} GC_SavedPeerInfo;

/** Holds info about peers who recently timed out */
typedef struct GC_TimedOutPeer {
    GC_SavedPeerInfo addr;
    uint64_t    last_seen;  // the time the peer disconnected
    uint64_t    last_reconn_try;  // the last time we tried to establish a new connection
} GC_TimedOutPeer;

typedef struct GC_Peer {
    /* Below state is sent to other peers in peer info exchange */
    uint8_t       nick[MAX_GC_NICK_SIZE];
    uint16_t      nick_length;
    uint8_t       status;

    /* Below state is local only */
    Group_Role    role;
    uint32_t      peer_id;    // permanent ID (used for the public API)
    bool          ignore;

    GC_Connection gconn;
} GC_Peer;

typedef struct GC_SharedState {
    uint32_t    version;
    uint8_t     founder_public_key[EXT_PUBLIC_KEY_SIZE];
    uint16_t    maxpeers;
    uint16_t    group_name_len;
    uint8_t     group_name[MAX_GC_GROUP_NAME_SIZE];
    Group_Privacy_State privacy_state;   // GI_PUBLIC (uses DHT) or GI_PRIVATE (invite only)
    uint16_t    password_length;
    uint8_t     password[MAX_GC_PASSWORD_SIZE];
    uint8_t     mod_list_hash[MOD_MODERATION_HASH_SIZE];
    uint32_t    topic_lock; // equal to GC_TOPIC_LOCK_ENABLED when lock is enabled
    Group_Voice_State voice_state;
} GC_SharedState;

typedef struct GC_TopicInfo {
    uint32_t    version;
    uint16_t    length;
    uint16_t    checksum;  // used for syncing problems. the checksum with the highest value gets priority.
    uint8_t     topic[MAX_GC_TOPIC_SIZE];
    uint8_t     public_sig_key[SIG_PUBLIC_KEY_SIZE];  // Public signature key of the topic setter
} GC_TopicInfo;

typedef struct GC_Chat {
    Mono_Time       *mono_time;
    const Logger    *log;
    const Random    *rng;

    uint32_t        connected_tcp_relays;
    Self_UDP_Status self_udp_status;
    IP_Port         self_ip_port;

    Networking_Core *net;
    TCP_Connections *tcp_conn;

    uint64_t        last_checked_tcp_relays;
    Group_Handshake_Join_Type join_type;

    GC_Peer         *group;
    Moderation      moderation;

    GC_Conn_State   connection_state;

    GC_SharedState  shared_state;
    uint8_t         shared_state_sig[SIGNATURE_SIZE];  // signed by founder using the chat secret key

    GC_TopicInfo    topic_info;
    uint8_t         topic_sig[SIGNATURE_SIZE];  // signed by the peer who set the current topic
    uint16_t        topic_prev_checksum;  // checksum of the previous topic
    uint64_t        topic_time_set;

    uint16_t    peers_checksum;  // sum of the public key hash of every confirmed peer in the group
    uint16_t    roles_checksum;  // sum of every confirmed peer's role plus the first byte of their public key

    uint32_t    numpeers;
    int         group_number;

    uint8_t     chat_public_key[EXT_PUBLIC_KEY_SIZE];  // the chat_id is the sig portion
    uint8_t     chat_secret_key[EXT_SECRET_KEY_SIZE];  // only used by the founder

    uint8_t     self_public_key[EXT_PUBLIC_KEY_SIZE];
    uint8_t     self_secret_key[EXT_SECRET_KEY_SIZE];

    uint64_t    time_connected;
    uint64_t    last_ping_interval;
    uint64_t    last_sync_request;  // The last time we sent a sync request to any peer
    uint64_t    last_sync_response_peer_list;  // The last time we sent the peer list to any peer
    uint64_t    last_time_peers_loaded;

    /* keeps track of frequency of new inbound connections */
    uint8_t     connection_O_metre;
    uint64_t    connection_cooldown_timer;
    bool        block_handshakes;

    int32_t     saved_invites[MAX_GC_SAVED_INVITES];
    uint8_t     saved_invites_index;

    /** A list of recently seen peers in case we disconnect from a private group.
     * Peers are added once they're confirmed, and only if there are vacant
     * spots (older connections get priority). An entry is removed only when the list
     * is full, its respective peer goes offline, and an online peer who isn't yet
     * present in the list can be added.
     */
    GC_SavedPeerInfo saved_peers[GC_MAX_SAVED_PEERS];

    GC_TimedOutPeer timeout_list[MAX_GC_SAVED_TIMEOUTS];
    size_t      timeout_list_index;
    uint64_t    last_timed_out_reconn_try;  // the last time we tried to reconnect to timed out peers

    bool        update_self_announces;  // true if we should try to update our announcements
    uint64_t    last_self_announce_check;  // the last time we checked if we should update our announcements
    uint64_t    last_time_self_announce;  // the last time we announced the group
    uint8_t     announced_tcp_relay_pk[CRYPTO_PUBLIC_KEY_SIZE];  // The pk of the last TCP relay we announced

    uint8_t     m_group_public_key[CRYPTO_PUBLIC_KEY_SIZE];  // public key for group's messenger friend connection
    int         friend_connection_id;  // identifier for group's messenger friend connection

    bool        flag_exit;  // true if the group will be deleted after the next do_gc() iteration
} GC_Chat;

#ifndef MESSENGER_DEFINED
#define MESSENGER_DEFINED
typedef struct Messenger Messenger;
#endif /* MESSENGER_DEFINED */

typedef void gc_message_cb(const Messenger *m, uint32_t group_number, uint32_t peer_id, unsigned int type,
                           const uint8_t *data, size_t length, uint32_t message_id, void *user_data);
typedef void gc_private_message_cb(const Messenger *m, uint32_t group_number, uint32_t peer_id, unsigned int type,
                                   const uint8_t *data, size_t length, void *user_data);
typedef void gc_custom_packet_cb(const Messenger *m, uint32_t group_number, uint32_t peer_id, const uint8_t *data,
                                 size_t length, void *user_data);
typedef void gc_custom_private_packet_cb(const Messenger *m, uint32_t group_number, uint32_t peer_id,
        const uint8_t *data,
        size_t length, void *user_data);
typedef void gc_moderation_cb(const Messenger *m, uint32_t group_number, uint32_t peer_id, uint32_t target_peer,
                              unsigned int mod_event, void *user_data);
typedef void gc_nick_change_cb(const Messenger *m, uint32_t group_number, uint32_t peer_id, const uint8_t *data,
                               size_t length, void *user_data);
typedef void gc_status_change_cb(const Messenger *m, uint32_t group_number, uint32_t peer_id, unsigned int status,
                                 void *user_data);
typedef void gc_connection_status_change_cb(const Messenger *m, uint32_t group_number, int32_t status, void *user_data);
typedef void gc_topic_change_cb(const Messenger *m, uint32_t group_number, uint32_t peer_id, const uint8_t *data,
                                size_t length, void *user_data);
typedef void gc_topic_lock_cb(const Messenger *m, uint32_t group_number, unsigned int topic_lock, void *user_data);
typedef void gc_voice_state_cb(const Messenger *m, uint32_t group_number, unsigned int voice_state, void *user_data);
typedef void gc_peer_limit_cb(const Messenger *m, uint32_t group_number, uint32_t max_peers, void *user_data);
typedef void gc_privacy_state_cb(const Messenger *m, uint32_t group_number, unsigned int state, void *user_data);
typedef void gc_password_cb(const Messenger *m, uint32_t group_number, const uint8_t *data, size_t length,
                            void *user_data);
typedef void gc_peer_join_cb(const Messenger *m, uint32_t group_number, uint32_t peer_id, void *user_data);
typedef void gc_peer_exit_cb(const Messenger *m, uint32_t group_number, uint32_t peer_id, unsigned int exit_type,
                             const uint8_t *nick, size_t nick_len, const uint8_t *data, size_t length, void *user_data);
typedef void gc_self_join_cb(const Messenger *m, uint32_t group_number, void *user_data);
typedef void gc_rejected_cb(const Messenger *m, uint32_t group_number, unsigned int type, void *user_data);

typedef struct GC_Session {
    Messenger                 *messenger;
    GC_Chat                   *chats;
    struct GC_Announces_List  *announces_list;

    uint32_t     chats_index;

    gc_message_cb *message;
    gc_private_message_cb *private_message;
    gc_custom_packet_cb *custom_packet;
    gc_custom_private_packet_cb *custom_private_packet;
    gc_moderation_cb *moderation;
    gc_nick_change_cb *nick_change;
    gc_status_change_cb *status_change;
    gc_connection_status_change_cb *connection_status_change;
    gc_topic_change_cb *topic_change;
    gc_topic_lock_cb *topic_lock;
    gc_voice_state_cb *voice_state;
    gc_peer_limit_cb *peer_limit;
    gc_privacy_state_cb *privacy_state;
    gc_password_cb *password;
    gc_peer_join_cb *peer_join;
    gc_peer_exit_cb *peer_exit;
    gc_self_join_cb *self_join;
    gc_rejected_cb *rejected;
} GC_Session;

/** @brief Adds a new peer to group_number's peer list.
 *
 * Return peer_number on success.
 * Return -1 on failure.
 * Return -2 if a peer with public_key is already in our peerlist.
 */
non_null(1, 3) nullable(2)
int peer_add(GC_Chat *chat, const IP_Port *ipp, const uint8_t *public_key);

/** @brief Unpacks saved peers from `data` of size `length` into `chat`.
 *
 * Returns the number of unpacked peers on success.
 * Returns -1 on failure.
 */
non_null()
int unpack_gc_saved_peers(GC_Chat *chat, const uint8_t *data, uint16_t length);

/** @brief Packs all valid entries from saved peerlist into `data`.
 *
 * If `processed` is non-null it will be set to the length of the packed data
 * on success, and will be untouched on error.
 *
 * Return the number of packed saved peers on success.
 * Return -1 if buffer is too small.
 */
non_null(1, 2) nullable(4)
int pack_gc_saved_peers(const GC_Chat *chat, uint8_t *data, uint16_t length, uint16_t *processed);

#endif  // GROUP_COMMON_H
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2020 The TokTok team.
 * Copyright © 2015 Tox project.
 */

/**
 * Similar to ping.h, but designed for group chat purposes
 */
#ifndef GROUP_ANNOUNCE_H
#define GROUP_ANNOUNCE_H

#include <stdbool.h>


#ifdef __cplusplus
extern "C" {
#endif

/* The maximum number of announces to save for a particular group chat. */
#define GCA_MAX_SAVED_ANNOUNCES_PER_GC 16

/* Maximum number of TCP relays that can be in an announce. */
#define GCA_MAX_ANNOUNCED_TCP_RELAYS 1

/* Maximum number of announces we can send in an announce response. */
#define GCA_MAX_SENT_ANNOUNCES 4

/* Maximum size of an announce. */
#define GCA_ANNOUNCE_MAX_SIZE (ENC_PUBLIC_KEY_SIZE + 1 + 1 + (PACKED_NODE_SIZE_IP6 * 2))

/* Maximum size of a public announce. */
#define GCA_PUBLIC_ANNOUNCE_MAX_SIZE (ENC_PUBLIC_KEY_SIZE + GCA_ANNOUNCE_MAX_SIZE)

typedef struct GC_Announce GC_Announce;
typedef struct GC_Peer_Announce GC_Peer_Announce;
typedef struct GC_Announces GC_Announces;
typedef struct GC_Announces_List GC_Announces_List;
typedef struct GC_Public_Announce GC_Public_Announce;

/* Base announce. */
struct GC_Announce {
    Node_format tcp_relays[GCA_MAX_ANNOUNCED_TCP_RELAYS];
    uint8_t tcp_relays_count;
    bool ip_port_is_set;
    IP_Port ip_port;
    uint8_t peer_public_key[ENC_PUBLIC_KEY_SIZE];
};

/* Peer announce for specific group. */
struct GC_Peer_Announce {
    GC_Announce base_announce;
    uint64_t timestamp;
};

/* Used for announces in public groups. */
struct GC_Public_Announce {
    GC_Announce base_announce;
    uint8_t chat_public_key[ENC_PUBLIC_KEY_SIZE];
};

/* A linked list that holds all announces for a particular group. */
struct GC_Announces {
    uint8_t chat_id[CHAT_ID_SIZE];
    uint64_t index;
    uint64_t last_announce_received_timestamp;

    GC_Peer_Announce peer_announces[GCA_MAX_SAVED_ANNOUNCES_PER_GC];

    GC_Announces *next_announce;
    GC_Announces *prev_announce;
};

/* A list of all announces. */
struct GC_Announces_List {
    GC_Announces *root_announces;
    uint64_t last_timeout_check;
};


/** @brief Returns a new group announces list.
 *
 * The caller is responsible for freeing the memory with `kill_gca`.
 */
GC_Announces_List *new_gca_list(void);

/** @brief Frees all dynamically allocated memory associated with `announces_list`. */
nullable(1)
void kill_gca(GC_Announces_List *announces_list);

/** @brief Iterates through the announces list and removes announces that are considered stale.
 *
 * @param gc_announces_list The list of announces to iterate.
 *
 * This function should be called from the main loop, and will iterate the list a
 * maxmimum of once per second.
 */
non_null()
void do_gca(const Mono_Time *mono_time, GC_Announces_List *gc_announces_list);

/** @brief Frees all dynamically allocated memory associated with an announces list entry.
 *
 * @param gc_announces_list The announces list we want to search through.
 * @param chat_id The chat ID that designates the entry we want to remove.
 */
non_null()
void cleanup_gca(GC_Announces_List *gc_announces_list, const uint8_t *chat_id);

/** @brief Puts a set of announces from the announces list in supplied list.
 *
 * @param gc_announces_list The announces list we want to search for entries in.
 * @param gc_announces An empty announces list that will be filled with matches.
 * @param max_nodes The maximum number of matches that we want to add to the list.
 * @param chat_id The chat ID associated with the announces that we want to add.
 * @param except_public_key The public key associated with announces that we want to ignore.
 *
 * @return the number of added nodes on success.
 * @retval -1 on failure.
 */
non_null()
int gca_get_announces(const GC_Announces_List *gc_announces_list, GC_Announce *gc_announces, uint8_t max_nodes,
                      const uint8_t *chat_id, const uint8_t *except_public_key);

/** @brief Adds a public_announce to list of announces.
 *
 * @param gc_announces_list The announces list that we want to add an entry to.
 * @param public_announce The public announce that we want to add.
 *
 * @return the peer announce on success.
 * @retval null on failure.
 */
non_null()
GC_Peer_Announce *gca_add_announce(const Mono_Time *mono_time, GC_Announces_List *gc_announces_list,
                                   const GC_Public_Announce *public_announce);

/** @brief Packs an announce into a data buffer.
 *
 * @param data The data buffer being packed.
 * @param length The size in bytes of the data buffer. Must be at least GCA_ANNOUNCE_MAX_SIZE.
 * @param announce The announce being packed into the data buffer.
 *
 * @return the size of the packed data on success.
 * @retval -1 on failure.
 */
non_null()
int gca_pack_announce(const Logger *log, uint8_t *data, uint16_t length, const GC_Announce *announce);

/** @brief Returns the number of bytes needed for a buff in which to pack `count` announces. */
uint16_t gca_pack_announces_list_size(uint16_t count);

/** @brief Packs a list of announces into a data buffer.
 *
 * @param data The data buffer being packed.
 * @param length The size in bytes of the data buffer. Use gca_pack_announces_list_size to get the
 *   required length.
 * @param announces The announces to be packed into the data buffer.
 * @param announces_count The number of announces in the announces list.
 * @param processed If non-null, will contain the number of bytes packed (only on success).
 *
 * @return the number of packed announces on success.
 * @retval -1 on failure.
 */
non_null(1, 2, 4) nullable(6)
int gca_pack_announces_list(const Logger *log, uint8_t *data, uint16_t length, const GC_Announce *announces,
                            uint8_t announces_count, size_t *processed);

/** @brief Unpacks packed announces from a data buffer into a supplied list.
 *
 * @param data The data buffer to unpack from.
 * @param length The size of the data buffer.
 * @param announces The announces list that the data buffer will be unpacked to.
 * @param max_count The maximum number of announces to unpack.
 *
 * @return the number of unpacked announces on success.
 * @retval -1 on failure.
 */
non_null()
int gca_unpack_announces_list(const Logger *log, const uint8_t *data, uint16_t length, GC_Announce *announces,
                              uint8_t max_count);

/** @brief Packs a public announce into a data buffer.
 *
 * @param data The data buffer being packed.
 * @param length The size in bytes of the data buffer. Must be at least GCA_PUBLIC_ANNOUNCE_MAX_SIZE.
 * @param public_announce The public announce being packed into the data buffer.
 *
 * @return the size of the packed data on success.
 * @retval -1 on failure.
 */
non_null()
int gca_pack_public_announce(const Logger *log, uint8_t *data, uint16_t length,
                             const GC_Public_Announce *public_announce);

/** @brief Unpacks a public announce from a data buffer into a supplied public announce.
 *
 * @param data The data buffer to unpack from.
 * @param length The size of the data buffer.
 * @param public_announce The public announce to unpack the data buffer into.
 *
 * @return the size of the unpacked data on success.
 * @retval -1 on failure.
 */
non_null()
int gca_unpack_public_announce(const Logger *log, const uint8_t *data, uint16_t length,
                               GC_Public_Announce *public_announce);

/** @brief Returns true if the announce is valid.
 *
 * An announce is considered valid if there is at least one TCP relay, or the ip_port is set.
 */
non_null()
bool gca_is_valid_announce(const GC_Announce *announce);

#ifdef __cplusplus
}  // extern "C"
#endif

#endif // GROUP_ANNOUNCE_H
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2018 The TokTok team.
 * Copyright © 2013 Tox project.
 */

/**
 * Implementation of the announce part of docs/Prevent_Tracking.txt
 */
#ifndef C_TOXCORE_TOXCORE_ONION_ANNOUNCE_H
#define C_TOXCORE_TOXCORE_ONION_ANNOUNCE_H


#define ONION_ANNOUNCE_MAX_ENTRIES 160
#define ONION_ANNOUNCE_TIMEOUT 300
#define ONION_PING_ID_SIZE TIMED_AUTH_SIZE
#define ONION_MAX_EXTRA_DATA_SIZE 136

#define ONION_ANNOUNCE_SENDBACK_DATA_LENGTH (sizeof(uint64_t))

#define MAX_SENT_GC_NODES 1
#define ONION_ANNOUNCE_REQUEST_MIN_SIZE (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_PING_ID_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_MAC_SIZE)
#define ONION_ANNOUNCE_REQUEST_MAX_SIZE (ONION_ANNOUNCE_REQUEST_MIN_SIZE + ONION_MAX_EXTRA_DATA_SIZE)

#define ONION_ANNOUNCE_RESPONSE_MIN_SIZE (2 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_NONCE_SIZE + ONION_PING_ID_SIZE + CRYPTO_MAC_SIZE)
#define ONION_ANNOUNCE_RESPONSE_MAX_SIZE (ONION_ANNOUNCE_RESPONSE_MIN_SIZE + ONION_MAX_EXTRA_DATA_SIZE * MAX_SENT_NODES)

/* TODO: DEPRECATE */
#define ONION_ANNOUNCE_REQUEST_SIZE (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_PING_ID_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_PUBLIC_KEY_SIZE + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_MAC_SIZE)

#define ONION_DATA_RESPONSE_MIN_SIZE (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_MAC_SIZE)

#define ONION_DATA_REQUEST_MIN_SIZE (1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_MAC_SIZE)
#define MAX_DATA_REQUEST_SIZE (ONION_MAX_DATA_SIZE - ONION_DATA_REQUEST_MIN_SIZE)

typedef struct Onion_Announce Onion_Announce;

/** These two are not public; they are for tests only! */
non_null()
uint8_t *onion_announce_entry_public_key(Onion_Announce *onion_a, uint32_t entry);
non_null()
void onion_announce_entry_set_time(Onion_Announce *onion_a, uint32_t entry, uint64_t announce_time);

/** @brief Create an onion announce request packet in packet of max_packet_length.
 *
 * Recommended value for max_packet_length is ONION_ANNOUNCE_REQUEST_MIN_SIZE.
 *
 * dest_client_id is the public key of the node the packet will be sent to.
 * public_key and secret_key is the kepair which will be used to encrypt the request.
 * ping_id is the ping id that will be sent in the request.
 * client_id is the client id of the node we are searching for.
 * data_public_key is the public key we want others to encrypt their data packets with.
 * sendback_data is the data of ONION_ANNOUNCE_SENDBACK_DATA_LENGTH length that we expect to
 * receive back in the response.
 *
 * return -1 on failure.
 * return packet length on success.
 */
non_null()
int create_announce_request(const Random *rng, uint8_t *packet, uint16_t max_packet_length, const uint8_t *dest_client_id,
                            const uint8_t *public_key, const uint8_t *secret_key, const uint8_t *ping_id, const uint8_t *client_id,
                            const uint8_t *data_public_key, uint64_t sendback_data);

/** @brief Create an onion data request packet in packet of max_packet_length.
 *
 * Recommended value for max_packet_length is ONION_ANNOUNCE_REQUEST_SIZE.
 *
 * public_key is the real public key of the node which we want to send the data of length length to.
 * encrypt_public_key is the public key used to encrypt the data packet.
 *
 * nonce is the nonce to encrypt this packet with
 *
 * return -1 on failure.
 * return 0 on success.
 */
non_null()
int create_data_request(const Random *rng, uint8_t *packet, uint16_t max_packet_length, const uint8_t *public_key,
                        const uint8_t *encrypt_public_key, const uint8_t *nonce, const uint8_t *data, uint16_t length);

/** @brief Create and send an onion announce request packet.
 *
 * path is the path the request will take before it is sent to dest.
 *
 * public_key and secret_key is the kepair which will be used to encrypt the request.
 * ping_id is the ping id that will be sent in the request.
 * client_id is the client id of the node we are searching for.
 * data_public_key is the public key we want others to encrypt their data packets with.
 * sendback_data is the data of ONION_ANNOUNCE_SENDBACK_DATA_LENGTH length that we expect to
 * receive back in the response.
 *
 * return -1 on failure.
 * return 0 on success.
 */
non_null()
int send_announce_request(const Networking_Core *net, const Random *rng,
                          const Onion_Path *path, const Node_format *dest,
                          const uint8_t *public_key, const uint8_t *secret_key,
                          const uint8_t *ping_id, const uint8_t *client_id,
                          const uint8_t *data_public_key, uint64_t sendback_data);

/** @brief Create and send an onion data request packet.
 *
 * path is the path the request will take before it is sent to dest.
 * (if dest knows the person with the public_key they should
 * send the packet to that person in the form of a response)
 *
 * public_key is the real public key of the node which we want to send the data of length length to.
 * encrypt_public_key is the public key used to encrypt the data packet.
 *
 * nonce is the nonce to encrypt this packet with
 *
 * The maximum length of data is MAX_DATA_REQUEST_SIZE.
 *
 * return -1 on failure.
 * return 0 on success.
 */
non_null()
int send_data_request(const Networking_Core *net, const Random *rng, const Onion_Path *path, const IP_Port *dest,
                      const uint8_t *public_key, const uint8_t *encrypt_public_key, const uint8_t *nonce,
                      const uint8_t *data, uint16_t length);


typedef int pack_extra_data_cb(void *object, const Logger *logger, const Mono_Time *mono_time,
                               uint8_t num_nodes, uint8_t *plain, uint16_t plain_size,
                               uint8_t *response, uint16_t response_size, uint16_t offset);

non_null()
void onion_announce_extra_data_callback(Onion_Announce *onion_a, uint16_t extra_data_max_size,
                                        pack_extra_data_cb *extra_data_callback, void *extra_data_object);

non_null()
Onion_Announce *new_onion_announce(const Logger *log, const Random *rng, const Mono_Time *mono_time, DHT *dht);

nullable(1)
void kill_onion_announce(Onion_Announce *onion_a);

#endif
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2020 The TokTok team.
 * Copyright © 2015 Tox project.
 */

#ifndef C_TOXCORE_TOXCORE_GROUP_ONION_ANNOUNCE_H
#define C_TOXCORE_TOXCORE_GROUP_ONION_ANNOUNCE_H


non_null()
void gca_onion_init(GC_Announces_List *group_announce, Onion_Announce *onion_a);

non_null()
int create_gca_announce_request(
    const Random *rng, uint8_t *packet, uint16_t max_packet_length, const uint8_t *dest_client_id,
    const uint8_t *public_key, const uint8_t *secret_key, const uint8_t *ping_id,
    const uint8_t *client_id, const uint8_t *data_public_key, uint64_t sendback_data,
    const uint8_t *gc_data, uint16_t gc_data_length);

#endif  // C_TOXCORE_TOXCORE_GROUP_ONION_ANNOUNCE_H
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2020 The TokTok team.
 * Copyright © 2014 Tox project.
 */

/**
 * The state module is responsible for parsing the Tox save data format and for
 * saving state in that format.
 *
 * This module provides functions for iterating over serialised data sections
 * and reading/writing numbers in the correct format (little endian).
 *
 * Note that unlike the Tox network protocol, the save data stores its values in
 * little endian, which is native to most desktop and server architectures in
 * 2018.
 */
#ifndef C_TOXCORE_TOXCORE_STATE_H
#define C_TOXCORE_TOXCORE_STATE_H


#ifdef __cplusplus
extern "C" {
#endif

#define STATE_COOKIE_GLOBAL 0x15ed1b1f

#define STATE_COOKIE_TYPE  0x01ce

typedef enum State_Type {
    STATE_TYPE_NOSPAMKEYS    = 1,
    STATE_TYPE_DHT           = 2,
    STATE_TYPE_FRIENDS       = 3,
    STATE_TYPE_NAME          = 4,
    STATE_TYPE_STATUSMESSAGE = 5,
    STATE_TYPE_STATUS        = 6,
    STATE_TYPE_GROUPS        = 7,
    STATE_TYPE_TCP_RELAY     = 10,
    STATE_TYPE_PATH_NODE     = 11,
    STATE_TYPE_CONFERENCES   = 20,
    STATE_TYPE_END           = 255,
} State_Type;

// Returned by the state_load_cb to instruct the loader on what to do next.
typedef enum State_Load_Status {
    // Continue loading state data sections.
    STATE_LOAD_STATUS_CONTINUE,
    // An error occurred. Stop loading sections.
    STATE_LOAD_STATUS_ERROR,
    // We're at the end of the save data, terminate loading successfully.
    STATE_LOAD_STATUS_END,
} State_Load_Status;

typedef State_Load_Status state_load_cb(void *outer, const uint8_t *data, uint32_t len, uint16_t type);

/** state load/save */
non_null()
int state_load(const Logger *log, state_load_cb *state_load_callback, void *outer,
               const uint8_t *data, uint32_t length, uint16_t cookie_inner);

non_null()
uint8_t *state_write_section_header(uint8_t *data, uint16_t cookie_type, uint32_t len, uint32_t section_type);

// Utilities for state data serialisation.

uint16_t lendian_to_host16(uint16_t lendian);
uint16_t host_to_lendian16(uint16_t host);

non_null()
void host_to_lendian_bytes64(uint8_t *dest, uint64_t num);
non_null()
void lendian_bytes_to_host64(uint64_t *dest, const uint8_t *lendian);

non_null()
void host_to_lendian_bytes32(uint8_t *dest, uint32_t num);
non_null()
void lendian_bytes_to_host32(uint32_t *dest, const uint8_t *lendian);

non_null()
void host_to_lendian_bytes16(uint8_t *dest, uint16_t num);
non_null()
void lendian_bytes_to_host16(uint16_t *dest, const uint8_t *lendian);

#ifdef __cplusplus
}  // extern "C"
#endif

#endif // C_TOXCORE_TOXCORE_STATE_H
/* SPDX-License-Identifier: MIT
 * Copyright © 2020-2024 Charles Gunyon.
 */
#ifndef CMP_H_INCLUDED
#define CMP_H_INCLUDED

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>

typedef struct cmp_ctx_s cmp_ctx_t;

typedef bool   cmp_reader(cmp_ctx_t *ctx, void *data, size_t limit);
typedef bool   cmp_skipper(cmp_ctx_t *ctx, size_t count);
typedef size_t cmp_writer(cmp_ctx_t *ctx, const void *data, size_t count);

enum {
  CMP_TYPE_POSITIVE_FIXNUM, /*  0 */
  CMP_TYPE_FIXMAP,          /*  1 */
  CMP_TYPE_FIXARRAY,        /*  2 */
  CMP_TYPE_FIXSTR,          /*  3 */
  CMP_TYPE_NIL,             /*  4 */
  CMP_TYPE_BOOLEAN,         /*  5 */
  CMP_TYPE_BIN8,            /*  6 */
  CMP_TYPE_BIN16,           /*  7 */
  CMP_TYPE_BIN32,           /*  8 */
  CMP_TYPE_EXT8,            /*  9 */
  CMP_TYPE_EXT16,           /* 10 */
  CMP_TYPE_EXT32,           /* 11 */
  CMP_TYPE_FLOAT,           /* 12 */
  CMP_TYPE_DOUBLE,          /* 13 */
  CMP_TYPE_UINT8,           /* 14 */
  CMP_TYPE_UINT16,          /* 15 */
  CMP_TYPE_UINT32,          /* 16 */
  CMP_TYPE_UINT64,          /* 17 */
  CMP_TYPE_SINT8,           /* 18 */
  CMP_TYPE_SINT16,          /* 19 */
  CMP_TYPE_SINT32,          /* 20 */
  CMP_TYPE_SINT64,          /* 21 */
  CMP_TYPE_FIXEXT1,         /* 22 */
  CMP_TYPE_FIXEXT2,         /* 23 */
  CMP_TYPE_FIXEXT4,         /* 24 */
  CMP_TYPE_FIXEXT8,         /* 25 */
  CMP_TYPE_FIXEXT16,        /* 26 */
  CMP_TYPE_STR8,            /* 27 */
  CMP_TYPE_STR16,           /* 28 */
  CMP_TYPE_STR32,           /* 29 */
  CMP_TYPE_ARRAY16,         /* 30 */
  CMP_TYPE_ARRAY32,         /* 31 */
  CMP_TYPE_MAP16,           /* 32 */
  CMP_TYPE_MAP32,           /* 33 */
  CMP_TYPE_NEGATIVE_FIXNUM  /* 34 */
};

typedef struct cmp_ext_s {
  int8_t type;
  uint32_t size;
} cmp_ext_t;

typedef union cmp_object_data_u {
  bool      boolean;
  uint8_t   u8;
  uint16_t  u16;
  uint32_t  u32;
  uint64_t  u64;
  int8_t    s8;
  int16_t   s16;
  int32_t   s32;
  int64_t   s64;
#ifndef CMP_NO_FLOAT
  float     flt;
  double    dbl;
#endif /* CMP_NO_FLOAT */
  uint32_t  array_size;
  uint32_t  map_size;
  uint32_t  str_size;
  uint32_t  bin_size;
  cmp_ext_t ext;
} cmp_object_data_t;

struct cmp_ctx_s {
  uint8_t      error;
  void        *buf;
  cmp_reader  *read;
  cmp_skipper *skip;
  cmp_writer  *write;
};

typedef struct cmp_object_s {
  uint8_t type;
  cmp_object_data_t as;
} cmp_object_t;

#ifdef __cplusplus
extern "C" {
#endif

/*
 * ============================================================================
 * === Main API
 * ============================================================================
 */

/*
 * Initializes a CMP context
 *
 * If you don't intend to read, `read` may be NULL, but calling `*read*`
 * functions will crash; there is no check.
 *
 * `skip` may be NULL, in which case skipping functions will use `read`.
 *
 * If you don't intend to write, `write` may be NULL, but calling `*write*`
 * functions will crash; there is no check.
 */
void cmp_init(cmp_ctx_t *ctx, void *buf, cmp_reader *read,
                                         cmp_skipper *skip,
                                         cmp_writer *write);

/* Returns CMP's version */
uint32_t cmp_version(void);

/* Returns the MessagePack version employed by CMP */
uint32_t cmp_mp_version(void);

/* Returns a string description of a CMP context's error */
const char* cmp_strerror(const cmp_ctx_t *ctx);

/* Writes a signed integer to the backend */
bool cmp_write_integer(cmp_ctx_t *ctx, int64_t d);

/* Writes an unsigned integer to the backend */
bool cmp_write_uinteger(cmp_ctx_t *ctx, uint64_t u);

/*
 * Writes a floating-point value (either single or double-precision) to the
 * backend
 */
#ifndef CMP_NO_FLOAT
bool cmp_write_decimal(cmp_ctx_t *ctx, double d);
#endif /* CMP_NO_FLOAT */

/* Writes NULL to the backend */
bool cmp_write_nil(cmp_ctx_t *ctx);

/* Writes true to the backend */
bool cmp_write_true(cmp_ctx_t *ctx);

/* Writes false to the backend */
bool cmp_write_false(cmp_ctx_t *ctx);

/* Writes a boolean value to the backend */
bool cmp_write_bool(cmp_ctx_t *ctx, bool b);

/*
 * Writes an unsigned char's value to the backend as a boolean.  This is useful
 * if you are using a different boolean type in your application.
 */
bool cmp_write_u8_as_bool(cmp_ctx_t *ctx, uint8_t b);

/*
 * Writes a string to the backend; according to the MessagePack spec, this must
 * be encoded using UTF-8, but CMP leaves that job up to the programmer.
 */
bool cmp_write_str(cmp_ctx_t *ctx, const char *data, uint32_t size);

/*
 * Writes a string to the backend.  This avoids using the STR8 marker, which
 * is unsupported by MessagePack v4, the version implemented by many other
 * MessagePack libraries.  No encoding is assumed in this case, not that it
 * matters.
 */
bool cmp_write_str_v4(cmp_ctx_t *ctx, const char *data, uint32_t size);

/*
 * Writes the string marker to the backend.  This is useful if you are writing
 * data in chunks instead of a single shot.
 */
bool cmp_write_str_marker(cmp_ctx_t *ctx, uint32_t size);

/*
 * Writes the string marker to the backend.  This is useful if you are writing
 * data in chunks instead of a single shot.  This avoids using the STR8
 * marker, which is unsupported by MessagePack v4, the version implemented by
 * many other MessagePack libraries.  No encoding is assumed in this case, not
 * that it matters.
 */
bool cmp_write_str_marker_v4(cmp_ctx_t *ctx, uint32_t size);

/* Writes binary data to the backend */
bool cmp_write_bin(cmp_ctx_t *ctx, const void *data, uint32_t size);

/*
 * Writes the binary data marker to the backend.  This is useful if you are
 * writing data in chunks instead of a single shot.
 */
bool cmp_write_bin_marker(cmp_ctx_t *ctx, uint32_t size);

/* Writes an array to the backend. */
bool cmp_write_array(cmp_ctx_t *ctx, uint32_t size);

/* Writes a map to the backend. */
bool cmp_write_map(cmp_ctx_t *ctx, uint32_t size);

/* Writes an extended type to the backend */
bool cmp_write_ext(cmp_ctx_t *ctx, int8_t type, uint32_t size,
                                   const void *data);

/*
 * Writes the extended type marker to the backend.  This is useful if you want
 * to write the type's data in chunks instead of a single shot.
 */
bool cmp_write_ext_marker(cmp_ctx_t *ctx, int8_t type, uint32_t size);

/* Writes an object to the backend */
bool cmp_write_object(cmp_ctx_t *ctx, const cmp_object_t *obj);

/*
 * Writes an object to the backend. This avoids using the STR8 marker, which
 * is unsupported by MessagePack v4, the version implemented by many other
 * MessagePack libraries.
 */
bool cmp_write_object_v4(cmp_ctx_t *ctx, const cmp_object_t *obj);

/* Reads a signed integer that fits inside a signed char */
bool cmp_read_char(cmp_ctx_t *ctx, int8_t *c);

/* Reads a signed integer that fits inside a signed short */
bool cmp_read_short(cmp_ctx_t *ctx, int16_t *s);

/* Reads a signed integer that fits inside a signed int */
bool cmp_read_int(cmp_ctx_t *ctx, int32_t *i);

/* Reads a signed integer that fits inside a signed long */
bool cmp_read_long(cmp_ctx_t *ctx, int64_t *d);

/* Reads a signed integer */
bool cmp_read_integer(cmp_ctx_t *ctx, int64_t *d);

/* Reads an unsigned integer that fits inside an unsigned char */
bool cmp_read_uchar(cmp_ctx_t *ctx, uint8_t *c);

/* Reads an unsigned integer that fits inside an unsigned short */
bool cmp_read_ushort(cmp_ctx_t *ctx, uint16_t *s);

/* Reads an unsigned integer that fits inside an unsigned int */
bool cmp_read_uint(cmp_ctx_t *ctx, uint32_t *i);

/* Reads an unsigned integer that fits inside an unsigned long */
bool cmp_read_ulong(cmp_ctx_t *ctx, uint64_t *u);

/* Reads an unsigned integer */
bool cmp_read_uinteger(cmp_ctx_t *ctx, uint64_t *u);

/*
 * Reads a floating point value (either single or double-precision) from the
 * backend
 */
#ifndef CMP_NO_FLOAT
bool cmp_read_decimal(cmp_ctx_t *ctx, double *d);
#endif /* CMP_NO_FLOAT */

/* "Reads" (more like "skips") a NULL value from the backend */
bool cmp_read_nil(cmp_ctx_t *ctx);

/* Reads a boolean from the backend */
bool cmp_read_bool(cmp_ctx_t *ctx, bool *b);

/*
 * Reads a boolean as an unsigned char from the backend; this is useful if your
 * application uses a different boolean type.
 */
bool cmp_read_bool_as_u8(cmp_ctx_t *ctx, uint8_t *b);

/* Reads a string's size from the backend */
bool cmp_read_str_size(cmp_ctx_t *ctx, uint32_t *size);

/*
 * Reads a string from the backend; according to the spec, the string's data
 * ought to be encoded using UTF-8, but CMP leaves that job up to the programmer.
 */
bool cmp_read_str(cmp_ctx_t *ctx, char *data, uint32_t *size);

/* Reads the size of packed binary data from the backend */
bool cmp_read_bin_size(cmp_ctx_t *ctx, uint32_t *size);

/* Reads packed binary data from the backend */
bool cmp_read_bin(cmp_ctx_t *ctx, void *data, uint32_t *size);

/* Reads an array from the backend */
bool cmp_read_array(cmp_ctx_t *ctx, uint32_t *size);

/* Reads a map from the backend */
bool cmp_read_map(cmp_ctx_t *ctx, uint32_t *size);

/* Reads the extended type's marker from the backend */
bool cmp_read_ext_marker(cmp_ctx_t *ctx, int8_t *type, uint32_t *size);

/* Reads an extended type from the backend */
bool cmp_read_ext(cmp_ctx_t *ctx, int8_t *type, uint32_t *size, void *data);

/* Reads an object from the backend */
bool cmp_read_object(cmp_ctx_t *ctx, cmp_object_t *obj);

/*
 * Skips the next object from the backend.  If that object is an array or map,
 * this function will:
 *   - If `obj` is not `NULL`, fill in `obj` with that object
 *   - Set `ctx->error` to `SKIP_DEPTH_LIMIT_EXCEEDED_ERROR`
 *   - Return `false`
 * Otherwise:
 *   - (Don't touch `obj`)
 *   - Return `true`
 */
bool cmp_skip_object(cmp_ctx_t *ctx, cmp_object_t *obj);

/*
 * This is similar to `cmp_skip_object`, except it tolerates flat arrays and
 * maps.  If when skipping such an array or map this function encounters
 * another array/map, it will:
 *   - If `obj` is not `NULL`, fill in `obj` with that (nested) object
 *   - Set `ctx->error` to `SKIP_DEPTH_LIMIT_EXCEEDED_ERROR`
 *   - Return `false`
 * Otherwise:
 *   - (Don't touch `obj`)
 *   - Return `true`
 *
 * WARNING: This can cause your application to spend an unbounded amount of
 *          time reading nested data structures.  Unless you completely trust
 *          the data source, you should use `cmp_skip_object`.
 */
bool cmp_skip_object_flat(cmp_ctx_t *ctx, cmp_object_t *obj);

/*
 * This is similar to `cmp_skip_object`, except it will continually skip
 * nested data structures.
 *
 * WARNING: This can cause your application to spend an unbounded amount of
 *          time reading nested data structures.  Unless you completely trust
 *          the data source, you should use `cmp_skip_object`.
 */
bool cmp_skip_object_no_limit(cmp_ctx_t *ctx);

/*
 * ============================================================================
 * === Specific API
 * ============================================================================
 */

bool cmp_write_pfix(cmp_ctx_t *ctx, uint8_t c);
bool cmp_write_nfix(cmp_ctx_t *ctx, int8_t c);

bool cmp_write_sfix(cmp_ctx_t *ctx, int8_t c);
bool cmp_write_s8(cmp_ctx_t *ctx, int8_t c);
bool cmp_write_s16(cmp_ctx_t *ctx, int16_t s);
bool cmp_write_s32(cmp_ctx_t *ctx, int32_t i);
bool cmp_write_s64(cmp_ctx_t *ctx, int64_t l);

bool cmp_write_ufix(cmp_ctx_t *ctx, uint8_t c);
bool cmp_write_u8(cmp_ctx_t *ctx, uint8_t c);
bool cmp_write_u16(cmp_ctx_t *ctx, uint16_t s);
bool cmp_write_u32(cmp_ctx_t *ctx, uint32_t i);
bool cmp_write_u64(cmp_ctx_t *ctx, uint64_t l);

#ifndef CMP_NO_FLOAT
bool cmp_write_float(cmp_ctx_t *ctx, float f);
bool cmp_write_double(cmp_ctx_t *ctx, double d);
#endif /* CMP_NO_FLOAT */

bool cmp_write_fixstr_marker(cmp_ctx_t *ctx, uint8_t size);
bool cmp_write_fixstr(cmp_ctx_t *ctx, const char *data, uint8_t size);
bool cmp_write_str8_marker(cmp_ctx_t *ctx, uint8_t size);
bool cmp_write_str8(cmp_ctx_t *ctx, const char *data, uint8_t size);
bool cmp_write_str16_marker(cmp_ctx_t *ctx, uint16_t size);
bool cmp_write_str16(cmp_ctx_t *ctx, const char *data, uint16_t size);
bool cmp_write_str32_marker(cmp_ctx_t *ctx, uint32_t size);
bool cmp_write_str32(cmp_ctx_t *ctx, const char *data, uint32_t size);

bool cmp_write_bin8_marker(cmp_ctx_t *ctx, uint8_t size);
bool cmp_write_bin8(cmp_ctx_t *ctx, const void *data, uint8_t size);
bool cmp_write_bin16_marker(cmp_ctx_t *ctx, uint16_t size);
bool cmp_write_bin16(cmp_ctx_t *ctx, const void *data, uint16_t size);
bool cmp_write_bin32_marker(cmp_ctx_t *ctx, uint32_t size);
bool cmp_write_bin32(cmp_ctx_t *ctx, const void *data, uint32_t size);

bool cmp_write_fixarray(cmp_ctx_t *ctx, uint8_t size);
bool cmp_write_array16(cmp_ctx_t *ctx, uint16_t size);
bool cmp_write_array32(cmp_ctx_t *ctx, uint32_t size);

bool cmp_write_fixmap(cmp_ctx_t *ctx, uint8_t size);
bool cmp_write_map16(cmp_ctx_t *ctx, uint16_t size);
bool cmp_write_map32(cmp_ctx_t *ctx, uint32_t size);

bool cmp_write_fixext1_marker(cmp_ctx_t *ctx, int8_t type);
bool cmp_write_fixext1(cmp_ctx_t *ctx, int8_t type, const void *data);
bool cmp_write_fixext2_marker(cmp_ctx_t *ctx, int8_t type);
bool cmp_write_fixext2(cmp_ctx_t *ctx, int8_t type, const void *data);
bool cmp_write_fixext4_marker(cmp_ctx_t *ctx, int8_t type);
bool cmp_write_fixext4(cmp_ctx_t *ctx, int8_t type, const void *data);
bool cmp_write_fixext8_marker(cmp_ctx_t *ctx, int8_t type);
bool cmp_write_fixext8(cmp_ctx_t *ctx, int8_t type, const void *data);
bool cmp_write_fixext16_marker(cmp_ctx_t *ctx, int8_t type);
bool cmp_write_fixext16(cmp_ctx_t *ctx, int8_t type, const void *data);

bool cmp_write_ext8_marker(cmp_ctx_t *ctx, int8_t type, uint8_t size);
bool cmp_write_ext8(cmp_ctx_t *ctx, int8_t type, uint8_t size,
                                    const void *data);
bool cmp_write_ext16_marker(cmp_ctx_t *ctx, int8_t type, uint16_t size);
bool cmp_write_ext16(cmp_ctx_t *ctx, int8_t type, uint16_t size,
                                     const void *data);
bool cmp_write_ext32_marker(cmp_ctx_t *ctx, int8_t type, uint32_t size);
bool cmp_write_ext32(cmp_ctx_t *ctx, int8_t type, uint32_t size,
                                     const void *data);

bool cmp_read_pfix(cmp_ctx_t *ctx, uint8_t *c);
bool cmp_read_nfix(cmp_ctx_t *ctx, int8_t *c);

bool cmp_read_sfix(cmp_ctx_t *ctx, int8_t *c);
bool cmp_read_s8(cmp_ctx_t *ctx, int8_t *c);
bool cmp_read_s16(cmp_ctx_t *ctx, int16_t *s);
bool cmp_read_s32(cmp_ctx_t *ctx, int32_t *i);
bool cmp_read_s64(cmp_ctx_t *ctx, int64_t *l);

bool cmp_read_ufix(cmp_ctx_t *ctx, uint8_t *c);
bool cmp_read_u8(cmp_ctx_t *ctx, uint8_t *c);
bool cmp_read_u16(cmp_ctx_t *ctx, uint16_t *s);
bool cmp_read_u32(cmp_ctx_t *ctx, uint32_t *i);
bool cmp_read_u64(cmp_ctx_t *ctx, uint64_t *l);

#ifndef CMP_NO_FLOAT
bool cmp_read_float(cmp_ctx_t *ctx, float *f);
bool cmp_read_double(cmp_ctx_t *ctx, double *d);
#endif /* CMP_NO_FLOAT */

bool cmp_read_fixext1_marker(cmp_ctx_t *ctx, int8_t *type);
bool cmp_read_fixext1(cmp_ctx_t *ctx, int8_t *type, void *data);
bool cmp_read_fixext2_marker(cmp_ctx_t *ctx, int8_t *type);
bool cmp_read_fixext2(cmp_ctx_t *ctx, int8_t *type, void *data);
bool cmp_read_fixext4_marker(cmp_ctx_t *ctx, int8_t *type);
bool cmp_read_fixext4(cmp_ctx_t *ctx, int8_t *type, void *data);
bool cmp_read_fixext8_marker(cmp_ctx_t *ctx, int8_t *type);
bool cmp_read_fixext8(cmp_ctx_t *ctx, int8_t *type, void *data);
bool cmp_read_fixext16_marker(cmp_ctx_t *ctx, int8_t *type);
bool cmp_read_fixext16(cmp_ctx_t *ctx, int8_t *type, void *data);

bool cmp_read_ext8_marker(cmp_ctx_t *ctx, int8_t *type, uint8_t *size);
bool cmp_read_ext8(cmp_ctx_t *ctx, int8_t *type, uint8_t *size, void *data);
bool cmp_read_ext16_marker(cmp_ctx_t *ctx, int8_t *type, uint16_t *size);
bool cmp_read_ext16(cmp_ctx_t *ctx, int8_t *type, uint16_t *size, void *data);
bool cmp_read_ext32_marker(cmp_ctx_t *ctx, int8_t *type, uint32_t *size);
bool cmp_read_ext32(cmp_ctx_t *ctx, int8_t *type, uint32_t *size, void *data);

/*
 * ============================================================================
 * === Object API
 * ============================================================================
 */

bool cmp_object_is_char(const cmp_object_t *obj);
bool cmp_object_is_short(const cmp_object_t *obj);
bool cmp_object_is_int(const cmp_object_t *obj);
bool cmp_object_is_long(const cmp_object_t *obj);
bool cmp_object_is_sinteger(const cmp_object_t *obj);
bool cmp_object_is_uchar(const cmp_object_t *obj);
bool cmp_object_is_ushort(const cmp_object_t *obj);
bool cmp_object_is_uint(const cmp_object_t *obj);
bool cmp_object_is_ulong(const cmp_object_t *obj);
bool cmp_object_is_uinteger(const cmp_object_t *obj);
bool cmp_object_is_float(const cmp_object_t *obj);
bool cmp_object_is_double(const cmp_object_t *obj);
bool cmp_object_is_nil(const cmp_object_t *obj);
bool cmp_object_is_bool(const cmp_object_t *obj);
bool cmp_object_is_str(const cmp_object_t *obj);
bool cmp_object_is_bin(const cmp_object_t *obj);
bool cmp_object_is_array(const cmp_object_t *obj);
bool cmp_object_is_map(const cmp_object_t *obj);
bool cmp_object_is_ext(const cmp_object_t *obj);

bool cmp_object_as_char(const cmp_object_t *obj, int8_t *c);
bool cmp_object_as_short(const cmp_object_t *obj, int16_t *s);
bool cmp_object_as_int(const cmp_object_t *obj, int32_t *i);
bool cmp_object_as_long(const cmp_object_t *obj, int64_t *d);
bool cmp_object_as_sinteger(const cmp_object_t *obj, int64_t *d);
bool cmp_object_as_uchar(const cmp_object_t *obj, uint8_t *c);
bool cmp_object_as_ushort(const cmp_object_t *obj, uint16_t *s);
bool cmp_object_as_uint(const cmp_object_t *obj, uint32_t *i);
bool cmp_object_as_ulong(const cmp_object_t *obj, uint64_t *u);
bool cmp_object_as_uinteger(const cmp_object_t *obj, uint64_t *u);
#ifndef CMP_NO_FLOAT
bool cmp_object_as_float(const cmp_object_t *obj, float *f);
bool cmp_object_as_double(const cmp_object_t *obj, double *d);
#endif /* CMP_NO_FLOAT */
bool cmp_object_as_bool(const cmp_object_t *obj, bool *b);
bool cmp_object_as_str(const cmp_object_t *obj, uint32_t *size);
bool cmp_object_as_bin(const cmp_object_t *obj, uint32_t *size);
bool cmp_object_as_array(const cmp_object_t *obj, uint32_t *size);
bool cmp_object_as_map(const cmp_object_t *obj, uint32_t *size);
bool cmp_object_as_ext(const cmp_object_t *obj, int8_t *type, uint32_t *size);

bool cmp_object_to_str(cmp_ctx_t *ctx, const cmp_object_t *obj, char *data, uint32_t buf_size);
bool cmp_object_to_bin(cmp_ctx_t *ctx, const cmp_object_t *obj, void *data, uint32_t buf_size);

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* CMP_H_INCLUDED */

/* vi: set et ts=2 sw=2: */
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2022 The TokTok team.
 */
#ifndef C_TOXCORE_TOXCORE_BIN_PACK_H
#define C_TOXCORE_TOXCORE_BIN_PACK_H

#include <stdbool.h>
#include <stdint.h>


#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Binary serialisation object.
 */
typedef struct Bin_Pack Bin_Pack;

/** @brief Function used to pack an object.
 *
 * This function would typically cast the `void *` to the actual object pointer type and then call
 * more appropriately typed packing functions.
 */
typedef bool bin_pack_cb(Bin_Pack *bp, const void *obj);

/** @brief Determine the serialised size of an object.
 *
 * @param callback The function called on the created packer and packed object.
 * @param obj The object to be packed, passed as `obj` to the callback.
 *
 * @return The packed size of the passed object according to the callback. UINT32_MAX in case of
 *   errors such as buffer overflow.
 */
non_null(1) nullable(2)
uint32_t bin_pack_obj_size(bin_pack_cb *callback, const void *obj);

/** @brief Pack an object into a buffer of a given size.
 *
 * This function creates and initialises a `Bin_Pack` packer object, calls the callback with the
 * packer object and the to-be-packed object, and then cleans up the packer object.
 *
 * You can use `bin_pack_obj_size` to determine the minimum required size of `buf`. If packing
 * overflows `uint32_t`, this function returns `false`.
 *
 * @param callback The function called on the created packer and packed object.
 * @param obj The object to be packed, passed as `obj` to the callback.
 * @param buf A byte array large enough to hold the serialised representation of `obj`.
 * @param buf_size The size of the byte array. Can be `UINT32_MAX` to disable bounds checking.
 *
 * @retval false if an error occurred (e.g. buffer overflow).
 */
non_null(1, 3) nullable(2)
bool bin_pack_obj(bin_pack_cb *callback, const void *obj, uint8_t *buf, uint32_t buf_size);

/** @brief Allocate a new packer object.
 *
 * This is the only function that allocates memory in this module.
 *
 * @param buf A byte array large enough to hold the serialised representation of `obj`.
 * @param buf_size The size of the byte array. Can be `UINT32_MAX` to disable bounds checking.
 *
 * @retval nullptr on allocation failure.
 */
non_null()
Bin_Pack *bin_pack_new(uint8_t *buf, uint32_t buf_size);

/** @brief Deallocates a packer object.
 *
 * Does not deallocate the buffer inside.
 */
nullable(1)
void bin_pack_free(Bin_Pack *bp);

/** @brief Start packing a MessagePack array.
 *
 * A call to this function must be followed by exactly `size` calls to other functions below.
 */
non_null()
bool bin_pack_array(Bin_Pack *bp, uint32_t size);

/** @brief Pack a MessagePack bool. */
non_null() bool bin_pack_bool(Bin_Pack *bp, bool val);
/** @brief Pack a `uint8_t` as MessagePack positive integer. */
non_null() bool bin_pack_u08(Bin_Pack *bp, uint8_t val);
/** @brief Pack a `uint16_t` as MessagePack positive integer. */
non_null() bool bin_pack_u16(Bin_Pack *bp, uint16_t val);
/** @brief Pack a `uint32_t` as MessagePack positive integer. */
non_null() bool bin_pack_u32(Bin_Pack *bp, uint32_t val);
/** @brief Pack a `uint64_t` as MessagePack positive integer. */
non_null() bool bin_pack_u64(Bin_Pack *bp, uint64_t val);
/** @brief Pack an empty array member as a MessagePack nil value. */
non_null() bool bin_pack_nil(Bin_Pack *bp);
/** @brief Pack a byte array as MessagePack bin. */
non_null() bool bin_pack_bin(Bin_Pack *bp, const uint8_t *data, uint32_t length);
/** @brief Start packing a custom binary representation.
 *
 * A call to this function must be followed by exactly `size` bytes packed by functions below.
 */
non_null() bool bin_pack_bin_marker(Bin_Pack *bp, uint32_t size);

/** @brief Write a `uint8_t` directly to the packer in 1 byte. */
non_null() bool bin_pack_u08_b(Bin_Pack *bp, uint8_t val);
/** @brief Write a `uint16_t` as big endian 16 bit int in 2 bytes. */
non_null() bool bin_pack_u16_b(Bin_Pack *bp, uint16_t val);
/** @brief Write a `uint32_t` as big endian 32 bit int in 4 bytes. */
non_null() bool bin_pack_u32_b(Bin_Pack *bp, uint32_t val);
/** @brief Write a `uint64_t` as big endian 64 bit int in 8 bytes. */
non_null() bool bin_pack_u64_b(Bin_Pack *bp, uint64_t val);

/** @brief Write a byte array directly to the packer in `length` bytes.
 *
 * Note that unless you prepend the array length manually, there is no record of it in the resulting
 * serialised representation.
 */
non_null() bool bin_pack_bin_b(Bin_Pack *bp, const uint8_t *data, uint32_t length);

#ifdef __cplusplus
}  // extern "C"
#endif

#endif // C_TOXCORE_TOXCORE_BIN_PACK_H
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2022 The TokTok team.
 */

#ifndef C_TOXCORE_TOXCORE_BIN_UNPACK_H
#define C_TOXCORE_TOXCORE_BIN_UNPACK_H

#include <stdbool.h>
#include <stdint.h>


#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Binary deserialisation object.
 */
typedef struct Bin_Unpack Bin_Unpack;

/** @brief Allocate a new unpacker object.
 *
 * @param buf The byte array to unpack values from.
 * @param buf_size The size of the byte array.
 *
 * @retval nullptr on allocation failure.
 */
non_null()
Bin_Unpack *bin_unpack_new(const uint8_t *buf, uint32_t buf_size);

/** @brief Deallocates an unpacker object.
 *
 * Does not deallocate the buffer inside.
 */
nullable(1)
void bin_unpack_free(Bin_Unpack *bu);

/** @brief Start unpacking a MessagePack array.
 *
 * A call to this function must be followed by exactly `size` calls to other functions below.
 *
 * @param size Will contain the number of array elements following the array marker.
 */
non_null() bool bin_unpack_array(Bin_Unpack *bu, uint32_t *size);

/** @brief Start unpacking a fixed size MessagePack array.
 *
 * @retval false if the packed array size is not exactly the required size.
 */
non_null() bool bin_unpack_array_fixed(Bin_Unpack *bu, uint32_t required_size);

/** @brief Unpack a MessagePack bool. */
non_null() bool bin_unpack_bool(Bin_Unpack *bu, bool *val);
/** @brief Unpack a MessagePack positive int into a `uint8_t`. */
non_null() bool bin_unpack_u08(Bin_Unpack *bu, uint8_t *val);
/** @brief Unpack a MessagePack positive int into a `uint16_t`. */
non_null() bool bin_unpack_u16(Bin_Unpack *bu, uint16_t *val);
/** @brief Unpack a MessagePack positive int into a `uint32_t`. */
non_null() bool bin_unpack_u32(Bin_Unpack *bu, uint32_t *val);
/** @brief Unpack a MessagePack positive int into a `uint64_t`. */
non_null() bool bin_unpack_u64(Bin_Unpack *bu, uint64_t *val);
/** @brief Unpack a Messagepack nil value. */
non_null() bool bin_unpack_nil(Bin_Unpack *bu);

/** @brief Unpack a MessagePack bin into a newly allocated byte array.
 *
 * Allocates a new byte array and stores it into `data_ptr` with its length stored in
 * `data_length_ptr`. This function requires that the unpacking buffer has at least as many bytes
 * remaining to be unpacked as the bin claims to need, so it's not possible to cause an arbitrarily
 * large allocation unless the input array was already that large.
 */
non_null() bool bin_unpack_bin(Bin_Unpack *bu, uint8_t **data_ptr, uint32_t *data_length_ptr);
/** @brief Unpack a MessagePack bin of a fixed length into a pre-allocated byte array.
 *
 * Unlike the function above, this function does not allocate any memory, but requires the size to
 * be known up front.
 */
non_null() bool bin_unpack_bin_fixed(Bin_Unpack *bu, uint8_t *data, uint32_t data_length);

/** @brief Start unpacking a custom binary representation.
 *
 * A call to this function must be followed by exactly `size` bytes packed by functions below.
 */
non_null() bool bin_unpack_bin_size(Bin_Unpack *bu, uint32_t *size);

/** @brief Read a `uint8_t` directly from the unpacker, consuming 1 byte. */
non_null() bool bin_unpack_u08_b(Bin_Unpack *bu, uint8_t *val);
/** @brief Read a `uint16_t` as big endian 16 bit int, consuming 2 bytes. */
non_null() bool bin_unpack_u16_b(Bin_Unpack *bu, uint16_t *val);
/** @brief Read a `uint32_t` as big endian 32 bit int, consuming 4 bytes. */
non_null() bool bin_unpack_u32_b(Bin_Unpack *bu, uint32_t *val);
/** @brief Read a `uint64_t` as big endian 64 bit int, consuming 8 bytes. */
non_null() bool bin_unpack_u64_b(Bin_Unpack *bu, uint64_t *val);

/** @brief Read a byte array directly from the packer, consuming `length` bytes. */
non_null() bool bin_unpack_bin_b(Bin_Unpack *bu, uint8_t *data, uint32_t length);

#ifdef __cplusplus
}  // extern "C"
#endif

#endif  // C_TOXCORE_TOXCORE_BIN_UNPACK_H
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2021 The TokTok team.
 * Copyright © 2013 Tox project.
 */

#ifndef C_TOXCORE_TOXENCRYPTSAVE_DEFINES_H
#define C_TOXCORE_TOXENCRYPTSAVE_DEFINES_H

#define TOX_ENC_SAVE_MAGIC_NUMBER ((const uint8_t *)"toxEsave")
#define TOX_ENC_SAVE_MAGIC_LENGTH 8

#endif
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2018 The TokTok team.
 * Copyright © 2013-2016 Tox Developers.
 */

/**
 * Batch encryption functions.
 */

#ifndef C_TOXCORE_TOXENCRYPTSAVE_TOXENCRYPTSAVE_H
#define C_TOXCORE_TOXENCRYPTSAVE_TOXENCRYPTSAVE_H

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>


#ifdef __cplusplus
extern "C" {
#endif

/*******************************************************************************
 *
 * This module is organized into two parts.
 *
 * 1. A simple API operating on plain text/cipher text data and a password to
 *    encrypt or decrypt it.
 * 2. A more advanced API that splits key derivation and encryption into two
 *    separate function calls.
 *
 * The first part is implemented in terms of the second part and simply calls
 * the separate functions in sequence. Since key derivation is very expensive
 * compared to the actual encryption, clients that do a lot of crypto should
 * prefer the advanced API and reuse pass-key objects.
 *
 * To use the second part, first derive an encryption key from a password with
 * tox_pass_key_derive, then use the derived key to encrypt the data.
 *
 * The encrypted data is prepended with a magic number, to aid validity
 * checking (no guarantees are made of course). Any data to be decrypted must
 * start with the magic number.
 *
 * Clients should consider alerting their users that, unlike plain data, if
 * even one bit becomes corrupted, the data will be entirely unrecoverable.
 * Ditto if they forget their password, there is no way to recover the data.
 *
 ******************************************************************************/



/**
 * The size of the salt part of a pass-key.
 */
#define TOX_PASS_SALT_LENGTH           32

uint32_t tox_pass_salt_length(void);

/**
 * The size of the key part of a pass-key.
 */
#define TOX_PASS_KEY_LENGTH            32

uint32_t tox_pass_key_length(void);

/**
 * The amount of additional data required to store any encrypted byte array.
 * Encrypting an array of N bytes requires N + TOX_PASS_ENCRYPTION_EXTRA_LENGTH
 * bytes in the encrypted byte array.
 */
#define TOX_PASS_ENCRYPTION_EXTRA_LENGTH 80

uint32_t tox_pass_encryption_extra_length(void);

typedef enum Tox_Err_Key_Derivation {

    /**
     * The function returned successfully.
     */
    TOX_ERR_KEY_DERIVATION_OK,

    /**
     * One of the arguments to the function was NULL when it was not expected.
     */
    TOX_ERR_KEY_DERIVATION_NULL,

    /**
     * The crypto lib was unable to derive a key from the given passphrase,
     * which is usually a lack of memory issue.
     */
    TOX_ERR_KEY_DERIVATION_FAILED,

} Tox_Err_Key_Derivation;


typedef enum Tox_Err_Encryption {

    /**
     * The function returned successfully.
     */
    TOX_ERR_ENCRYPTION_OK,

    /**
     * One of the arguments to the function was NULL when it was not expected.
     */
    TOX_ERR_ENCRYPTION_NULL,

    /**
     * The crypto lib was unable to derive a key from the given passphrase,
     * which is usually a lack of memory issue. The functions accepting keys
     * do not produce this error.
     */
    TOX_ERR_ENCRYPTION_KEY_DERIVATION_FAILED,

    /**
     * The encryption itself failed.
     */
    TOX_ERR_ENCRYPTION_FAILED,

} Tox_Err_Encryption;


typedef enum Tox_Err_Decryption {

    /**
     * The function returned successfully.
     */
    TOX_ERR_DECRYPTION_OK,

    /**
     * One of the arguments to the function was NULL when it was not expected.
     */
    TOX_ERR_DECRYPTION_NULL,

    /**
     * The input data was shorter than TOX_PASS_ENCRYPTION_EXTRA_LENGTH bytes
     */
    TOX_ERR_DECRYPTION_INVALID_LENGTH,

    /**
     * The input data is missing the magic number (i.e. wasn't created by this
     * module, or is corrupted).
     */
    TOX_ERR_DECRYPTION_BAD_FORMAT,

    /**
     * The crypto lib was unable to derive a key from the given passphrase,
     * which is usually a lack of memory issue. The functions accepting keys
     * do not produce this error.
     */
    TOX_ERR_DECRYPTION_KEY_DERIVATION_FAILED,

    /**
     * The encrypted byte array could not be decrypted. Either the data was
     * corrupted or the password/key was incorrect.
     */
    TOX_ERR_DECRYPTION_FAILED,

} Tox_Err_Decryption;



/*******************************************************************************
 *
 *                                BEGIN PART 1
 *
 * The simple API is presented first. If your code spends too much time using
 * these functions, consider using the advanced functions instead and caching
 * the generated pass-key.
 *
 ******************************************************************************/



/**
 * Encrypts the given data with the given passphrase.
 *
 * The output array must be at least `plaintext_len + TOX_PASS_ENCRYPTION_EXTRA_LENGTH`
 * bytes long. This delegates to tox_pass_key_derive and
 * tox_pass_key_encrypt.
 *
 * @param plaintext A byte array of length `plaintext_len`.
 * @param plaintext_len The length of the plain text array. Bigger than 0.
 * @param passphrase The user-provided password. Can be empty.
 * @param passphrase_len The length of the password.
 * @param ciphertext The cipher text array to write the encrypted data to.
 *
 * @return true on success.
 */
bool tox_pass_encrypt(const uint8_t *plaintext, size_t plaintext_len, const uint8_t *passphrase, size_t passphrase_len,
                      uint8_t *ciphertext, Tox_Err_Encryption *error);

/**
 * Decrypts the given data with the given passphrase.
 *
 * The output array must be at least `ciphertext_len - TOX_PASS_ENCRYPTION_EXTRA_LENGTH`
 * bytes long. This delegates to tox_pass_key_decrypt.
 *
 * @param ciphertext A byte array of length `ciphertext_len`.
 * @param ciphertext_len The length of the cipher text array. At least TOX_PASS_ENCRYPTION_EXTRA_LENGTH.
 * @param passphrase The user-provided password. Can be empty.
 * @param passphrase_len The length of the password.
 * @param plaintext The plain text array to write the decrypted data to.
 *
 * @return true on success.
 */
bool tox_pass_decrypt(const uint8_t *ciphertext, size_t ciphertext_len, const uint8_t *passphrase,
                      size_t passphrase_len, uint8_t *plaintext, Tox_Err_Decryption *error);


/*******************************************************************************
 *
 *                                BEGIN PART 2
 *
 * And now part 2, which does the actual encryption, and can be used to write
 * less CPU intensive client code than part one.
 *
 ******************************************************************************/



/**
 * This type represents a pass-key.
 *
 * A pass-key and a password are two different concepts: a password is given
 * by the user in plain text. A pass-key is the generated symmetric key used
 * for encryption and decryption. It is derived from a salt and the
 * user-provided password.
 *
 * The Tox_Pass_Key structure is hidden in the implementation. It can be created
 * using tox_pass_key_derive or tox_pass_key_derive_with_salt and must be deallocated using tox_pass_key_free.
 */
#ifndef TOX_PASS_KEY_DEFINED
#define TOX_PASS_KEY_DEFINED
typedef struct Tox_Pass_Key Tox_Pass_Key;
#endif /* TOX_PASS_KEY_DEFINED */

/**
 * Deallocate a Tox_Pass_Key. This function behaves like `free()`, so NULL is an
 * acceptable argument value.
 */
void tox_pass_key_free(Tox_Pass_Key *key);

/**
 * Generates a secret symmetric key from the given passphrase.
 *
 * Be sure to not compromise the key! Only keep it in memory, do not write
 * it to disk.
 *
 * Note that this function is not deterministic; to derive the same key from
 * a password, you also must know the random salt that was used. A
 * deterministic version of this function is `tox_pass_key_derive_with_salt`.
 *
 * @param passphrase The user-provided password. Can be empty.
 * @param passphrase_len The length of the password.
 *
 * @return new symmetric key on success, NULL on failure.
 */
Tox_Pass_Key *tox_pass_key_derive(const uint8_t *passphrase, size_t passphrase_len,
        Tox_Err_Key_Derivation *error);

/**
 * Same as above, except use the given salt for deterministic key derivation.
 *
 * @param passphrase The user-provided password. Can be empty.
 * @param passphrase_len The length of the password.
 * @param salt An array of at least TOX_PASS_SALT_LENGTH bytes.
 *
 * @return new symmetric key on success, NULL on failure.
 */
Tox_Pass_Key *tox_pass_key_derive_with_salt(const uint8_t *passphrase, size_t passphrase_len,
        const uint8_t *salt, Tox_Err_Key_Derivation *error);

/**
 * Encrypt a plain text with a key produced by tox_pass_key_derive or tox_pass_key_derive_with_salt.
 *
 * The output array must be at least `plaintext_len + TOX_PASS_ENCRYPTION_EXTRA_LENGTH`
 * bytes long.
 *
 * @param plaintext A byte array of length `plaintext_len`.
 * @param plaintext_len The length of the plain text array. Bigger than 0.
 * @param ciphertext The cipher text array to write the encrypted data to.
 *
 * @return true on success.
 */
bool tox_pass_key_encrypt(const Tox_Pass_Key *key, const uint8_t *plaintext, size_t plaintext_len,
                          uint8_t *ciphertext, Tox_Err_Encryption *error);

/**
 * This is the inverse of tox_pass_key_encrypt, also using only keys produced by
 * tox_pass_key_derive or tox_pass_key_derive_with_salt.
 *
 * @param ciphertext A byte array of length `ciphertext_len`.
 * @param ciphertext_len The length of the cipher text array. At least TOX_PASS_ENCRYPTION_EXTRA_LENGTH.
 * @param plaintext The plain text array to write the decrypted data to.
 *
 * @return true on success.
 */
bool tox_pass_key_decrypt(const Tox_Pass_Key *key, const uint8_t *ciphertext, size_t ciphertext_len,
                          uint8_t *plaintext, Tox_Err_Decryption *error);

typedef enum Tox_Err_Get_Salt {

    /**
     * The function returned successfully.
     */
    TOX_ERR_GET_SALT_OK,

    /**
     * One of the arguments to the function was NULL when it was not expected.
     */
    TOX_ERR_GET_SALT_NULL,

    /**
     * The input data is missing the magic number (i.e. wasn't created by this
     * module, or is corrupted).
     */
    TOX_ERR_GET_SALT_BAD_FORMAT,

} Tox_Err_Get_Salt;


/**
 * Retrieves the salt used to encrypt the given data.
 *
 * The retrieved salt can then be passed to tox_pass_key_derive_with_salt to
 * produce the same key as was previously used. Any data encrypted with this
 * module can be used as input.
 *
 * The cipher text must be at least TOX_PASS_ENCRYPTION_EXTRA_LENGTH bytes in length.
 * The salt must be TOX_PASS_SALT_LENGTH bytes in length.
 * If the passed byte arrays are smaller than required, the behaviour is
 * undefined.
 *
 * If the cipher text pointer or the salt is NULL, this function returns false.
 *
 * Success does not say anything about the validity of the data, only that
 * data of the appropriate size was copied.
 *
 * @return true on success.
 */
bool tox_get_salt(const uint8_t *ciphertext, uint8_t *salt, Tox_Err_Get_Salt *error);

/**
 * Determines whether or not the given data is encrypted by this module.
 *
 * It does this check by verifying that the magic number is the one put in
 * place by the encryption functions.
 *
 * The data must be at least TOX_PASS_ENCRYPTION_EXTRA_LENGTH bytes in length.
 * If the passed byte array is smaller than required, the behaviour is
 * undefined.
 *
 * If the data pointer is NULL, the behaviour is undefined
 *
 * @return true if the data is encrypted by this module.
 */
bool tox_is_data_encrypted(const uint8_t *data);


#ifdef __cplusplus
}
#endif

//!TOKSTYLE-

typedef Tox_Err_Key_Derivation TOX_ERR_KEY_DERIVATION;
typedef Tox_Err_Encryption TOX_ERR_ENCRYPTION;
typedef Tox_Err_Decryption TOX_ERR_DECRYPTION;
typedef Tox_Err_Get_Salt TOX_ERR_GET_SALT;

//!TOKSTYLE+

#endif // C_TOXCORE_TOXENCRYPTSAVE_TOXENCRYPTSAVE_H
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2018 The TokTok team.
 * Copyright © 2013 Tox project.
 */

/** @file
 * @brief Public core API for Tox clients.
 *
 * Every function that can fail takes a function-specific error code pointer
 * that can be used to diagnose problems with the Tox state or the function
 * arguments. The error code pointer can be NULL, which does not influence the
 * function's behaviour, but can be done if the reason for failure is irrelevant
 * to the client.
 *
 * The exception to this rule are simple allocation functions whose only failure
 * mode is allocation failure. They return NULL in that case, and do not set an
 * error code.
 *
 * Every error code type has an OK value to which functions will set their error
 * code value on success. Clients can keep their error code uninitialised before
 * passing it to a function. The library guarantees that after returning, the
 * value pointed to by the error code pointer has been initialised.
 *
 * Functions with pointer parameters often have a NULL error code, meaning they
 * could not perform any operation, because one of the required parameters was
 * NULL. Some functions operate correctly or are defined as effectless on NULL.
 *
 * Some functions additionally return a value outside their
 * return type domain, or a bool containing true on success and false on
 * failure.
 *
 * All functions that take a Tox instance pointer will cause undefined behaviour
 * when passed a NULL Tox pointer.
 *
 * All integer values are expected in host byte order.
 *
 * Functions with parameters with enum types cause unspecified behaviour if the
 * enumeration value is outside the valid range of the type. If possible, the
 * function will try to use a sane default, but there will be no error code,
 * and one possible action for the function to take is to have no effect.
 *
 * Integer constants and the memory layout of publicly exposed structs are not
 * part of the ABI.
 *
 * @section events Events and callbacks
 *
 * Events are handled by callbacks. One callback can be registered per event.
 * All events have a callback function type named `tox_{event}_cb` and a
 * function to register it named `tox_callback_{event}`. Passing a NULL
 * callback will result in no callback being registered for that event. Only
 * one callback per event can be registered, so if a client needs multiple
 * event listeners, it needs to implement the dispatch functionality itself.
 *
 * The last argument to a callback is the user data pointer. It is passed from
 * tox_iterate to each callback in sequence.
 *
 * The user data pointer is never stored or dereferenced by any library code, so
 * can be any pointer, including NULL. Callbacks must all operate on the same
 * object type. In the apidsl code (tox.in.h), this is denoted with `any`. The
 * `any` in tox_iterate must be the same `any` as in all callbacks. In C,
 * lacking parametric polymorphism, this is a pointer to void.
 *
 * Old style callbacks that are registered together with a user data pointer
 * receive that pointer as argument when they are called. They can each have
 * their own user data pointer of their own type.
 *
 * @section threading Threading implications
 *
 * It is possible to run multiple concurrent threads with a Tox instance for
 * each thread. It is also possible to run all Tox instances in the same thread.
 * A common way to run Tox (multiple or single instance) is to have one thread
 * running a simple tox_iterate loop, sleeping for tox_iteration_interval
 * milliseconds on each iteration.
 *
 * If you want to access a single Tox instance from multiple threads, access
 * to the instance must be synchronised. While multiple threads can concurrently
 * access multiple different Tox instances, no more than one API function can
 * operate on a single instance at any given time.
 *
 * Functions that write to variable length byte arrays will always have a size
 * function associated with them. The result of this size function is only valid
 * until another mutating function (one that takes a pointer to non-const Tox)
 * is called. Thus, clients must ensure that no other thread calls a mutating
 * function between the call to the size function and the call to the retrieval
 * function.
 *
 * E.g. to get the current nickname, one would write
 *
 * @code
 * size_t length = tox_self_get_name_size(tox);
 * uint8_t *name = malloc(length);
 * if (!name) abort();
 * tox_self_get_name(tox, name);
 * @endcode
 *
 * If any other thread calls tox_self_set_name while this thread is allocating
 * memory, the length may have become invalid, and the call to
 * tox_self_get_name may cause undefined behaviour.
 */
#ifndef C_TOXCORE_TOXCORE_TOX_H
#define C_TOXCORE_TOXCORE_TOX_H

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>

#ifdef __cplusplus
extern "C" {
#endif

/** @{ @namespace tox */

#ifndef TOX_DEFINED
#define TOX_DEFINED
/**
 * @brief The Tox instance type.
 *
 * All the state associated with a connection is held
 * within the instance. Multiple instances can exist and operate concurrently.
 * The maximum number of Tox instances that can exist on a single network
 * device is limited. Note that this is not just a per-process limit, since the
 * limiting factor is the number of usable ports on a device.
 */
typedef struct Tox Tox;
#endif /* TOX_DEFINED */


/** @{
 * @name API version
 */

/**
 * @brief The major version number.
 *
 * Incremented when the API or ABI changes in an incompatible way.
 *
 * The function variants of these constants return the version number of the
 * library. They can be used to display the Tox library version or to check
 * whether the client is compatible with the dynamically linked version of Tox.
 */
#define TOX_VERSION_MAJOR              0

uint32_t tox_version_major(void);

/**
 * @brief The minor version number.
 *
 * Incremented when functionality is added without  breaking the API or ABI.
 * Set to 0 when the major version number is incremented.
 */
#define TOX_VERSION_MINOR              2

uint32_t tox_version_minor(void);

/**
 * @brief The patch or revision number.
 *
 * Incremented when bugfixes are applied without changing any functionality or
 * API or ABI.
 */
#define TOX_VERSION_PATCH              19

uint32_t tox_version_patch(void);

#define TOX_HAVE_TOXUTIL               1

#define TOX_HAVE_TOXAV_CALLBACKS_002   1

#define TOX_GIT_COMMIT_HASH "00000004"


//!TOKSTYLE-
/**
 * @brief A macro to check at preprocessing time whether the client code is
 *   compatible with the installed version of Tox.
 *
 * Leading zeros in the version number are  ignored. E.g. 0.1.5 is to 0.1.4
 * what 1.5 is to 1.4, that is: it can add new features, but can't break the
 * API.
 */
#define TOX_VERSION_IS_API_COMPATIBLE(MAJOR, MINOR, PATCH)              \
  ((TOX_VERSION_MAJOR > 0 && TOX_VERSION_MAJOR == MAJOR) && (           \
    /* 1.x.x, 2.x.x, etc. with matching major version. */               \
    TOX_VERSION_MINOR > MINOR ||                                        \
    (TOX_VERSION_MINOR == MINOR && TOX_VERSION_PATCH >= PATCH)          \
  )) || ((TOX_VERSION_MAJOR == 0 && MAJOR == 0) && (                    \
    /* 0.x.x makes minor behave like major above. */                    \
    ((TOX_VERSION_MINOR > 0 && TOX_VERSION_MINOR == MINOR) && (         \
      TOX_VERSION_PATCH >= PATCH                                        \
    )) || ((TOX_VERSION_MINOR == 0 && MINOR == 0) && (                  \
      /* 0.0.x and 0.0.y are only compatible if x == y. */              \
      TOX_VERSION_PATCH == PATCH                                        \
    ))                                                                  \
  ))
//!TOKSTYLE+

/**
 * @brief Return whether the compiled library version is compatible with the
 *   passed version numbers.
 */
bool tox_version_is_compatible(uint32_t major, uint32_t minor, uint32_t patch);

/**
 * @brief A convenience macro to call tox_version_is_compatible with the
 *   currently compiling API version.
 */
#define TOX_VERSION_IS_ABI_COMPATIBLE()                         \
  tox_version_is_compatible(TOX_VERSION_MAJOR, TOX_VERSION_MINOR, TOX_VERSION_PATCH)

/** @} */


/** @{
 * @name Numeric constants
 *
 * The values of these are not part of the ABI. Prefer to use the function
 * versions of them for code that should remain compatible with future versions
 * of toxcore.
 */

/**
 * @brief The size of a Tox Public Key in bytes.
 */
#define TOX_PUBLIC_KEY_SIZE            32

uint32_t tox_public_key_size(void);

/**
 * @brief The size of a Tox Secret Key in bytes.
 */
#define TOX_SECRET_KEY_SIZE            32

uint32_t tox_secret_key_size(void);

/**
 * @brief The size of a Tox Conference unique id in bytes.
 *
 * @deprecated Use TOX_CONFERENCE_ID_SIZE instead.
 */
#define TOX_CONFERENCE_UID_SIZE        32

uint32_t tox_conference_uid_size(void);

/**
 * @brief The size of a Tox Conference unique id in bytes.
 */
#define TOX_CONFERENCE_ID_SIZE         32

uint32_t tox_conference_id_size(void);

/**
 * @brief The size of the nospam in bytes when written in a Tox address.
 */
#define TOX_NOSPAM_SIZE                (sizeof(uint32_t))

uint32_t tox_nospam_size(void);

/**
 * @brief The size of a Tox address in bytes.
 *
 * Tox addresses are in the format
 * `[Public Key (TOX_PUBLIC_KEY_SIZE bytes)][nospam (4 bytes)][checksum (2 bytes)]`.
 *
 * The checksum is computed over the Public Key and the nospam value. The first
 * byte is an XOR of all the even bytes (0, 2, 4, ...), the second byte is an
 * XOR of all the odd bytes (1, 3, 5, ...) of the Public Key and nospam.
 */
#define TOX_ADDRESS_SIZE               (TOX_PUBLIC_KEY_SIZE + TOX_NOSPAM_SIZE + sizeof(uint16_t))

uint32_t tox_address_size(void);

/**
 * @brief Maximum length of a nickname in bytes.
 *
 * @deprecated The macro will be removed in 0.3.0. Use the function instead.
 */
#define TOX_MAX_NAME_LENGTH            128

uint32_t tox_max_name_length(void);

/**
 * @brief Maximum length of a status message in bytes.
 *
 * @deprecated The macro will be removed in 0.3.0. Use the function instead.
 */
#define TOX_MAX_STATUS_MESSAGE_LENGTH  1007

uint32_t tox_max_status_message_length(void);

/**
 * @brief Maximum length of a friend request message in bytes.
 *
 * @deprecated The macro will be removed in 0.3.0. Use the function instead.
 */
#define TOX_MAX_FRIEND_REQUEST_LENGTH  1016

uint32_t tox_max_friend_request_length(void);

/**
 * @brief Maximum length of a single message after which it should be split.
 *
 * @deprecated The macro will be removed in 0.3.0. Use the function instead.
 */
#define TOX_MAX_MESSAGE_LENGTH         1372

uint32_t tox_max_message_length(void);


#define TOX_MSGV3_MSGID_LENGTH         32
#define TOX_MSGV3_TIMESTAMP_LENGTH     4
#define TOX_MSGV3_GUARD                2
#define TOX_MSGV3_MAX_MESSAGE_LENGTH   (TOX_MAX_MESSAGE_LENGTH - TOX_MSGV3_MSGID_LENGTH - TOX_MSGV3_TIMESTAMP_LENGTH - TOX_MSGV3_GUARD)


/**
 * @brief Maximum size of custom packets. TODO(iphydf): should be LENGTH?
 *
 * @deprecated The macro will be removed in 0.3.0. Use the function instead.
 */
#define TOX_MAX_CUSTOM_PACKET_SIZE     1373

uint32_t tox_max_custom_packet_size(void);

/**
 * Maximum size of MessageV2 Messagetext
 */
#define TOX_MESSAGEV2_MAX_TEXT_LENGTH  4096

uint32_t tox_messagev2_max_text_length(void);

/**
 * Maximum size of MessageV2 Header
 */
#define TOX_MESSAGEV2_MAX_HEADER_SIZE  (TOX_PUBLIC_KEY_SIZE + 4 + 2 + TOX_PUBLIC_KEY_SIZE + 4)

uint32_t tox_messagev2_max_header_size(void);

/**
 * Maximum size of MessageV2 Header of non sync messages
 */
#define TOX_MESSAGEV2_MAX_NON_SYNC_HEADER_SIZE  (TOX_PUBLIC_KEY_SIZE + 4 + 2 + 1 + TOX_PUBLIC_KEY_SIZE)

/**
 * Maximum size of MessageV2 Filetransfers (overall size including any overhead)
 */
#define TOX_MAX_FILETRANSFER_SIZE_MSGV2 (TOX_MESSAGEV2_MAX_TEXT_LENGTH + TOX_MESSAGEV2_MAX_HEADER_SIZE + TOX_MESSAGEV2_MAX_NON_SYNC_HEADER_SIZE)

uint32_t tox_max_filetransfer_size_msgv2(void);

/**
 * @brief The number of bytes in a hash generated by tox_hash.
 */
#define TOX_HASH_LENGTH                32

uint32_t tox_hash_length(void);

/**
 * @brief The number of bytes in a file id.
 */
#define TOX_FILE_ID_LENGTH             32

uint32_t tox_file_id_length(void);

/**
 * @brief Maximum file name length for file transfers.
 *
 * @deprecated The macro will be removed in 0.3.0. Use the function instead.
 */
#define TOX_MAX_FILENAME_LENGTH        255

uint32_t tox_max_filename_length(void);

/**
 * @brief Maximum length of a hostname, e.g. proxy or bootstrap node names.
 *
 * This length does not include the NUL byte. Hostnames are NUL-terminated C
 * strings, so they are 255 characters plus one NUL byte.
 *
 * @deprecated The macro will be removed in 0.3.0. Use the function instead.
 */
#define TOX_MAX_HOSTNAME_LENGTH        255

uint32_t tox_max_hostname_length(void);

/** @} */

void tox_set_force_udp_only_mode(bool value);
void tox_set_do_not_sync_av(bool value);
void tox_set_onion_active(bool value);

/** @{
 * @name Global enumerations
 */

/**
 * @brief Represents the possible statuses a client can have.
 */
typedef enum Tox_User_Status {

    /**
     * User is online and available.
     */
    TOX_USER_STATUS_NONE,

    /**
     * User is away. Clients can set this e.g. after a user defined
     * inactivity time.
     */
    TOX_USER_STATUS_AWAY,

    /**
     * User is busy. Signals to other clients that this client does not
     * currently wish to communicate.
     */
    TOX_USER_STATUS_BUSY,

} Tox_User_Status;


/**
 * @brief Represents message types for tox_friend_send_message and conference
 *   messages.
 */
typedef enum Tox_Message_Type {

    /**
     * Normal text message. Similar to PRIVMSG on IRC.
     */
    TOX_MESSAGE_TYPE_NORMAL,

    /**
     * A message describing an user action. This is similar to /me (CTCP ACTION)
     * on IRC.
     */
    TOX_MESSAGE_TYPE_ACTION,

    /**
     * A high level ACK for MSG ID (MSG V3 functionality)
     */
    TOX_MESSAGE_TYPE_HIGH_LEVEL_ACK = 2,

} Tox_Message_Type;

/** @} */


/** @{
 * @name Startup options
 */

/**
 * @brief Type of proxy used to connect to TCP relays.
 */
typedef enum Tox_Proxy_Type {

    /**
     * Don't use a proxy.
     */
    TOX_PROXY_TYPE_NONE,

    /**
     * HTTP proxy using CONNECT.
     */
    TOX_PROXY_TYPE_HTTP,

    /**
     * SOCKS proxy for simple socket pipes.
     */
    TOX_PROXY_TYPE_SOCKS5,

} Tox_Proxy_Type;


/**
 * @brief Type of savedata to create the Tox instance from.
 */
typedef enum Tox_Savedata_Type {

    /**
     * No savedata.
     */
    TOX_SAVEDATA_TYPE_NONE,

    /**
     * Savedata is one that was obtained from tox_get_savedata.
     */
    TOX_SAVEDATA_TYPE_TOX_SAVE,

    /**
     * Savedata is a secret key of length TOX_SECRET_KEY_SIZE.
     */
    TOX_SAVEDATA_TYPE_SECRET_KEY,

} Tox_Savedata_Type;


/**
 * @brief Severity level of log messages.
 */
typedef enum Tox_Log_Level {

    /**
     * Very detailed traces including all network activity.
     */
    TOX_LOG_LEVEL_TRACE,

    /**
     * Debug messages such as which port we bind to.
     */
    TOX_LOG_LEVEL_DEBUG,

    /**
     * Informational log messages such as video call status changes.
     */
    TOX_LOG_LEVEL_INFO,

    /**
     * Warnings about events_alloc inconsistency or logic errors.
     */
    TOX_LOG_LEVEL_WARNING,

    /**
     * Severe unexpected errors caused by external or events_alloc inconsistency.
     */
    TOX_LOG_LEVEL_ERROR,

} Tox_Log_Level;


/**
 * @brief This event is triggered when the toxcore library logs an events_alloc message.
 *
 * This is mostly useful for debugging. This callback can be called from any
 * function, not just tox_iterate. This means the user data lifetime must at
 * least extend between registering and unregistering it or tox_kill.
 *
 * Other toxcore modules such as toxav may concurrently call this callback at
 * any time. Thus, user code must make sure it is equipped to handle concurrent
 * execution, e.g. by employing appropriate mutex locking.
 *
 * @param level The severity of the log message.
 * @param file The source file from which the message originated.
 * @param line The source line from which the message originated.
 * @param func The function from which the message originated.
 * @param message The log message.
 * @param user_data The user data pointer passed to tox_new in options.
 */
typedef void tox_log_cb(Tox *tox, Tox_Log_Level level, const char *file, uint32_t line, const char *func,
                        const char *message, void *user_data);


/**
 * @brief Operating system functions used by Tox.
 *
 * This struct is opaque and generally shouldn't be used in clients, but in
 * combination with tox_private.h, it allows tests to inject non-IO (hermetic)
 * versions of low level network, RNG, and time keeping functions.
 */
typedef struct Tox_System Tox_System;


/**
 * @brief This struct contains all the startup options for Tox.
 *
 * You must tox_options_new to allocate an object of this type.
 *
 * WARNING: Although this struct happens to be visible in the API, it is
 * effectively private. Do not allocate this yourself or access members
 * directly, as it *will* break binary compatibility frequently.
 *
 * @deprecated The memory layout of this struct (size, alignment, and field
 *   order) is not part of the ABI. To remain compatible, prefer to use
 *   tox_options_new to allocate the object and accessor functions to set the
 *   members. The struct will become opaque (i.e. the definition will become
 *   private) in v0.3.0.
 */
struct Tox_Options {

    /**
     * The type of socket to create.
     *
     * If this is set to false, an IPv4 socket is created, which subsequently
     * only allows IPv4 communication.
     * If it is set to true, an IPv6 socket is created, allowing both IPv4 and
     * IPv6 communication.
     */
    bool ipv6_enabled;


    /**
     * Enable the use of UDP communication when available.
     *
     * Setting this to false will force Tox to use TCP only. Communications will
     * need to be relayed through a TCP relay node, potentially slowing them down.
     *
     * If a proxy is enabled, UDP will be disabled if either toxcore or the
     * proxy don't support proxying UDP messages.
     */
    bool udp_enabled;


    /**
     * Enable local network peer discovery.
     *
     * Disabling this will cause Tox to not look for peers on the local network.
     */
    bool local_discovery_enabled;


    /**
     * Enable storing DHT announcements and forwarding corresponding requests.
     *
     * Disabling this will cause Tox to ignore the relevant packets.
     */
    bool dht_announcements_enabled;

    /**
     * Pass communications through a proxy.
     */
    Tox_Proxy_Type proxy_type;


    /**
     * The IP address or DNS name of the proxy to be used.
     *
     * If used, this must be non-NULL and be a valid DNS name. The name must not
     * exceed TOX_MAX_HOSTNAME_LENGTH characters, and be in a NUL-terminated C string
     * format (TOX_MAX_HOSTNAME_LENGTH includes the NUL byte).
     *
     * This member is ignored (it can be NULL) if proxy_type is TOX_PROXY_TYPE_NONE.
     *
     * The data pointed at by this member is owned by the user, so must
     * outlive the options object.
     */
    const char *proxy_host;


    /**
     * The port to use to connect to the proxy server.
     *
     * Ports must be in the range (1, 65535). The value is ignored if
     * proxy_type is TOX_PROXY_TYPE_NONE.
     */
    uint16_t proxy_port;


    /**
     * The start port of the inclusive port range to attempt to use.
     *
     * If both start_port and end_port are 0, the default port range will be
     * used: `[33445, 33545]`.
     *
     * If either start_port or end_port is 0 while the other is non-zero, the
     * non-zero port will be the only port in the range.
     *
     * Having start_port > end_port will yield the same behavior as if start_port
     * and end_port were swapped.
     */
    uint16_t start_port;


    /**
     * The end port of the inclusive port range to attempt to use.
     */
    uint16_t end_port;


    /**
     * The port to use for the TCP server (relay). If 0, the TCP server is
     * disabled.
     *
     * Enabling it is not required for Tox to function properly.
     *
     * When enabled, your Tox instance can act as a TCP relay for other Tox
     * instance. This leads to increased traffic, thus when writing a client
     * it is recommended to enable TCP server only if the user has an option
     * to disable it.
     */
    uint16_t tcp_port;


    /**
     * Enables or disables UDP hole-punching in toxcore. (Default: enabled).
     */
    bool hole_punching_enabled;


    /**
     * The type of savedata to load from.
     */
    Tox_Savedata_Type savedata_type;


    /**
     * The savedata.
     *
     * The data pointed at by this member is owned by the user, so must
     * outlive the options object.
     */
    const uint8_t *savedata_data;


    /**
     * The length of the savedata.
     */
    size_t savedata_length;


    /**
     * Logging callback for the new tox instance.
     */
    tox_log_cb *log_callback;


    /**
     * User data pointer passed to the logging callback.
     */
    void *log_user_data;


    /**
     * These options are experimental, so avoid writing code that depends on
     * them. Options marked "experimental" may change their behaviour or go away
     * entirely in the future, or may be renamed to something non-experimental
     * if they become part of the supported API.
     */
    /**
     * Make public API functions thread-safe using a per-instance lock.
     *
     * Default: false.
     */
    bool experimental_thread_safety;

    /**
     * Low level operating system functionality such as send/recv and random
     * number generation.
     */
    const Tox_System *operating_system;

};


bool tox_options_get_ipv6_enabled(const struct Tox_Options *options);

void tox_options_set_ipv6_enabled(struct Tox_Options *options, bool ipv6_enabled);

bool tox_options_get_udp_enabled(const struct Tox_Options *options);

void tox_options_set_udp_enabled(struct Tox_Options *options, bool udp_enabled);

bool tox_options_get_local_discovery_enabled(const struct Tox_Options *options);

void tox_options_set_local_discovery_enabled(struct Tox_Options *options, bool local_discovery_enabled);

bool tox_options_get_dht_announcements_enabled(const struct Tox_Options *options);

void tox_options_set_dht_announcements_enabled(struct Tox_Options *options, bool dht_announcements_enabled);

Tox_Proxy_Type tox_options_get_proxy_type(const struct Tox_Options *options);

void tox_options_set_proxy_type(struct Tox_Options *options, Tox_Proxy_Type type);

const char *tox_options_get_proxy_host(const struct Tox_Options *options);

void tox_options_set_proxy_host(struct Tox_Options *options, const char *host);

uint16_t tox_options_get_proxy_port(const struct Tox_Options *options);

void tox_options_set_proxy_port(struct Tox_Options *options, uint16_t port);

uint16_t tox_options_get_start_port(const struct Tox_Options *options);

void tox_options_set_start_port(struct Tox_Options *options, uint16_t start_port);

uint16_t tox_options_get_end_port(const struct Tox_Options *options);

void tox_options_set_end_port(struct Tox_Options *options, uint16_t end_port);

uint16_t tox_options_get_tcp_port(const struct Tox_Options *options);

void tox_options_set_tcp_port(struct Tox_Options *options, uint16_t tcp_port);

bool tox_options_get_hole_punching_enabled(const struct Tox_Options *options);

void tox_options_set_hole_punching_enabled(struct Tox_Options *options, bool hole_punching_enabled);

Tox_Savedata_Type tox_options_get_savedata_type(const struct Tox_Options *options);

void tox_options_set_savedata_type(struct Tox_Options *options, Tox_Savedata_Type type);

const uint8_t *tox_options_get_savedata_data(const struct Tox_Options *options);

void tox_options_set_savedata_data(struct Tox_Options *options, const uint8_t *data, size_t length);

size_t tox_options_get_savedata_length(const struct Tox_Options *options);

void tox_options_set_savedata_length(struct Tox_Options *options, size_t length);

tox_log_cb *tox_options_get_log_callback(const struct Tox_Options *options);

void tox_options_set_log_callback(struct Tox_Options *options, tox_log_cb *callback);

void *tox_options_get_log_user_data(const struct Tox_Options *options);

void tox_options_set_log_user_data(struct Tox_Options *options, void *user_data);

bool tox_options_get_experimental_thread_safety(const struct Tox_Options *options);

void tox_options_set_experimental_thread_safety(struct Tox_Options *options, bool experimental_thread_safety);

const Tox_System *tox_options_get_operating_system(const struct Tox_Options *options);

void tox_options_set_operating_system(struct Tox_Options *options, const Tox_System *operating_system);

/**
 * @brief Initialises a Tox_Options object with the default options.
 *
 * The result of this function is independent of the original options. All
 * values will be overwritten, no values will be read (so it is permissible
 * to pass an uninitialised object).
 *
 * If options is NULL, this function has no effect.
 *
 * @param options An options object to be filled with default options.
 */
void tox_options_default(struct Tox_Options *options);

typedef enum Tox_Err_Options_New {

    /**
     * The function returned successfully.
     */
    TOX_ERR_OPTIONS_NEW_OK,

    /**
     * The function failed to allocate enough memory for the options struct.
     */
    TOX_ERR_OPTIONS_NEW_MALLOC,

} Tox_Err_Options_New;


/**
 * @brief Allocates a new Tox_Options object and initialises it with the default
 *   options.
 *
 * This function can be used to preserve long term ABI compatibility by
 * giving the responsibility of allocation and deallocation to the Tox library.
 *
 * Objects returned from this function must be freed using the tox_options_free
 * function.
 *
 * @return A new Tox_Options object with default options or NULL on failure.
 */
struct Tox_Options *tox_options_new(Tox_Err_Options_New *error);

/**
 * @brief Releases all resources associated with an options objects.
 *
 * Passing a pointer that was not returned by tox_options_new results in
 * undefined behaviour.
 */
void tox_options_free(struct Tox_Options *options);

/** @} */


/** @{
 * @name Creation and destruction
 */

typedef enum Tox_Err_New {

    /**
     * The function returned successfully.
     */
    TOX_ERR_NEW_OK,

    /**
     * One of the arguments to the function was NULL when it was not expected.
     */
    TOX_ERR_NEW_NULL,

    /**
     * The function was unable to allocate enough memory to store the events_alloc
     * structures for the Tox object.
     */
    TOX_ERR_NEW_MALLOC,

    /**
     * The function was unable to bind to a port. This may mean that all ports
     * have already been bound, e.g. by other Tox instances, or it may mean
     * a permission error. You may be able to gather more information from errno.
     */
    TOX_ERR_NEW_PORT_ALLOC,

    /**
     * proxy_type was invalid.
     */
    TOX_ERR_NEW_PROXY_BAD_TYPE,

    /**
     * proxy_type was valid but the proxy_host passed had an invalid format
     * or was NULL.
     */
    TOX_ERR_NEW_PROXY_BAD_HOST,

    /**
     * proxy_type was valid, but the proxy_port was invalid.
     */
    TOX_ERR_NEW_PROXY_BAD_PORT,

    /**
     * The proxy address passed could not be resolved.
     */
    TOX_ERR_NEW_PROXY_NOT_FOUND,

    /**
     * The byte array to be loaded contained an encrypted save.
     */
    TOX_ERR_NEW_LOAD_ENCRYPTED,

    /**
     * The data format was invalid. This can happen when loading data that was
     * saved by an older version of Tox, or when the data has been corrupted.
     * When loading from badly formatted data, some data may have been loaded,
     * and the rest is discarded. Passing an invalid length parameter also
     * causes this error.
     */
    TOX_ERR_NEW_LOAD_BAD_FORMAT,

} Tox_Err_New;


/**
 * @brief Creates and initialises a new Tox instance with the options passed.
 *
 * This function will bring the instance into a valid state. Running the event
 * loop with a new instance will operate correctly.
 *
 * @param options An options object as described above. If this parameter is
 *   NULL, the default options are used.
 *
 * @see tox_iterate for the event loop.
 *
 * @return A new Tox instance pointer on success or NULL on failure.
 */
Tox *tox_new(const struct Tox_Options *options, Tox_Err_New *error);

/**
 * @brief Releases all resources associated with the Tox instance and
 *   disconnects from the network.
 *
 * After calling this function, the Tox pointer becomes invalid. No other
 * functions can be called, and the pointer value can no longer be read.
 */
void tox_kill(Tox *tox);

/**
 * @brief Get a Tox_Options similar to the one used to create the Tox.
 *
 * Initialises the `options` object such that @ref tox_new called with the passed
 * options will recreate the current @ref Tox instance.
 *
 * @param options the options object we want to initialise.
 */
void tox_get_options(Tox *tox, struct Tox_Options *options);

/**
 * @brief Calculates the number of bytes required to store the tox instance with
 *   tox_get_savedata.
 *
 * This function cannot fail. The result is always greater than 0.
 *
 * @see threading for concurrency implications.
 */
size_t tox_get_savedata_size(const Tox *tox);

/**
 * @brief Store all information associated with the tox instance to a byte array.
 *
 * @param savedata A memory region large enough to store the tox instance
 *   data. Call tox_get_savedata_size to find the number of bytes required. If this parameter
 *   is NULL, this function has no effect.
 */
void tox_get_savedata(const Tox *tox, uint8_t *savedata);

/** @} */


/** @{
 * @name Connection lifecycle and event loop
 */

typedef enum Tox_Err_Bootstrap {

    /**
     * The function returned successfully.
     */
    TOX_ERR_BOOTSTRAP_OK,

    /**
     * One of the arguments to the function was NULL when it was not expected.
     */
    TOX_ERR_BOOTSTRAP_NULL,

    /**
     * The hostname could not be resolved to an IP address, the IP address
     * passed was invalid, or the function failed to send the initial request
     * packet to the bootstrap node or TCP relay.
     */
    TOX_ERR_BOOTSTRAP_BAD_HOST,

    /**
     * The port passed was invalid. The valid port range is (1, 65535).
     */
    TOX_ERR_BOOTSTRAP_BAD_PORT,

} Tox_Err_Bootstrap;


/**
 * @brief Sends a "get nodes" request to the given bootstrap node with IP, port,
 *   and public key to setup connections.
 *
 * This function will attempt to connect to the node using UDP. You must use
 * this function even if Tox_Options.udp_enabled was set to false.
 *
 * @param host The hostname or IP address (IPv4 or IPv6) of the node. Must be
 *   at most TOX_MAX_HOSTNAME_LENGTH chars, including the NUL byte.
 * @param port The port on the host on which the bootstrap Tox instance is
 *   listening.
 * @param public_key The long term public key of the bootstrap node
 *   (TOX_PUBLIC_KEY_SIZE bytes).
 * @return true on success.
 */
bool tox_bootstrap(Tox *tox, const char *host, uint16_t port, const uint8_t *public_key, Tox_Err_Bootstrap *error);

/**
 * @brief Adds additional host:port pair as TCP relay.
 *
 * This function can be used to initiate TCP connections to different ports on
 * the same bootstrap node, or to add TCP relays without using them as
 * bootstrap nodes.
 *
 * @param host The hostname or IP address (IPv4 or IPv6) of the TCP relay.
 *   Must be at most TOX_MAX_HOSTNAME_LENGTH chars, including the NUL byte.
 * @param port The port on the host on which the TCP relay is listening.
 * @param public_key The long term public key of the TCP relay
 *   (TOX_PUBLIC_KEY_SIZE bytes).
 * @return true on success.
 */
bool tox_add_tcp_relay(Tox *tox, const char *host, uint16_t port, const uint8_t *public_key, Tox_Err_Bootstrap *error);

/**
 * @brief Protocols that can be used to connect to the network or friends.
 */
typedef enum Tox_Connection {

    /**
     * @brief There is no connection.
     *
     * This instance, or the friend the state change is about, is now offline.
     */
    TOX_CONNECTION_NONE,

    /**
     * @brief A TCP connection has been established.
     *
     * For the own instance, this means it is connected through a TCP relay,
     * only. For a friend, this means that the connection to that particular
     * friend goes through a TCP relay.
     */
    TOX_CONNECTION_TCP,

    /**
     * @brief A UDP connection has been established.
     *
     * For the own instance, this means it is able to send UDP packets to DHT
     * nodes, but may still be connected to a TCP relay. For a friend, this
     * means that the connection to that particular friend was built using
     * direct UDP packets.
     */
    TOX_CONNECTION_UDP,

} Tox_Connection;

/**
 * @brief Return whether we are connected to the DHT.
 *
 * The return value is equal to the last value received through the
 * `self_connection_status` callback.
 *
 * @deprecated This getter is deprecated. Use the event and store the status
 *   in the client state.
 */
Tox_Connection tox_self_get_connection_status(const Tox *tox);

/**
 * @param connection_status Whether we are connected to the DHT.
 */
typedef void tox_self_connection_status_cb(Tox *tox, Tox_Connection connection_status, void *user_data);


/**
 * @brief Set the callback for the `self_connection_status` event.
 *
 * Pass NULL to unset.
 *
 * This event is triggered whenever there is a change in the DHT connection
 * state. When disconnected, a client may choose to call tox_bootstrap again, to
 * reconnect to the DHT. Note that this state may frequently change for short
 * amounts of time. Clients should therefore not immediately bootstrap on
 * receiving a disconnect.
 *
 * TODO(iphydf): how long should a client wait before bootstrapping again?
 */
void tox_callback_self_connection_status(Tox *tox, tox_self_connection_status_cb *callback);

/**
 * @brief Return the time in milliseconds before `tox_iterate()` should be called again
 *   for optimal performance.
 */
uint32_t tox_iteration_interval(const Tox *tox);

/**
 * @brief The main loop that needs to be run in intervals of `tox_iteration_interval()`
 *   milliseconds.
 */
void tox_iterate(Tox *tox, void *user_data);

/** @} */


/** @{
 * @name Internal client information (Tox address/id)
 */

/**
 * @brief Writes the Tox friend address of the client to a byte array.
 *
 * The address is not in human-readable format. If a client wants to display
 * the address, formatting is required.
 *
 * @param address A memory region of at least TOX_ADDRESS_SIZE bytes. If this
 *   parameter is NULL, this function has no effect.
 * @see TOX_ADDRESS_SIZE for the address format.
 */
void tox_self_get_address(const Tox *tox, uint8_t *address);

/**
 * @brief Set the 4-byte nospam part of the address.
 *
 * This value is expected in host byte order. I.e. 0x12345678 will form the
 * bytes `[12, 34, 56, 78]` in the nospam part of the Tox friend address.
 *
 * @param nospam Any 32 bit unsigned integer.
 */
void tox_self_set_nospam(Tox *tox, uint32_t nospam);

/**
 * @brief Get the 4-byte nospam part of the address.
 *
 * This value is returned in host byte order.
 */
uint32_t tox_self_get_nospam(const Tox *tox);

/**
 * @brief Copy the Tox Public Key (long term) from the Tox object.
 *
 * @param public_key A memory region of at least TOX_PUBLIC_KEY_SIZE bytes. If
 *   this parameter is NULL, this function has no effect.
 */
void tox_self_get_public_key(const Tox *tox, uint8_t *public_key);

/**
 * @brief Copy the Tox Secret Key from the Tox object.
 *
 * @param secret_key A memory region of at least TOX_SECRET_KEY_SIZE bytes. If
 *   this parameter is NULL, this function has no effect.
 */
void tox_self_get_secret_key(const Tox *tox, uint8_t *secret_key);

/**
 * Return the capabilities flags for this tox instance.
 */
uint64_t tox_self_get_capabilities(void);
/** @} */


/** @{
 * @name User-visible client information (nickname/status)
 */

/**
 * @brief Common error codes for all functions that set a piece of user-visible
 *   client information.
 */
typedef enum Tox_Err_Set_Info {

    /**
     * The function returned successfully.
     */
    TOX_ERR_SET_INFO_OK,

    /**
     * One of the arguments to the function was NULL when it was not expected.
     */
    TOX_ERR_SET_INFO_NULL,

    /**
     * Information length exceeded maximum permissible size.
     */
    TOX_ERR_SET_INFO_TOO_LONG,

} Tox_Err_Set_Info;


/**
 * @brief Set the nickname for the Tox client.
 *
 * Nickname length cannot exceed TOX_MAX_NAME_LENGTH. If length is 0, the name
 * parameter is ignored (it can be NULL), and the nickname is set back to empty.
 *
 * @param name A byte array containing the new nickname.
 * @param length The size of the name byte array.
 *
 * @return true on success.
 */
bool tox_self_set_name(Tox *tox, const uint8_t *name, size_t length, Tox_Err_Set_Info *error);

/**
 * @brief Return the length of the current nickname as passed to tox_self_set_name.
 *
 * If no nickname was set before calling this function, the name is empty,
 * and this function returns 0.
 *
 * @see threading for concurrency implications.
 */
size_t tox_self_get_name_size(const Tox *tox);

/**
 * @brief Write the nickname set by tox_self_set_name to a byte array.
 *
 * If no nickname was set before calling this function, the name is empty,
 * and this function has no effect.
 *
 * Call tox_self_get_name_size to find out how much memory to allocate for
 * the result.
 *
 * @param name A valid memory location large enough to hold the nickname.
 *   If this parameter is NULL, the function has no effect.
 */
void tox_self_get_name(const Tox *tox, uint8_t *name);

/**
 * Write new message ID to a byte array.
 *
 * @param msg_id A valid memory location at least TOX_HASH_LENGTH bytes in size.
 *
 * @return true on success.
 */
bool tox_messagev3_get_new_message_id(uint8_t *msg_id);

/**
 * @brief Set the client's status message.
 *
 * Status message length cannot exceed TOX_MAX_STATUS_MESSAGE_LENGTH. If
 * length is 0, the status parameter is ignored (it can be NULL), and the
 * user status is set back to empty.
 */
bool tox_self_set_status_message(Tox *tox, const uint8_t *status_message, size_t length, Tox_Err_Set_Info *error);

/**
 * @brief Return the length of the current status message as passed to tox_self_set_status_message.
 *
 * If no status message was set before calling this function, the status
 * is empty, and this function returns 0.
 *
 * @see threading for concurrency implications.
 */
size_t tox_self_get_status_message_size(const Tox *tox);

/**
 * @brief Write the status message set by tox_self_set_status_message to a byte array.
 *
 * If no status message was set before calling this function, the status is
 * empty, and this function has no effect.
 *
 * Call tox_self_get_status_message_size to find out how much memory to allocate for
 * the result.
 *
 * @param status_message A valid memory location large enough to hold the
 *   status message. If this parameter is NULL, the function has no effect.
 */
void tox_self_get_status_message(const Tox *tox, uint8_t *status_message);

/**
 * @brief Set the client's user status.
 *
 * @param status One of the user statuses listed in the enumeration above.
 */
void tox_self_set_status(Tox *tox, Tox_User_Status status);

/**
 * @brief Returns the client's user status.
 */
Tox_User_Status tox_self_get_status(const Tox *tox);

/** @} */


/** @{
 * @name Friend list management
 */

typedef enum Tox_Err_Friend_Add {

    /**
     * The function returned successfully.
     */
    TOX_ERR_FRIEND_ADD_OK,

    /**
     * One of the arguments to the function was NULL when it was not expected.
     */
    TOX_ERR_FRIEND_ADD_NULL,

    /**
     * The length of the friend request message exceeded
     * TOX_MAX_FRIEND_REQUEST_LENGTH.
     */
    TOX_ERR_FRIEND_ADD_TOO_LONG,

    /**
     * The friend request message was empty. This, and the TOO_LONG code will
     * never be returned from tox_friend_add_norequest.
     */
    TOX_ERR_FRIEND_ADD_NO_MESSAGE,

    /**
     * The friend address belongs to the sending client.
     */
    TOX_ERR_FRIEND_ADD_OWN_KEY,

    /**
     * A friend request has already been sent, or the address belongs to a friend
     * that is already on the friend list.
     */
    TOX_ERR_FRIEND_ADD_ALREADY_SENT,

    /**
     * The friend address checksum failed.
     */
    TOX_ERR_FRIEND_ADD_BAD_CHECKSUM,

    /**
     * The friend was already there, but the nospam value was different.
     */
    TOX_ERR_FRIEND_ADD_SET_NEW_NOSPAM,

    /**
     * A memory allocation failed when trying to increase the friend list size.
     */
    TOX_ERR_FRIEND_ADD_MALLOC,

} Tox_Err_Friend_Add;


/**
 * @brief Add a friend to the friend list and send a friend request.
 *
 * A friend request message must be at least 1 byte long and at most
 * TOX_MAX_FRIEND_REQUEST_LENGTH.
 *
 * Friend numbers are unique identifiers used in all functions that operate on
 * friends. Once added, a friend number is stable for the lifetime of the Tox
 * object. After saving the state and reloading it, the friend numbers may not
 * be the same as before. Deleting a friend creates a gap in the friend number
 * set, which is filled by the next adding of a friend. Any pattern in friend
 * numbers should not be relied on.
 *
 * If more than INT32_MAX friends are added, this function causes undefined
 * behaviour.
 *
 * @param address The address of the friend (returned by tox_self_get_address of
 *   the friend you wish to add) it must be TOX_ADDRESS_SIZE bytes.
 * @param message The message that will be sent along with the friend request.
 * @param length The length of the data byte array.
 *
 * @return the friend number on success, an unspecified value on failure.
 */
uint32_t tox_friend_add(Tox *tox, const uint8_t *address, const uint8_t *message, size_t length,
                        Tox_Err_Friend_Add *error);

/**
 * @brief Add a friend without sending a friend request.
 *
 * This function is used to add a friend in response to a friend request. If the
 * client receives a friend request, it can be reasonably sure that the other
 * client added this client as a friend, eliminating the need for a friend
 * request.
 *
 * This function is also useful in a situation where both instances are
 * controlled by the same entity, so that this entity can perform the mutual
 * friend adding. In this case, there is no need for a friend request, either.
 *
 * @param public_key A byte array of length TOX_PUBLIC_KEY_SIZE containing the
 *   Public Key (not the Address) of the friend to add.
 *
 * @return the friend number on success, an unspecified value on failure.
 * @see tox_friend_add for a more detailed description of friend numbers.
 */
uint32_t tox_friend_add_norequest(Tox *tox, const uint8_t *public_key, Tox_Err_Friend_Add *error);

typedef enum Tox_Err_Friend_Delete {

    /**
     * The function returned successfully.
     */
    TOX_ERR_FRIEND_DELETE_OK,

    /**
     * There was no friend with the given friend number. No friends were deleted.
     */
    TOX_ERR_FRIEND_DELETE_FRIEND_NOT_FOUND,

} Tox_Err_Friend_Delete;


/**
 * @brief Remove a friend from the friend list.
 *
 * This does not notify the friend of their deletion. After calling this
 * function, this client will appear offline to the friend and no communication
 * can occur between the two.
 *
 * @param friend_number Friend number for the friend to be deleted.
 *
 * @return true on success.
 */
bool tox_friend_delete(Tox *tox, uint32_t friend_number, Tox_Err_Friend_Delete *error);

/** @} */


/** @{
 * @name Friend list queries
 */

typedef enum Tox_Err_Friend_By_Public_Key {

    /**
     * The function returned successfully.
     */
    TOX_ERR_FRIEND_BY_PUBLIC_KEY_OK,

    /**
     * One of the arguments to the function was NULL when it was not expected.
     */
    TOX_ERR_FRIEND_BY_PUBLIC_KEY_NULL,

    /**
     * No friend with the given Public Key exists on the friend list.
     */
    TOX_ERR_FRIEND_BY_PUBLIC_KEY_NOT_FOUND,

} Tox_Err_Friend_By_Public_Key;


/**
 * @brief Return the friend number associated with that Public Key.
 *
 * @return the friend number on success, an unspecified value on failure.
 * @param public_key A byte array containing the Public Key.
 */
uint32_t tox_friend_by_public_key(const Tox *tox, const uint8_t *public_key, Tox_Err_Friend_By_Public_Key *error);

/**
 * @brief Checks if a friend with the given friend number exists and returns true if
 * it does.
 */
bool tox_friend_exists(const Tox *tox, uint32_t friend_number);

/**
 * @brief Return the number of friends on the friend list.
 *
 * This function can be used to determine how much memory to allocate for
 * tox_self_get_friend_list.
 */
size_t tox_self_get_friend_list_size(const Tox *tox);

/**
 * @brief Copy a list of valid friend numbers into an array.
 *
 * Call tox_self_get_friend_list_size to determine the number of elements to allocate.
 *
 * @param friend_list A memory region with enough space to hold the friend
 *   list. If this parameter is NULL, this function has no effect.
 */
void tox_self_get_friend_list(const Tox *tox, uint32_t *friend_list);

typedef enum Tox_Err_Friend_Get_Public_Key {

    /**
     * The function returned successfully.
     */
    TOX_ERR_FRIEND_GET_PUBLIC_KEY_OK,

    /**
     * No friend with the given number exists on the friend list.
     */
    TOX_ERR_FRIEND_GET_PUBLIC_KEY_FRIEND_NOT_FOUND,

} Tox_Err_Friend_Get_Public_Key;


/**
 * @brief Copies the Public Key associated with a given friend number to a byte array.
 *
 * @param friend_number The friend number you want the Public Key of.
 * @param public_key A memory region of at least TOX_PUBLIC_KEY_SIZE bytes. If
 *   this parameter is NULL, this function has no effect.
 *
 * @return true on success.
 */
bool tox_friend_get_public_key(const Tox *tox, uint32_t friend_number, uint8_t *public_key,
                               Tox_Err_Friend_Get_Public_Key *error);

typedef enum Tox_Err_Friend_Get_Last_Online {

    /**
     * The function returned successfully.
     */
    TOX_ERR_FRIEND_GET_LAST_ONLINE_OK,

    /**
     * No friend with the given number exists on the friend list.
     */
    TOX_ERR_FRIEND_GET_LAST_ONLINE_FRIEND_NOT_FOUND,

} Tox_Err_Friend_Get_Last_Online;


/**
 * @brief Return a unix-time timestamp of the last time the friend associated with a given
 * friend number was seen online.
 *
 * This function will return UINT64_MAX on error.
 *
 * @param friend_number The friend number you want to query.
 */
uint64_t tox_friend_get_last_online(const Tox *tox, uint32_t friend_number, Tox_Err_Friend_Get_Last_Online *error);

/** @} */


/** @{
 * @name Friend-specific state queries (can also be received through callbacks)
 */

/**
 * @brief Common error codes for friend state query functions.
 */
typedef enum Tox_Err_Friend_Query {

    /**
     * The function returned successfully.
     */
    TOX_ERR_FRIEND_QUERY_OK,

    /**
     * The pointer parameter for storing the query result (name, message) was
     * NULL. Unlike the `_self_` variants of these functions, which have no effect
     * when a parameter is NULL, these functions return an error in that case.
     */
    TOX_ERR_FRIEND_QUERY_NULL,

    /**
     * The friend_number did not designate a valid friend.
     */
    TOX_ERR_FRIEND_QUERY_FRIEND_NOT_FOUND,

} Tox_Err_Friend_Query;

/**
 * Return the capabilities flags for a friend. If the friend number is invalid, the
 * return value is unspecified.
 */
uint64_t tox_friend_get_capabilities(const Tox *tox, uint32_t friend_number);

/**
 * @brief Return the length of the friend's name.
 *
 * If the friend number is invalid, the return value is unspecified.
 *
 * The return value is equal to the `length` argument received by the last
 * `friend_name` callback.
 */
size_t tox_friend_get_name_size(const Tox *tox, uint32_t friend_number, Tox_Err_Friend_Query *error);

/**
 * @brief Write the name of the friend designated by the given friend number to a byte
 * array.
 *
 * Call tox_friend_get_name_size to determine the allocation size for the `name`
 * parameter.
 *
 * The data written to `name` is equal to the data received by the last
 * `friend_name` callback.
 *
 * @param name A valid memory region large enough to store the friend's name.
 *
 * @return true on success.
 */
bool tox_friend_get_name(const Tox *tox, uint32_t friend_number, uint8_t *name, Tox_Err_Friend_Query *error);

/**
 * @param friend_number The friend number of the friend whose name changed.
 * @param name A byte array containing the same data as
 *   tox_friend_get_name would write to its `name` parameter.
 * @param length A value equal to the return value of
 *   tox_friend_get_name_size.
 */
typedef void tox_friend_name_cb(Tox *tox, uint32_t friend_number, const uint8_t *name, size_t length, void *user_data);


/**
 * @brief Set the callback for the `friend_name` event.
 *
 * Pass NULL to unset.
 *
 * This event is triggered when a friend changes their name.
 */
void tox_callback_friend_name(Tox *tox, tox_friend_name_cb *callback);

/**
 * @brief Return the length of the friend's status message.
 *
 * If the friend number isinvalid, the return value is SIZE_MAX.
 */
size_t tox_friend_get_status_message_size(const Tox *tox, uint32_t friend_number, Tox_Err_Friend_Query *error);

/**
 * @brief Write the status message of the friend designated by the given friend number to a byte
 * array.
 *
 * Call tox_friend_get_status_message_size to determine the allocation size for the `status_message`
 * parameter.
 *
 * The data written to `status_message` is equal to the data received by the last
 * `friend_status_message` callback.
 *
 * @param status_message A valid memory region large enough to store the friend's status message.
 */
bool tox_friend_get_status_message(const Tox *tox, uint32_t friend_number, uint8_t *status_message,
                                   Tox_Err_Friend_Query *error);

/**
 * @param friend_number The friend number of the friend whose status message
 *   changed.
 * @param message A byte array containing the same data as
 *   tox_friend_get_status_message would write to its `status_message` parameter.
 * @param length A value equal to the return value of
 *   tox_friend_get_status_message_size.
 */
typedef void tox_friend_status_message_cb(Tox *tox, uint32_t friend_number, const uint8_t *message, size_t length,
        void *user_data);


/**
 * @brief Set the callback for the `friend_status_message` event.
 *
 * Pass NULL to unset.
 *
 * This event is triggered when a friend changes their status message.
 */
void tox_callback_friend_status_message(Tox *tox, tox_friend_status_message_cb *callback);

/**
 * @brief Return the friend's user status (away/busy/...).
 *
 * If the friend number is invalid, the return value is unspecified.
 *
 * The status returned is equal to the last status received through the
 * `friend_status` callback.
 *
 * @deprecated This getter is deprecated. Use the event and store the status
 *   in the client state.
 */
Tox_User_Status tox_friend_get_status(const Tox *tox, uint32_t friend_number, Tox_Err_Friend_Query *error);

/**
 * @param friend_number The friend number of the friend whose user status
 *   changed.
 * @param status The new user status.
 */
typedef void tox_friend_status_cb(Tox *tox, uint32_t friend_number, Tox_User_Status status, void *user_data);


/**
 * @brief Set the callback for the `friend_status` event.
 *
 * Pass NULL to unset.
 *
 * This event is triggered when a friend changes their user status.
 */
void tox_callback_friend_status(Tox *tox, tox_friend_status_cb *callback);

/**
 * @brief Check whether a friend is currently connected to this client.
 *
 * The result of this function is equal to the last value received by the
 * `friend_connection_status` callback.
 *
 * @param friend_number The friend number for which to query the connection
 *   status.
 *
 * @return the friend's connection status as it was received through the
 *   `friend_connection_status` event.
 *
 * @deprecated This getter is deprecated. Use the event and store the status
 *   in the client state.
 */
Tox_Connection tox_friend_get_connection_status(const Tox *tox, uint32_t friend_number, Tox_Err_Friend_Query *error);

void tox_friend_get_connection_ip(const Tox *tox, uint32_t friend_number, uint8_t *ip_str);


/**
 * @param friend_number The friend number of the friend whose connection status
 *   changed.
 * @param connection_status The result of calling
 *   tox_friend_get_connection_status on the passed friend_number.
 */
typedef void tox_friend_connection_status_cb(Tox *tox, uint32_t friend_number, Tox_Connection connection_status,
        void *user_data);


/**
 * @brief Set the callback for the `friend_connection_status` event.
 *
 * Pass NULL to unset.
 *
 * This event is triggered when a friend goes offline after having been online,
 * or when a friend goes online.
 *
 * This callback is not called when adding friends. It is assumed that when
 * adding friends, their connection status is initially offline.
 */
void tox_callback_friend_connection_status(Tox *tox, tox_friend_connection_status_cb *callback);

/**
 * @brief Check whether a friend is currently typing a message.
 *
 * @param friend_number The friend number for which to query the typing status.
 *
 * @return true if the friend is typing.
 * @return false if the friend is not typing, or the friend number was
 *   invalid. Inspect the error code to determine which case it is.
 *
 * @deprecated This getter is deprecated. Use the event and store the status
 *   in the client state.
 */
bool tox_friend_get_typing(const Tox *tox, uint32_t friend_number, Tox_Err_Friend_Query *error);

/**
 * @param friend_number The friend number of the friend who started or stopped
 *   typing.
 * @param typing The result of calling tox_friend_get_typing on the passed
 *   friend_number.
 */
typedef void tox_friend_typing_cb(Tox *tox, uint32_t friend_number, bool typing, void *user_data);


/**
 * @brief Set the callback for the `friend_typing` event.
 *
 * Pass NULL to unset.
 *
 * This event is triggered when a friend starts or stops typing.
 */
void tox_callback_friend_typing(Tox *tox, tox_friend_typing_cb *callback);

/** @} */


/** @{
 * @name Sending private messages
 */

typedef enum Tox_Err_Set_Typing {

    /**
     * The function returned successfully.
     */
    TOX_ERR_SET_TYPING_OK,

    /**
     * The friend number did not designate a valid friend.
     */
    TOX_ERR_SET_TYPING_FRIEND_NOT_FOUND,

} Tox_Err_Set_Typing;


/**
 * @brief Set the client's typing status for a friend.
 *
 * The client is responsible for turning it on or off.
 *
 * @param friend_number The friend to which the client is typing a message.
 * @param typing The typing status. True means the client is typing.
 *
 * @return true on success.
 */
bool tox_self_set_typing(Tox *tox, uint32_t friend_number, bool typing, Tox_Err_Set_Typing *error);

typedef enum Tox_Err_Friend_Send_Message {

    /**
     * The function returned successfully.
     */
    TOX_ERR_FRIEND_SEND_MESSAGE_OK,

    /**
     * One of the arguments to the function was NULL when it was not expected.
     */
    TOX_ERR_FRIEND_SEND_MESSAGE_NULL,

    /**
     * The friend number did not designate a valid friend.
     */
    TOX_ERR_FRIEND_SEND_MESSAGE_FRIEND_NOT_FOUND,

    /**
     * This client is currently not connected to the friend.
     */
    TOX_ERR_FRIEND_SEND_MESSAGE_FRIEND_NOT_CONNECTED,

    /**
     * An allocation error occurred while increasing the send queue size.
     */
    TOX_ERR_FRIEND_SEND_MESSAGE_SENDQ,

    /**
     * Message length exceeded TOX_MAX_MESSAGE_LENGTH.
     */
    TOX_ERR_FRIEND_SEND_MESSAGE_TOO_LONG,

    /**
     * Attempted to send a zero-length message.
     */
    TOX_ERR_FRIEND_SEND_MESSAGE_EMPTY,

} Tox_Err_Friend_Send_Message;


/**
 * @brief Send a text chat message to an online friend.
 *
 * This function creates a chat message packet and pushes it into the send
 * queue.
 *
 * The message length may not exceed TOX_MAX_MESSAGE_LENGTH. Larger messages
 * must be split by the client and sent as separate messages. Other clients can
 * then reassemble the fragments. Messages may not be empty.
 *
 * The return value of this function is the message ID. If a read receipt is
 * received, the triggered `friend_read_receipt` event will be passed this message ID.
 *
 * Message IDs are unique per friend. The first message ID is 0. Message IDs are
 * incremented by 1 each time a message is sent. If UINT32_MAX messages were
 * sent, the next message ID is 0.
 *
 * @param type Message type (normal, action, ...).
 * @param friend_number The friend number of the friend to send the message to.
 * @param message A non-NULL pointer to the first element of a byte array
 *   containing the message text.
 * @param length Length of the message to be sent.
 */
uint32_t tox_friend_send_message(Tox *tox, uint32_t friend_number, Tox_Message_Type type, const uint8_t *message,
                                 size_t length, Tox_Err_Friend_Send_Message *error);

/**
 * @param friend_number The friend number of the friend who received the message.
 * @param message_id The message ID as returned from tox_friend_send_message
 *   corresponding to the message sent.
 */
typedef void tox_friend_read_receipt_cb(Tox *tox, uint32_t friend_number, uint32_t message_id, void *user_data);


/**
 * @brief Set the callback for the `friend_read_receipt` event.
 *
 * Pass NULL to unset.
 *
 * This event is triggered when the friend receives the message sent with
 * tox_friend_send_message with the corresponding message ID.
 */
void tox_callback_friend_read_receipt(Tox *tox, tox_friend_read_receipt_cb *callback);

/** @} */


/** @{
 * @name Receiving private messages and friend requests
 */

/**
 * @param public_key The Public Key of the user who sent the friend request.
 * @param message The message they sent along with the request.
 * @param length The size of the message byte array.
 */
typedef void tox_friend_request_cb(Tox *tox, const uint8_t *public_key, const uint8_t *message, size_t length,
                                   void *user_data);


/**
 * @brief Set the callback for the `friend_request` event.
 *
 * Pass NULL to unset.
 *
 * This event is triggered when a friend request is received.
 */
void tox_callback_friend_request(Tox *tox, tox_friend_request_cb *callback);

/**
 * @param friend_number The friend number of the friend who sent the message.
 * @param message The message data they sent.
 * @param length The size of the message byte array.
 */
typedef void tox_friend_message_cb(Tox *tox, uint32_t friend_number, Tox_Message_Type type, const uint8_t *message,
                                   size_t length, void *user_data);


/**
 * @brief Set the callback for the `friend_message` event.
 *
 * Pass NULL to unset.
 *
 * This event is triggered when a message from a friend is received.
 */
void tox_callback_friend_message(Tox *tox, tox_friend_message_cb *callback);

/** @} */


/** @{
 * @name File transmission: common between sending and receiving
 */

/**
 * @brief Generates a cryptographic hash of the given data.
 *
 * This function may be used by clients for any purpose, but is provided
 * primarily for validating cached avatars. This use is highly recommended to
 * avoid unnecessary avatar updates.
 *
 * If hash is NULL or data is NULL while length is not 0 the function returns false,
 * otherwise it returns true.
 *
 * This function is a wrapper to events_alloc message-digest functions.
 *
 * @param hash A valid memory location the hash data. It must be at least
 *   TOX_HASH_LENGTH bytes in size.
 * @param data Data to be hashed or NULL.
 * @param length Size of the data array or 0.
 *
 * @return true if hash was not NULL.
 */
bool tox_hash(uint8_t *hash, const uint8_t *data, size_t length);

/**
 * @brief A list of pre-defined file kinds.
 *
 * Toxcore itself does not behave differently for different file kinds. These
 * are a hint to the client telling it what use the sender intended for the
 * file. The `kind` parameter in the send function and recv callback are
 * `uint32_t`, not Tox_File_Kind, because clients can invent their own file
 * kind. Unknown file kinds should be treated as TOX_FILE_KIND_DATA.
 */
enum Tox_File_Kind {

    /**
     * Arbitrary file data. Clients can choose to handle it based on the file name
     * or magic or any other way they choose.
     */
    TOX_FILE_KIND_DATA,

    /**
     * Avatar file_id. This consists of tox_hash(image).
     * Avatar data. This consists of the image data.
     *
     * Avatars can be sent at any time the client wishes. Generally, a client will
     * send the avatar to a friend when that friend comes online, and to all
     * friends when the avatar changed. A client can save some traffic by
     * remembering which friend received the updated avatar already and only send
     * it if the friend has an out of date avatar.
     *
     * Clients who receive avatar send requests can reject it (by sending
     * TOX_FILE_CONTROL_CANCEL before any other controls), or accept it (by
     * sending TOX_FILE_CONTROL_RESUME). The file_id of length TOX_HASH_LENGTH bytes
     * (same length as TOX_FILE_ID_LENGTH) will contain the hash. A client can compare
     * this hash with a saved hash and send TOX_FILE_CONTROL_CANCEL to terminate the avatar
     * transfer if it matches.
     *
     * When file_size is set to 0 in the transfer request it means that the client
     * has no avatar.
     */
    TOX_FILE_KIND_AVATAR,

    /**
     * MessageV2 Filetransfers
     *
     * filetransfers of this type are always autoaccepted
     * and the overall size is limited to TOX_MAX_FILETRANSFER_SIZE_MSGV2
     */
    TOX_FILE_KIND_MESSAGEV2_SEND = 2,

    /**
     * TODO: Generate doc
     */
    TOX_FILE_KIND_MESSAGEV2_ANSWER = 3,

    /**
     * TODO: Generate doc
     */
    TOX_FILE_KIND_MESSAGEV2_ALTER = 4,

    /**
     * TODO: Generate doc
     */
    TOX_FILE_KIND_MESSAGEV2_SYNC = 5,

    /**
     * Filetransfer V2
     *
     * filetransfers of this type are not cancelled on going offline (either self or the other friend)
     */
    TOX_FILE_KIND_FTV2 = 16,
};

typedef enum TOX_MESSAGEV2_ALTER_TYPE {
    TOX_MESSAGEV2_ALTER_TYPE_DELETE,
    TOX_MESSAGEV2_ALTER_TYPE_CORRECT,
} TOX_MESSAGEV2_ALTER_TYPE;

typedef enum Tox_File_Control {

    /**
     * Sent by the receiving side to accept a file send request. Also sent after a
     * TOX_FILE_CONTROL_PAUSE command to continue sending or receiving.
     */
    TOX_FILE_CONTROL_RESUME,

    /**
     * Sent by clients to pause the file transfer. The initial state of a file
     * transfer is always paused on the receiving side and running on the sending
     * side. If both the sending and receiving side pause the transfer, then both
     * need to send TOX_FILE_CONTROL_RESUME for the transfer to resume.
     */
    TOX_FILE_CONTROL_PAUSE,

    /**
     * Sent by the receiving side to reject a file send request before any other
     * commands are sent. Also sent by either side to terminate a file transfer.
     */
    TOX_FILE_CONTROL_CANCEL,

} Tox_File_Control;


typedef enum Tox_Err_File_Control {

    /**
     * The function returned successfully.
     */
    TOX_ERR_FILE_CONTROL_OK,

    /**
     * The friend_number passed did not designate a valid friend.
     */
    TOX_ERR_FILE_CONTROL_FRIEND_NOT_FOUND,

    /**
     * This client is currently not connected to the friend.
     */
    TOX_ERR_FILE_CONTROL_FRIEND_NOT_CONNECTED,

    /**
     * No file transfer with the given file number was found for the given friend.
     */
    TOX_ERR_FILE_CONTROL_NOT_FOUND,

    /**
     * A RESUME control was sent, but the file transfer is running normally.
     */
    TOX_ERR_FILE_CONTROL_NOT_PAUSED,

    /**
     * A RESUME control was sent, but the file transfer was paused by the other
     * party. Only the party that paused the transfer can resume it.
     */
    TOX_ERR_FILE_CONTROL_DENIED,

    /**
     * A PAUSE control was sent, but the file transfer was already paused.
     */
    TOX_ERR_FILE_CONTROL_ALREADY_PAUSED,

    /**
     * Packet queue is full.
     */
    TOX_ERR_FILE_CONTROL_SENDQ,

} Tox_Err_File_Control;


/**
 * @brief Sends a file control command to a friend for a given file transfer.
 *
 * @param friend_number The friend number of the friend the file is being
 *   transferred to or received from.
 * @param file_number The friend-specific identifier for the file transfer.
 * @param control The control command to send.
 *
 * @return true on success.
 */
bool tox_file_control(Tox *tox, uint32_t friend_number, uint32_t file_number, Tox_File_Control control,
                      Tox_Err_File_Control *error);

/**
 * @brief When receiving TOX_FILE_CONTROL_CANCEL, the client should release the
 * resources associated with the file number and consider the transfer failed.
 *
 * @param friend_number The friend number of the friend who is sending the file.
 * @param file_number The friend-specific file number the data received is
 *   associated with.
 * @param control The file control command received.
 */
typedef void tox_file_recv_control_cb(Tox *tox, uint32_t friend_number, uint32_t file_number, Tox_File_Control control,
                                      void *user_data);


/**
 * @brief Set the callback for the `file_recv_control` event.
 *
 * Pass NULL to unset.
 *
 * This event is triggered when a file control command is received from a
 * friend.
 */
void tox_callback_file_recv_control(Tox *tox, tox_file_recv_control_cb *callback);

typedef enum Tox_Err_File_Seek {

    /**
     * The function returned successfully.
     */
    TOX_ERR_FILE_SEEK_OK,

    /**
     * The friend_number passed did not designate a valid friend.
     */
    TOX_ERR_FILE_SEEK_FRIEND_NOT_FOUND,

    /**
     * This client is currently not connected to the friend.
     */
    TOX_ERR_FILE_SEEK_FRIEND_NOT_CONNECTED,

    /**
     * No file transfer with the given file number was found for the given friend.
     */
    TOX_ERR_FILE_SEEK_NOT_FOUND,

    /**
     * File was not in a state where it could be seeked.
     */
    TOX_ERR_FILE_SEEK_DENIED,

    /**
     * Seek position was invalid
     */
    TOX_ERR_FILE_SEEK_INVALID_POSITION,

    /**
     * Packet queue is full.
     */
    TOX_ERR_FILE_SEEK_SENDQ,

} Tox_Err_File_Seek;


/**
 * @brief Sends a file seek control command to a friend for a given file transfer.
 *
 * This function can only be called to resume a file transfer right before
 * TOX_FILE_CONTROL_RESUME is sent.
 *
 * @param friend_number The friend number of the friend the file is being
 *   received from.
 * @param file_number The friend-specific identifier for the file transfer.
 * @param position The position that the file should be seeked to.
 */
bool tox_file_seek(Tox *tox, uint32_t friend_number, uint32_t file_number, uint64_t position, Tox_Err_File_Seek *error);

typedef enum Tox_Err_File_Get {

    /**
     * The function returned successfully.
     */
    TOX_ERR_FILE_GET_OK,

    /**
     * One of the arguments to the function was NULL when it was not expected.
     */
    TOX_ERR_FILE_GET_NULL,

    /**
     * The friend_number passed did not designate a valid friend.
     */
    TOX_ERR_FILE_GET_FRIEND_NOT_FOUND,

    /**
     * No file transfer with the given file number was found for the given friend.
     */
    TOX_ERR_FILE_GET_NOT_FOUND,

} Tox_Err_File_Get;


/**
 * @brief Copy the file id associated to the file transfer to a byte array.
 *
 * @param friend_number The friend number of the friend the file is being
 *   transferred to or received from.
 * @param file_number The friend-specific identifier for the file transfer.
 * @param file_id A memory region of at least TOX_FILE_ID_LENGTH bytes. If
 *   this parameter is NULL, this function has no effect.
 *
 * @return true on success.
 */
bool tox_file_get_file_id(const Tox *tox, uint32_t friend_number, uint32_t file_number, uint8_t *file_id,
                          Tox_Err_File_Get *error);

/** @} */


/** @{
 * @name File transmission: sending
 */

typedef enum Tox_Err_File_Send {

    /**
     * The function returned successfully.
     */
    TOX_ERR_FILE_SEND_OK,

    /**
     * One of the arguments to the function was NULL when it was not expected.
     */
    TOX_ERR_FILE_SEND_NULL,

    /**
     * The friend_number passed did not designate a valid friend.
     */
    TOX_ERR_FILE_SEND_FRIEND_NOT_FOUND,

    /**
     * This client is currently not connected to the friend.
     */
    TOX_ERR_FILE_SEND_FRIEND_NOT_CONNECTED,

    /**
     * Filename length exceeded TOX_MAX_FILENAME_LENGTH bytes.
     */
    TOX_ERR_FILE_SEND_NAME_TOO_LONG,

    /**
     * Too many ongoing transfers. The maximum number of concurrent file transfers
     * is 256 per friend per direction (sending and receiving).
     */
    TOX_ERR_FILE_SEND_TOO_MANY,

} Tox_Err_File_Send;


/**
 * @brief Send a file transmission request.
 *
 * Maximum filename length is TOX_MAX_FILENAME_LENGTH bytes. The filename
 * should generally just be a file name, not a path with directory names.
 *
 * If a non-UINT64_MAX file size is provided, it can be used by both sides to
 * determine the sending progress. File size can be set to UINT64_MAX for
 * streaming data of unknown size.
 *
 * File transmission occurs in chunks, which are requested through the
 * `file_chunk_request` event.
 *
 * When a friend goes offline, all file transfers associated with the friend are
 * purged from core.
 *
 * If the file contents change during a transfer, the behaviour is unspecified
 * in general. What will actually happen depends on the mode in which the file
 * was modified and how the client determines the file size.
 *
 * - If the file size was increased
 *   - and sending mode was streaming (file_size = UINT64_MAX), the behaviour
 *     will be as expected.
 *   - and sending mode was file (file_size != UINT64_MAX), the file_chunk_request
 *     callback will receive length = 0 when Core thinks the file transfer has
 *     finished. If the client remembers the file size as it was when sending the
 *     request, it will terminate the transfer normally. If the client re-reads the
 *     size, it will think the friend cancelled the transfer.
 * - If the file size was decreased
 *   - and sending mode was streaming, the behaviour is as expected.
 *   - and sending mode was file, the callback will return 0 at the new
 *     (earlier) end-of-file, signalling to the friend that the transfer was
 *     cancelled.
 * - If the file contents were modified
 *   - at a position before the current read, the two files (local and remote)
 *     will differ after the transfer terminates.
 *   - at a position after the current read, the file transfer will succeed as
 *     expected.
 *   - In either case, both sides will regard the transfer as complete and
 *     successful.
 *
 * @param friend_number The friend number of the friend the file send request
 *   should be sent to.
 * @param kind The meaning of the file to be sent.
 * @param file_size Size in bytes of the file the client wants to send, UINT64_MAX if
 *   unknown or streaming.
 * @param file_id A file identifier of length TOX_FILE_ID_LENGTH that can be used to
 *   uniquely identify file transfers across core restarts. If NULL, a random one will
 *   be generated by core. It can then be obtained by using `tox_file_get_file_id()`.
 * @param filename Name of the file. Does not need to be the actual name. This
 *   name will be sent along with the file send request.
 * @param filename_length Size in bytes of the filename.
 *
 * @return A file number used as an identifier in subsequent callbacks. This
 *   number is per friend. File numbers are reused after a transfer terminates.
 *   On failure, this function returns an unspecified value. Any pattern in file numbers
 *   should not be relied on.
 */
uint32_t tox_file_send(Tox *tox, uint32_t friend_number, uint32_t kind, uint64_t file_size, const uint8_t *file_id,
                       const uint8_t *filename, size_t filename_length, Tox_Err_File_Send *error);

typedef enum Tox_Err_File_Send_Chunk {

    /**
     * The function returned successfully.
     */
    TOX_ERR_FILE_SEND_CHUNK_OK,

    /**
     * The length parameter was non-zero, but data was NULL.
     */
    TOX_ERR_FILE_SEND_CHUNK_NULL,

    /**
     * The friend_number passed did not designate a valid friend.
     */
    TOX_ERR_FILE_SEND_CHUNK_FRIEND_NOT_FOUND,

    /**
     * This client is currently not connected to the friend.
     */
    TOX_ERR_FILE_SEND_CHUNK_FRIEND_NOT_CONNECTED,

    /**
     * No file transfer with the given file number was found for the given friend.
     */
    TOX_ERR_FILE_SEND_CHUNK_NOT_FOUND,

    /**
     * File transfer was found but isn't in a transferring state: (paused, done,
     * broken, etc...) (happens only when not called from the request chunk callback).
     */
    TOX_ERR_FILE_SEND_CHUNK_NOT_TRANSFERRING,

    /**
     * Attempted to send more or less data than requested. The requested data size is
     * adjusted according to maximum transmission unit and the expected end of
     * the file. Trying to send less or more than requested will return this error.
     */
    TOX_ERR_FILE_SEND_CHUNK_INVALID_LENGTH,

    /**
     * Packet queue is full.
     */
    TOX_ERR_FILE_SEND_CHUNK_SENDQ,

    /**
     * Position parameter was wrong.
     */
    TOX_ERR_FILE_SEND_CHUNK_WRONG_POSITION,

} Tox_Err_File_Send_Chunk;


/**
 * @brief Send a chunk of file data to a friend.
 *
 * This function is called in response to the `file_chunk_request` callback. The
 * length parameter should be equal to the one received though the callback.
 * If it is zero, the transfer is assumed complete. For files with known size,
 * Core will know that the transfer is complete after the last byte has been
 * received, so it is not necessary (though not harmful) to send a zero-length
 * chunk to terminate. For streams, core will know that the transfer is finished
 * if a chunk with length less than the length requested in the callback is sent.
 *
 * @param friend_number The friend number of the receiving friend for this file.
 * @param file_number The file transfer identifier returned by tox_file_send.
 * @param position The file or stream position from which to continue reading.
 * @return true on success.
 */
bool tox_file_send_chunk(Tox *tox, uint32_t friend_number, uint32_t file_number, uint64_t position, const uint8_t *data,
                         size_t length, Tox_Err_File_Send_Chunk *error);

/**
 * If the length parameter is 0, the file transfer is finished, and the client's
 * resources associated with the file number should be released. After a call
 * with zero length, the file number can be reused for future file transfers.
 *
 * If the requested position is not equal to the client's idea of the current
 * file or stream position, it will need to seek. In case of read-once streams,
 * the client should keep the last read chunk so that a seek back can be
 * supported. A seek-back only ever needs to read from the last requested chunk.
 * This happens when a chunk was requested, but the send failed. A seek-back
 * request can occur an arbitrary number of times for any given chunk.
 *
 * In response to receiving this callback, the client should call the function
 * `tox_file_send_chunk` with the requested chunk. If the number of bytes sent
 * through that function is zero, the file transfer is assumed complete. A
 * client must send the full length of data requested with this callback.
 *
 * @param friend_number The friend number of the receiving friend for this file.
 * @param file_number The file transfer identifier returned by tox_file_send.
 * @param position The file or stream position from which to continue reading.
 * @param length The number of bytes requested for the current chunk.
 */
typedef void tox_file_chunk_request_cb(Tox *tox, uint32_t friend_number, uint32_t file_number, uint64_t position,
                                       size_t length, void *user_data);


/**
 * @brief Set the callback for the `file_chunk_request` event.
 *
 * Pass NULL to unset.
 *
 * This event is triggered when Core is ready to send more file data.
 */
void tox_callback_file_chunk_request(Tox *tox, tox_file_chunk_request_cb *callback);

/** @} */


/** @{
 * @name File transmission: receiving
 */

/**
 * The client should acquire resources to be associated with the file transfer.
 * Incoming file transfers start in the PAUSED state. After this callback
 * returns, a transfer can be rejected by sending a TOX_FILE_CONTROL_CANCEL
 * control command before any other control commands. It can be accepted by
 * sending TOX_FILE_CONTROL_RESUME.
 *
 * @param friend_number The friend number of the friend who is sending the file
 *   transfer request.
 * @param file_number The friend-specific file number the data received is
 *   associated with.
 * @param kind The meaning of the file that was sent.
 * @param file_size Size in bytes of the file the client wants to send,
 *   UINT64_MAX if unknown or streaming.
 * @param filename Name of the file. Does not need to be the actual name. This
 *   name will be sent along with the file send request.
 * @param filename_length Size in bytes of the filename.
 */
typedef void tox_file_recv_cb(Tox *tox, uint32_t friend_number, uint32_t file_number, uint32_t kind, uint64_t file_size,
                              const uint8_t *filename, size_t filename_length, void *user_data);


/**
 * @brief Set the callback for the `file_recv` event.
 *
 * Pass NULL to unset.
 *
 * This event is triggered when a file transfer request is received.
 */
void tox_callback_file_recv(Tox *tox, tox_file_recv_cb *callback);

/**
 * When length is 0, the transfer is finished and the client should release the
 * resources it acquired for the transfer. After a call with length = 0, the
 * file number can be reused for new file transfers.
 *
 * If position is equal to file_size (received in the file_receive callback)
 * when the transfer finishes, the file was received completely. Otherwise, if
 * file_size was UINT64_MAX, streaming ended successfully when length is 0.
 *
 * @param friend_number The friend number of the friend who is sending the file.
 * @param file_number The friend-specific file number the data received is
 *   associated with.
 * @param position The file position of the first byte in data.
 * @param data A byte array containing the received chunk.
 * @param length The length of the received chunk.
 */
typedef void tox_file_recv_chunk_cb(Tox *tox, uint32_t friend_number, uint32_t file_number, uint64_t position,
                                    const uint8_t *data, size_t length, void *user_data);


/**
 * @brief Set the callback for the `file_recv_chunk` event.
 *
 * Pass NULL to unset.
 *
 * This event is first triggered when a file transfer request is received, and
 * subsequently when a chunk of file data for an accepted request was received.
 */
void tox_callback_file_recv_chunk(Tox *tox, tox_file_recv_chunk_cb *callback);

/** @} */


/** @{
 * @name Conference management
 */

/**
 * @brief Conference types for the conference_invite event.
 */
typedef enum Tox_Conference_Type {

    /**
     * Text-only conferences that must be accepted with the tox_conference_join function.
     */
    TOX_CONFERENCE_TYPE_TEXT,

    /**
     * Video conference. The function to accept these is in toxav.
     */
    TOX_CONFERENCE_TYPE_AV,

} Tox_Conference_Type;


/**
 * The invitation will remain valid until the inviting friend goes offline
 * or exits the conference.
 *
 * @param friend_number The friend who invited us.
 * @param type The conference type (text only or audio/video).
 * @param cookie A piece of data of variable length required to join the
 *   conference.
 * @param length The length of the cookie.
 */
typedef void tox_conference_invite_cb(Tox *tox, uint32_t friend_number, Tox_Conference_Type type, const uint8_t *cookie,
                                      size_t length, void *user_data);


/**
 * @brief Set the callback for the `conference_invite` event.
 *
 * Pass NULL to unset.
 *
 * This event is triggered when the client is invited to join a conference.
 */
void tox_callback_conference_invite(Tox *tox, tox_conference_invite_cb *callback);

/**
 * @param conference_number The conference number of the conference to which we have connected.
 */
typedef void tox_conference_connected_cb(Tox *tox, uint32_t conference_number, void *user_data);


/**
 * @brief Set the callback for the `conference_connected` event.
 *
 * Pass NULL to unset.
 *
 * This event is triggered when the client successfully connects to a
 * conference after joining it with the tox_conference_join function.
 */
void tox_callback_conference_connected(Tox *tox, tox_conference_connected_cb *callback);

/**
 * @param conference_number The conference number of the conference the message
 *   is intended for.
 * @param peer_number The ID of the peer who sent the message.
 * @param type The type of message (normal, action, ...).
 * @param message The message data.
 * @param length The length of the message.
 */
typedef void tox_conference_message_cb(Tox *tox, uint32_t conference_number, uint32_t peer_number,
                                       Tox_Message_Type type, const uint8_t *message, size_t length, void *user_data);


/**
 * @brief Set the callback for the `conference_message` event.
 *
 * Pass NULL to unset.
 *
 * This event is triggered when the client receives a conference message.
 */
void tox_callback_conference_message(Tox *tox, tox_conference_message_cb *callback);

/**
 * @param conference_number The conference number of the conference the title
 *   change is intended for.
 * @param peer_number The ID of the peer who changed the title.
 * @param title The title data.
 * @param length The title length.
 */
typedef void tox_conference_title_cb(Tox *tox, uint32_t conference_number, uint32_t peer_number, const uint8_t *title,
                                     size_t length, void *user_data);


/**
 * @brief Set the callback for the `conference_title` event.
 *
 * Pass NULL to unset.
 *
 * This event is triggered when a peer changes the conference title.
 *
 * If peer_number == UINT32_MAX, then author is unknown (e.g. initial joining the conference).
 */
void tox_callback_conference_title(Tox *tox, tox_conference_title_cb *callback);

/**
 * @param conference_number The conference number of the conference the
 *   peer is in.
 * @param peer_number The ID of the peer who changed their nickname.
 * @param name A byte array containing the new nickname.
 * @param length The size of the name byte array.
 */
typedef void tox_conference_peer_name_cb(Tox *tox, uint32_t conference_number, uint32_t peer_number,
        const uint8_t *name, size_t length, void *user_data);


/**
 * @brief Set the callback for the `conference_peer_name` event.
 *
 * Pass NULL to unset.
 *
 * This event is triggered when a peer changes their name.
 */
void tox_callback_conference_peer_name(Tox *tox, tox_conference_peer_name_cb *callback);

/**
 * @param conference_number The conference number of the conference the
 *   peer is in.
 */
typedef void tox_conference_peer_list_changed_cb(Tox *tox, uint32_t conference_number, void *user_data);


/**
 * @brief Set the callback for the `conference_peer_list_changed` event.
 *
 * Pass NULL to unset.
 *
 * This event is triggered when a peer joins or leaves the conference.
 */
void tox_callback_conference_peer_list_changed(Tox *tox, tox_conference_peer_list_changed_cb *callback);

typedef enum Tox_Err_Conference_New {

    /**
     * The function returned successfully.
     */
    TOX_ERR_CONFERENCE_NEW_OK,

    /**
     * The conference instance failed to initialize.
     */
    TOX_ERR_CONFERENCE_NEW_INIT,

} Tox_Err_Conference_New;


/**
 * @brief Creates a new conference.
 *
 * This function creates and connects to a new text conference.
 *
 * @return
 *   - conference number on success
 *   - an unspecified value on failure
 */
uint32_t tox_conference_new(Tox *tox, Tox_Err_Conference_New *error);

typedef enum Tox_Err_Conference_Delete {

    /**
     * The function returned successfully.
     */
    TOX_ERR_CONFERENCE_DELETE_OK,

    /**
     * The conference number passed did not designate a valid conference.
     */
    TOX_ERR_CONFERENCE_DELETE_CONFERENCE_NOT_FOUND,

} Tox_Err_Conference_Delete;


/**
 * @brief This function deletes a conference.
 *
 * @param conference_number The conference number of the conference to be deleted.
 *
 * @return true on success.
 */
bool tox_conference_delete(Tox *tox, uint32_t conference_number, Tox_Err_Conference_Delete *error);

/**
 * @brief Error codes for peer info queries.
 */
typedef enum Tox_Err_Conference_Peer_Query {

    /**
     * The function returned successfully.
     */
    TOX_ERR_CONFERENCE_PEER_QUERY_OK,

    /**
     * The conference number passed did not designate a valid conference.
     */
    TOX_ERR_CONFERENCE_PEER_QUERY_CONFERENCE_NOT_FOUND,

    /**
     * The peer number passed did not designate a valid peer.
     */
    TOX_ERR_CONFERENCE_PEER_QUERY_PEER_NOT_FOUND,

    /**
     * The client is not connected to the conference.
     */
    TOX_ERR_CONFERENCE_PEER_QUERY_NO_CONNECTION,

} Tox_Err_Conference_Peer_Query;


/**
 * @brief Return the number of online peers in the conference.
 *
 * The unsigned integers less than this number are the valid values of
 * peer_number for the functions querying these peers. Return value is
 * unspecified on failure.
 */
uint32_t tox_conference_peer_count(const Tox *tox, uint32_t conference_number, Tox_Err_Conference_Peer_Query *error);

/**
 * @brief Return the length of the peer's name.
 *
 * Return value is unspecified on failure.
 */
size_t tox_conference_peer_get_name_size(const Tox *tox, uint32_t conference_number, uint32_t peer_number,
        Tox_Err_Conference_Peer_Query *error);

/**
 * @brief Copy the name of peer_number who is in conference_number to name.
 *
 * Call tox_conference_peer_get_name_size to determine the allocation size for the `name` parameter.
 *
 * @param name A valid memory region large enough to store the peer's name.
 *
 * @return true on success.
 */
bool tox_conference_peer_get_name(const Tox *tox, uint32_t conference_number, uint32_t peer_number, uint8_t *name,
                                  Tox_Err_Conference_Peer_Query *error);

/**
 * @brief Copy the public key of peer_number who is in conference_number to public_key.
 *
 * public_key must be TOX_PUBLIC_KEY_SIZE long.
 *
 * @return true on success.
 */
bool tox_conference_peer_get_public_key(const Tox *tox, uint32_t conference_number, uint32_t peer_number,
                                        uint8_t *public_key, Tox_Err_Conference_Peer_Query *error);

/**
 * @brief Return true if passed peer_number corresponds to our own.
 */
bool tox_conference_peer_number_is_ours(const Tox *tox, uint32_t conference_number, uint32_t peer_number,
                                        Tox_Err_Conference_Peer_Query *error);

/**
 * @brief Return the number of offline peers in the conference.
 *
 * The unsigned integers less than this number are the valid values of
 * offline_peer_number for the functions querying these peers.
 *
 * Return value is unspecified on failure.
 */
uint32_t tox_conference_offline_peer_count(const Tox *tox, uint32_t conference_number,
        Tox_Err_Conference_Peer_Query *error);

/**
 * @brief Return the length of the offline peer's name.
 *
 * Return value is unspecified on failure.
 */
size_t tox_conference_offline_peer_get_name_size(const Tox *tox, uint32_t conference_number,
        uint32_t offline_peer_number, Tox_Err_Conference_Peer_Query *error);

/**
 * @brief Copy the name of offline_peer_number who is in conference_number to name.
 *
 * Call tox_conference_offline_peer_get_name_size to determine the allocation
 * size for the `name` parameter.
 *
 * @param name A valid memory region large enough to store the peer's name.
 *
 * @return true on success.
 */
bool tox_conference_offline_peer_get_name(const Tox *tox, uint32_t conference_number, uint32_t offline_peer_number,
        uint8_t *name, Tox_Err_Conference_Peer_Query *error);

/**
 * @brief Copy the public key of offline_peer_number who is in conference_number to public_key.
 *
 * public_key must be TOX_PUBLIC_KEY_SIZE long.
 *
 * @return true on success.
 */
bool tox_conference_offline_peer_get_public_key(const Tox *tox, uint32_t conference_number,
        uint32_t offline_peer_number, uint8_t *public_key, Tox_Err_Conference_Peer_Query *error);

/**
 * @brief Return a unix-time timestamp of the last time offline_peer_number was seen to be active.
 */
uint64_t tox_conference_offline_peer_get_last_active(const Tox *tox, uint32_t conference_number,
        uint32_t offline_peer_number, Tox_Err_Conference_Peer_Query *error);

typedef enum Tox_Err_Conference_Set_Max_Offline {

    /**
     * The function returned successfully.
     */
    TOX_ERR_CONFERENCE_SET_MAX_OFFLINE_OK,

    /**
     * The conference number passed did not designate a valid conference.
     */
    TOX_ERR_CONFERENCE_SET_MAX_OFFLINE_CONFERENCE_NOT_FOUND,

} Tox_Err_Conference_Set_Max_Offline;


/**
 * @brief Set maximum number of offline peers to store, overriding the default.
 */
bool tox_conference_set_max_offline(Tox *tox, uint32_t conference_number, uint32_t max_offline_peers,
                                    Tox_Err_Conference_Set_Max_Offline *error);

typedef enum Tox_Err_Conference_Invite {

    /**
     * The function returned successfully.
     */
    TOX_ERR_CONFERENCE_INVITE_OK,

    /**
     * The conference number passed did not designate a valid conference.
     */
    TOX_ERR_CONFERENCE_INVITE_CONFERENCE_NOT_FOUND,

    /**
     * The invite packet failed to send.
     */
    TOX_ERR_CONFERENCE_INVITE_FAIL_SEND,

    /**
     * The client is not connected to the conference.
     */
    TOX_ERR_CONFERENCE_INVITE_NO_CONNECTION,

} Tox_Err_Conference_Invite;


/**
 * @brief Invites a friend to a conference.
 *
 * @param friend_number The friend number of the friend we want to invite.
 * @param conference_number The conference number of the conference we want to invite the friend to.
 *
 * @return true on success.
 */
bool tox_conference_invite(Tox *tox, uint32_t friend_number, uint32_t conference_number,
                           Tox_Err_Conference_Invite *error);

typedef enum Tox_Err_Conference_Join {

    /**
     * The function returned successfully.
     */
    TOX_ERR_CONFERENCE_JOIN_OK,

    /**
     * The cookie passed has an invalid length.
     */
    TOX_ERR_CONFERENCE_JOIN_INVALID_LENGTH,

    /**
     * The conference is not the expected type. This indicates an invalid cookie.
     */
    TOX_ERR_CONFERENCE_JOIN_WRONG_TYPE,

    /**
     * The friend number passed does not designate a valid friend.
     */
    TOX_ERR_CONFERENCE_JOIN_FRIEND_NOT_FOUND,

    /**
     * Client is already in this conference.
     */
    TOX_ERR_CONFERENCE_JOIN_DUPLICATE,

    /**
     * Conference instance failed to initialize.
     */
    TOX_ERR_CONFERENCE_JOIN_INIT_FAIL,

    /**
     * The join packet failed to send.
     */
    TOX_ERR_CONFERENCE_JOIN_FAIL_SEND,

} Tox_Err_Conference_Join;


/**
 * @brief Joins a conference that the client has been invited to.
 *
 * After successfully joining the conference, the client will not be "connected"
 * to it until a handshaking procedure has been completed. A
 * `conference_connected` event will then occur for the conference. The client
 * will then remain connected to the conference until the conference is deleted,
 * even across core restarts. Many operations on a conference will fail with a
 * corresponding error if attempted on a conference to which the client is not
 * yet connected.
 *
 * @param friend_number The friend number of the friend who sent the invite.
 * @param cookie Received via the `conference_invite` event.
 * @param length The size of cookie.
 *
 * @return conference number on success, an unspecified value on failure.
 */
uint32_t tox_conference_join(Tox *tox, uint32_t friend_number, const uint8_t *cookie, size_t length,
                             Tox_Err_Conference_Join *error);

typedef enum Tox_Err_Conference_Send_Message {

    /**
     * The function returned successfully.
     */
    TOX_ERR_CONFERENCE_SEND_MESSAGE_OK,

    /**
     * The conference number passed did not designate a valid conference.
     */
    TOX_ERR_CONFERENCE_SEND_MESSAGE_CONFERENCE_NOT_FOUND,

    /**
     * The message is too long.
     */
    TOX_ERR_CONFERENCE_SEND_MESSAGE_TOO_LONG,

    /**
     * The client is not connected to the conference.
     */
    TOX_ERR_CONFERENCE_SEND_MESSAGE_NO_CONNECTION,

    /**
     * The message packet failed to send.
     */
    TOX_ERR_CONFERENCE_SEND_MESSAGE_FAIL_SEND,

} Tox_Err_Conference_Send_Message;


/**
 * @brief Send a text chat message to the conference.
 *
 * This function creates a conference message packet and pushes it into the send
 * queue.
 *
 * The message length may not exceed TOX_MAX_MESSAGE_LENGTH. Larger messages
 * must be split by the client and sent as separate messages. Other clients can
 * then reassemble the fragments.
 *
 * @param conference_number The conference number of the conference the message
 *   is intended for.
 * @param type Message type (normal, action, ...).
 * @param message A non-NULL pointer to the first element of a byte array
 *   containing the message text.
 * @param length Length of the message to be sent.
 *
 * @return true on success.
 */
bool tox_conference_send_message(Tox *tox, uint32_t conference_number, Tox_Message_Type type, const uint8_t *message,
                                 size_t length, Tox_Err_Conference_Send_Message *error);

typedef enum Tox_Err_Conference_Title {

    /**
     * The function returned successfully.
     */
    TOX_ERR_CONFERENCE_TITLE_OK,

    /**
     * The conference number passed did not designate a valid conference.
     */
    TOX_ERR_CONFERENCE_TITLE_CONFERENCE_NOT_FOUND,

    /**
     * The title is too long or empty.
     */
    TOX_ERR_CONFERENCE_TITLE_INVALID_LENGTH,

    /**
     * The title packet failed to send.
     */
    TOX_ERR_CONFERENCE_TITLE_FAIL_SEND,

} Tox_Err_Conference_Title;


/**
 * @brief Return the length of the conference title.
 *
 * Return value is unspecified on failure.
 *
 * The return value is equal to the `length` argument received by the last
 * `conference_title` callback.
 */
size_t tox_conference_get_title_size(const Tox *tox, uint32_t conference_number, Tox_Err_Conference_Title *error);

/**
 * @brief Write the title designated by the given conference number to a byte array.
 *
 * Call tox_conference_get_title_size to determine the allocation size for the `title` parameter.
 *
 * The data written to `title` is equal to the data received by the last
 * `conference_title` callback.
 *
 * @param title A valid memory region large enough to store the title.
 *   If this parameter is NULL, this function has no effect.
 *
 * @return true on success.
 */
bool tox_conference_get_title(const Tox *tox, uint32_t conference_number, uint8_t *title,
                              Tox_Err_Conference_Title *error);

/**
 * @brief Set the conference title and broadcast it to the rest of the conference.
 *
 * Title length cannot be longer than TOX_MAX_NAME_LENGTH.
 *
 * @return true on success.
 */
bool tox_conference_set_title(Tox *tox, uint32_t conference_number, const uint8_t *title, size_t length,
                              Tox_Err_Conference_Title *error);

/**
 * @brief Return the number of conferences in the Tox instance.
 *
 * This should be used to determine how much memory to allocate for `tox_conference_get_chatlist`.
 */
size_t tox_conference_get_chatlist_size(const Tox *tox);

/**
 * @brief Copy a list of valid conference numbers into the array chatlist.
 *
 * Determine how much space to allocate for the array with the
 * `tox_conference_get_chatlist_size` function.
 *
 * Note that `tox_get_savedata` saves all connected conferences;
 * when toxcore is created from savedata in which conferences were saved, those
 * conferences will be connected at startup, and will be listed by
 * `tox_conference_get_chatlist`.
 *
 * The conference number of a loaded conference may differ from the conference
 * number it had when it was saved.
 */
void tox_conference_get_chatlist(const Tox *tox, uint32_t *chatlist);

/**
 * @brief Returns the type of conference (Tox_Conference_Type) that conference_number is.
 *
 * Return value is unspecified on failure.
 */
typedef enum Tox_Err_Conference_Get_Type {

    /**
     * The function returned successfully.
     */
    TOX_ERR_CONFERENCE_GET_TYPE_OK,

    /**
     * The conference number passed did not designate a valid conference.
     */
    TOX_ERR_CONFERENCE_GET_TYPE_CONFERENCE_NOT_FOUND,

} Tox_Err_Conference_Get_Type;


/**
 * @brief Get the type (text or A/V) for the conference.
 */
Tox_Conference_Type tox_conference_get_type(const Tox *tox, uint32_t conference_number,
        Tox_Err_Conference_Get_Type *error);

/**
 * @brief Get the conference unique ID.
 *
 * If id is NULL, this function has no effect.
 *
 * @param id A memory region large enough to store TOX_CONFERENCE_ID_SIZE bytes.
 *
 * @return true on success.
 */
bool tox_conference_get_id(const Tox *tox, uint32_t conference_number, uint8_t *id);

typedef enum Tox_Err_Conference_By_Id {

    /**
     * The function returned successfully.
     */
    TOX_ERR_CONFERENCE_BY_ID_OK,

    /**
     * One of the arguments to the function was NULL when it was not expected.
     */
    TOX_ERR_CONFERENCE_BY_ID_NULL,

    /**
     * No conference with the given id exists on the conference list.
     */
    TOX_ERR_CONFERENCE_BY_ID_NOT_FOUND,

} Tox_Err_Conference_By_Id;


/**
 * @brief Return the conference number associated with the specified id.
 *
 * @param id A byte array containing the conference id (TOX_CONFERENCE_ID_SIZE).
 *
 * @return the conference number on success, an unspecified value on failure.
 */
uint32_t tox_conference_by_id(const Tox *tox, const uint8_t *id, Tox_Err_Conference_By_Id *error);

/**
 * @brief Get the conference unique ID.
 *
 * If uid is NULL, this function has no effect.
 *
 * @param uid A memory region large enough to store TOX_CONFERENCE_UID_SIZE bytes.
 *
 * @return true on success.
 * @deprecated use tox_conference_get_id instead (exactly the same function, just renamed).
 */
bool tox_conference_get_uid(const Tox *tox, uint32_t conference_number, uint8_t *uid);

typedef enum Tox_Err_Conference_By_Uid {

    /**
     * The function returned successfully.
     */
    TOX_ERR_CONFERENCE_BY_UID_OK,

    /**
     * One of the arguments to the function was NULL when it was not expected.
     */
    TOX_ERR_CONFERENCE_BY_UID_NULL,

    /**
     * No conference with the given uid exists on the conference list.
     */
    TOX_ERR_CONFERENCE_BY_UID_NOT_FOUND,

} Tox_Err_Conference_By_Uid;


/**
 * @brief Return the conference number associated with the specified uid.
 *
 * @param uid A byte array containing the conference id (TOX_CONFERENCE_UID_SIZE).
 *
 * @return the conference number on success, an unspecified value on failure.
 * @deprecated use tox_conference_by_id instead (exactly the same function, just renamed).
 */
uint32_t tox_conference_by_uid(const Tox *tox, const uint8_t *uid, Tox_Err_Conference_By_Uid *error);

/** @} */


/** @{
 * @name Low-level custom packet sending and receiving
 */

typedef enum Tox_Err_Friend_Custom_Packet {

    /**
     * The function returned successfully.
     */
    TOX_ERR_FRIEND_CUSTOM_PACKET_OK,

    /**
     * One of the arguments to the function was NULL when it was not expected.
     */
    TOX_ERR_FRIEND_CUSTOM_PACKET_NULL,

    /**
     * The friend number did not designate a valid friend.
     */
    TOX_ERR_FRIEND_CUSTOM_PACKET_FRIEND_NOT_FOUND,

    /**
     * This client is currently not connected to the friend.
     */
    TOX_ERR_FRIEND_CUSTOM_PACKET_FRIEND_NOT_CONNECTED,

    /**
     * The first byte of data was not one of the permitted values;
     * for lossy packets the first byte must be in the range 192-254,
     * and for lossless packets it must be either 69 or in the range 160-191.
     */
    TOX_ERR_FRIEND_CUSTOM_PACKET_INVALID,

    /**
     * Attempted to send an empty packet.
     */
    TOX_ERR_FRIEND_CUSTOM_PACKET_EMPTY,

    /**
     * Packet data length exceeded TOX_MAX_CUSTOM_PACKET_SIZE.
     */
    TOX_ERR_FRIEND_CUSTOM_PACKET_TOO_LONG,

    /**
     * Packet queue is full.
     */
    TOX_ERR_FRIEND_CUSTOM_PACKET_SENDQ,

} Tox_Err_Friend_Custom_Packet;


/**
 * @brief Send a custom lossy packet to a friend.
 *
 * The first byte of data must be in the range 192-254. Maximum length of a
 * custom packet is TOX_MAX_CUSTOM_PACKET_SIZE.
 *
 * Lossy packets behave like UDP packets, meaning they might never reach the
 * other side or might arrive more than once (if someone is messing with the
 * connection) or might arrive in the wrong order.
 *
 * Unless latency is an issue, it is recommended that you use lossless custom
 * packets instead.
 *
 * @param friend_number The friend number of the friend this lossy packet
 *   should be sent to.
 * @param data A byte array containing the packet data.
 * @param length The length of the packet data byte array.
 *
 * @return true on success.
 */
bool tox_friend_send_lossy_packet(Tox *tox, uint32_t friend_number, const uint8_t *data, size_t length,
                                  Tox_Err_Friend_Custom_Packet *error);

/**
 * @brief Send a custom lossless packet to a friend.
 *
 * The first byte of data must be either 69 or in the range 160-191. Maximum length of a
 * custom packet is TOX_MAX_CUSTOM_PACKET_SIZE.
 *
 * Lossless packet behaviour is comparable to TCP (reliability, arrive in order)
 * but with packets instead of a stream.
 *
 * @param friend_number The friend number of the friend this lossless packet
 *   should be sent to.
 * @param data A byte array containing the packet data.
 * @param length The length of the packet data byte array.
 *
 * @return true on success.
 */
bool tox_friend_send_lossless_packet(Tox *tox, uint32_t friend_number, const uint8_t *data, size_t length,
                                     Tox_Err_Friend_Custom_Packet *error);

/**
 * tox_callback_friend_lossy_packet is the compatibility function to
 * set callback for all packet IDs except those reserved for ToxAV
 *
 * @param friend_number The friend number of the friend who sent a lossy packet.
 * @param data A byte array containing the received packet data.
 * @param length The length of the packet data byte array.
 */
typedef void tox_friend_lossy_packet_cb(Tox *tox, uint32_t friend_number, const uint8_t *data, size_t length,
                                        void *user_data);


/**
 * @brief Set the callback for the `friend_lossy_packet` event.
 *
 * Pass NULL to unset.
 */
void tox_callback_friend_lossy_packet(Tox *tox, tox_friend_lossy_packet_cb *callback);

/**
 * @param friend_number The friend number of the friend who sent the packet.
 * @param data A byte array containing the received packet data.
 * @param length The length of the packet data byte array.
 */
typedef void tox_friend_lossless_packet_cb(Tox *tox, uint32_t friend_number, const uint8_t *data, size_t length,
        void *user_data);


/**
 * @brief Set the callback for the `friend_lossless_packet` event.
 *
 * Pass NULL to unset.
 */
void tox_callback_friend_lossless_packet(Tox *tox, tox_friend_lossless_packet_cb *callback);

/** @} */


/** @{
 * @name Low-level network information
 */

typedef enum Tox_Err_Get_Port {

    /**
     * The function returned successfully.
     */
    TOX_ERR_GET_PORT_OK,

    /**
     * The instance was not bound to any port.
     */
    TOX_ERR_GET_PORT_NOT_BOUND,

} Tox_Err_Get_Port;


/**
 * @brief Writes the temporary DHT public key of this instance to a byte array.
 *
 * This can be used in combination with an externally accessible IP address and
 * the bound port (from tox_self_get_udp_port) to run a temporary bootstrap node.
 *
 * Be aware that every time a new instance is created, the DHT public key
 * changes, meaning this cannot be used to run a permanent bootstrap node.
 *
 * @param dht_id A memory region of at least TOX_PUBLIC_KEY_SIZE bytes. If this
 *   parameter is NULL, this function has no effect.
 */
void tox_self_get_dht_id(const Tox *tox, uint8_t *dht_id);

/**
 * @brief Return the UDP port this Tox instance is bound to.
 */
uint16_t tox_self_get_udp_port(const Tox *tox, Tox_Err_Get_Port *error);

/**
 * @brief Return the TCP port this Tox instance is bound to.
 *
 * This is only relevant if the instance is acting as a TCP relay.
 */
uint16_t tox_self_get_tcp_port(const Tox *tox, Tox_Err_Get_Port *error);




/*******************************************************************************
 *
 * :: Message V2 functions
 *
 ******************************************************************************/
#define TOX_MESSAGE_V2_ACTIVE 1
/*
* sending
*/
uint32_t tox_messagev2_size(uint32_t text_length, uint32_t type, uint32_t alter_type);

// wrap a sync message
//         data_length                  length of the input data
//         original_sender_pubkey_bin   pubkey of original sender
//         data_msg_type                type of msg to wrap
//         raw_data                     input data of the msg to wrap
//         ts_sec                       unixtimestamp when message was sent (in seconds since epoch)
//         ts_ms                        unixtimestamp when message was sent (millisecond part)
//         raw_message                  filled buffer with the wrapped data of the message
//         msgid                        filled buffer of the message hash, exactly TOX_PUBLIC_KEY_SIZE byte long
// return: bool                         true -> if message was wrapped OK
bool tox_messagev2_sync_wrap(uint32_t data_length, const uint8_t *original_sender_pubkey_bin,
                             uint32_t data_msg_type,
                             const uint8_t *raw_data, uint32_t ts_sec,
                             uint16_t ts_ms, uint8_t *raw_message,
                             uint8_t *msgid);

// wrap a message
//         text_length      length of the input text
//         type             type of msg to wrap
//         alter_type       alter type of msg to wrap (only if it is an alter msg)
//         message_text     input text of the msg to wrap
//         ts_sec           uixtimestamp when message was sent (in seconds since epoch)
//         ts_ms            unixtimestamp when message was sent (millisecond part)
//         raw_message      filled buffer with the wrapped data of the message
//         msgid            filled buffer of the message hash, exactly TOX_PUBLIC_KEY_SIZE byte long
// return: bool             true -> if message was wrapped OK
bool tox_messagev2_wrap(uint32_t text_length, uint32_t type,
                        uint32_t alter_type,
                        const uint8_t *message_text, uint32_t ts_sec,
                        uint16_t ts_ms, uint8_t *raw_message,
                        uint8_t *msgid);
/*
* receiving
*/
bool tox_messagev2_get_message_id(const uint8_t *raw_message, uint8_t *msg_id);
bool tox_messagev2_get_message_alter_id(uint8_t *raw_message, uint8_t *alter_id);
bool tox_messagev2_get_sync_message_pubkey(const uint8_t *raw_message, uint8_t *pubkey);
uint32_t tox_messagev2_get_sync_message_type(const uint8_t *raw_message);
uint8_t tox_messagev2_get_alter_type(uint8_t *raw_message);
uint32_t tox_messagev2_get_ts_sec(const uint8_t *raw_message);
uint16_t tox_messagev2_get_ts_ms(const uint8_t *raw_message);
bool tox_messagev2_get_sync_message_data(const uint8_t *raw_message, uint32_t raw_message_len,
                                    uint8_t *data, uint32_t *data_length);
bool tox_messagev2_get_message_text(const uint8_t *raw_message, uint32_t raw_message_len,
                                    bool is_alter_msg,
                                    uint32_t alter_type, uint8_t *message_text,
                                    uint32_t *text_length);




/** @} */

/*******************************************************************************
 *
 * :: Group chats
 *
 ******************************************************************************/




/*******************************************************************************
 *
 * :: Group chat numeric constants
 *
 ******************************************************************************/



/** @{
 * Maximum length of a group topic.
 */
#define TOX_GROUP_MAX_TOPIC_LENGTH     512

uint32_t tox_group_max_topic_length(void);

/**
 * Maximum length of a peer part message.
 */
#define TOX_GROUP_MAX_PART_LENGTH      128

uint32_t tox_group_max_part_length(void);

/**
 * Maximum length of a group text message.
 */
#define TOX_GROUP_MAX_MESSAGE_LENGTH    1372

/**
 * Maximum length of a group name.
 */
#define TOX_GROUP_MAX_GROUP_NAME_LENGTH 48

uint32_t tox_group_max_group_name_length(void);

/**
 * Maximum length of a group password.
 */
#define TOX_GROUP_MAX_PASSWORD_SIZE    32

uint32_t tox_group_max_password_size(void);

/**
 * Number of bytes in a group Chat ID.
 */
#define TOX_GROUP_CHAT_ID_SIZE         32

uint32_t tox_group_chat_id_size(void);

/**
 * Size of a peer public key.
 */
#define TOX_GROUP_PEER_PUBLIC_KEY_SIZE 32

uint32_t tox_group_peer_public_key_size(void);


/*******************************************************************************
 *
 * :: Group chat state enumerators
 *
 ******************************************************************************/



/**
 * Represents the group privacy state.
 */
typedef enum Tox_Group_Privacy_State {

    /**
     * The group is considered to be public. Anyone may join the group using the Chat ID.
     *
     * If the group is in this state, even if the Chat ID is never explicitly shared
     * with someone outside of the group, information including the Chat ID, IP addresses,
     * and peer ID's (but not Tox ID's) is visible to anyone with access to a node
     * storing a DHT entry for the given group.
     */
    TOX_GROUP_PRIVACY_STATE_PUBLIC,

    /**
     * The group is considered to be private. The only way to join the group is by having
     * someone in your contact list send you an invite.
     *
     * If the group is in this state, no group information (mentioned above) is present in the DHT;
     * the DHT is not used for any purpose at all. If a public group is set to private,
     * all DHT information related to the group will expire shortly.
     */
    TOX_GROUP_PRIVACY_STATE_PRIVATE,

} Tox_Group_Privacy_State;


/**
 * Represents the state of the group topic lock.
 */
typedef enum Tox_Group_Topic_Lock {

    /**
     * The topic lock is enabled. Only peers with the founder and moderator roles may set the topic.
     */
    TOX_GROUP_TOPIC_LOCK_ENABLED,

    /**
     * The topic lock is disabled. All peers except those with the observer role may set the topic.
     */
    TOX_GROUP_TOPIC_LOCK_DISABLED,

} Tox_Group_Topic_Lock;

/**
 * Represents the group voice state, which determines which Group Roles have permission to speak
 * in the group chat. The voice state does not have any effect private messages or topic setting.
 */
typedef enum Tox_Group_Voice_State {
    /**
     * All group roles above Observer have permission to speak.
     */
    TOX_GROUP_VOICE_STATE_ALL,

    /**
     * Moderators and Founders have permission to speak.
     */
    TOX_GROUP_VOICE_STATE_MODERATOR,

    /**
     * Only the founder may speak.
     */
    TOX_GROUP_VOICE_STATE_FOUNDER,
} Tox_Group_Voice_State;

/**
 * Represents group roles.
 *
 * Roles are hierarchical in that each role has a set of privileges plus all the privileges
 * of the roles below it.
 */
typedef enum Tox_Group_Role {

    /**
     * May kick all other peers as well as set their role to anything (except founder).
     * Founders may also set the group password, toggle the privacy state, and set the peer limit.
     */
    TOX_GROUP_ROLE_FOUNDER,

    /**
     * May kick and set the user and observer roles for peers below this role.
     * May also set the group topic.
     */
    TOX_GROUP_ROLE_MODERATOR,

    /**
     * May communicate with other peers normally.
     */
    TOX_GROUP_ROLE_USER,

    /**
     * May observe the group and ignore peers; may not communicate with other peers or with the group.
     */
    TOX_GROUP_ROLE_OBSERVER,

} Tox_Group_Role;



/*******************************************************************************
 *
 * :: Group chat instance management
 *
 ******************************************************************************/


void tox_group_get_peer_connection_ip(const Tox *tox, uint32_t group_number, uint32_t peer_id, uint8_t *ip_str);


typedef enum Tox_Err_Group_New {

    /**
     * The function returned successfully.
     */
    TOX_ERR_GROUP_NEW_OK,

    /**
     * name exceeds TOX_MAX_NAME_LENGTH or group_name exceeded TOX_GROUP_MAX_GROUP_NAME_LENGTH.
     */
    TOX_ERR_GROUP_NEW_TOO_LONG,

    /**
     * name or group_name is NULL or length is zero.
     */
    TOX_ERR_GROUP_NEW_EMPTY,

    /**
     * The group instance failed to initialize.
     */
    TOX_ERR_GROUP_NEW_INIT,

    /**
     * The group state failed to initialize. This usually indicates that something went wrong
     * related to cryptographic signing.
     */
    TOX_ERR_GROUP_NEW_STATE,

    /**
     * The group failed to announce to the DHT. This indicates a network related error.
     */
    TOX_ERR_GROUP_NEW_ANNOUNCE,

} Tox_Err_Group_New;


/**
 * Creates a new group chat.
 *
 * This function creates a new group chat object and adds it to the chats array.
 *
 * The caller of this function has Founder role privileges.
 *
 * The client should initiate its peer list with self info after calling this function, as
 * the peer_join callback will not be triggered.
 *
 * @param privacy_state The privacy state of the group. If this is set to TOX_GROUP_PRIVACY_STATE_PUBLIC,
 *   the group will attempt to announce itself to the DHT and anyone with the Chat ID may join.
 *   Otherwise a friend invite will be required to join the group.
 * @param group_name The name of the group. The name must be non-NULL.
 * @param group_name_length The length of the group name. This must be greater than zero and no larger than
 *   TOX_GROUP_MAX_GROUP_NAME_LENGTH.
 * @param name The name of the peer creating the group.
 * @param name_length The length of the peer's name. This must be greater than zero and no larger
 *   than TOX_MAX_NAME_LENGTH.
 *
 * @return group_number on success, UINT32_MAX on failure.
 */
uint32_t tox_group_new(Tox *tox, Tox_Group_Privacy_State privacy_state, const uint8_t *group_name,
                       size_t group_name_length, const uint8_t *name, size_t name_length, Tox_Err_Group_New *error);

typedef enum Tox_Err_Group_Join {

    /**
     * The function returned successfully.
     */
    TOX_ERR_GROUP_JOIN_OK,

    /**
     * The group instance failed to initialize.
     */
    TOX_ERR_GROUP_JOIN_INIT,

    /**
     * The chat_id pointer is set to NULL or a group with chat_id already exists. This usually
     * happens if the client attempts to create multiple sessions for the same group.
     */
    TOX_ERR_GROUP_JOIN_BAD_CHAT_ID,

    /**
     * name is NULL or name_length is zero.
     */
    TOX_ERR_GROUP_JOIN_EMPTY,

    /**
     * name exceeds TOX_MAX_NAME_LENGTH.
     */
    TOX_ERR_GROUP_JOIN_TOO_LONG,

    /**
     * Failed to set password. This usually occurs if the password exceeds TOX_GROUP_MAX_PASSWORD_SIZE.
     */
    TOX_ERR_GROUP_JOIN_PASSWORD,

    /**
     * There was a core error when initiating the group.
     */
    TOX_ERR_GROUP_JOIN_CORE,

} Tox_Err_Group_Join;


/**
 * Joins a group chat with specified Chat ID.
 *
 * This function creates a new group chat object, adds it to the chats array, and sends
 * a DHT announcement to find peers in the group associated with chat_id. Once a peer has been
 * found a join attempt will be initiated.
 *
 * @param chat_id The Chat ID of the group you wish to join. This must be TOX_GROUP_CHAT_ID_SIZE bytes.
 * @param password The password required to join the group. Set to NULL if no password is required.
 * @param password_length The length of the password. If length is equal to zero,
 *   the password parameter is ignored. length must be no larger than TOX_GROUP_MAX_PASSWORD_SIZE.
 * @param name The name of the peer joining the group.
 * @param name_length The length of the peer's name. This must be greater than zero and no larger
 *   than TOX_MAX_NAME_LENGTH.
 *
 * @return group_number on success, UINT32_MAX on failure.
 */
uint32_t tox_group_join(Tox *tox, const uint8_t *chat_id, const uint8_t *name, size_t name_length,
                        const uint8_t *password, size_t password_length, Tox_Err_Group_Join *error);

typedef enum Tox_Err_Group_Is_Connected {

    /**
     * The function returned successfully.
     */
    TOX_ERR_GROUP_IS_CONNECTED_OK,

    /**
     * The group number passed did not designate a valid group.
     */
    TOX_ERR_GROUP_IS_CONNECTED_GROUP_NOT_FOUND,

} Tox_Err_Group_Is_Connected;


/**
 * Returns 1 if the group chat is currently connected or 0 when attempting to connect to other peers
 * in the group. Otherwise returns -1.
 *
 * @param group_number The group number of the designated group.
 */
int32_t tox_group_is_connected(const Tox *tox, uint32_t group_number, Tox_Err_Group_Is_Connected *error);

typedef enum Tox_Err_Group_Disconnect {

    /**
     * The function returned successfully.
     */
    TOX_ERR_GROUP_DISCONNECT_OK,

    /**
     * The group number passed did not designate a valid group.
     */
    TOX_ERR_GROUP_DISCONNECT_GROUP_NOT_FOUND,

    /**
     * The group is already disconnected.
     */
    TOX_ERR_GROUP_DISCONNECT_ALREADY_DISCONNECTED,
} Tox_Err_Group_Disconnect;


/**
 * Disconnects from a group chat while retaining the group state and credentials.
 *
 * Returns true if we successfully disconnect from the group.
 *
 * @param group_number The group number of the designated group.
 */
bool tox_group_disconnect(const Tox *tox, uint32_t group_number, Tox_Err_Group_Disconnect *error);

typedef enum Tox_Err_Group_Reconnect {

    /**
     * The function returned successfully.
     */
    TOX_ERR_GROUP_RECONNECT_OK,

    /**
     * The group number passed did not designate a valid group.
     */
    TOX_ERR_GROUP_RECONNECT_GROUP_NOT_FOUND,

    /**
     * There was a core error when initiating the group.
     */
    TOX_ERR_GROUP_RECONNECT_CORE,

} Tox_Err_Group_Reconnect;


/**
 * Reconnects to a group.
 *
 * This function disconnects from all peers in the group, then attempts to reconnect with the group.
 * The caller's state is not changed (i.e. name, status, role, chat public key etc.).
 *
 * @param group_number The group number of the group we wish to reconnect to.
 *
 * @return true on success.
 */
bool tox_group_reconnect(Tox *tox, uint32_t group_number, Tox_Err_Group_Reconnect *error);

typedef enum Tox_Err_Group_Leave {

    /**
     * The function returned successfully.
     */
    TOX_ERR_GROUP_LEAVE_OK,

    /**
     * The group number passed did not designate a valid group.
     */
    TOX_ERR_GROUP_LEAVE_GROUP_NOT_FOUND,

    /**
     * Message length exceeded TOX_GROUP_MAX_PART_LENGTH.
     */
    TOX_ERR_GROUP_LEAVE_TOO_LONG,

    /**
     * The parting packet failed to send.
     */
    TOX_ERR_GROUP_LEAVE_FAIL_SEND,
} Tox_Err_Group_Leave;


/**
 * Leaves a group.
 *
 * This function sends a parting packet containing a custom (non-obligatory) message to all
 * peers in a group, and deletes the group from the chat array. All group state information is permanently
 * lost, including keys and role credentials.
 *
 * @param group_number The group number of the group we wish to leave.
 * @param part_message The parting message to be sent to all the peers. Set to NULL if we do not wish to
 *   send a parting message.
 * @param length The length of the parting message. Set to 0 if we do not wish to send a parting message.
 *
 * @return true if the group chat instance is successfully deleted.
 */
bool tox_group_leave(Tox *tox, uint32_t group_number, const uint8_t *part_message, size_t length,
                     Tox_Err_Group_Leave *error);


/*******************************************************************************
 *
 * :: Group user-visible client information (nickname/status/role/public key)
 *
 ******************************************************************************/



/**
 * General error codes for self state get and size functions.
 */
typedef enum Tox_Err_Group_Self_Query {

    /**
     * The function returned successfully.
     */
    TOX_ERR_GROUP_SELF_QUERY_OK,

    /**
     * The group number passed did not designate a valid group.
     */
    TOX_ERR_GROUP_SELF_QUERY_GROUP_NOT_FOUND,

} Tox_Err_Group_Self_Query;


/**
 * Error codes for self name setting.
 */
typedef enum Tox_Err_Group_Self_Name_Set {

    /**
     * The function returned successfully.
     */
    TOX_ERR_GROUP_SELF_NAME_SET_OK,

    /**
     * The group number passed did not designate a valid group.
     */
    TOX_ERR_GROUP_SELF_NAME_SET_GROUP_NOT_FOUND,

    /**
     * Name length exceeded TOX_MAX_NAME_LENGTH.
     */
    TOX_ERR_GROUP_SELF_NAME_SET_TOO_LONG,

    /**
     * The length given to the set function is zero or name is a NULL pointer.
     */
    TOX_ERR_GROUP_SELF_NAME_SET_INVALID,

    /**
     * The packet failed to send.
     */
    TOX_ERR_GROUP_SELF_NAME_SET_FAIL_SEND,

} Tox_Err_Group_Self_Name_Set;


/**
 * Set the client's nickname for the group instance designated by the given group number.
 *
 * Nickname length cannot exceed TOX_MAX_NAME_LENGTH. If length is equal to zero or name is a NULL
 * pointer, the function call will fail.
 *
 * @param name A byte array containing the new nickname.
 * @param length The size of the name byte array.
 *
 * @return true on success.
 */
bool tox_group_self_set_name(const Tox *tox, uint32_t group_number, const uint8_t *name, size_t length,
                             Tox_Err_Group_Self_Name_Set *error);

/**
 * Return the length of the client's current nickname for the group instance designated
 * by group_number as passed to tox_group_self_set_name.
 *
 * If no nickname was set before calling this function, the name is empty,
 * and this function returns 0.
 *
 * @see threading for concurrency implications.
 */
size_t tox_group_self_get_name_size(const Tox *tox, uint32_t group_number, Tox_Err_Group_Self_Query *error);

/**
 * Write the nickname set by tox_group_self_set_name to a byte array.
 *
 * If no nickname was set before calling this function, the name is empty,
 * and this function has no effect.
 *
 * Call tox_group_self_get_name_size to find out how much memory to allocate for the result.
 *
 * @param name A valid memory location large enough to hold the nickname.
 *   If this parameter is NULL, the function has no effect.
 *
 * @return true on success.
 */
bool tox_group_self_get_name(const Tox *tox, uint32_t group_number, uint8_t *name, Tox_Err_Group_Self_Query *error);

/**
 * Error codes for self status setting.
 */
typedef enum Tox_Err_Group_Self_Status_Set {

    /**
     * The function returned successfully.
     */
    TOX_ERR_GROUP_SELF_STATUS_SET_OK,

    /**
     * The group number passed did not designate a valid group.
     */
    TOX_ERR_GROUP_SELF_STATUS_SET_GROUP_NOT_FOUND,

    /**
     * The packet failed to send.
     */
    TOX_ERR_GROUP_SELF_STATUS_SET_FAIL_SEND,

} Tox_Err_Group_Self_Status_Set;


/**
 * Set the client's status for the group instance. Status must be a Tox_User_Status.
 *
 * @return true on success.
 */
bool tox_group_self_set_status(const Tox *tox, uint32_t group_number, Tox_User_Status status,
                               Tox_Err_Group_Self_Status_Set *error);

/**
 * returns the client's status for the group instance on success.
 * return value is unspecified on failure.
 */
Tox_User_Status tox_group_self_get_status(const Tox *tox, uint32_t group_number, Tox_Err_Group_Self_Query *error);

/**
 * returns the client's role for the group instance on success.
 * return value is unspecified on failure.
 */
Tox_Group_Role tox_group_self_get_role(const Tox *tox, uint32_t group_number, Tox_Err_Group_Self_Query *error);

/**
 * returns the client's peer id for the group instance on success.
 * return value is unspecified on failure.
 */
uint32_t tox_group_self_get_peer_id(const Tox *tox, uint32_t group_number, Tox_Err_Group_Self_Query *error);

/**
 * Write the client's group public key designated by the given group number to a byte array.
 *
 * This key will be permanently tied to the client's identity for this particular group until
 * the client explicitly leaves the group. This key is the only way for other peers to reliably
 * identify the client across client restarts.
 *
 * `public_key` should have room for at least TOX_GROUP_PEER_PUBLIC_KEY_SIZE bytes.
 *
 * @param public_key A valid memory region large enough to store the public key.
 *   If this parameter is NULL, this function call has no effect.
 *
 * @return true on success.
 */
bool tox_group_self_get_public_key(const Tox *tox, uint32_t group_number, uint8_t *public_key,
                                   Tox_Err_Group_Self_Query *error);


/*******************************************************************************
 *
 * :: Peer-specific group state queries.
 *
 ******************************************************************************/



/**
 * Error codes for peer info queries.
 */
typedef enum Tox_Err_Group_Peer_Query {

    /**
     * The function returned successfully.
     */
    TOX_ERR_GROUP_PEER_QUERY_OK,

    /**
     * The group number passed did not designate a valid group.
     */
    TOX_ERR_GROUP_PEER_QUERY_GROUP_NOT_FOUND,

    /**
     * The ID passed did not designate a valid peer.
     */
    TOX_ERR_GROUP_PEER_QUERY_PEER_NOT_FOUND,

} Tox_Err_Group_Peer_Query;


uint32_t tox_group_peer_count(const Tox *tox, uint32_t group_number, Tox_Err_Group_Peer_Query *error);
uint32_t tox_group_offline_peer_count(const Tox *tox, uint32_t group_number, Tox_Err_Group_Peer_Query *error);

void tox_group_get_peerlist(const Tox *tox, uint32_t group_number, uint32_t *peerlist, Tox_Err_Group_Peer_Query *error);

/**
 * Return the length of the peer's name. If the group number or ID is invalid, the
 * return value is unspecified.
 *
 * @param group_number The group number of the group we wish to query.
 * @param peer_id The ID of the peer whose name length we want to retrieve.
 *
 * The return value is equal to the `length` argument received by the last
 * `group_peer_name` callback.
 */
size_t tox_group_peer_get_name_size(const Tox *tox, uint32_t group_number, uint32_t peer_id,
                                    Tox_Err_Group_Peer_Query *error);

/**
 * Write the name of the peer designated by the given ID to a byte
 * array.
 *
 * Call tox_group_peer_get_name_size to determine the allocation size for the `name` parameter.
 *
 * The data written to `name` is equal to the data received by the last
 * `group_peer_name` callback.
 *
 * @param group_number The group number of the group we wish to query.
 * @param peer_id The ID of the peer whose name we wish to retrieve.
 * @param name A valid memory region large enough to store the friend's name.
 *
 * @return true on success.
 */
bool tox_group_peer_get_name(const Tox *tox, uint32_t group_number, uint32_t peer_id, uint8_t *name,
                             Tox_Err_Group_Peer_Query *error);

/**
 * Return the peer's user status (away/busy/...). If the ID or group number is
 * invalid, the return value is unspecified.
 *
 * @param group_number The group number of the group we wish to query.
 * @param peer_id The ID of the peer whose status we wish to query.
 *
 * The status returned is equal to the last status received through the
 * `group_peer_status` callback.
 */
Tox_User_Status tox_group_peer_get_status(const Tox *tox, uint32_t group_number, uint32_t peer_id,
        Tox_Err_Group_Peer_Query *error);

/**
 * Return the peer's role (user/moderator/founder...). If the ID or group number is
 * invalid, the return value is unspecified.
 *
 * @param group_number The group number of the group we wish to query.
 * @param peer_id The ID of the peer whose role we wish to query.
 *
 * The role returned is equal to the last role received through the
 * `group_moderation` callback.
 */
Tox_Group_Role tox_group_peer_get_role(const Tox *tox, uint32_t group_number, uint32_t peer_id,
                                       Tox_Err_Group_Peer_Query *error);

/**
 * Return the type of connection we have established with a peer.
 *
 * If `peer_id` designates ourself, the return value indicates whether we're capable
 * of making UDP connections with other peers, or are limited to TCP connections.
 *
 * @param group_number The group number of the group we wish to query.
 * @param peer_id The ID of the peer whose connection status we wish to query.
 */
Tox_Connection tox_group_peer_get_connection_status(const Tox *tox, uint32_t group_number, uint32_t peer_id,
        Tox_Err_Group_Peer_Query *error);

/**
 * Write the group public key with the designated peer_id for the designated group number to public_key.
 *
 * This key will be permanently tied to a particular peer until they explicitly leave the group or
 * get kicked, and is the only way to reliably identify the same peer across client restarts.
 *
 * `public_key` should have room for at least TOX_GROUP_PEER_PUBLIC_KEY_SIZE bytes. If `public_key` is null
 * this function has no effect.
 *
 * @param group_number The group number of the group we wish to query.
 * @param peer_id The ID of the peer whose public key we wish to retrieve.
 * @param public_key A valid memory region large enough to store the public key.
 *   If this parameter is NULL, this function call has no effect.
 *
 * @return true on success.
 */
bool tox_group_peer_get_public_key(const Tox *tox, uint32_t group_number, uint32_t peer_id, uint8_t *public_key,
                                   Tox_Err_Group_Peer_Query *error);

bool tox_group_savedpeer_get_public_key(const Tox *tox, uint32_t group_number, uint32_t slot_number, uint8_t *public_key,
                                   Tox_Err_Group_Peer_Query *error);

/**
 * @brief Return the peer number associated with that NGC Peer Public Key.
 *
 * @return the peer number on success, an unspecified value on failure.
 * @param public_key A byte array containing the NGC Peer Public Key.
 */
uint32_t tox_group_peer_by_public_key(const Tox *tox, uint32_t group_number, const uint8_t *public_key, Tox_Err_Group_Peer_Query *error);



/**
 * @param group_number The group number of the group the name change is intended for.
 * @param peer_id The ID of the peer who has changed their name.
 * @param name The name data.
 * @param length The length of the name.
 */
typedef void tox_group_peer_name_cb(Tox *tox, uint32_t group_number, uint32_t peer_id, const uint8_t *name,
                                    size_t length, void *user_data);


/**
 * Set the callback for the `group_peer_name` event. Pass NULL to unset.
 *
 * This event is triggered when a peer changes their nickname.
 */
void tox_callback_group_peer_name(Tox *tox, tox_group_peer_name_cb *callback);

/**
 * @param group_number The group number of the group the status change is intended for.
 * @param peer_id The ID of the peer who has changed their status.
 * @param status The new status of the peer.
 */
typedef void tox_group_peer_status_cb(Tox *tox, uint32_t group_number, uint32_t peer_id, Tox_User_Status status,
                                      void *user_data);


/**
 * Set the callback for the `group_peer_status` event. Pass NULL to unset.
 *
 * This event is triggered when a peer changes their status.
 */
void tox_callback_group_peer_status(Tox *tox, tox_group_peer_status_cb *callback);

/**
 * @param group_number The group number of the group the status change is intended for.
 * @param status The connection status of the group.
 */
typedef void tox_group_connection_status_cb(Tox *tox, uint32_t group_number, int32_t status,
                                            void *user_data);


/**
 *
 * This event is triggered when a group changes it's status.
 */
void tox_callback_group_connection_status(Tox *tox, tox_group_connection_status_cb *callback);

/*******************************************************************************
 *
 * :: Group chat state queries and events.
 *
 ******************************************************************************/



/**
 * General error codes for group state get and size functions.
 */
typedef enum Tox_Err_Group_State_Queries {

    /**
     * The function returned successfully.
     */
    TOX_ERR_GROUP_STATE_QUERIES_OK,

    /**
     * The group number passed did not designate a valid group.
     */
    TOX_ERR_GROUP_STATE_QUERIES_GROUP_NOT_FOUND,

} Tox_Err_Group_State_Queries;


/**
 * Error codes for group topic setting.
 */
typedef enum Tox_Err_Group_Topic_Set {

    /**
     * The function returned successfully.
     */
    TOX_ERR_GROUP_TOPIC_SET_OK,

    /**
     * The group number passed did not designate a valid group.
     */
    TOX_ERR_GROUP_TOPIC_SET_GROUP_NOT_FOUND,

    /**
     * Topic length exceeded TOX_GROUP_MAX_TOPIC_LENGTH.
     */
    TOX_ERR_GROUP_TOPIC_SET_TOO_LONG,

    /**
     * The caller does not have the required permissions to set the topic.
     */
    TOX_ERR_GROUP_TOPIC_SET_PERMISSIONS,

    /**
     * The packet could not be created. This error is usually related to cryptographic signing.
     */
    TOX_ERR_GROUP_TOPIC_SET_FAIL_CREATE,

    /**
     * The packet failed to send.
     */
    TOX_ERR_GROUP_TOPIC_SET_FAIL_SEND,

    /**
     * The group is disconnected.
     */
    TOX_ERR_GROUP_TOPIC_SET_DISCONNECTED,

} Tox_Err_Group_Topic_Set;


/**
 * Set the group topic and broadcast it to the rest of the group.
 *
 * topic length cannot be longer than TOX_GROUP_MAX_TOPIC_LENGTH. If length is equal to zero or
 * topic is set to NULL, the topic will be unset.
 *
 * @return true on success.
 */
bool tox_group_set_topic(const Tox *tox, uint32_t group_number, const uint8_t *topic, size_t length,
                         Tox_Err_Group_Topic_Set *error);

/**
 * Return the length of the group topic. If the group number is invalid, the
 * return value is unspecified.
 *
 * The return value is equal to the `length` argument received by the last
 * `group_topic` callback.
 */
size_t tox_group_get_topic_size(const Tox *tox, uint32_t group_number, Tox_Err_Group_State_Queries *error);

/**
 * Write the topic designated by the given group number to a byte array.
 *
 * Call tox_group_get_topic_size to determine the allocation size for the `topic` parameter.
 *
 * The data written to `topic` is equal to the data received by the last
 * `group_topic` callback.
 *
 * @param topic A valid memory region large enough to store the topic.
 *   If this parameter is NULL, this function has no effect.
 *
 * @return true on success.
 */
bool tox_group_get_topic(const Tox *tox, uint32_t group_number, uint8_t *topic, Tox_Err_Group_State_Queries *error);

/**
 * @param group_number The group number of the group the topic change is intended for.
 * @param peer_id The ID of the peer who changed the topic. If the peer who set the topic
 *   is not present in our peer list this value will be set to 0.
 * @param topic The topic data.
 * @param length The topic length.
 */
typedef void tox_group_topic_cb(Tox *tox, uint32_t group_number, uint32_t peer_id, const uint8_t *topic, size_t length,
                                void *user_data);


/**
 * Set the callback for the `group_topic` event. Pass NULL to unset.
 *
 * This event is triggered when a peer changes the group topic.
 */
void tox_callback_group_topic(Tox *tox, tox_group_topic_cb *callback);

/**
 * Return the length of the group name. If the group number is invalid, the
 * return value is unspecified.
 */
size_t tox_group_get_name_size(const Tox *tox, uint32_t group_number, Tox_Err_Group_State_Queries *error);

/**
 * Write the name of the group designated by the given group number to a byte array.
 *
 * Call tox_group_get_name_size to determine the allocation size for the `name` parameter.
 *
 * @param group_name A valid memory region large enough to store the group name.
 *   If this parameter is NULL, this function call has no effect.
 *
 * @return true on success.
 */
bool tox_group_get_name(const Tox *tox, uint32_t group_number, uint8_t *group_name, Tox_Err_Group_State_Queries *error);

/**
 * Write the Chat ID designated by the given group number to a byte array.
 *
 * `chat_id` should have room for at least TOX_GROUP_CHAT_ID_SIZE bytes.
 *
 * @param chat_id A valid memory region large enough to store the Chat ID.
 *   If this parameter is NULL, this function call has no effect.
 *
 * @return true on success.
 */
bool tox_group_get_chat_id(const Tox *tox, uint32_t group_number, uint8_t *chat_id, Tox_Err_Group_State_Queries *error);

/**
 * Return the number of groups in the Tox chats array.
 */
uint32_t tox_group_get_number_groups(const Tox *tox);

/**
 * Return an array of valid groupnumbers
 *
 * grouplist array has to be tox_group_get_number_groups() of uint32_t in size.
 */
void tox_group_get_grouplist(const Tox *tox, uint32_t *grouplist);

uint32_t tox_group_by_chat_id(const Tox *tox, const uint8_t *chat_id, Tox_Err_Group_State_Queries *error);

/**
 * Return the privacy state of the group designated by the given group number. If group number
 * is invalid, the return value is unspecified.
 *
 * The value returned is equal to the data received by the last
 * `group_privacy_state` callback.
 *
 * @see the `Group chat founder controls` section for the respective set function.
 */
Tox_Group_Privacy_State tox_group_get_privacy_state(const Tox *tox, uint32_t group_number,
        Tox_Err_Group_State_Queries *error);

/**
 * @param group_number The group number of the group the privacy state is intended for.
 * @param privacy_state The new privacy state.
 */
typedef void tox_group_privacy_state_cb(Tox *tox, uint32_t group_number, Tox_Group_Privacy_State privacy_state,
                                        void *user_data);


/**
 * Set the callback for the `group_privacy_state` event. Pass NULL to unset.
 *
 * This event is triggered when the group founder changes the privacy state.
 */
void tox_callback_group_privacy_state(Tox *tox, tox_group_privacy_state_cb *callback);

/**
 * Return the voice state of the group designated by the given group number. If group number
 * is invalid, the return value is unspecified.
 *
 * The value returned is equal to the data received by the last `group_voice_state` callback.
 *
 * @see the `Group chat founder controls` section for the respective set function.
 */
Tox_Group_Voice_State tox_group_get_voice_state(const Tox *tox, uint32_t group_number,
        Tox_Err_Group_State_Queries *error);

/**
 * @param group_number The group number of the group the voice state change is intended for.
 * @param voice_state The new voice state.
 */
typedef void tox_group_voice_state_cb(Tox *tox, uint32_t group_number, Tox_Group_Voice_State voice_state,
                                      void *user_data);


/**
 * Set the callback for the `group_privacy_state` event. Pass NULL to unset.
 *
 * This event is triggered when the group founder changes the voice state.
 */
void tox_callback_group_voice_state(Tox *tox, tox_group_voice_state_cb *callback);

/**
 * Return the topic lock status of the group designated by the given group number. If group number
 * is invalid, the return value is unspecified.
 *
 * The value returned is equal to the data received by the last
 * `group_topic_lock` callback.
 *
 * @see the `Group chat founder contols` section for the respective set function.
 */
Tox_Group_Topic_Lock tox_group_get_topic_lock(const Tox *tox, uint32_t group_number,
        Tox_Err_Group_State_Queries *error);

/**
 * @param group_number The group number of the group for which the topic lock has changed.
 * @param topic_lock The new topic lock state.
 */
typedef void tox_group_topic_lock_cb(Tox *tox, uint32_t group_number, Tox_Group_Topic_Lock topic_lock, void *user_data);



/**
 * Set the callback for the `group_topic_lock` event. Pass NULL to unset.
 *
 * This event is triggered when the group founder changes the topic lock status.
 */
void tox_callback_group_topic_lock(Tox *tox, tox_group_topic_lock_cb *callback);

/**
 * Return the maximum number of peers allowed for the group designated by the given group number.
 * If the group number is invalid, the return value is unspecified.
 *
 * The value returned is equal to the data received by the last
 * `group_peer_limit` callback.
 *
 * @see the `Group chat founder controls` section for the respective set function.
 */
uint16_t tox_group_get_peer_limit(const Tox *tox, uint32_t group_number, Tox_Err_Group_State_Queries *error);

/**
 * @param group_number The group number of the group for which the peer limit has changed.
 * @param peer_limit The new peer limit for the group.
 */
typedef void tox_group_peer_limit_cb(Tox *tox, uint32_t group_number, uint32_t peer_limit, void *user_data);


/**
 * Set the callback for the `group_peer_limit` event. Pass NULL to unset.
 *
 * This event is triggered when the group founder changes the maximum peer limit.
 */
void tox_callback_group_peer_limit(Tox *tox, tox_group_peer_limit_cb *callback);

/**
 * Return the length of the group password. If the group number is invalid, the
 * return value is unspecified.
 */
size_t tox_group_get_password_size(const Tox *tox, uint32_t group_number, Tox_Err_Group_State_Queries *error);

/**
 * Write the password for the group designated by the given group number to a byte array.
 *
 * Call tox_group_get_password_size to determine the allocation size for the `password` parameter.
 *
 * The data received is equal to the data received by the last
 * `group_password` callback.
 *
 * @see the `Group chat founder controls` section for the respective set function.
 *
 * @param password A valid memory region large enough to store the group password.
 *   If this parameter is NULL, this function call has no effect.
 *
 * @return true on success.
 */
bool tox_group_get_password(const Tox *tox, uint32_t group_number, uint8_t *password,
                            Tox_Err_Group_State_Queries *error);

/**
 * @param group_number The group number of the group for which the password has changed.
 * @param password The new group password.
 * @param length The length of the password.
 */
typedef void tox_group_password_cb(Tox *tox, uint32_t group_number, const uint8_t *password, size_t length,
                                   void *user_data);


/**
 * Set the callback for the `group_password` event. Pass NULL to unset.
 *
 * This event is triggered when the group founder changes the group password.
 */
void tox_callback_group_password(Tox *tox, tox_group_password_cb *callback);


/*******************************************************************************
 *
 * :: Group chat message sending
 *
 ******************************************************************************/



typedef enum Tox_Err_Group_Send_Message {

    /**
     * The function returned successfully.
     */
    TOX_ERR_GROUP_SEND_MESSAGE_OK,

    /**
     * The group number passed did not designate a valid group.
     */
    TOX_ERR_GROUP_SEND_MESSAGE_GROUP_NOT_FOUND,

    /**
     * Message length exceeded TOX_GROUP_MAX_MESSAGE_LENGTH.
     */
    TOX_ERR_GROUP_SEND_MESSAGE_TOO_LONG,

    /**
     * The message pointer is null or length is zero.
     */
    TOX_ERR_GROUP_SEND_MESSAGE_EMPTY,

    /**
     * The message type is invalid.
     */
    TOX_ERR_GROUP_SEND_MESSAGE_BAD_TYPE,

    /**
     * The caller does not have the required permissions to send group messages.
     */
    TOX_ERR_GROUP_SEND_MESSAGE_PERMISSIONS,

    /**
     * Packet failed to send.
     */
    TOX_ERR_GROUP_SEND_MESSAGE_FAIL_SEND,

    /**
     * The group is disconnected.
     */
    TOX_ERR_GROUP_SEND_MESSAGE_DISCONNECTED,

} Tox_Err_Group_Send_Message;


/**
 * Send a text chat message to the group.
 *
 * This function creates a group message packet and pushes it into the send
 * queue.
 *
 * The message length may not exceed TOX_GROUP_MAX_MESSAGE_LENGTH. Larger messages
 * must be split by the client and sent as separate messages. Other clients can
 * then reassemble the fragments. Messages may not be empty.
 *
 * @param group_number The group number of the group the message is intended for.
 * @param type Message type (normal, action, ...).
 * @param message A non-NULL pointer to the first element of a byte array
 *   containing the message text.
 * @param length Length of the message to be sent.
 * @param message_id A pointer to a uint32_t. The message_id of this message will be returned
 *   unless the parameter is NULL, in which case the returned parameter value will be undefined.
 *   If this function returns false the returned parameter `message_id` value will also be undefined.
 *
 * @return true on success.
 */
bool tox_group_send_message(const Tox *tox, uint32_t group_number, Tox_Message_Type type, const uint8_t *message,
                            size_t length, uint32_t *message_id, Tox_Err_Group_Send_Message *error);

typedef enum Tox_Err_Group_Send_Private_Message {

    /**
     * The function returned successfully.
     */
    TOX_ERR_GROUP_SEND_PRIVATE_MESSAGE_OK,

    /**
     * The group number passed did not designate a valid group.
     */
    TOX_ERR_GROUP_SEND_PRIVATE_MESSAGE_GROUP_NOT_FOUND,

    /**
     * The peer ID passed did not designate a valid peer.
     */
    TOX_ERR_GROUP_SEND_PRIVATE_MESSAGE_PEER_NOT_FOUND,

    /**
     * Message length exceeded TOX_GROUP_MAX_MESSAGE_LENGTH.
     */
    TOX_ERR_GROUP_SEND_PRIVATE_MESSAGE_TOO_LONG,

    /**
     * The message pointer is null or length is zero.
     */
    TOX_ERR_GROUP_SEND_PRIVATE_MESSAGE_EMPTY,

    /**
     * The caller does not have the required permissions to send group messages.
     */
    TOX_ERR_GROUP_SEND_PRIVATE_MESSAGE_PERMISSIONS,

    /**
     * Packet failed to send.
     */
    TOX_ERR_GROUP_SEND_PRIVATE_MESSAGE_FAIL_SEND,

    /**
     * The group is disconnected.
     */
    TOX_ERR_GROUP_SEND_PRIVATE_MESSAGE_DISCONNECTED,

    /**
     * The message type is invalid.
     */
    TOX_ERR_GROUP_SEND_PRIVATE_MESSAGE_BAD_TYPE,

} Tox_Err_Group_Send_Private_Message;


/**
 * Send a text chat message to the specified peer in the specified group.
 *
 * This function creates a group private message packet and pushes it into the send
 * queue.
 *
 * The message length may not exceed TOX_GROUP_MAX_MESSAGE_LENGTH. Larger messages
 * must be split by the client and sent as separate messages. Other clients can
 * then reassemble the fragments. Messages may not be empty.
 *
 * @param group_number The group number of the group the message is intended for.
 * @param peer_id The ID of the peer the message is intended for.
 * @param message A non-NULL pointer to the first element of a byte array
 *   containing the message text.
 * @param length Length of the message to be sent.
 *
 * @return true on success.
 */
bool tox_group_send_private_message(const Tox *tox, uint32_t group_number, uint32_t peer_id, Tox_Message_Type type,
                                    const uint8_t *message, size_t length, Tox_Err_Group_Send_Private_Message *error);

/**
 * Send a text chat message to the specified peer in the specified group.
 *
 * This function creates a group private packet and pushes it into the send
 * queue.
 *
 * The message length may not exceed TOX_GROUP_MAX_MESSAGE_LENGTH. Larger messages
 * must be split by the client and sent as separate messages. Other clients can
 * then reassemble the fragments. Messages may not be empty.
 *
 * @param group_number The group number of the group the message is intended for.
 * @param public_key A memory region of at least TOX_PUBLIC_KEY_SIZE bytes of the peer the
 *   message is intended for. If this parameter is NULL, this function will return false.
 * @param message A non-NULL pointer to the first element of a byte array
 *   containing the message text.
 * @param length Length of the message to be sent.
 *
 * @return true on success.
 */
bool tox_group_send_private_message_by_peerpubkey(const Tox *tox, uint32_t group_number, const uint8_t *public_key,
                                    Tox_Message_Type type, const uint8_t *message, size_t length,
                                    Tox_Err_Group_Send_Private_Message *error);

typedef enum Tox_Err_Group_Send_Custom_Packet {

    /**
     * The function returned successfully.
     */
    TOX_ERR_GROUP_SEND_CUSTOM_PACKET_OK,

    /**
     * The group number passed did not designate a valid group.
     */
    TOX_ERR_GROUP_SEND_CUSTOM_PACKET_GROUP_NOT_FOUND,

    /**
     * Message length exceeded TOX_GROUP_MAX_MESSAGE_LENGTH.
     */
    TOX_ERR_GROUP_SEND_CUSTOM_PACKET_TOO_LONG,

    /**
     * The message pointer is null or length is zero.
     */
    TOX_ERR_GROUP_SEND_CUSTOM_PACKET_EMPTY,

    /**
     * The caller does not have the required permissions to send group messages.
     */
    TOX_ERR_GROUP_SEND_CUSTOM_PACKET_PERMISSIONS,

    /**
     * The group is disconnected.
     */
    TOX_ERR_GROUP_SEND_CUSTOM_PACKET_DISCONNECTED,

} Tox_Err_Group_Send_Custom_Packet;


/**
 * Send a custom packet to the group.
 *
 * If lossless is true the packet will be lossless. Lossless packet behaviour is comparable
 * to TCP (reliability, arrive in order) but with packets instead of a stream.
 *
 * If lossless is false, the packet will be lossy. Lossy packets behave like UDP packets,
 * meaning they might never reach the other side or might arrive more than once (if someone
 * is messing with the connection) or might arrive in the wrong order.
 *
 * Unless latency is an issue or message reliability is not important, it is recommended that you use
 * lossless packets.
 *
 * The message length may not exceed TOX_MAX_CUSTOM_PACKET_SIZE. Larger packets
 * must be split by the client and sent as separate packets. Other clients can
 * then reassemble the fragments. Packets may not be empty.
 *
 * @param group_number The group number of the group the packet is intended for.
 * @param lossless True if the packet should be lossless.
 * @param data A byte array containing the packet data.
 * @param length The length of the packet data byte array.
 *
 * @return true on success.
 */
bool tox_group_send_custom_packet(const Tox *tox, uint32_t group_number, bool lossless, const uint8_t *data,
                                  size_t length,
                                  Tox_Err_Group_Send_Custom_Packet *error);


typedef enum Tox_Err_Group_Send_Custom_Private_Packet {

    /**
     * The function returned successfully.
     */
    TOX_ERR_GROUP_SEND_CUSTOM_PRIVATE_PACKET_OK,

    /**
     * The group number passed did not designate a valid group.
     */
    TOX_ERR_GROUP_SEND_CUSTOM_PRIVATE_PACKET_GROUP_NOT_FOUND,

    /**
     * Message length exceeded TOX_MAX_CUSTOM_PACKET_SIZE.
     */
    TOX_ERR_GROUP_SEND_CUSTOM_PRIVATE_PACKET_TOO_LONG,

    /**
     * The message pointer is null or length is zero.
     */
    TOX_ERR_GROUP_SEND_CUSTOM_PRIVATE_PACKET_EMPTY,

    /**
     * The peer ID passed did no designate a valid peer.
     */
    TOX_ERR_GROUP_SEND_CUSTOM_PRIVATE_PACKET_PEER_NOT_FOUND,

    /**
     * The caller does not have the required permissions to send group messages.
     */
    TOX_ERR_GROUP_SEND_CUSTOM_PRIVATE_PACKET_PERMISSIONS,

    /**
     * The packet failed to send.
     */
    TOX_ERR_GROUP_SEND_CUSTOM_PRIVATE_PACKET_FAIL_SEND,

    /**
     * The group is disconnected.
     */
    TOX_ERR_GROUP_SEND_CUSTOM_PRIVATE_PACKET_DISCONNECTED,

} Tox_Err_Group_Send_Custom_Private_Packet;

/**
 * Send a custom private packet to a designated peer in the group.
 *
 * If lossless is true the packet will be lossless. Lossless packet behaviour is comparable
 * to TCP (reliability, arrive in order) but with packets instead of a stream.
 *
 * If lossless is false, the packet will be lossy. Lossy packets behave like UDP packets,
 * meaning they might never reach the other side or might arrive more than once (if someone
 * is messing with the connection) or might arrive in the wrong order.
 *
 * Unless latency is an issue or message reliability is not important, it is recommended that you use
 * lossless packets.
 *
 * The packet length may not exceed TOX_MAX_CUSTOM_PACKET_SIZE. Larger packets
 * must be split by the client and sent as separate packets. Other clients can
 * then reassemble the fragments. Packets may not be empty.
 *
 * @param group_number The group number of the group the packet is intended for.
 * @param peer_id The ID of the peer the packet is intended for.
 * @param lossless True if the packet should be lossless.
 * @param data A byte array containing the packet data.
 * @param length The length of the packet data byte array.
 *
 * @return true on success.
 */
bool tox_group_send_custom_private_packet(const Tox *tox, uint32_t group_number, uint32_t peer_id, bool lossless,
        const uint8_t *data, size_t length,
        Tox_Err_Group_Send_Custom_Private_Packet *error);


/*******************************************************************************
 *
 * :: Group chat message receiving
 *
 ******************************************************************************/



/**
 * @param group_number The group number of the group the message is intended for.
 * @param peer_id The ID of the peer who sent the message.
 * @param type The type of message (normal, action, ...).
 * @param message The message data.
 * @param message_id A pseudo message id that clients can use to uniquely identify this group message.
 * @param length The length of the message.
 */
typedef void tox_group_message_cb(Tox *tox, uint32_t group_number, uint32_t peer_id, Tox_Message_Type type,
                                  const uint8_t *message, size_t length, uint32_t message_id, void *user_data);


/**
 * Set the callback for the `group_message` event. Pass NULL to unset.
 *
 * This event is triggered when the client receives a group message.
 */
void tox_callback_group_message(Tox *tox, tox_group_message_cb *callback);

/**
 * @param group_number The group number of the group the private message is intended for.
 * @param peer_id The ID of the peer who sent the private message.
 * @param message The message data.
 * @param length The length of the message.
 */
typedef void tox_group_private_message_cb(Tox *tox, uint32_t group_number, uint32_t peer_id, Tox_Message_Type type,
        const uint8_t *message, size_t length, void *user_data);


/**
 * Set the callback for the `group_private_message` event. Pass NULL to unset.
 *
 * This event is triggered when the client receives a private message.
 */
void tox_callback_group_private_message(Tox *tox, tox_group_private_message_cb *callback);

/**
 * @param group_number The group number of the group the packet is intended for.
 * @param peer_id The ID of the peer who sent the packet.
 * @param data The packet data.
 * @param length The length of the data.
 */
typedef void tox_group_custom_packet_cb(Tox *tox, uint32_t group_number, uint32_t peer_id, const uint8_t *data,
                                        size_t length, void *user_data);


/**
 * Set the callback for the `group_custom_packet` event. Pass NULL to unset.
 *
 * This event is triggered when the client receives a custom packet.
 */
void tox_callback_group_custom_packet(Tox *tox, tox_group_custom_packet_cb *callback);

/**
 * @param group_number The group number of the group the packet is intended for.
 * @param peer_id The ID of the peer who sent the packet.
 * @param data The packet data.
 * @param length The length of the data.
 */
typedef void tox_group_custom_private_packet_cb(Tox *tox, uint32_t group_number, uint32_t peer_id, const uint8_t *data,
        size_t length, void *user_data);


/**
 * Set the callback for the `group_custom_private_packet` event. Pass NULL to unset.
 *
 * This event is triggered when the client receives a custom private packet.
 */
void tox_callback_group_custom_private_packet(Tox *tox, tox_group_custom_private_packet_cb *callback);


/*******************************************************************************
 *
 * :: Group chat inviting and join/part events
 *
 ******************************************************************************/



typedef enum Tox_Err_Group_Invite_Friend {

    /**
     * The function returned successfully.
     */
    TOX_ERR_GROUP_INVITE_FRIEND_OK,

    /**
     * The group number passed did not designate a valid group.
     */
    TOX_ERR_GROUP_INVITE_FRIEND_GROUP_NOT_FOUND,

    /**
     * The friend number passed did not designate a valid friend.
     */
    TOX_ERR_GROUP_INVITE_FRIEND_FRIEND_NOT_FOUND,

    /**
     * Creation of the invite packet failed. This indicates a network related error.
     */
    TOX_ERR_GROUP_INVITE_FRIEND_INVITE_FAIL,

    /**
     * Packet failed to send.
     */
    TOX_ERR_GROUP_INVITE_FRIEND_FAIL_SEND,

    /**
     * The group is disconnected.
     */
    TOX_ERR_GROUP_INVITE_FRIEND_DISCONNECTED,

} Tox_Err_Group_Invite_Friend;


/**
 * Invite a friend to a group.
 *
 * This function creates an invite request packet and pushes it to the send queue.
 *
 * @param group_number The group number of the group the message is intended for.
 * @param friend_number The friend number of the friend the invite is intended for.
 *
 * @return true on success.
 */
bool tox_group_invite_friend(const Tox *tox, uint32_t group_number, uint32_t friend_number,
                             Tox_Err_Group_Invite_Friend *error);

typedef enum Tox_Err_Group_Invite_Accept {

    /**
     * The function returned successfully.
     */
    TOX_ERR_GROUP_INVITE_ACCEPT_OK,

    /**
     * The invite data is not in the expected format.
     */
    TOX_ERR_GROUP_INVITE_ACCEPT_BAD_INVITE,

    /**
     * The group instance failed to initialize.
     */
    TOX_ERR_GROUP_INVITE_ACCEPT_INIT_FAILED,

    /**
     * name exceeds TOX_MAX_NAME_LENGTH
     */
    TOX_ERR_GROUP_INVITE_ACCEPT_TOO_LONG,

    /**
     * name is NULL or name_length is zero.
     */
    TOX_ERR_GROUP_INVITE_ACCEPT_EMPTY,

    /**
     * Failed to set password. This usually occurs if the password exceeds TOX_GROUP_MAX_PASSWORD_SIZE.
     */
    TOX_ERR_GROUP_INVITE_ACCEPT_PASSWORD,

    /**
     * There was a core error when initiating the group.
     */
    TOX_ERR_GROUP_INVITE_ACCEPT_CORE,

    /**
     * Packet failed to send.
     */
    TOX_ERR_GROUP_INVITE_ACCEPT_FAIL_SEND,

} Tox_Err_Group_Invite_Accept;


/**
 * Accept an invite to a group chat that the client previously received from a friend. The invite
 * is only valid while the inviter is present in the group.
 *
 * @param invite_data The invite data received from the `group_invite` event.
 * @param length The length of the invite data.
 * @param name The name of the peer joining the group.
 * @param name_length The length of the peer's name. This must be greater than zero and no larger
 *   than TOX_MAX_NAME_LENGTH.
 * @param password The password required to join the group. Set to NULL if no password is required.
 * @param password_length The length of the password. If password_length is equal to zero, the password
 *   parameter will be ignored. password_length must be no larger than TOX_GROUP_MAX_PASSWORD_SIZE.
 *
 * @return the group_number on success, UINT32_MAX on failure.
 */
uint32_t tox_group_invite_accept(Tox *tox, uint32_t friend_number, const uint8_t *invite_data, size_t length,
                                 const uint8_t *name, size_t name_length, const uint8_t *password, size_t password_length,
                                 Tox_Err_Group_Invite_Accept *error);

/**
 * @param friend_number The friend number of the contact who sent the invite.
 * @param invite_data The invite data.
 * @param length The length of invite_data.
 */
typedef void tox_group_invite_cb(Tox *tox, uint32_t friend_number, const uint8_t *invite_data, size_t length,
                                 const uint8_t *group_name, size_t group_name_length, void *user_data);


/**
 * Set the callback for the `group_invite` event. Pass NULL to unset.
 *
 * This event is triggered when the client receives a group invite from a friend. The client must store
 * invite_data which is used to join the group via tox_group_invite_accept.
 */
void tox_callback_group_invite(Tox *tox, tox_group_invite_cb *callback);

/**
 * @param group_number The group number of the group in which a new peer has joined.
 * @param peer_id The permanent ID of the new peer. This id should not be relied on for
 * client behaviour and should be treated as a random value.
 */
typedef void tox_group_peer_join_cb(Tox *tox, uint32_t group_number, uint32_t peer_id, void *user_data);


/**
 * Set the callback for the `group_peer_join` event. Pass NULL to unset.
 *
 * This event is triggered when a peer other than self joins the group.
 */
void tox_callback_group_peer_join(Tox *tox, tox_group_peer_join_cb *callback);

/**
 * Represents peer exit events. These should be used with the `group_peer_exit` event.
 */
typedef enum Tox_Group_Exit_Type {

    /**
     * The peer has quit the group.
     */
    TOX_GROUP_EXIT_TYPE_QUIT,

    /**
     * Your connection with this peer has timed out.
     */
    TOX_GROUP_EXIT_TYPE_TIMEOUT,

    /**
     * Your connection with this peer has been severed.
     */
    TOX_GROUP_EXIT_TYPE_DISCONNECTED,

    /**
     * Your connection with all peers has been severed. This will occur when you are kicked from
     * a group, rejoin a group, or manually disconnect from a group.
     */
    TOX_GROUP_EXIT_TYPE_SELF_DISCONNECTED,

    /**
     * The peer has been kicked.
     */
    TOX_GROUP_EXIT_TYPE_KICK,

    /**
     * The peer provided invalid group sync information.
     */
    TOX_GROUP_EXIT_TYPE_SYNC_ERROR,

} Tox_Group_Exit_Type;


/**
 * @param group_number The group number of the group in which a peer has left.
 * @param peer_id The ID of the peer who left the group. This ID no longer designates a valid peer
 *   and cannot be used for API calls.
 * @param exit_type The type of exit event. One of Tox_Group_Exit_Type.
 * @param name The nickname of the peer who left the group.
 * @param name_length The length of the peer name.
 * @param part_message The parting message data.
 * @param part_message_length The length of the parting message.
 */
typedef void tox_group_peer_exit_cb(Tox *tox, uint32_t group_number, uint32_t peer_id, Tox_Group_Exit_Type exit_type,
                                    const uint8_t *name, size_t name_length, const uint8_t *part_message, size_t part_message_length, void *user_data);


/**
 * Set the callback for the `group_peer_exit` event. Pass NULL to unset.
 *
 * This event is triggered when a peer other than self exits the group.
 */
void tox_callback_group_peer_exit(Tox *tox, tox_group_peer_exit_cb *callback);

/**
 * @param group_number The group number of the group that the client has joined.
 */
typedef void tox_group_self_join_cb(Tox *tox, uint32_t group_number, void *user_data);


/**
 * Set the callback for the `group_self_join` event. Pass NULL to unset.
 *
 * This event is triggered when the client has successfully joined a group. Use this to initialize
 * any group information the client may need.
 */
void tox_callback_group_self_join(Tox *tox, tox_group_self_join_cb *callback);

/**
 * Represents types of failed group join attempts. These are used in the tox_callback_group_rejected
 * callback when a peer fails to join a group.
 */
typedef enum Tox_Group_Join_Fail {

    /**
     * The group peer limit has been reached.
     */
    TOX_GROUP_JOIN_FAIL_PEER_LIMIT,

    /**
     * You have supplied an invalid password.
     */
    TOX_GROUP_JOIN_FAIL_INVALID_PASSWORD,

    /**
     * The join attempt failed due to an unspecified error. This often occurs when the group is
     * not found in the DHT.
     */
    TOX_GROUP_JOIN_FAIL_UNKNOWN,

} Tox_Group_Join_Fail;


/**
 * @param group_number The group number of the group for which the join has failed.
 * @param fail_type The type of group rejection.
 */
typedef void tox_group_join_fail_cb(Tox *tox, uint32_t group_number, Tox_Group_Join_Fail fail_type, void *user_data);


/**
 * Set the callback for the `group_join_fail` event. Pass NULL to unset.
 *
 * This event is triggered when the client fails to join a group.
 */
void tox_callback_group_join_fail(Tox *tox, tox_group_join_fail_cb *callback);


/*******************************************************************************
 *
 * :: Group chat founder controls (these only work for the group founder)
 *
 ******************************************************************************/



typedef enum Tox_Err_Group_Founder_Set_Password {

    /**
     * The function returned successfully.
     */
    TOX_ERR_GROUP_FOUNDER_SET_PASSWORD_OK,

    /**
     * The group number passed did not designate a valid group.
     */
    TOX_ERR_GROUP_FOUNDER_SET_PASSWORD_GROUP_NOT_FOUND,

    /**
     * The caller does not have the required permissions to set the password.
     */
    TOX_ERR_GROUP_FOUNDER_SET_PASSWORD_PERMISSIONS,

    /**
     * Password length exceeded TOX_GROUP_MAX_PASSWORD_SIZE.
     */
    TOX_ERR_GROUP_FOUNDER_SET_PASSWORD_TOO_LONG,

    /**
     * The packet failed to send.
     */
    TOX_ERR_GROUP_FOUNDER_SET_PASSWORD_FAIL_SEND,

    /**
     * The function failed to allocate enough memory for the operation.
     */
    TOX_ERR_GROUP_FOUNDER_SET_PASSWORD_MALLOC,

    /**
     * The group is disconnected.
     */
    TOX_ERR_GROUP_FOUNDER_SET_PASSWORD_DISCONNECTED,

} Tox_Err_Group_Founder_Set_Password;


/**
 * Set or unset the group password.
 *
 * This function sets the groups password, creates a new group shared state including the change,
 * and distributes it to the rest of the group.
 *
 * @param group_number The group number of the group for which we wish to set the password.
 * @param password The password we want to set. Set password to NULL to unset the password.
 * @param length The length of the password. length must be no longer than TOX_GROUP_MAX_PASSWORD_SIZE.
 *
 * @return true on success.
 */
bool tox_group_founder_set_password(const Tox *tox, uint32_t group_number, const uint8_t *password, size_t length,
                                    Tox_Err_Group_Founder_Set_Password *error);

typedef enum Tox_Err_Group_Founder_Set_Topic_Lock {

    /**
     * The function returned successfully.
     */
    TOX_ERR_GROUP_FOUNDER_SET_TOPIC_LOCK_OK,

    /**
     * The group number passed did not designate a valid group.
     */
    TOX_ERR_GROUP_FOUNDER_SET_TOPIC_LOCK_GROUP_NOT_FOUND,

    /**
     * Tox_Group_Topic_Lock is an invalid type.
     */
    TOX_ERR_GROUP_FOUNDER_SET_TOPIC_LOCK_INVALID,

    /**
     * The caller does not have the required permissions to set the topic lock.
     */
    TOX_ERR_GROUP_FOUNDER_SET_TOPIC_LOCK_PERMISSIONS,

    /**
     * The topic lock could not be set. This may occur due to an error related to
     * cryptographic signing of the new shared state.
     */
    TOX_ERR_GROUP_FOUNDER_SET_TOPIC_LOCK_FAIL_SET,

    /**
     * The packet failed to send.
     */
    TOX_ERR_GROUP_FOUNDER_SET_TOPIC_LOCK_FAIL_SEND,

    /**
     * The group is disconnected.
     */
    TOX_ERR_GROUP_FOUNDER_SET_TOPIC_LOCK_DISCONNECTED,

} Tox_Err_Group_Founder_Set_Topic_Lock;


/**
 * Set the group topic lock state.
 *
 * This function sets the group's topic lock state to enabled or disabled, creates a new shared
 * state including the change, and distributes it to the rest of the group.
 *
 * When the topic lock is enabled, only the group founder and moderators may set the topic.
 * When disabled, all peers except those with the observer role may set the topic.
 *
 * @param group_number The group number of the group for which we wish to change the topic lock state.
 * @param topic_lock The state we wish to set the topic lock to.
 *
 * @return true on success.
 */
bool tox_group_founder_set_topic_lock(const Tox *tox, uint32_t group_number, Tox_Group_Topic_Lock topic_lock,
                                      Tox_Err_Group_Founder_Set_Topic_Lock *error);

typedef enum Tox_Err_Group_Founder_Set_Voice_State {

    /**
     * The function returned successfully.
     */
    TOX_ERR_GROUP_FOUNDER_SET_VOICE_STATE_OK,

    /**
     * The group number passed did not designate a valid group.
     */
    TOX_ERR_GROUP_FOUNDER_SET_VOICE_STATE_GROUP_NOT_FOUND,

    /**
     * The caller does not have the required permissions to set the privacy state.
     */
    TOX_ERR_GROUP_FOUNDER_SET_VOICE_STATE_PERMISSIONS,

    /**
     * The voice state could not be set. This may occur due to an error related to
     * cryptographic signing of the new shared state.
     */
    TOX_ERR_GROUP_FOUNDER_SET_VOICE_STATE_FAIL_SET,

    /**
     * The packet failed to send.
     */
    TOX_ERR_GROUP_FOUNDER_SET_VOICE_STATE_FAIL_SEND,

    /**
     * The group is disconnected.
     */
    TOX_ERR_GROUP_FOUNDER_SET_VOICE_STATE_DISCONNECTED,

} Tox_Err_Group_Founder_Set_Voice_State;

/**
 * Set the group voice state.
 *
 * This function sets the group's voice state, creates a new group shared state
 * including the change, and distributes it to the rest of the group.
 *
 * If an attempt is made to set the voice state to the same state that the group is already
 * in, the function call will be successful and no action will be taken.
 *
 * @param group_number The group number of the group for which we wish to change the voice state.
 * @param voice_state The voice state we wish to set the group to.
 *
 * @return true on success.
 */
bool tox_group_founder_set_voice_state(const Tox *tox, uint32_t group_number, Tox_Group_Voice_State voice_state,
                                       Tox_Err_Group_Founder_Set_Voice_State *error);

typedef enum Tox_Err_Group_Founder_Set_Privacy_State {

    /**
     * The function returned successfully.
     */
    TOX_ERR_GROUP_FOUNDER_SET_PRIVACY_STATE_OK,

    /**
     * The group number passed did not designate a valid group.
     */
    TOX_ERR_GROUP_FOUNDER_SET_PRIVACY_STATE_GROUP_NOT_FOUND,

    /**
     * The caller does not have the required permissions to set the privacy state.
     */
    TOX_ERR_GROUP_FOUNDER_SET_PRIVACY_STATE_PERMISSIONS,

    /**
     * The privacy state could not be set. This may occur due to an error related to
     * cryptographic signing of the new shared state.
     */
    TOX_ERR_GROUP_FOUNDER_SET_PRIVACY_STATE_FAIL_SET,

    /**
     * The packet failed to send.
     */
    TOX_ERR_GROUP_FOUNDER_SET_PRIVACY_STATE_FAIL_SEND,

    /**
     * The group is disconnected.
     */
    TOX_ERR_GROUP_FOUNDER_SET_PRIVACY_STATE_DISCONNECTED,

} Tox_Err_Group_Founder_Set_Privacy_State;

/**
 * Set the group privacy state.
 *
 * This function sets the group's privacy state, creates a new group shared state
 * including the change, and distributes it to the rest of the group.
 *
 * If an attempt is made to set the privacy state to the same state that the group is already
 * in, the function call will be successful and no action will be taken.
 *
 * @param group_number The group number of the group for which we wish to change the privacy state.
 * @param privacy_state The privacy state we wish to set the group to.
 *
 * @return true on success.
 */
bool tox_group_founder_set_privacy_state(const Tox *tox, uint32_t group_number, Tox_Group_Privacy_State privacy_state,
        Tox_Err_Group_Founder_Set_Privacy_State *error);

typedef enum Tox_Err_Group_Founder_Set_Peer_Limit {

    /**
     * The function returned successfully.
     */
    TOX_ERR_GROUP_FOUNDER_SET_PEER_LIMIT_OK,

    /**
     * The group number passed did not designate a valid group.
     */
    TOX_ERR_GROUP_FOUNDER_SET_PEER_LIMIT_GROUP_NOT_FOUND,

    /**
     * The caller does not have the required permissions to set the peer limit.
     */
    TOX_ERR_GROUP_FOUNDER_SET_PEER_LIMIT_PERMISSIONS,

    /**
     * The peer limit could not be set. This may occur due to an error related to
     * cryptographic signing of the new shared state.
     */
    TOX_ERR_GROUP_FOUNDER_SET_PEER_LIMIT_FAIL_SET,

    /**
     * The packet failed to send.
     */
    TOX_ERR_GROUP_FOUNDER_SET_PEER_LIMIT_FAIL_SEND,

    /**
     * The group is disconnected.
     */
    TOX_ERR_GROUP_FOUNDER_SET_PEER_LIMIT_DISCONNECTED,

} Tox_Err_Group_Founder_Set_Peer_Limit;


/**
 * Set the group peer limit.
 *
 * This function sets a limit for the number of peers who may be in the group, creates a new
 * group shared state including the change, and distributes it to the rest of the group.
 *
 * @param group_number The group number of the group for which we wish to set the peer limit.
 * @param max_peers The maximum number of peers to allow in the group.
 *
 * @return true on success.
 */
bool tox_group_founder_set_peer_limit(const Tox *tox, uint32_t group_number, uint16_t max_peers,
                                      Tox_Err_Group_Founder_Set_Peer_Limit *error);


/*******************************************************************************
 *
 * :: Group chat moderation
 *
 ******************************************************************************/



typedef enum Tox_Err_Group_Set_Ignore {

    /**
     * The function returned successfully.
     */
    TOX_ERR_GROUP_SET_IGNORE_OK,

    /**
     * The group number passed did not designate a valid group.
     */
    TOX_ERR_GROUP_SET_IGNORE_GROUP_NOT_FOUND,

    /**
     * The ID passed did not designate a valid peer.
     */
    TOX_ERR_GROUP_SET_IGNORE_PEER_NOT_FOUND,

    /**
     * The caller attempted to ignore himself.
     */
    TOX_ERR_GROUP_SET_IGNORE_SELF,

} Tox_Err_Group_Set_Ignore;


/**
 * Ignore or unignore a peer.
 *
 * @param group_number The group number of the group in which you wish to ignore a peer.
 * @param peer_id The ID of the peer who shall be ignored or unignored.
 * @param ignore True to ignore the peer, false to unignore the peer.
 *
 * @return true on success.
 */
bool tox_group_set_ignore(const Tox *tox, uint32_t group_number, uint32_t peer_id, bool ignore,
                          Tox_Err_Group_Set_Ignore *error);

typedef enum Tox_Err_Group_Mod_Set_Role {

    /**
     * The function returned successfully.
     */
    TOX_ERR_GROUP_MOD_SET_ROLE_OK,

    /**
     * The group number passed did not designate a valid group.
     */
    TOX_ERR_GROUP_MOD_SET_ROLE_GROUP_NOT_FOUND,

    /**
     * The ID passed did not designate a valid peer. Note: you cannot set your own role.
     */
    TOX_ERR_GROUP_MOD_SET_ROLE_PEER_NOT_FOUND,

    /**
     * The caller does not have the required permissions for this action.
     */
    TOX_ERR_GROUP_MOD_SET_ROLE_PERMISSIONS,

    /**
     * The role assignment is invalid. This will occur if you try to set a peer's role to
     * the role they already have.
     */
    TOX_ERR_GROUP_MOD_SET_ROLE_ASSIGNMENT,

    /**
     * The role was not successfully set. This may occur if the packet failed to send, or
     * if the role limit has been reached.
     */
    TOX_ERR_GROUP_MOD_SET_ROLE_FAIL_ACTION,

    /**
     * The caller attempted to set their own role.
     */
    TOX_ERR_GROUP_MOD_SET_ROLE_SELF,

} Tox_Err_Group_Mod_Set_Role;


/**
 * Set a peer's role.
 *
 * This function will first remove the peer's previous role and then assign them a new role.
 * It will also send a packet to the rest of the group, requesting that they perform
 * the role reassignment. Note: peers cannot be set to the founder role.
 *
 * @param group_number The group number of the group the in which you wish set the peer's role.
 * @param peer_id The ID of the peer whose role you wish to set.
 * @param role The role you wish to set the peer to.
 *
 * @return true on success.
 */
bool tox_group_mod_set_role(const Tox *tox, uint32_t group_number, uint32_t peer_id, Tox_Group_Role role,
                            Tox_Err_Group_Mod_Set_Role *error);

typedef enum Tox_Err_Group_Mod_Kick_Peer {

    /**
     * The function returned successfully.
     */
    TOX_ERR_GROUP_MOD_KICK_PEER_OK,

    /**
     * The group number passed did not designate a valid group.
     */
    TOX_ERR_GROUP_MOD_KICK_PEER_GROUP_NOT_FOUND,

    /**
     * The ID passed did not designate a valid peer.
     */
    TOX_ERR_GROUP_MOD_KICK_PEER_PEER_NOT_FOUND,

    /**
     * The caller does not have the required permissions for this action.
     */
    TOX_ERR_GROUP_MOD_KICK_PEER_PERMISSIONS,

    /**
     * The peer could not be kicked from the group.
     */
    TOX_ERR_GROUP_MOD_KICK_PEER_FAIL_ACTION,

    /**
     * The packet failed to send.
     */
    TOX_ERR_GROUP_MOD_KICK_PEER_FAIL_SEND,

    /**
     * The caller attempted to set their own role.
     */
    TOX_ERR_GROUP_MOD_KICK_PEER_SELF,

} Tox_Err_Group_Mod_Kick_Peer;


/**
 * Kick a peer.
 *
 * This function will remove a peer from the caller's peer list and send a packet to all
 * group members requesting them to do the same. Note: This function will not trigger
 * the `group_peer_exit` event for the caller.
 *
 * @param group_number The group number of the group the action is intended for.
 * @param peer_id The ID of the peer who will be kicked.
 *
 * @return true on success.
 */
bool tox_group_mod_kick_peer(const Tox *tox, uint32_t group_number, uint32_t peer_id,
                             Tox_Err_Group_Mod_Kick_Peer *error);

/**
 * Represents moderation events. These should be used with the `group_moderation` event.
 */
typedef enum Tox_Group_Mod_Event {

    /**
     * A peer has been kicked from the group.
     */
    TOX_GROUP_MOD_EVENT_KICK,

    /**
     * A peer as been given the observer role.
     */
    TOX_GROUP_MOD_EVENT_OBSERVER,

    /**
     * A peer has been given the user role.
     */
    TOX_GROUP_MOD_EVENT_USER,

    /**
     * A peer has been given the moderator role.
     */
    TOX_GROUP_MOD_EVENT_MODERATOR,

} Tox_Group_Mod_Event;


/**
 * @param group_number The group number of the group the event is intended for.
 * @param source_peer_id The ID of the peer who initiated the event.
 * @param target_peer_id The ID of the peer who is the target of the event.
 * @param mod_type The type of event.
 */
typedef void tox_group_moderation_cb(Tox *tox, uint32_t group_number, uint32_t source_peer_id, uint32_t target_peer_id,
                                     Tox_Group_Mod_Event mod_type, void *user_data);


/**
 * Set the callback for the `group_moderation` event. Pass NULL to unset.
 *
 * This event is triggered when a moderator or founder executes a moderation event, with
 * the exception of the peer who initiates the event. It is also triggered when the
 * observer and moderator lists are silently modified (this may occur during group syncing).
 *
 * If either peer id does not designate a valid peer in the group chat, the client should
 * manually update all peer roles.
 */
void tox_callback_group_moderation(Tox *tox, tox_group_moderation_cb *callback);

/** @} */

/** @} */

/**
 * Set the callback for the `friend_lossy_packet` event for a specific packet ID.
 * to Pass NULL to unset.
 * You need to set to NULL first, only then you are allowed to change it
 *
 */
void tox_callback_friend_lossy_packet_per_pktid(Tox *tox, tox_friend_lossy_packet_cb *callback, uint8_t pktid);

/**
 * Set the callback for the `friend_lossless_packet` event for a specific packet ID.
 * to Pass NULL to unset.
 *
 */
void tox_callback_friend_lossless_packet_per_pktid(Tox *tox, tox_friend_lossless_packet_cb *callback, uint8_t pktid);

/**
 * Get a report as utf-8 encoded string of all connected tcp relays (friend connections and NGC group chats).
 * `report` has to be allocated to at least 60301 bytes and cleared to all NULL bytes, before calling this API function.
 *
 */
void tox_get_all_tcp_relays(const Tox *tox, char *report);

/**
 * Get a report as utf-8 encoded string of all udp connections (friend connections and NGC group chats).
 * `report` has to be allocated to at least 60301 bytes and cleared to all NULL bytes, before calling this API function.
 *
 */
void tox_get_all_udp_connections(const Tox *tox, char *report);

#ifdef __cplusplus
}
#endif

//!TOKSTYLE-
#ifndef DOXYGEN_IGNORE

typedef Tox_Err_Options_New TOX_ERR_OPTIONS_NEW;
typedef Tox_Err_New TOX_ERR_NEW;
typedef Tox_Err_Bootstrap TOX_ERR_BOOTSTRAP;
typedef Tox_Err_Set_Info TOX_ERR_SET_INFO;
typedef Tox_Err_Friend_Add TOX_ERR_FRIEND_ADD;
typedef Tox_Err_Friend_Delete TOX_ERR_FRIEND_DELETE;
typedef Tox_Err_Friend_By_Public_Key TOX_ERR_FRIEND_BY_PUBLIC_KEY;
typedef Tox_Err_Friend_Get_Public_Key TOX_ERR_FRIEND_GET_PUBLIC_KEY;
typedef Tox_Err_Friend_Get_Last_Online TOX_ERR_FRIEND_GET_LAST_ONLINE;
typedef Tox_Err_Friend_Query TOX_ERR_FRIEND_QUERY;
typedef Tox_Err_Set_Typing TOX_ERR_SET_TYPING;
typedef Tox_Err_Friend_Send_Message TOX_ERR_FRIEND_SEND_MESSAGE;
typedef Tox_Err_File_Control TOX_ERR_FILE_CONTROL;
typedef Tox_Err_File_Seek TOX_ERR_FILE_SEEK;
typedef Tox_Err_File_Get TOX_ERR_FILE_GET;
typedef Tox_Err_File_Send TOX_ERR_FILE_SEND;
typedef Tox_Err_File_Send_Chunk TOX_ERR_FILE_SEND_CHUNK;
typedef Tox_Err_Conference_New TOX_ERR_CONFERENCE_NEW;
typedef Tox_Err_Conference_Delete TOX_ERR_CONFERENCE_DELETE;
typedef Tox_Err_Conference_Peer_Query TOX_ERR_CONFERENCE_PEER_QUERY;
typedef Tox_Err_Conference_Set_Max_Offline TOX_ERR_CONFERENCE_SET_MAX_OFFLINE;
typedef Tox_Err_Conference_By_Id TOX_ERR_CONFERENCE_BY_ID;
typedef Tox_Err_Conference_By_Uid TOX_ERR_CONFERENCE_BY_UID;
typedef Tox_Err_Conference_Invite TOX_ERR_CONFERENCE_INVITE;
typedef Tox_Err_Conference_Join TOX_ERR_CONFERENCE_JOIN;
typedef Tox_Err_Conference_Send_Message TOX_ERR_CONFERENCE_SEND_MESSAGE;
typedef Tox_Err_Conference_Title TOX_ERR_CONFERENCE_TITLE;
typedef Tox_Err_Conference_Get_Type TOX_ERR_CONFERENCE_GET_TYPE;
typedef Tox_Err_Friend_Custom_Packet TOX_ERR_FRIEND_CUSTOM_PACKET;
typedef Tox_Err_Get_Port TOX_ERR_GET_PORT;
typedef Tox_User_Status TOX_USER_STATUS;
typedef Tox_Message_Type TOX_MESSAGE_TYPE;
typedef Tox_Proxy_Type TOX_PROXY_TYPE;
typedef Tox_Savedata_Type TOX_SAVEDATA_TYPE;
typedef Tox_Log_Level TOX_LOG_LEVEL;
typedef Tox_Connection TOX_CONNECTION;
typedef Tox_File_Control TOX_FILE_CONTROL;
typedef Tox_Conference_Type TOX_CONFERENCE_TYPE;
typedef enum Tox_File_Kind TOX_FILE_KIND;

#endif

//!TOKSTYLE+

#endif // C_TOXCORE_TOXCORE_TOX_H
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2022 The TokTok team.
 */

#ifndef C_TOXCORE_TOXCORE_TOX_EVENTS_H
#define C_TOXCORE_TOXCORE_TOX_EVENTS_H


#ifdef __cplusplus
extern "C" {
#endif

typedef struct Tox_Event_Conference_Connected Tox_Event_Conference_Connected;
uint32_t tox_event_conference_connected_get_conference_number(
    const Tox_Event_Conference_Connected *conference_connected);

typedef struct Tox_Event_Conference_Invite Tox_Event_Conference_Invite;
const uint8_t *tox_event_conference_invite_get_cookie(
    const Tox_Event_Conference_Invite *conference_invite);
uint32_t tox_event_conference_invite_get_cookie_length(
    const Tox_Event_Conference_Invite *conference_invite);
Tox_Conference_Type tox_event_conference_invite_get_type(
    const Tox_Event_Conference_Invite *conference_invite);
uint32_t tox_event_conference_invite_get_friend_number(
    const Tox_Event_Conference_Invite *conference_invite);

typedef struct Tox_Event_Conference_Message Tox_Event_Conference_Message;
const uint8_t *tox_event_conference_message_get_message(
    const Tox_Event_Conference_Message *conference_message);
uint32_t tox_event_conference_message_get_message_length(
    const Tox_Event_Conference_Message *conference_message);
Tox_Message_Type tox_event_conference_message_get_type(
    const Tox_Event_Conference_Message *conference_message);
uint32_t tox_event_conference_message_get_conference_number(
    const Tox_Event_Conference_Message *conference_message);
uint32_t tox_event_conference_message_get_peer_number(
    const Tox_Event_Conference_Message *conference_message);

typedef struct Tox_Event_Conference_Peer_List_Changed Tox_Event_Conference_Peer_List_Changed;
uint32_t tox_event_conference_peer_list_changed_get_conference_number(
    const Tox_Event_Conference_Peer_List_Changed *conference_peer_list_changed);

typedef struct Tox_Event_Conference_Peer_Name Tox_Event_Conference_Peer_Name;
const uint8_t *tox_event_conference_peer_name_get_name(
    const Tox_Event_Conference_Peer_Name *conference_peer_name);
uint32_t tox_event_conference_peer_name_get_name_length(
    const Tox_Event_Conference_Peer_Name *conference_peer_name);
uint32_t tox_event_conference_peer_name_get_conference_number(
    const Tox_Event_Conference_Peer_Name *conference_peer_name);
uint32_t tox_event_conference_peer_name_get_peer_number(
    const Tox_Event_Conference_Peer_Name *conference_peer_name);

typedef struct Tox_Event_Conference_Title Tox_Event_Conference_Title;
const uint8_t *tox_event_conference_title_get_title(
    const Tox_Event_Conference_Title *conference_title);
uint32_t tox_event_conference_title_get_title_length(
    const Tox_Event_Conference_Title *conference_title);
uint32_t tox_event_conference_title_get_conference_number(
    const Tox_Event_Conference_Title *conference_title);
uint32_t tox_event_conference_title_get_peer_number(
    const Tox_Event_Conference_Title *conference_title);

typedef struct Tox_Event_File_Chunk_Request Tox_Event_File_Chunk_Request;
uint16_t tox_event_file_chunk_request_get_length(
    const Tox_Event_File_Chunk_Request *file_chunk_request);
uint32_t tox_event_file_chunk_request_get_file_number(
    const Tox_Event_File_Chunk_Request *file_chunk_request);
uint32_t tox_event_file_chunk_request_get_friend_number(
    const Tox_Event_File_Chunk_Request *file_chunk_request);
uint64_t tox_event_file_chunk_request_get_position(
    const Tox_Event_File_Chunk_Request *file_chunk_request);

typedef struct Tox_Event_File_Recv Tox_Event_File_Recv;
const uint8_t *tox_event_file_recv_get_filename(
    const Tox_Event_File_Recv *file_recv);
uint32_t tox_event_file_recv_get_filename_length(
    const Tox_Event_File_Recv *file_recv);
uint32_t tox_event_file_recv_get_file_number(
    const Tox_Event_File_Recv *file_recv);
uint64_t tox_event_file_recv_get_file_size(
    const Tox_Event_File_Recv *file_recv);
uint32_t tox_event_file_recv_get_friend_number(
    const Tox_Event_File_Recv *file_recv);
uint32_t tox_event_file_recv_get_kind(
    const Tox_Event_File_Recv *file_recv);

typedef struct Tox_Event_File_Recv_Chunk Tox_Event_File_Recv_Chunk;
const uint8_t *tox_event_file_recv_chunk_get_data(
    const Tox_Event_File_Recv_Chunk *file_recv_chunk);
uint32_t tox_event_file_recv_chunk_get_length(
    const Tox_Event_File_Recv_Chunk *file_recv_chunk);
uint32_t tox_event_file_recv_chunk_get_file_number(
    const Tox_Event_File_Recv_Chunk *file_recv_chunk);
uint32_t tox_event_file_recv_chunk_get_friend_number(
    const Tox_Event_File_Recv_Chunk *file_recv_chunk);
uint64_t tox_event_file_recv_chunk_get_position(
    const Tox_Event_File_Recv_Chunk *file_recv_chunk);

typedef struct Tox_Event_File_Recv_Control Tox_Event_File_Recv_Control;
Tox_File_Control tox_event_file_recv_control_get_control(
    const Tox_Event_File_Recv_Control *file_recv_control);
uint32_t tox_event_file_recv_control_get_file_number(
    const Tox_Event_File_Recv_Control *file_recv_control);
uint32_t tox_event_file_recv_control_get_friend_number(
    const Tox_Event_File_Recv_Control *file_recv_control);

typedef struct Tox_Event_Friend_Connection_Status Tox_Event_Friend_Connection_Status;
Tox_Connection tox_event_friend_connection_status_get_connection_status(
    const Tox_Event_Friend_Connection_Status *friend_connection_status);
uint32_t tox_event_friend_connection_status_get_friend_number(
    const Tox_Event_Friend_Connection_Status *friend_connection_status);

typedef struct Tox_Event_Friend_Lossless_Packet Tox_Event_Friend_Lossless_Packet;
const uint8_t *tox_event_friend_lossless_packet_get_data(
    const Tox_Event_Friend_Lossless_Packet *friend_lossless_packet);
uint32_t tox_event_friend_lossless_packet_get_data_length(
    const Tox_Event_Friend_Lossless_Packet *friend_lossless_packet);
uint32_t tox_event_friend_lossless_packet_get_friend_number(
    const Tox_Event_Friend_Lossless_Packet *friend_lossless_packet);

typedef struct Tox_Event_Friend_Lossy_Packet Tox_Event_Friend_Lossy_Packet;
const uint8_t *tox_event_friend_lossy_packet_get_data(
    const Tox_Event_Friend_Lossy_Packet *friend_lossy_packet);
uint32_t tox_event_friend_lossy_packet_get_data_length(
    const Tox_Event_Friend_Lossy_Packet *friend_lossy_packet);
uint32_t tox_event_friend_lossy_packet_get_friend_number(
    const Tox_Event_Friend_Lossy_Packet *friend_lossy_packet);

typedef struct Tox_Event_Friend_Message Tox_Event_Friend_Message;
uint32_t tox_event_friend_message_get_friend_number(
    const Tox_Event_Friend_Message *friend_message);
Tox_Message_Type tox_event_friend_message_get_type(
    const Tox_Event_Friend_Message *friend_message);
uint32_t tox_event_friend_message_get_message_length(
    const Tox_Event_Friend_Message *friend_message);
const uint8_t *tox_event_friend_message_get_message(
    const Tox_Event_Friend_Message *friend_message);

typedef struct Tox_Event_Friend_Name Tox_Event_Friend_Name;
const uint8_t *tox_event_friend_name_get_name(
    const Tox_Event_Friend_Name *friend_name);
uint32_t tox_event_friend_name_get_name_length(
    const Tox_Event_Friend_Name *friend_name);
uint32_t tox_event_friend_name_get_friend_number(
    const Tox_Event_Friend_Name *friend_name);

typedef struct Tox_Event_Friend_Read_Receipt Tox_Event_Friend_Read_Receipt;
uint32_t tox_event_friend_read_receipt_get_friend_number(
    const Tox_Event_Friend_Read_Receipt *friend_read_receipt);
uint32_t tox_event_friend_read_receipt_get_message_id(
    const Tox_Event_Friend_Read_Receipt *friend_read_receipt);

typedef struct Tox_Event_Friend_Request Tox_Event_Friend_Request;
const uint8_t *tox_event_friend_request_get_message(
    const Tox_Event_Friend_Request *friend_request);
const uint8_t *tox_event_friend_request_get_public_key(
    const Tox_Event_Friend_Request *friend_request);
uint32_t tox_event_friend_request_get_message_length(
    const Tox_Event_Friend_Request *friend_request);

typedef struct Tox_Event_Friend_Status Tox_Event_Friend_Status;
Tox_User_Status tox_event_friend_status_get_status(
    const Tox_Event_Friend_Status *friend_status);
uint32_t tox_event_friend_status_get_friend_number(
    const Tox_Event_Friend_Status *friend_status);

typedef struct Tox_Event_Friend_Status_Message Tox_Event_Friend_Status_Message;
const uint8_t *tox_event_friend_status_message_get_message(
    const Tox_Event_Friend_Status_Message *friend_status_message);
uint32_t tox_event_friend_status_message_get_message_length(
    const Tox_Event_Friend_Status_Message *friend_status_message);
uint32_t tox_event_friend_status_message_get_friend_number(
    const Tox_Event_Friend_Status_Message *friend_status_message);

typedef struct Tox_Event_Friend_Typing Tox_Event_Friend_Typing;
bool tox_event_friend_typing_get_typing(
    const Tox_Event_Friend_Typing *friend_typing);
uint32_t tox_event_friend_typing_get_friend_number(
    const Tox_Event_Friend_Typing *friend_typing);

typedef struct Tox_Event_Self_Connection_Status Tox_Event_Self_Connection_Status;
Tox_Connection tox_event_self_connection_status_get_connection_status(
    const Tox_Event_Self_Connection_Status *self_connection_status);


typedef enum Tox_Event {
    TOX_EVENT_SELF_CONNECTION_STATUS        = 0,

    TOX_EVENT_FRIEND_REQUEST                = 1,
    TOX_EVENT_FRIEND_CONNECTION_STATUS      = 2,
    TOX_EVENT_FRIEND_LOSSY_PACKET           = 3,
    TOX_EVENT_FRIEND_LOSSLESS_PACKET        = 4,

    TOX_EVENT_FRIEND_NAME                   = 5,
    TOX_EVENT_FRIEND_STATUS                 = 6,
    TOX_EVENT_FRIEND_STATUS_MESSAGE         = 7,

    TOX_EVENT_FRIEND_MESSAGE                = 8,
    TOX_EVENT_FRIEND_READ_RECEIPT           = 9,
    TOX_EVENT_FRIEND_TYPING                 = 10,

    TOX_EVENT_FILE_CHUNK_REQUEST            = 11,
    TOX_EVENT_FILE_RECV                     = 12,
    TOX_EVENT_FILE_RECV_CHUNK               = 13,
    TOX_EVENT_FILE_RECV_CONTROL             = 14,

    TOX_EVENT_CONFERENCE_INVITE             = 15,
    TOX_EVENT_CONFERENCE_CONNECTED          = 16,
    TOX_EVENT_CONFERENCE_PEER_LIST_CHANGED  = 17,
    TOX_EVENT_CONFERENCE_PEER_NAME          = 18,
    TOX_EVENT_CONFERENCE_TITLE              = 19,

    TOX_EVENT_CONFERENCE_MESSAGE            = 20,
} Tox_Event;

/**
 * Container object for all Tox core events.
 *
 * This is an immutable object once created.
 */
typedef struct Tox_Events Tox_Events;

uint32_t tox_events_get_conference_connected_size(const Tox_Events *events);
uint32_t tox_events_get_conference_invite_size(const Tox_Events *events);
uint32_t tox_events_get_conference_message_size(const Tox_Events *events);
uint32_t tox_events_get_conference_peer_list_changed_size(const Tox_Events *events);
uint32_t tox_events_get_conference_peer_name_size(const Tox_Events *events);
uint32_t tox_events_get_conference_title_size(const Tox_Events *events);
uint32_t tox_events_get_file_chunk_request_size(const Tox_Events *events);
uint32_t tox_events_get_file_recv_chunk_size(const Tox_Events *events);
uint32_t tox_events_get_file_recv_control_size(const Tox_Events *events);
uint32_t tox_events_get_file_recv_size(const Tox_Events *events);
uint32_t tox_events_get_friend_connection_status_size(const Tox_Events *events);
uint32_t tox_events_get_friend_lossless_packet_size(const Tox_Events *events);
uint32_t tox_events_get_friend_lossy_packet_size(const Tox_Events *events);
uint32_t tox_events_get_friend_message_size(const Tox_Events *events);
uint32_t tox_events_get_friend_name_size(const Tox_Events *events);
uint32_t tox_events_get_friend_read_receipt_size(const Tox_Events *events);
uint32_t tox_events_get_friend_request_size(const Tox_Events *events);
uint32_t tox_events_get_friend_status_message_size(const Tox_Events *events);
uint32_t tox_events_get_friend_status_size(const Tox_Events *events);
uint32_t tox_events_get_friend_typing_size(const Tox_Events *events);
uint32_t tox_events_get_self_connection_status_size(const Tox_Events *events);

const Tox_Event_Conference_Connected *tox_events_get_conference_connected(
    const Tox_Events *events, uint32_t index);
const Tox_Event_Conference_Invite *tox_events_get_conference_invite(
    const Tox_Events *events, uint32_t index);
const Tox_Event_Conference_Message *tox_events_get_conference_message(
    const Tox_Events *events, uint32_t index);
const Tox_Event_Conference_Peer_List_Changed *tox_events_get_conference_peer_list_changed(
    const Tox_Events *events, uint32_t index);
const Tox_Event_Conference_Peer_Name *tox_events_get_conference_peer_name(
    const Tox_Events *events, uint32_t index);
const Tox_Event_Conference_Title *tox_events_get_conference_title(
    const Tox_Events *events, uint32_t index);
const Tox_Event_File_Chunk_Request *tox_events_get_file_chunk_request(
    const Tox_Events *events, uint32_t index);
const Tox_Event_File_Recv_Chunk *tox_events_get_file_recv_chunk(
    const Tox_Events *events, uint32_t index);
const Tox_Event_File_Recv_Control *tox_events_get_file_recv_control(
    const Tox_Events *events, uint32_t index);
const Tox_Event_File_Recv *tox_events_get_file_recv(
    const Tox_Events *events, uint32_t index);
const Tox_Event_Friend_Connection_Status *tox_events_get_friend_connection_status(
    const Tox_Events *events, uint32_t index);
const Tox_Event_Friend_Lossless_Packet *tox_events_get_friend_lossless_packet(
    const Tox_Events *events, uint32_t index);
const Tox_Event_Friend_Lossy_Packet *tox_events_get_friend_lossy_packet(
    const Tox_Events *events, uint32_t index);
const Tox_Event_Friend_Message *tox_events_get_friend_message(
    const Tox_Events *events, uint32_t index);
const Tox_Event_Friend_Name *tox_events_get_friend_name(
    const Tox_Events *events, uint32_t index);
const Tox_Event_Friend_Read_Receipt *tox_events_get_friend_read_receipt(
    const Tox_Events *events, uint32_t index);
const Tox_Event_Friend_Request *tox_events_get_friend_request(
    const Tox_Events *events, uint32_t index);
const Tox_Event_Friend_Status_Message *tox_events_get_friend_status_message(
    const Tox_Events *events, uint32_t index);
const Tox_Event_Friend_Status *tox_events_get_friend_status(
    const Tox_Events *events, uint32_t index);
const Tox_Event_Friend_Typing *tox_events_get_friend_typing(
    const Tox_Events *events, uint32_t index);
const Tox_Event_Self_Connection_Status *tox_events_get_self_connection_status(
    const Tox_Events *events, uint32_t index);

/**
 * Initialise the events recording system.
 *
 * All callbacks will be set to handlers inside the events recording system.
 * After this function returns, no user-defined event handlers will be
 * invoked. If the client sets their own handlers after calling this function,
 * the events associated with that handler will not be recorded.
 */
void tox_events_init(Tox *tox);

typedef enum Tox_Err_Events_Iterate {
    /**
     * The function returned successfully.
     */
    TOX_ERR_EVENTS_ITERATE_OK,

    /**
     * The function failed to allocate enough memory to store the events.
     *
     * Some events may still be stored if the return value is NULL. The events
     * object will always be valid (or NULL) but if this error code is set,
     * the function may have missed some events.
     */
    TOX_ERR_EVENTS_ITERATE_MALLOC,
} Tox_Err_Events_Iterate;

/**
 * Run a single `tox_iterate` iteration and record all the events.
 *
 * If allocation of the top level events object fails, this returns NULL.
 * Otherwise it returns an object with the recorded events in it. If an
 * allocation fails while recording events, some events may be dropped.
 *
 * If @p fail_hard is `true`, any failure will result in NULL, so all recorded
 * events will be dropped.
 *
 * The result must be freed using `tox_events_free`.
 *
 * @param tox The Tox instance to iterate on.
 * @param fail_hard Drop all events when any allocation fails.
 * @param error An error code. Will be set to OK on success.
 *
 * @return the recorded events structure.
 */
Tox_Events *tox_events_iterate(Tox *tox, bool fail_hard, Tox_Err_Events_Iterate *error);

/**
 * Frees all memory associated with the events structure.
 *
 * All pointers into this object and its sub-objects, including byte buffers,
 * will be invalid once this function returns.
 */
void tox_events_free(Tox_Events *events);

uint32_t tox_events_bytes_size(const Tox_Events *events);
void tox_events_get_bytes(const Tox_Events *events, uint8_t *bytes);

Tox_Events *tox_events_load(const uint8_t *bytes, uint32_t bytes_size);

bool tox_events_equal(const Tox_Events *a, const Tox_Events *b);

#ifdef __cplusplus
}
#endif

#endif // C_TOXCORE_TOXCORE_TOX_EVENTS_H
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2022 The TokTok team.
 */

#ifndef C_TOXCORE_TOXCORE_TOX_EVENTS_INTERNAL_H
#define C_TOXCORE_TOXCORE_TOX_EVENTS_INTERNAL_H


#ifdef __cplusplus
extern "C" {
#endif

struct Tox_Events {
    Tox_Event_Conference_Connected *conference_connected;
    uint32_t conference_connected_size;
    uint32_t conference_connected_capacity;

    Tox_Event_Conference_Invite *conference_invite;
    uint32_t conference_invite_size;
    uint32_t conference_invite_capacity;

    Tox_Event_Conference_Message *conference_message;
    uint32_t conference_message_size;
    uint32_t conference_message_capacity;

    Tox_Event_Conference_Peer_List_Changed *conference_peer_list_changed;
    uint32_t conference_peer_list_changed_size;
    uint32_t conference_peer_list_changed_capacity;

    Tox_Event_Conference_Peer_Name *conference_peer_name;
    uint32_t conference_peer_name_size;
    uint32_t conference_peer_name_capacity;

    Tox_Event_Conference_Title *conference_title;
    uint32_t conference_title_size;
    uint32_t conference_title_capacity;

    Tox_Event_File_Chunk_Request *file_chunk_request;
    uint32_t file_chunk_request_size;
    uint32_t file_chunk_request_capacity;

    Tox_Event_File_Recv *file_recv;
    uint32_t file_recv_size;
    uint32_t file_recv_capacity;

    Tox_Event_File_Recv_Chunk *file_recv_chunk;
    uint32_t file_recv_chunk_size;
    uint32_t file_recv_chunk_capacity;

    Tox_Event_File_Recv_Control *file_recv_control;
    uint32_t file_recv_control_size;
    uint32_t file_recv_control_capacity;

    Tox_Event_Friend_Connection_Status *friend_connection_status;
    uint32_t friend_connection_status_size;
    uint32_t friend_connection_status_capacity;

    Tox_Event_Friend_Lossless_Packet *friend_lossless_packet;
    uint32_t friend_lossless_packet_size;
    uint32_t friend_lossless_packet_capacity;

    Tox_Event_Friend_Lossy_Packet *friend_lossy_packet;
    uint32_t friend_lossy_packet_size;
    uint32_t friend_lossy_packet_capacity;

    Tox_Event_Friend_Message *friend_message;
    uint32_t friend_message_size;
    uint32_t friend_message_capacity;

    Tox_Event_Friend_Name *friend_name;
    uint32_t friend_name_size;
    uint32_t friend_name_capacity;

    Tox_Event_Friend_Read_Receipt *friend_read_receipt;
    uint32_t friend_read_receipt_size;
    uint32_t friend_read_receipt_capacity;

    Tox_Event_Friend_Request *friend_request;
    uint32_t friend_request_size;
    uint32_t friend_request_capacity;

    Tox_Event_Friend_Status *friend_status;
    uint32_t friend_status_size;
    uint32_t friend_status_capacity;

    Tox_Event_Friend_Status_Message *friend_status_message;
    uint32_t friend_status_message_size;
    uint32_t friend_status_message_capacity;

    Tox_Event_Friend_Typing *friend_typing;
    uint32_t friend_typing_size;
    uint32_t friend_typing_capacity;

    Tox_Event_Self_Connection_Status *self_connection_status;
    uint32_t self_connection_status_size;
    uint32_t self_connection_status_capacity;
};

typedef struct Tox_Events_State {
    Tox_Err_Events_Iterate error;
    Tox_Events *events;
} Tox_Events_State;

tox_conference_connected_cb tox_events_handle_conference_connected;
tox_conference_invite_cb tox_events_handle_conference_invite;
tox_conference_message_cb tox_events_handle_conference_message;
tox_conference_peer_list_changed_cb tox_events_handle_conference_peer_list_changed;
tox_conference_peer_name_cb tox_events_handle_conference_peer_name;
tox_conference_title_cb tox_events_handle_conference_title;
tox_file_chunk_request_cb tox_events_handle_file_chunk_request;
tox_file_recv_cb tox_events_handle_file_recv;
tox_file_recv_chunk_cb tox_events_handle_file_recv_chunk;
tox_file_recv_control_cb tox_events_handle_file_recv_control;
tox_friend_connection_status_cb tox_events_handle_friend_connection_status;
tox_friend_lossless_packet_cb tox_events_handle_friend_lossless_packet;
tox_friend_lossy_packet_cb tox_events_handle_friend_lossy_packet;
tox_friend_message_cb tox_events_handle_friend_message;
tox_friend_name_cb tox_events_handle_friend_name;
tox_friend_read_receipt_cb tox_events_handle_friend_read_receipt;
tox_friend_request_cb tox_events_handle_friend_request;
tox_friend_status_cb tox_events_handle_friend_status;
tox_friend_status_message_cb tox_events_handle_friend_status_message;
tox_friend_typing_cb tox_events_handle_friend_typing;
tox_self_connection_status_cb tox_events_handle_self_connection_status;

// non_null()
typedef void tox_events_clear_cb(Tox_Events *events);

tox_events_clear_cb tox_events_clear_conference_connected;
tox_events_clear_cb tox_events_clear_conference_invite;
tox_events_clear_cb tox_events_clear_conference_message;
tox_events_clear_cb tox_events_clear_conference_peer_list_changed;
tox_events_clear_cb tox_events_clear_conference_peer_name;
tox_events_clear_cb tox_events_clear_conference_title;
tox_events_clear_cb tox_events_clear_file_chunk_request;
tox_events_clear_cb tox_events_clear_file_recv_chunk;
tox_events_clear_cb tox_events_clear_file_recv_control;
tox_events_clear_cb tox_events_clear_file_recv;
tox_events_clear_cb tox_events_clear_friend_connection_status;
tox_events_clear_cb tox_events_clear_friend_lossless_packet;
tox_events_clear_cb tox_events_clear_friend_lossy_packet;
tox_events_clear_cb tox_events_clear_friend_message;
tox_events_clear_cb tox_events_clear_friend_name;
tox_events_clear_cb tox_events_clear_friend_read_receipt;
tox_events_clear_cb tox_events_clear_friend_request;
tox_events_clear_cb tox_events_clear_friend_status_message;
tox_events_clear_cb tox_events_clear_friend_status;
tox_events_clear_cb tox_events_clear_friend_typing;
tox_events_clear_cb tox_events_clear_self_connection_status;

// non_null()
typedef bool tox_events_pack_cb(const Tox_Events *events, Bin_Pack *bp);

tox_events_pack_cb tox_events_pack_conference_connected;
tox_events_pack_cb tox_events_pack_conference_invite;
tox_events_pack_cb tox_events_pack_conference_message;
tox_events_pack_cb tox_events_pack_conference_peer_list_changed;
tox_events_pack_cb tox_events_pack_conference_peer_name;
tox_events_pack_cb tox_events_pack_conference_title;
tox_events_pack_cb tox_events_pack_file_chunk_request;
tox_events_pack_cb tox_events_pack_file_recv_chunk;
tox_events_pack_cb tox_events_pack_file_recv_control;
tox_events_pack_cb tox_events_pack_file_recv;
tox_events_pack_cb tox_events_pack_friend_connection_status;
tox_events_pack_cb tox_events_pack_friend_lossless_packet;
tox_events_pack_cb tox_events_pack_friend_lossy_packet;
tox_events_pack_cb tox_events_pack_friend_message;
tox_events_pack_cb tox_events_pack_friend_name;
tox_events_pack_cb tox_events_pack_friend_read_receipt;
tox_events_pack_cb tox_events_pack_friend_request;
tox_events_pack_cb tox_events_pack_friend_status_message;
tox_events_pack_cb tox_events_pack_friend_status;
tox_events_pack_cb tox_events_pack_friend_typing;
tox_events_pack_cb tox_events_pack_self_connection_status;

tox_events_pack_cb tox_events_pack;

// non_null()
typedef bool tox_events_unpack_cb(Tox_Events *events, Bin_Unpack *bu);

tox_events_unpack_cb tox_events_unpack_conference_connected;
tox_events_unpack_cb tox_events_unpack_conference_invite;
tox_events_unpack_cb tox_events_unpack_conference_message;
tox_events_unpack_cb tox_events_unpack_conference_peer_list_changed;
tox_events_unpack_cb tox_events_unpack_conference_peer_name;
tox_events_unpack_cb tox_events_unpack_conference_title;
tox_events_unpack_cb tox_events_unpack_file_chunk_request;
tox_events_unpack_cb tox_events_unpack_file_recv_chunk;
tox_events_unpack_cb tox_events_unpack_file_recv_control;
tox_events_unpack_cb tox_events_unpack_file_recv;
tox_events_unpack_cb tox_events_unpack_friend_connection_status;
tox_events_unpack_cb tox_events_unpack_friend_lossless_packet;
tox_events_unpack_cb tox_events_unpack_friend_lossy_packet;
tox_events_unpack_cb tox_events_unpack_friend_message;
tox_events_unpack_cb tox_events_unpack_friend_name;
tox_events_unpack_cb tox_events_unpack_friend_read_receipt;
tox_events_unpack_cb tox_events_unpack_friend_request;
tox_events_unpack_cb tox_events_unpack_friend_status_message;
tox_events_unpack_cb tox_events_unpack_friend_status;
tox_events_unpack_cb tox_events_unpack_friend_typing;
tox_events_unpack_cb tox_events_unpack_self_connection_status;

tox_events_unpack_cb tox_events_unpack;

non_null()
Tox_Events_State *tox_events_alloc(void *user_data);

#ifdef __cplusplus
}
#endif

#endif // C_TOXCORE_TOXCORE_TOX_EVENTS_INTERNAL_H
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2020-2021 The TokTok team.
 */

#ifndef C_TOXCORE_TOXCORE_ANNOUNCE_H
#define C_TOXCORE_TOXCORE_ANNOUNCE_H


#define MAX_ANNOUNCEMENT_SIZE 512

typedef void announce_on_retrieve_cb(void *object, const uint8_t *data, uint16_t length);

uint8_t announce_response_of_request_type(uint8_t request_type);

typedef struct Announcements Announcements;

non_null()
Announcements *new_announcements(const Logger *log, const Random *rng, const Mono_Time *mono_time, Forwarding *forwarding);

/**
 * @brief If data is stored, run `on_retrieve_callback` on it.
 *
 * @return true if data is stored, false otherwise.
 */
non_null(1, 2) nullable(3, 4)
bool announce_on_stored(const Announcements *announce, const uint8_t *data_public_key,
                        announce_on_retrieve_cb *on_retrieve_callback, void *object);

non_null()
void announce_set_synch_offset(Announcements *announce, int32_t synch_offset);

nullable(1)
void kill_announcements(Announcements *announce);


/* The declarations below are not public, they are exposed only for tests. */

/** @private
 * Return xor of first ANNOUNCE_BUCKET_PREFIX_LENGTH bits from one bit after
 * base and pk first differ
 */
non_null()
uint16_t announce_get_bucketnum(const uint8_t *base, const uint8_t *pk);

/** @private */
non_null(1, 2) nullable(3)
bool announce_store_data(Announcements *announce, const uint8_t *data_public_key,
                         const uint8_t *data, uint32_t length, uint32_t timeout);

/** @private */
#define MAX_MAX_ANNOUNCEMENT_TIMEOUT 900
#define MIN_MAX_ANNOUNCEMENT_TIMEOUT 10
#define MAX_ANNOUNCEMENT_TIMEOUT_UPTIME_RATIO 4

/** @private
 * For efficient lookup and updating, entries are stored as a hash table keyed
 * to the first ANNOUNCE_BUCKET_PREFIX_LENGTH bits starting from one bit after
 * the first bit in which data public key first differs from the dht key, with
 * (2-adically) closest keys preferentially stored within a given bucket. A
 * given key appears at most once (even if timed out).
 */
#define ANNOUNCE_BUCKET_SIZE 8
#define ANNOUNCE_BUCKET_PREFIX_LENGTH 5
#define ANNOUNCE_BUCKETS 32 // ANNOUNCE_BUCKETS = 2 ** ANNOUNCE_BUCKET_PREFIX_LENGTH

#endif
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2018 The TokTok team.
 * Copyright © 2014 Tox project.
 */

/**
 * Connection to friends.
 */
#ifndef C_TOXCORE_TOXCORE_FRIEND_CONNECTION_H
#define C_TOXCORE_TOXCORE_FRIEND_CONNECTION_H


#define MAX_FRIEND_CONNECTION_CALLBACKS 2
#define MESSENGER_CALLBACK_INDEX 0
#define GROUPCHAT_CALLBACK_INDEX 1

#define PACKET_ID_ALIVE 16
#define PACKET_ID_SHARE_RELAYS 17
#define PACKET_ID_FRIEND_REQUESTS 18

/** Interval between the sending of ping packets. */
#define FRIEND_PING_INTERVAL 8

/** If no packets are received from friend in this time interval, kill the connection. */
#define FRIEND_CONNECTION_TIMEOUT (FRIEND_PING_INTERVAL * 4)

/** Time before friend is removed from the DHT after last hearing about him. */
#define FRIEND_DHT_TIMEOUT BAD_NODE_TIMEOUT

#define FRIEND_MAX_STORED_TCP_RELAYS (MAX_FRIEND_TCP_CONNECTIONS * 4)

/** Max number of tcp relays sent to friends */
#define MAX_SHARED_RELAYS RECOMMENDED_FRIEND_TCP_CONNECTIONS

/** How often we share our TCP relays with each friend connection */
#define SHARE_RELAYS_INTERVAL (60 * 2)


typedef enum Friendconn_Status {
    FRIENDCONN_STATUS_NONE,
    FRIENDCONN_STATUS_CONNECTING,
    FRIENDCONN_STATUS_CONNECTED,
} Friendconn_Status;

typedef struct Friend_Connections Friend_Connections;

non_null() Net_Crypto *friendconn_net_crypto(const Friend_Connections *fr_c);

/** @return friendcon_id corresponding to the real public key on success.
 * @retval -1 on failure.
 */
non_null()
int getfriend_conn_id_pk(const Friend_Connections *fr_c, const uint8_t *real_pk);

/** @brief Increases lock_count for the connection with friendcon_id by 1.
 *
 * @retval 0 on success.
 * @retval -1 on failure.
 */
non_null()
int friend_connection_lock(const Friend_Connections *fr_c, int friendcon_id);

/**
 * @retval FRIENDCONN_STATUS_CONNECTED if the friend is connected.
 * @retval FRIENDCONN_STATUS_CONNECTING if the friend isn't connected.
 * @retval FRIENDCONN_STATUS_NONE on failure.
 */
non_null()
unsigned int friend_con_connected(const Friend_Connections *fr_c, int friendcon_id);

/** @brief Copy public keys associated to friendcon_id.
 *
 * @retval 0 on success.
 * @retval -1 on failure.
 */
non_null(3) nullable(1, 2)
int get_friendcon_public_keys(uint8_t *real_pk, uint8_t *dht_temp_pk, const Friend_Connections *fr_c, int friendcon_id);

/** Set temp dht key for connection. */
non_null()
void set_dht_temp_pk(Friend_Connections *fr_c, int friendcon_id, const uint8_t *dht_temp_pk, void *userdata);

typedef int global_status_cb(void *object, int id, bool status, void *userdata);

typedef int fc_status_cb(void *object, int id, bool status, void *userdata);
typedef int fc_data_cb(void *object, int id, const uint8_t *data, uint16_t length, void *userdata);
typedef int fc_lossy_data_cb(void *object, int id, const uint8_t *data, uint16_t length, void *userdata);

/** Set global status callback for friend connections. */
non_null(1) nullable(2, 3)
void set_global_status_callback(Friend_Connections *fr_c, global_status_cb *global_status_callback, void *object);

/** @brief Set the callbacks for the friend connection.
 * @param index is the index (0 to (MAX_FRIEND_CONNECTION_CALLBACKS - 1)) we
 *   want the callback to set in the array.
 *
 * @retval 0 on success.
 * @retval -1 on failure
 */
non_null(1) nullable(4, 5, 6, 7)
int friend_connection_callbacks(const Friend_Connections *fr_c, int friendcon_id, unsigned int index,
                                fc_status_cb *status_callback,
                                fc_data_cb *data_callback,
                                fc_lossy_data_cb *lossy_data_callback,
                                void *object, int number);

/** @brief return the crypt_connection_id for the connection.
 *
 * @return crypt_connection_id on success.
 * @retval -1 on failure.
 */
non_null()
int friend_connection_crypt_connection_id(const Friend_Connections *fr_c, int friendcon_id);

/** @brief Create a new friend connection.
 * If one to that real public key already exists, increase lock count and return it.
 *
 * @retval -1 on failure.
 * @return connection id on success.
 */
non_null()
int new_friend_connection(Friend_Connections *fr_c, const uint8_t *real_public_key);

/** @brief Kill a friend connection.
 *
 * @retval -1 on failure.
 * @retval 0 on success.
 */
non_null()
int kill_friend_connection(Friend_Connections *fr_c, int friendcon_id);

/** @brief Send a Friend request packet.
 *
 * @retval -1 if failure.
 * @retval  0 if it sent the friend request directly to the friend.
 * @return the number of peers it was routed through if it did not send it directly.
 */
non_null()
int send_friend_request_packet(
    Friend_Connections *fr_c, int friendcon_id, uint32_t nospam_num, const uint8_t *data, uint16_t length);

typedef int fr_request_cb(
    void *object, const uint8_t *source_pubkey, const uint8_t *data, uint16_t len, void *userdata);

/** @brief Set friend request callback.
 *
 * This function will be called every time a friend request packet is received.
 */
non_null()
void set_friend_request_callback(Friend_Connections *fr_c, fr_request_cb *fr_request_callback, void *object);

/** Create new friend_connections instance. */
non_null()
Friend_Connections *new_friend_connections(
        const Logger *logger, const Mono_Time *mono_time, const Network *ns,
        Onion_Client *onion_c, bool local_discovery_enabled);

/** main friend_connections loop. */
non_null()
void do_friend_connections(Friend_Connections *fr_c, void *userdata);

/** Free everything related with friend_connections. */
nullable(1)
void kill_friend_connections(Friend_Connections *fr_c);

typedef struct Friend_Conn Friend_Conn;

non_null() Friend_Conn *get_conn(const Friend_Connections *fr_c, int friendcon_id);
non_null() int friend_conn_get_onion_friendnum(const Friend_Conn *fc);
non_null() const IP_Port *friend_conn_get_dht_ip_port(const Friend_Conn *fc);

#endif
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2018 The TokTok team.
 * Copyright © 2014 Tox project.
 */

/**
 * Handle friend requests.
 */
#ifndef C_TOXCORE_TOXCORE_FRIEND_REQUESTS_H
#define C_TOXCORE_TOXCORE_FRIEND_REQUESTS_H


#define MAX_FRIEND_REQUEST_DATA_SIZE (ONION_CLIENT_MAX_DATA_SIZE - (1 + sizeof(uint32_t)))

typedef struct Friend_Requests Friend_Requests;

/** Set and get the nospam variable used to prevent one type of friend request spam. */
non_null() void set_nospam(Friend_Requests *fr, uint32_t num);
non_null() uint32_t get_nospam(const Friend_Requests *fr);

/** @brief Remove real_pk from received_requests list.
 *
 * @retval 0 if it removed it successfully.
 * @retval -1 if it didn't find it.
 */
non_null()
int remove_request_received(Friend_Requests *fr, const uint8_t *real_pk);

typedef void fr_friend_request_cb(void *object, const uint8_t *public_key, const uint8_t *message, size_t length,
                                  void *user_data);

/** Set the function that will be executed when a friend request for us is received. */
non_null()
void callback_friendrequest(Friend_Requests *fr, fr_friend_request_cb *function, void *object);

typedef int filter_function_cb(const uint8_t *public_key, void *user_data);

/** @brief Set the function used to check if a friend request should be displayed to the user or not.
 * It must return 0 if the request is ok (anything else if it is bad).
 */
non_null()
void set_filter_function(Friend_Requests *fr, filter_function_cb *function, void *userdata);

/** Sets up friendreq packet handlers. */
non_null()
void friendreq_init(Friend_Requests *fr, Friend_Connections *fr_c);

Friend_Requests *friendreq_new(void);

nullable(1)
void friendreq_kill(Friend_Requests *fr);

#endif
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2020 The TokTok team.
 * Copyright © 2015 Tox project.
 */

/**
 * An implementation of massive text only group chats.
 */

#ifndef GROUP_CHATS_H
#define GROUP_CHATS_H

#include <stdbool.h>
#include <stdint.h>


#define GC_PING_TIMEOUT 12
#define GC_SEND_IP_PORT_INTERVAL (GC_PING_TIMEOUT * 5)
#define GC_CONFIRMED_PEER_TIMEOUT (GC_PING_TIMEOUT * 4 + 10)
#define GC_UNCONFIRMED_PEER_TIMEOUT GC_PING_TIMEOUT

#define GC_JOIN_DATA_LENGTH (ENC_PUBLIC_KEY_SIZE + CHAT_ID_SIZE)

/** Group topic lock states. */
typedef enum Group_Topic_Lock {
    TL_ENABLED  = 0x00,  // Only the Founder and moderators may set the topic
    TL_DISABLED = 0x01,  // Anyone except Observers may set the topic
} Group_Topic_Lock;

/** Group moderation events. */
typedef enum Group_Moderation_Event {
    MV_KICK      = 0x00,  // A peer has been kicked
    MV_OBSERVER  = 0x01,  // A peer has been demoted to Observer
    MV_USER      = 0x02,  // A peer has been demoted or promoted to User
    MV_MOD       = 0x03,  // A peer has been promoted to or demoted from Moderator
} Group_Moderation_Event;

/** Messenger level group invite types */
typedef enum Group_Invite_Message_Type {
    GROUP_INVITE              = 0x00,  // Peer has initiated an invite
    GROUP_INVITE_ACCEPTED     = 0x01,  // Peer has accepted the invite
    GROUP_INVITE_CONFIRMATION = 0x02,  // Peer has confirmed the accepted invite
} Group_Invite_Message_Type;

/** Group join rejection types. */
typedef enum Group_Join_Rejected {
    GJ_GROUP_FULL       = 0x00,
    GJ_INVALID_PASSWORD = 0x01,
    GJ_INVITE_FAILED    = 0x02,
    GJ_INVALID          = 0x03,
} Group_Join_Rejected;

/** Group broadcast packet types */
typedef enum Group_Broadcast_Type {
    GM_STATUS          = 0x00,  // Peer changed their status
    GM_NICK            = 0x01,  // Peer changed their nickname
    GM_PLAIN_MESSAGE   = 0x02,  // Peer sent a normal message
    GM_ACTION_MESSAGE  = 0x03,  // Peer sent an action message
    GM_PRIVATE_MESSAGE = 0x04,  // Peer sent a private message
    GM_PEER_EXIT       = 0x05,  // Peer left the group
    GM_KICK_PEER       = 0x06,  // Peer was kicked from the group
    GM_SET_MOD         = 0x07,  // Peer was promoted to or demoted from Moderator role
    GM_SET_OBSERVER    = 0x08,  // Peer was demoted to or promoted from Observer role
} Group_Broadcast_Type;

/***
 * Group packet types.
 *
 * For a detailed spec, see docs/DHT_Group_Chats_Packet_Spec.md
 */
typedef enum Group_Packet_Type {
    /* lossy packets (ID 0 is reserved) */
    GP_PING                     = 0x01,
    GP_MESSAGE_ACK              = 0x02,
    GP_INVITE_RESPONSE_REJECT   = 0x03,

    /* lossless packets */
    GP_CUSTOM_PRIVATE_PACKET    = 0xee,
    GP_FRAGMENT                 = 0xef,
    GP_KEY_ROTATION             = 0xf0,
    GP_TCP_RELAYS               = 0xf1,
    GP_CUSTOM_PACKET            = 0xf2,
    GP_BROADCAST                = 0xf3,
    GP_PEER_INFO_REQUEST        = 0xf4,
    GP_PEER_INFO_RESPONSE       = 0xf5,
    GP_INVITE_REQUEST           = 0xf6,
    GP_INVITE_RESPONSE          = 0xf7,
    GP_SYNC_REQUEST             = 0xf8,
    GP_SYNC_RESPONSE            = 0xf9,
    GP_TOPIC                    = 0xfa,
    GP_SHARED_STATE             = 0xfb,
    GP_MOD_LIST                 = 0xfc,
    GP_SANCTIONS_LIST           = 0xfd,
    GP_FRIEND_INVITE            = 0xfe,
    GP_HS_RESPONSE_ACK          = 0xff,
} Group_Packet_Type;

/** Lossless message acknowledgement types. */
typedef enum Group_Message_Ack_Type {
    GR_ACK_RECV    = 0x00,  // indicates a message has been received
    GR_ACK_REQ     = 0x01,  // indicates a message needs to be re-sent
} Group_Message_Ack_Type;

/** @brief Returns the GC_Connection object associated with `peer_number`.
 * Returns null if peer_number does not designate a valid peer.
 */
non_null()
GC_Connection *get_gc_connection(const GC_Chat *chat, int peer_number);

/** @brief Returns the jenkins hash of a 32 byte public encryption key. */
non_null()
uint32_t gc_get_pk_jenkins_hash(const uint8_t *public_key);

/** @brief Check if peer with the public encryption key is in peer list.
 *
 * Returns the peer number if peer is in the peer list.
 * Returns -1 if peer is not in the peer list.
 *
 * If `confirmed` is true the peer number will only be returned if the peer is confirmed.
 */
non_null()
int get_peer_number_of_enc_pk(const GC_Chat *chat, const uint8_t *public_enc_key, bool confirmed);

/** @brief Encrypts `data` of size `length` using the peer's shared key and a new nonce.
 *
 * Adds encrypted header consisting of: packet type, message_id (only for lossless packets).
 * Adds plaintext header consisting of: packet identifier, self public encryption key, nonce.
 *
 * Return length of encrypted packet on success.
 * Return -1 if plaintext length is invalid.
 * Return -2 if malloc fails.
 * Return -3 if encryption fails.
 */
non_null(1, 2, 3, 4, 5) nullable(7)
int group_packet_wrap(
    const Logger *log, const Random *rng, const uint8_t *self_pk, const uint8_t *shared_key, uint8_t *packet,
    uint16_t packet_size, const uint8_t *data, uint16_t length, uint64_t message_id,
    uint8_t gp_packet_type, uint8_t net_packet_type);

/** @brief Returns the size of a wrapped/encrypted packet with a plain size of `length`.
 *
 * `packet_type` should be either NET_PACKET_GC_LOSSY or NET_PACKET_GC_LOSSLESS.
 */
uint16_t gc_get_wrapped_packet_size(uint16_t length, Net_Packet_Type packet_type);

/** @brief Sends a plain message or an action, depending on type.
 *
 * `length` must not exceed MAX_GC_MESSAGE_SIZE and must not be equal to zero.
 * `message_id` should either point to a uint32_t or be NULL.
 *
 * Returns 0 on success.
 * Returns -1 if the message is too long.
 * Returns -2 if the message pointer is NULL or length is zero.
 * Returns -3 if the message type is invalid.
 * Returns -4 if the sender does not have permission to speak.
 * Returns -5 if the packet fails to send.
 */
non_null(1, 2, 3, 4) nullable(5)
int gc_send_message(const GC_Chat *chat, const uint8_t *message, uint16_t length, uint8_t type,
                    uint32_t *message_id);

/** @brief Sends a private message to peer_id.
 *
 * `length` must not exceed MAX_GC_MESSAGE_SIZE and must not be equal to zero.
 *
 * Returns 0 on success.
 * Returns -1 if the message is too long.
 * Returns -2 if the message pointer is NULL or length is zero.
 * Returns -3 if the peer_id is invalid.
 * Returns -4 if the message type is invalid.
 * Returns -5 if the sender has the observer role.
 * Returns -6 if the packet fails to send.
 */
non_null()
int gc_send_private_message(const GC_Chat *chat, uint32_t peer_id, uint8_t type, const uint8_t *message,
                            uint16_t length);

/** @brief Sends a custom packet to the group. If lossless is true, the packet will be lossless.
 *
 * `length` must not exceed MAX_GC_MESSAGE_SIZE and must not be equal to zero.
 *
 * Returns 0 on success.
 * Returns -1 if the message is too long.
 * Returns -2 if the message pointer is NULL or length is zero.
 * Returns -3 if the sender has the observer role.
 */
non_null()
int gc_send_custom_packet(const GC_Chat *chat, bool lossless, const uint8_t *data, uint16_t length);

/** @brief Sends a custom private packet to the peer designated by peer_id.
 *
 * `length` must not exceed MAX_GC_MESSAGE_SIZE and must not be equal to zero.
 *
 * @retval 0 on success.
 * @retval -1 if the message is too long.
 * @retval -2 if the message pointer is NULL or length is zero.
 * @retval -3 if the supplied peer_id does not designate a valid peer.
 * @retval -4 if the sender has the observer role.
 * @retval -5 if the packet fails to send.
 */
non_null()
int gc_send_custom_private_packet(const GC_Chat *chat, bool lossless, uint32_t peer_id, const uint8_t *message,
                                  uint16_t length);

/** @brief Sets ignore for peer_id.
 *
 * Returns 0 on success.
 * Returns -1 if the peer_id is invalid.
 * Returns -2 if the caller attempted to ignore himself.
 */
non_null()
int gc_set_ignore(const GC_Chat *chat, uint32_t peer_id, bool ignore);

/** @brief Sets the group topic and broadcasts it to the group.
 *
 * If `length` is equal to zero the topic will be unset.
 *
 * Returns 0 on success.
 * Returns -1 if the topic is too long (must be `<= MAX_GC_TOPIC_SIZE`).
 * Returns -2 if the caller does not have the required permissions to set the topic.
 * Returns -3 if the packet cannot be created or signing fails.
 * Returns -4 if the packet fails
 */
non_null(1) nullable(2)
int gc_set_topic(GC_Chat *chat, const uint8_t *topic, uint16_t length);

/** @brief Copies the group topic to `topic`. If topic is null this function has no effect.
 *
 * Call `gc_get_topic_size` to determine the allocation size for the `topic` parameter.
 *
 * The data written to `topic` is equal to the data received by the last topic callback.
 */
non_null(1) nullable(2)
void gc_get_topic(const GC_Chat *chat, uint8_t *topic);

/** @brief Returns the topic length.
 *
 * The return value is equal to the `length` agument received by the last topic callback.
 */
non_null()
uint16_t gc_get_topic_size(const GC_Chat *chat);

/** @brief Copies group name to `group_name`. If `group_name` is null this function has no effect.
 *
 * Call `gc_get_group_name_size` to determine the allocation size for the `group_name`
 * parameter.
 */
non_null()
void gc_get_group_name(const GC_Chat *chat, uint8_t *group_name);

/** @brief Returns the group name length. */
non_null()
uint16_t gc_get_group_name_size(const GC_Chat *chat);

/** @brief Copies the group password to password.
 *
 * If password is null this function has no effect.
 *
 * Call the `gc_get_password_size` function to determine the allocation size for
 * the `password` buffer.
 *
 * The data received is equal to the data received by the last password callback.
 */
non_null()
void gc_get_password(const GC_Chat *chat, uint8_t *password);

/** @brief Returns the group password length. */
non_null()
uint16_t gc_get_password_size(const GC_Chat *chat);

/** @brief Returns the group privacy state.
 *
 * The value returned is equal to the data receieved by the last privacy_state callback.
 */
non_null()
Group_Privacy_State gc_get_privacy_state(const GC_Chat *chat);

/** @brief Returns the group topic lock state.
 *
 * The value returned is equal to the data received by the last last topic_lock callback.
 */
non_null()
Group_Topic_Lock gc_get_topic_lock_state(const GC_Chat *chat);

/** @brief Returns the group voice state.
 *
 * The value returned is equal to the data received by the last voice_state callback.
 */
non_null()
Group_Voice_State gc_get_voice_state(const GC_Chat *chat);

/** @brief Returns the group peer limit.
 *
 * The value returned is equal to the data receieved by the last peer_limit callback.
 */
non_null()
uint16_t gc_get_max_peers(const GC_Chat *chat);

void gc_get_group_peer_connection_ip(const Messenger *m, int group_number, uint32_t peer_id, uint8_t *ip_str);

/** @brief Sets your own nick to `nick`.
 *
 * `length` cannot exceed MAX_GC_NICK_SIZE. if `length` is zero or `name` is a
 * null pointer the function call will fail.
 *
 * Returns 0 on success.
 * Returns -1 if group_number is invalid.
 * Returns -2 if the length is too long.
 * Returns -3 if the length is zero or nick is a NULL pointer.
 * Returns -4 if the packet fails to send.
 */
non_null()
int gc_set_self_nick(const Messenger *m, int group_number, const uint8_t *nick, uint16_t length);

/** @brief Copies your own name to `nick`.
 *
 * If `nick` is null this function has no effect.
 */
non_null()
void gc_get_self_nick(const GC_Chat *chat, uint8_t *nick);

/** @brief Return your own nick length.
 *
 * If no nick was set before calling this function it will return 0.
 */
non_null()
uint16_t gc_get_self_nick_size(const GC_Chat *chat);

/** @brief Returns your own group role. */
non_null()
Group_Role gc_get_self_role(const GC_Chat *chat);

/** @brief Return your own status. */
non_null()
uint8_t gc_get_self_status(const GC_Chat *chat);

/** @brief Returns your own peer id. */
non_null()
uint32_t gc_get_self_peer_id(const GC_Chat *chat);

/** @brief Copies self public key to `public_key`.
 *
 * If `public_key` is null this function has no effect.
 *
 * This key is permanently tied to our identity for `chat` until we explicitly
 * exit the group. This key is the only way for other peers to reliably identify
 * us across client restarts.
 */
non_null(1) nullable(2)
void gc_get_self_public_key(const GC_Chat *chat, uint8_t *public_key);

/** @brief Copies nick designated by `peer_id` to `name`.
 *
 * Call `gc_get_peer_nick_size` to determine the allocation size for the `name` parameter.
 *
 * The data written to `name` is equal to the data received by the last nick_change callback.
 *
 * Returns true on success.
 * Returns false if peer_id is invalid.
 */
non_null(1) nullable(3)
bool gc_get_peer_nick(const GC_Chat *chat, uint32_t peer_id, uint8_t *name);

/** @brief Returns the length of the nick for the peer designated by `peer_id`.
 * Returns -1 if peer_id is invalid.
 *
 * The value returned is equal to the `length` argument received by the last
 * nick_change callback.
 */
non_null()
int gc_get_peer_nick_size(const GC_Chat *chat, uint32_t peer_id);

/** @brief Returns the peer_id of the peer with this `public_key`.
 *
 * Returns peer_id on success.
 * Returns -1 on error.
 */
non_null()
int64_t get_gc_peer_id_by_public_key(const GC_Chat *chat, const uint8_t *public_key);

/** @brief Copies peer_id's public key to `public_key`.
 *
 * This key is permanently tied to the peer's identity for `chat` until they explicitly
 * exit the group. This key is the only way for to reliably identify the given peer
 * across client restarts.
 *
 * `public_key` shold have room for at least ENC_PUBLIC_KEY_SIZE bytes.
 *
 * Returns 0 on success.
 * Returns -1 if peer_id is invalid or doesn't correspond to a valid peer connection.
 * Returns -2 if `public_key` is null.
 */
non_null(1) nullable(3)
int gc_get_peer_public_key_by_peer_id(const GC_Chat *chat, uint32_t peer_id, uint8_t *public_key);

non_null(1) nullable(3)
int gc_get_savedpeer_public_key_by_slot_number(const GC_Chat *chat, uint32_t slot_number, uint8_t *public_key);

/** @brief Gets the connection status for peer associated with `peer_id`.
 *
 * If `peer_id` designates ourself, the return value indicates whether we're capable
 * of making UDP connections with other peers, or are limited to TCP connections.
 *
 * Returns 2 if we have a direct (UDP) connection with a peer.
 * Returns 1 if we have an indirect (TCP) connection with a peer.
 * Returns 0 if peer_id is invalid.
 *
 * Note: Return values must correspond to Tox_Connection enum in API.
 */
non_null()
unsigned int gc_get_peer_connection_status(const GC_Chat *chat, uint32_t peer_id);

/** @brief Sets the caller's status to `status`.
 *
 * Returns 0 on success.
 * Returns -1 if the group_number is invalid.
 * Returns -2 if the packet failed to send.
 */
non_null()
int gc_set_self_status(const Messenger *m, int group_number, Group_Peer_Status status);

/** @brief Returns the status of peer designated by `peer_id`.
 * Returns UINT8_MAX on failure.
 *
 * The status returned is equal to the last status received through the status_change
 * callback.
 */
non_null()
uint8_t gc_get_status(const GC_Chat *chat, uint32_t peer_id);

/** @brief Returns the group role of peer designated by `peer_id`.
 * Returns UINT8_MAX on failure.
 *
 * The role returned is equal to the last role received through the moderation callback.
 */
non_null()
uint8_t gc_get_role(const GC_Chat *chat, uint32_t peer_id);

/** @brief Sets the role of peer_id. role must be one of: GR_MODERATOR, GR_USER, GR_OBSERVER
 *
 * Returns 0 on success.
 * Returns -1 if the group_number is invalid.
 * Returns -2 if the peer_id is invalid.
 * Returns -3 if caller does not have sufficient permissions for the action.
 * Returns -4 if the role assignment is invalid.
 * Returns -5 if the role failed to be set.
 * Returns -6 if the caller attempted to kick himself.
 */
non_null()
int gc_set_peer_role(const Messenger *m, int group_number, uint32_t peer_id, Group_Role new_role);

/** @brief Sets the group password and distributes the new shared state to the group.
 *
 * This function requires that the shared state be re-signed and will only work for the group founder.
 *
 * If `password` is null or `password_length` is 0 the password will be unset for the group.
 *
 * Returns 0 on success.
 * Returns -1 if the caller does not have sufficient permissions for the action.
 * Returns -2 if the password is too long.
 * Returns -3 if the packet failed to send.
 * Returns -4 if malloc failed.
 */
non_null(1) nullable(2)
int gc_founder_set_password(GC_Chat *chat, const uint8_t *password, uint16_t password_length);

/** @brief Sets the topic lock and distributes the new shared state to the group.
 *
 * When the topic lock is enabled, only the group founder and moderators may set the topic.
 * When disabled, all peers except those with the observer role may set the topic.
 *
 * This function requires that the shared state be re-signed and will only work for the group founder.
 *
 * Returns 0 on success.
 * Returns -1 if group_number is invalid.
 * Returns -2 if `topic_lock` is an invalid type.
 * Returns -3 if the caller does not have sufficient permissions for this action.
 * Returns -4 if the group is disconnected.
 * Returns -5 if the topic lock could not be set.
 * Returns -6 if the packet failed to send.
 */
non_null()
int gc_founder_set_topic_lock(const Messenger *m, int group_number, Group_Topic_Lock new_lock_state);

/** @brief Sets the group privacy state and distributes the new shared state to the group.
 *
 * This function requires that the shared state be re-signed and will only work for the group founder.
 *
 * If an attempt is made to set the privacy state to the same state that the group is already
 * in, the function call will be successful and no action will be taken.
 *
 * Returns 0 on success.
 * Returns -1 if group_number is invalid.
 * Returns -2 if the caller does not have sufficient permissions for this action.
 * Returns -3 if the group is disconnected.
 * Returns -4 if the privacy state could not be set.
 * Returns -5 if the packet failed to send.
 */
non_null()
int gc_founder_set_privacy_state(const Messenger *m, int group_number, Group_Privacy_State new_privacy_state);

/** @brief Sets the group voice state and distributes the new shared state to the group.
 *
 * This function requires that the shared state be re-signed and will only work for the group founder.
 *
 * If an attempt is made to set the voice state to the same state that the group is already
 * in, the function call will be successful and no action will be taken.
 *
 * Returns 0 on success.
 * Returns -1 if group_number is invalid.
 * Returns -2 if the caller does not have sufficient permissions for this action.
 * Returns -3 if the group is disconnected.
 * Returns -4 if the voice state could not be set.
 * Returns -5 if the packet failed to send.
 */
non_null()
int gc_founder_set_voice_state(const Messenger *m, int group_number, Group_Voice_State new_voice_state);

/** @brief Sets the peer limit to maxpeers and distributes the new shared state to the group.
 *
 * This function requires that the shared state be re-signed and will only work for the group founder.
 *
 * Returns 0 on success.
 * Returns -1 if the caller does not have sufficient permissions for this action.
 * Returns -2 if the peer limit could not be set.
 * Returns -3 if the packet failed to send.
 */
non_null()
int gc_founder_set_max_peers(GC_Chat *chat, uint16_t max_peers);

/** @brief Removes peer designated by `peer_id` from peer list and sends a broadcast instructing
 * all other peers to remove the peer from their peerlist as well.
 *
 * This function will not trigger the peer_exit callback for the caller.
 *
 * Returns 0 on success.
 * Returns -1 if the group_number is invalid.
 * Returns -2 if the peer_id is invalid.
 * Returns -3 if the caller does not have sufficient permissions for this action.
 * Returns -4 if the action failed.
 * Returns -5 if the packet failed to send.
 * Returns -6 if the caller attempted to kick himself.
 */
non_null()
int gc_kick_peer(const Messenger *m, int group_number, uint32_t peer_id);

/** @brief Copies the chat_id to dest. If dest is null this function has no effect.
 *
 * `dest` should have room for at least CHAT_ID_SIZE bytes.
 */
non_null(1) nullable(2)
void gc_get_chat_id(const GC_Chat *chat, uint8_t *dest);


/** Group callbacks */
non_null(1) nullable(2) void gc_callback_message(const Messenger *m, gc_message_cb *function);
non_null(1) nullable(2) void gc_callback_private_message(const Messenger *m, gc_private_message_cb *function);
non_null(1) nullable(2) void gc_callback_custom_packet(const Messenger *m, gc_custom_packet_cb *function);
non_null(1) nullable(2) void gc_callback_custom_private_packet(const Messenger *m,
        gc_custom_private_packet_cb *function);
non_null(1) nullable(2) void gc_callback_moderation(const Messenger *m, gc_moderation_cb *function);
non_null(1) nullable(2) void gc_callback_nick_change(const Messenger *m, gc_nick_change_cb *function);
non_null(1) nullable(2) void gc_callback_status_change(const Messenger *m, gc_status_change_cb *function);
non_null(1) nullable(2) void gc_callback_connection_status_change(const Messenger *m, gc_connection_status_change_cb *function);
non_null(1) nullable(2) void gc_callback_topic_change(const Messenger *m, gc_topic_change_cb *function);
non_null(1) nullable(2) void gc_callback_peer_limit(const Messenger *m, gc_peer_limit_cb *function);
non_null(1) nullable(2) void gc_callback_privacy_state(const Messenger *m, gc_privacy_state_cb *function);
non_null(1) nullable(2) void gc_callback_topic_lock(const Messenger *m, gc_topic_lock_cb *function);
non_null(1) nullable(2) void gc_callback_password(const Messenger *m, gc_password_cb *function);
non_null(1) nullable(2) void gc_callback_peer_join(const Messenger *m, gc_peer_join_cb *function);
non_null(1) nullable(2) void gc_callback_peer_exit(const Messenger *m, gc_peer_exit_cb *function);
non_null(1) nullable(2) void gc_callback_self_join(const Messenger *m, gc_self_join_cb *function);
non_null(1) nullable(2) void gc_callback_rejected(const Messenger *m, gc_rejected_cb *function);
non_null(1) nullable(2) void gc_callback_voice_state(const Messenger *m, gc_voice_state_cb *function);

/** @brief The main loop. Should be called with every Messenger iteration. */
non_null(1) nullable(2)
void do_gc(GC_Session *c, void *userdata);

/**
 * Make sure that DHT is initialized before calling this.
 * Returns a NULL pointer on failure.
 */
nullable(1)
GC_Session *new_dht_groupchats(Messenger *m);

/** @brief Cleans up groupchat structures and calls `gc_group_exit()` for every group chat */
nullable(1)
void kill_dht_groupchats(GC_Session *c);

/** @brief Loads a previously saved group and attempts to join it.
 *
 * `bu` is the packed group info.
 *
 * Returns group_number on success.
 * Returns -1 on failure.
 */
non_null()
int gc_group_load(GC_Session *c, Bin_Unpack *bu);

/**
 * @brief Saves info from `chat` to `bp` in binary format.
 */
non_null()
void gc_group_save(const GC_Chat *chat, Bin_Pack *bp);

/** @brief Creates a new group and adds it to the group sessions group array.
 *
 * The caller of this function has founder role privileges.
 *
 * The client should initiate its peer list with self info after calling this function, as
 * the peer_join callback will not be triggered.
 *
 * Return -1 if the nick or group name is too long.
 * Return -2 if the nick or group name is empty.
 * Return -3 if the the group object fails to initialize.
 * Return -4 if the group state fails to initialize.
 * Return -5 if the Messenger friend connection fails to initialize.
 */
non_null()
int gc_group_add(GC_Session *c, Group_Privacy_State privacy_state, const uint8_t *group_name,
                 uint16_t group_name_length,
                 const uint8_t *nick, size_t nick_length);

/** @brief Joins a group designated by `chat_id`.
 *
 * This function creates a new GC_Chat object, adds it to the chats array, and sends a DHT
 * announcement to find peers in the group associated with `chat_id`. Once a peer has been
 * found a join attempt will be initiated.
 *
 * If the group is not password protected password should be set to NULL and password_length should be 0.
 *
 * Return group_number on success.
 * Return -1 if the group object fails to initialize.
 * Return -2 if chat_id is NULL or a group with chat_id already exists in the chats array.
 * Return -3 if nick is too long.
 * Return -4 if nick is empty or nick length is zero.
 * Return -5 if there is an error setting the group password.
 * Return -6 if the Messenger friend connection fails to initialize.
 */
non_null(1, 2, 3) nullable(5)
int gc_group_join(GC_Session *c, const uint8_t *chat_id, const uint8_t *nick, size_t nick_length, const uint8_t *passwd,
                  uint16_t passwd_len);

/** @brief Disconnects from all peers in a group but saves the group state for later use.
 *
 * Return true on sucess.
 * Return false if the group handler object or chat object is null.
 */
non_null()
bool gc_disconnect_from_group(const GC_Session *c, GC_Chat *chat);

/** @brief Disconnects from all peers in a group and attempts to reconnect.
 *
 * All self state and credentials are retained.
 *
 * Returns 0 on success.
 * Returns -1 if the group handler object or chat object is null.
 * Returns -2 if the Messenger friend connection fails to initialize.
 */
non_null()
int gc_rejoin_group(GC_Session *c, GC_Chat *chat);

/** @brief Joins a group using the invite data received in a friend's group invite.
 *
 * The invite is only valid while the inviter is present in the group.
 *
 * Return group_number on success.
 * Return -1 if the invite data is malformed.
 * Return -2 if the group object fails to initialize.
 * Return -3 if nick is too long.
 * Return -4 if nick is empty or nick length is zero.
 * Return -5 if there is an error setting the password.
 * Return -6 if friend doesn't exist.
 * Return -7 if sending packet failed.
 */
non_null(1, 3, 5) nullable(7)
int gc_accept_invite(GC_Session *c, int32_t friend_number, const uint8_t *data, uint16_t length, const uint8_t *nick,
                     size_t nick_length, const uint8_t *passwd, uint16_t passwd_len);

typedef bool gc_send_group_invite_packet_cb(const Messenger *m, uint32_t friendnumber, const uint8_t *packet,
        uint16_t length);

/** @brief Invites friend designated by `friendnumber` to chat.
 * Packet includes: Type, chat_id, TCP node or packed IP_Port.
 *
 * Return 0 on success.
 * Return -1 if friendnumber does not exist.
 * Return -2 on failure to create the invite data.
 * Return -3 if the packet fails to send.
 */
non_null()
int gc_invite_friend(const GC_Session *c, GC_Chat *chat, int32_t friend_number,
                     gc_send_group_invite_packet_cb *callback);

/** @brief Leaves a group and sends an exit broadcast packet with an optional parting message.
 *
 * All group state is permanently lost, including keys and roles.
 *
 * Return 0 on success.
 * Return -1 if the parting message is too long.
 * Return -2 if the parting message failed to send.
 */
non_null(1, 2) nullable(3)
int gc_group_exit(GC_Session *c, GC_Chat *chat, const uint8_t *message, uint16_t length);

/** @brief Returns true if `chat` is a valid group chat.
 *
 * A valid group chat constitutes an initialized chat instance with a non-zero shared state version.
 * The shared state version will be non-zero either if a peer has created the group, or if
 * they have ever successfully connected to the group.
 */
non_null()
bool gc_group_is_valid(const GC_Chat *chat);

/** @brief Returns the number of active groups in `c`. */
non_null()
uint32_t gc_count_groups(const GC_Session *c);

non_null()
uint32_t copy_grouplist(const GC_Session *c, uint32_t *out_list, uint32_t list_size);

non_null()
uint32_t get_group_peercount(const GC_Chat *chat);

non_null()
uint32_t get_group_offline_peercount(const GC_Chat *chat);

non_null()
void copy_peerlist(const GC_Chat *chat, uint32_t *out_list);

/** @brief Returns true if peer_number exists */
non_null()
bool gc_peer_number_is_valid(const GC_Chat *chat, int peer_number);

/** @brief Return group_number's GC_Chat pointer on success
 * Return NULL on failure
 */
non_null()
GC_Chat *gc_get_group(const GC_Session *c, int group_number);

/** @brief Sends a lossy message acknowledgement to peer associated with `gconn`.
 *
 * If `type` is GR_ACK_RECV we send a read-receipt for read_id's packet. If `type` is GR_ACK_REQ
 * we send a request for the respective id's packet.
 *
 * Requests are limited to one per second per peer.
 *
 * @retval true on success.
 */
non_null()
bool gc_send_message_ack(const GC_Chat *chat, GC_Connection *gconn, uint64_t message_id, Group_Message_Ack_Type type);

/** @brief Helper function for `handle_gc_lossless_packet()`.
 *
 * Note: This function may modify the peer list and change peer numbers.
 *
 * @retval true if packet is successfully handled.
 */
non_null(1, 2) nullable(4, 7)
bool handle_gc_lossless_helper(const GC_Session *c, GC_Chat *chat, uint32_t peer_number, const uint8_t *data,
                               uint16_t length, uint8_t packet_type, void *userdata);

/** @brief Handles an invite accept packet.
 *
 * @retval true on success.
 */
non_null()
bool handle_gc_invite_accepted_packet(const GC_Session *c, int friend_number, const uint8_t *data, uint16_t length);

/** @brief Return true if `chat_id` is not present in our group sessions array.
 *
 * `length` must be at least CHAT_ID_SIZE bytes in length.
 */
non_null()
bool group_not_added(const GC_Session *c, const uint8_t *chat_id, uint32_t length);

/** @brief Handles an invite confirmed packet.
 *
 * Return 0 on success.
 * Return -1 if length is invalid.
 * Return -2 if data contains invalid chat_id.
 * Return -3 if data contains invalid peer info.
 * Return -4 if `friend_number` does not designate a valid friend.
 * Return -5 if data contains invalid connection info.
 */
non_null()
int handle_gc_invite_confirmed_packet(const GC_Session *c, int friend_number, const uint8_t *data, uint16_t length);

/** @brief Returns the group designated by `public_key`.
 * Returns null if group does not exist.
 */
non_null()
GC_Chat *gc_get_group_by_public_key(const GC_Session *c, const uint8_t *public_key);

/** @brief Attempts to add peers from `announces` to our peer list and initiate an invite request.
 *
 * Returns the number of peers added on success.
 * Returns -1 on failure.
 */
non_null()
int gc_add_peers_from_announces(GC_Chat *chat, const GC_Announce *announces, uint8_t gc_announces_count);

#endif  // GROUP_CHATS_H
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2020 The TokTok team.
 * Copyright © 2015 Tox project.
 */

/**
 * An implementation of massive text only group chats.
 */

#ifndef GROUP_CONNECTION_H
#define GROUP_CONNECTION_H


/* Max number of TCP relays we share with a peer on handshake */
#define GCC_MAX_TCP_SHARED_RELAYS 3

/** Marks a peer for deletion. If gconn is null or already marked for deletion this function has no effect. */
non_null(1, 2) nullable(4)
void gcc_mark_for_deletion(GC_Connection *gconn, TCP_Connections *tcp_conn, Group_Exit_Type type,
                           const uint8_t *part_message, uint16_t length);

/** @brief Decides if message need to be put in recv_array or immediately handled.
 *
 * Return 3 if message is in correct sequence and is a fragment packet.
 * Return 2 if message is in correct sequence and may be handled immediately.
 * Return 1 if packet is out of sequence and added to recv_array.
 * Return 0 if message is a duplicate.
 * Return -1 on failure
 */
non_null(1, 2, 3) nullable(4)
int gcc_handle_received_message(const Logger *log, const Mono_Time *mono_time, GC_Connection *gconn,
                                const uint8_t *data, uint16_t length, uint8_t packet_type, uint64_t message_id,
                                bool direct_conn);

/** @brief Handles a packet fragment.
 *
 * If the fragment is incomplete, it gets stored in the recv
 * array. Otherwise the segment is re-assembled into a complete
 * payload and processed.
 *
 * Return 1 if fragment is successfully handled and is not the end of the sequence.
 * Return 0 if fragment is the end of a sequence and successfully handled.
 * Return -1 on failure.
 */
non_null(1, 2, 4) nullable(5, 9)
int gcc_handle_packet_fragment(const GC_Session *c, GC_Chat *chat, uint32_t peer_number, GC_Connection *gconn,
                               const uint8_t *chunk, uint16_t length, uint8_t packet_type,  uint64_t message_id,
                               void *userdata);

/** @brief Return array index for message_id */
uint16_t gcc_get_array_index(uint64_t message_id);

/** @brief Removes send_array item with message_id.
 *
 * Return true on success.
 */
non_null()
bool gcc_handle_ack(const Logger *log, GC_Connection *gconn, uint64_t message_id);

/** @brief Sets the send_message_id and send_array_start for `gconn` to `id`.
 *
 * This should only be used to initialize a new lossless connection.
 */
non_null()
void gcc_set_send_message_id(GC_Connection *gconn, uint64_t id);

/** @brief Sets the received_message_id for `gconn` to `id`. */
non_null()
void gcc_set_recv_message_id(GC_Connection *gconn, uint64_t id);

/**
 * @brief Returns true if the ip_port is set for gconn.
 */
non_null()
bool gcc_ip_port_is_set(const GC_Connection *gconn);

/**
 * @brief Sets the ip_port for gconn to ipp.
 *
 * If ipp is not set this function has no effect.
 */
non_null(1) nullable(2)
void gcc_set_ip_port(GC_Connection *gconn, const IP_Port *ipp);

/** @brief Copies a random TCP relay node from gconn to tcp_node.
 *
 * Return true on success.
 */
non_null()
bool gcc_copy_tcp_relay(const Random *rng, Node_format *tcp_node, const GC_Connection *gconn);

/** @brief Saves tcp_node to gconn's list of connected tcp relays.
 *
 * If relays list is full a random node is overwritten with the new node.
 *
 * Return 0 on success.
 * Return -1 on failure.
 * Return -2 if node is already in list.
 */
non_null()
int gcc_save_tcp_relay(const Random *rng, GC_Connection *gconn, const Node_format *tcp_node);

/** @brief Checks for and handles messages that are in proper sequence in gconn's recv_array.
 * This should always be called after a new packet is successfully handled.
 */
non_null(1, 2, 3) nullable(5)
void gcc_check_recv_array(const GC_Session *c, GC_Chat *chat, GC_Connection *gconn, uint32_t peer_number,
                          void *userdata);

/** @brief Attempts to re-send lossless packets that have not yet received an ack. */
non_null()
void gcc_resend_packets(const GC_Chat *chat, GC_Connection *gconn);

/**
 * Uses public encryption key `sender_pk` and the shared secret key associated with `gconn`
 * to generate a shared 32-byte encryption key that can be used by the owners of both keys for symmetric
 * encryption and decryption.
 *
 * Puts the result in the shared session key buffer for `gconn`, which must have room for
 * CRYPTO_SHARED_KEY_SIZE bytes. This resulting shared key should be treated as a secret key.
 */
non_null()
void gcc_make_session_shared_key(GC_Connection *gconn, const uint8_t *sender_pk);

/** @brief Return true if we have a direct connection with `gconn`. */
non_null()
bool gcc_conn_is_direct(const Mono_Time *mono_time, const GC_Connection *gconn);

/** @brief Return true if a direct UDP connection is possible with `gconn`. */
non_null()
bool gcc_direct_conn_is_possible(const GC_Chat *chat, const GC_Connection *gconn);

/** @brief Sends a packet to the peer associated with gconn.
 *
 * This is a lower level function that does not encrypt or wrap the packet.
 *
 * Return true on success.
 */
non_null()
bool gcc_send_packet(const GC_Chat *chat, const GC_Connection *gconn, const uint8_t *packet, uint16_t length);

/** @brief Sends a lossless packet to `gconn` comprised of `data` of size `length`.
 *
 * This function will add the packet to the lossless send array, encrypt/wrap it using the
 * shared key associated with `gconn`, and send it over the wire.
 *
 * Return 0 on success.
 * Return -1 if the packet couldn't be added to the send array.
 * Return -2 if the packet failed to be encrypted or failed to send.
 */
non_null(1, 2) nullable(3)
int gcc_send_lossless_packet(const GC_Chat *chat, GC_Connection *gconn, const uint8_t *data, uint16_t length,
                             uint8_t packet_type);

/** @brief Splits a lossless packet up into fragments, wraps each fragment in a GP_FRAGMENT
 * header, encrypts them, and send them in succession.
 *
 * This function will first try to add each packet fragment to the send array as an atomic
 * unit. If any chunk fails to be added the process will be reversed and an error will be
 * returned. Otherwise it will then try to send all the fragments in succession.
 *
 * Return true if all fragments are successfully added to the send array.
 */
non_null()
bool gcc_send_lossless_packet_fragments(const GC_Chat *chat, GC_Connection *gconn, const uint8_t *data,
                                        uint16_t length, uint8_t packet_type);


/** @brief Encrypts `data` of `length` bytes, designated by `message_id`, using the shared key
 * associated with `gconn` and sends lossless packet over the wire.
 *
 * This function does not add the packet to the send array.
 *
 * Return true on success.
 */
non_null(1, 2) nullable(3)
bool gcc_encrypt_and_send_lossless_packet(const GC_Chat *chat, const GC_Connection *gconn, const uint8_t *data,
        uint16_t length, uint64_t message_id, uint8_t packet_type);

/** @brief Called when a peer leaves the group. */
non_null()
void gcc_peer_cleanup(GC_Connection *gconn);

/** @brief Called on group exit. */
non_null()
void gcc_cleanup(const GC_Chat *chat);

#endif  // GROUP_CONNECTION_H
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2018 The TokTok team.
 * Copyright © 2014 Tox project.
 */

/**
 * Slightly better groupchats implementation.
 */
#ifndef C_TOXCORE_TOXCORE_GROUP_H
#define C_TOXCORE_TOXCORE_GROUP_H


typedef enum Groupchat_Type {
    GROUPCHAT_TYPE_TEXT,
    GROUPCHAT_TYPE_AV,
} Groupchat_Type;

typedef void peer_on_join_cb(void *object, uint32_t conference_number, uint32_t peer_number);
typedef void peer_on_leave_cb(void *object, uint32_t conference_number, void *peer_object);
typedef void group_on_delete_cb(void *object, uint32_t conference_number);

/** @brief Callback for group invites.
 *
 * data of length is what needs to be passed to `join_groupchat()`.
 */
typedef void g_conference_invite_cb(Messenger *m, uint32_t friend_number, int type, const uint8_t *cookie,
                                    size_t length, void *user_data);

/** Callback for group connection. */
typedef void g_conference_connected_cb(Messenger *m, uint32_t conference_number, void *user_data);

/** Callback for group messages. */
typedef void g_conference_message_cb(Messenger *m, uint32_t conference_number, uint32_t peer_number, int type,
                                     const uint8_t *message, size_t length, void *user_data);

/** Callback for peer nickname changes. */
typedef void peer_name_cb(Messenger *m, uint32_t conference_number, uint32_t peer_number, const uint8_t *name,
                          size_t length, void *user_data);

/** Set callback function for peer list changes. */
typedef void peer_list_changed_cb(Messenger *m, uint32_t conference_number, void *user_data);

/** @brief Callback for title changes.
 *
 * If peer_number == -1, then author is unknown (e.g. initial joining the group).
 */
typedef void title_cb(Messenger *m, uint32_t conference_number, uint32_t peer_number, const uint8_t *title,
                      size_t length, void *user_data);

/** @brief Callback for lossy packets.
 *
 * NOTE: Handler must return 0 if packet is to be relayed, -1 if the packet should not be relayed.
 */
typedef int lossy_packet_cb(void *object, uint32_t conference_number, uint32_t peer_number, void *peer_object,
                            const uint8_t *packet, uint16_t length);

typedef struct Group_Chats Group_Chats;

non_null()
const Mono_Time *g_mono_time(const Group_Chats *g_c);

/** Set the callback for group invites. */
non_null()
void g_callback_group_invite(Group_Chats *g_c, g_conference_invite_cb *function);

/** Set the callback for group connection. */
non_null()
void g_callback_group_connected(Group_Chats *g_c, g_conference_connected_cb *function);

/** Set the callback for group messages. */
non_null()
void g_callback_group_message(Group_Chats *g_c, g_conference_message_cb *function);


/** Set callback function for title changes. */
non_null()
void g_callback_group_title(Group_Chats *g_c, title_cb *function);

/** @brief Set callback function for peer nickname changes.
 *
 * It gets called every time a peer changes their nickname.
 */
non_null()
void g_callback_peer_name(Group_Chats *g_c, peer_name_cb *function);

/** @brief Set callback function for peer list changes.
 *
 * It gets called every time the name list changes(new peer, deleted peer)
 */
non_null()
void g_callback_peer_list_changed(Group_Chats *g_c, peer_list_changed_cb *function);

/** @brief Creates a new groupchat and puts it in the chats array.
 *
 * @param rng Random number generator used for generating the group ID.
 * @param type is one of `GROUPCHAT_TYPE_*`
 *
 * @return group number on success.
 * @retval -1 on failure.
 */
non_null()
int add_groupchat(Group_Chats *g_c, const Random *rng, uint8_t type);

/** @brief Delete a groupchat from the chats array, informing the group first as
 * appropriate.
 *
 * @retval true on success.
 * @retval false if groupnumber is invalid.
 */
non_null()
bool del_groupchat(Group_Chats *g_c, uint32_t groupnumber, bool leave_permanently);

/**
 * @brief Copy the public key of (frozen, if frozen is true) peernumber who is in
 *   groupnumber to pk.
 *
 * @param pk must be CRYPTO_PUBLIC_KEY_SIZE long.
 *
 * @retval 0 on success
 * @retval -1 if groupnumber is invalid.
 * @retval -2 if peernumber is invalid.
 */
non_null()
int group_peer_pubkey(const Group_Chats *g_c, uint32_t groupnumber, uint32_t peernumber, uint8_t *pk, bool frozen);

/**
 * @brief Return the size of (frozen, if frozen is true) peernumber's name.
 *
 * @retval -1 if groupnumber is invalid.
 * @retval -2 if peernumber is invalid.
 */
non_null()
int group_peername_size(const Group_Chats *g_c, uint32_t groupnumber, uint32_t peernumber, bool frozen);

/**
 * @brief Copy the name of (frozen, if frozen is true) peernumber who is in
 *   groupnumber to name.
 *
 * @param  name must be at least MAX_NAME_LENGTH long.
 *
 * @return length of name if success
 * @retval -1 if groupnumber is invalid.
 * @retval -2 if peernumber is invalid.
 */
non_null()
int group_peername(const Group_Chats *g_c, uint32_t groupnumber, uint32_t peernumber, uint8_t *name,
                   bool frozen);

/**
 * @brief Copy last active timestamp of frozen peernumber who is in groupnumber to
 *   last_active.
 *
 * @retval 0 on success.
 * @retval -1 if groupnumber is invalid.
 * @retval -2 if peernumber is invalid.
 */
non_null()
int group_frozen_last_active(
    const Group_Chats *g_c, uint32_t groupnumber, uint32_t peernumber, uint64_t *last_active);

/** @brief Set maximum number of frozen peers.
 *
 * @retval 0 on success.
 * @retval -1 if groupnumber is invalid.
 */
non_null()
int group_set_max_frozen(const Group_Chats *g_c, uint32_t groupnumber, uint32_t maxfrozen);

/** @brief invite friendnumber to groupnumber.
 *
 * @retval 0 on success.
 * @retval -1 if groupnumber is invalid.
 * @retval -2 if invite packet failed to send.
 * @retval -3 if we are not connected to the group chat.
 */
non_null()
int invite_friend(const Group_Chats *g_c, uint32_t friendnumber, uint32_t groupnumber);

/** @brief Join a group (we need to have been invited first).
 *
 * @param expected_type is the groupchat type we expect the chat we are joining
 *   to have.
 *
 * @return group number on success.
 * @retval -1 if data length is invalid.
 * @retval -2 if group is not the expected type.
 * @retval -3 if friendnumber is invalid.
 * @retval -4 if client is already in this group.
 * @retval -5 if group instance failed to initialize.
 * @retval -6 if join packet fails to send.
 */
non_null()
int join_groupchat(
    Group_Chats *g_c, uint32_t friendnumber, uint8_t expected_type, const uint8_t *data, uint16_t length);

/** @brief send a group message
 * @retval 0 on success
 * @see send_message_group for error codes.
 */
non_null()
int group_message_send(const Group_Chats *g_c, uint32_t groupnumber, const uint8_t *message, uint16_t length);

/** @brief send a group action
 * @retval 0 on success
 * @see send_message_group for error codes.
 */
non_null()
int group_action_send(const Group_Chats *g_c, uint32_t groupnumber, const uint8_t *action, uint16_t length);

/** @brief set the group's title, limited to MAX_NAME_LENGTH.
 * @retval 0 on success
 * @retval -1 if groupnumber is invalid.
 * @retval -2 if title is too long or empty.
 * @retval -3 if packet fails to send.
 */
non_null()
int group_title_send(const Group_Chats *g_c, uint32_t groupnumber, const uint8_t *title, uint8_t title_len);


/** @brief return the group's title size.
 * @retval -1 of groupnumber is invalid.
 * @retval -2 if title is too long or empty.
 */
non_null()
int group_title_get_size(const Group_Chats *g_c, uint32_t groupnumber);

/** @brief Get group title from groupnumber and put it in title.
 *
 * Title needs to be a valid memory location with a size of at least MAX_NAME_LENGTH (128) bytes.
 *
 * @return length of copied title if success.
 * @retval -1 if groupnumber is invalid.
 * @retval -2 if title is too long or empty.
 */
non_null()
int group_title_get(const Group_Chats *g_c, uint32_t groupnumber, uint8_t *title);

/**
 * @return the number of (frozen, if frozen is true) peers in the group chat on success.
 * @retval -1 if groupnumber is invalid.
 */
non_null()
int group_number_peers(const Group_Chats *g_c, uint32_t groupnumber, bool frozen);

/**
 * @retval 1 if the peernumber corresponds to ours.
 * @retval 0 if the peernumber is not ours.
 * @retval -1 if groupnumber is invalid.
 * @retval -2 if peernumber is invalid.
 * @retval -3 if we are not connected to the group chat.
 */
non_null()
int group_peernumber_is_ours(const Group_Chats *g_c, uint32_t groupnumber, uint32_t peernumber);

/** Set handlers for custom lossy packets. */
non_null()
void group_lossy_packet_registerhandler(Group_Chats *g_c, uint8_t byte, lossy_packet_cb *function);

/** @brief High level function to send custom lossy packets.
 *
 * @retval -1 on failure.
 * @retval 0 on success.
 */
non_null()
int send_group_lossy_packet(const Group_Chats *g_c, uint32_t groupnumber, const uint8_t *data, uint16_t length);

/**
 * @brief Return the number of chats in the instance m.
 *
 * You should use this to determine how much memory to allocate
 * for copy_chatlist.
 */
non_null()
uint32_t count_chatlist(const Group_Chats *g_c);

/** @brief Copy a list of valid chat IDs into the array out_list.
 *
 * If out_list is NULL, returns 0.
 * Otherwise, returns the number of elements copied.
 * If the array was too small, the contents
 * of out_list will be truncated to list_size.
 */
non_null()
uint32_t copy_chatlist(const Group_Chats *g_c, uint32_t *out_list, uint32_t list_size);

/** @brief return the type of groupchat (GROUPCHAT_TYPE_) that groupnumber is.
 *
 * @retval -1 on failure.
 * @return type on success.
 */
non_null()
int group_get_type(const Group_Chats *g_c, uint32_t groupnumber);

/** @brief Copies the unique id of `group_chat[groupnumber]` into `id`.
 *
 * @retval false on failure.
 * @retval true on success.
 */
non_null()
bool conference_get_id(const Group_Chats *g_c, uint32_t groupnumber, uint8_t *id);

non_null() int32_t conference_by_id(const Group_Chats *g_c, const uint8_t *id);

/** Send current name (set in messenger) to all online groups. */
non_null()
void send_name_all_groups(const Group_Chats *g_c);

/** @brief Set the object that is tied to the group chat.
 *
 * @retval 0 on success.
 * @retval -1 on failure
 */
non_null(1) nullable(3)
int group_set_object(const Group_Chats *g_c, uint32_t groupnumber, void *object);

/** @brief Set the object that is tied to the group peer.
 *
 * @retval 0 on success.
 * @retval -1 on failure
 */
non_null(1) nullable(4)
int group_peer_set_object(const Group_Chats *g_c, uint32_t groupnumber, uint32_t peernumber, void *object);

/** @brief Return the object tied to the group chat previously set by group_set_object.
 *
 * @retval NULL on failure.
 * @return object on success.
 */
non_null()
void *group_get_object(const Group_Chats *g_c, uint32_t groupnumber);

/** @brief Return the object tied to the group chat peer previously set by group_peer_set_object.
 *
 * @retval NULL on failure.
 * @return object on success.
 */
non_null()
void *group_peer_get_object(const Group_Chats *g_c, uint32_t groupnumber, uint32_t peernumber);

/** @brief Set a function to be called when a new peer joins a group chat.
 *
 * @retval 0 on success.
 * @retval -1 on failure.
 */
non_null(1) nullable(3)
int callback_groupchat_peer_new(const Group_Chats *g_c, uint32_t groupnumber, peer_on_join_cb *function);

/** @brief Set a function to be called when a peer leaves a group chat.
 *
 * @retval 0 on success.
 * @retval -1 on failure.
 */
non_null(1) nullable(3)
int callback_groupchat_peer_delete(const Group_Chats *g_c, uint32_t groupnumber, peer_on_leave_cb *function);

/** @brief Set a function to be called when the group chat is deleted.
 *
 * @retval 0 on success.
 * @retval -1 on failure.
 */
non_null(1) nullable(3)
int callback_groupchat_delete(const Group_Chats *g_c, uint32_t groupnumber, group_on_delete_cb *function);

/** Return size of the conferences data (for saving). */
non_null()
uint32_t conferences_size(const Group_Chats *g_c);

/** Save the conferences in data (must be allocated memory of size at least `conferences_size()`). */
non_null()
uint8_t *conferences_save(const Group_Chats *g_c, uint8_t *data);

/**
 * Load a state section.
 *
 * @param data Data to load
 * @param length Length of data
 * @param type Type of section (`STATE_TYPE_*`)
 * @param status Result of loading section is stored here if the section is handled.
 * @return true iff section handled.
 */
non_null()
bool conferences_load_state_section(
    Group_Chats *g_c, const uint8_t *data, uint32_t length, uint16_t type, State_Load_Status *status);

/** Create new groupchat instance. */
non_null()
Group_Chats *new_groupchats(const Mono_Time *mono_time, Messenger *m);

/** main groupchats loop. */
non_null(1) nullable(2)
void do_groupchats(Group_Chats *g_c, void *userdata);

/** Free everything related with group chats. */
nullable(1)
void kill_groupchats(Group_Chats *g_c);

#endif
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2020 The TokTok team.
 * Copyright © 2015 Tox project.
 */

/**
 * Packer and unpacker functions for saving and loading groups.
 */

#ifndef GROUP_PACK_H
#define GROUP_PACK_H

#include <stdbool.h>


/**
 * Packs group data from `chat` into `mp` in binary format. Parallel to the
 * `gc_load_unpack_group` function.
 */
non_null()
void gc_save_pack_group(const GC_Chat *chat, Bin_Pack *bp);

/**
 * Unpacks binary group data from `obj` into `chat`. Parallel to the `gc_save_pack_group`
 * function.
 *
 * Return true if unpacking is successful.
 */
non_null()
bool gc_load_unpack_group(GC_Chat *chat, Bin_Unpack *bu);

#endif // GROUP_PACK_H
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2018 The TokTok team.
 * Copyright © 2013 Tox project.
 */

/**
 * LAN discovery implementation.
 */
#ifndef C_TOXCORE_TOXCORE_LAN_DISCOVERY_H
#define C_TOXCORE_TOXCORE_LAN_DISCOVERY_H


/**
 * Interval in seconds between LAN discovery packet sending.
 */
#define LAN_DISCOVERY_INTERVAL         10

typedef struct Broadcast_Info Broadcast_Info;

/**
 * Send a LAN discovery pcaket to the broadcast address with port port.
 *
 * @return true on success, false on failure.
 */
non_null()
bool lan_discovery_send(const Networking_Core *net, const Broadcast_Info *broadcast, const uint8_t *dht_pk,
                        uint16_t port);

/**
 * Discovers broadcast devices and IP addresses.
 */
non_null()
Broadcast_Info *lan_discovery_init(const Network *ns);

/**
 * Free all resources associated with the broadcast info.
 */
nullable(1)
void lan_discovery_kill(Broadcast_Info *broadcast);

/**
 * Is IP a local ip or not.
 */
non_null()
bool ip_is_local(const IP *ip);

/**
 * Checks if a given IP isn't routable.
 *
 * @return true if ip is a LAN ip, false if it is not.
 */
non_null()
bool ip_is_lan(const IP *ip);

#endif // C_TOXCORE_TOXCORE_LAN_DISCOVERY_H
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2018 The TokTok team.
 * Copyright © 2014 Tox project.
 */

/**
 * Simple struct with functions to create a list which associates ids with data
 * -Allows for finding ids associated with data such as IPs or public keys in a short time
 * -Should only be used if there are relatively few add/remove calls to the list
 */
#ifndef C_TOXCORE_TOXCORE_LIST_H
#define C_TOXCORE_TOXCORE_LIST_H

#include <stdbool.h>
#include <stdint.h>


#ifdef __cplusplus
extern "C" {
#endif

typedef struct BS_List {
    uint32_t n; // number of elements
    uint32_t capacity; // number of elements memory is allocated for
    uint32_t element_size; // size of the elements
    uint8_t *data; // array of elements
    int *ids; // array of element ids
} BS_List;

/** @brief Initialize a list.
 *
 * @param element_size is the size of the elements in the list.
 * @param initial_capacity is the number of elements the memory will be initially allocated for.
 *
 * @retval 1 success
 * @retval 0 failure
 */
non_null()
int bs_list_init(BS_List *list, uint32_t element_size, uint32_t initial_capacity);

/** Free a list initiated with list_init */
nullable(1)
void bs_list_free(BS_List *list);

/** @brief Retrieve the id of an element in the list
 *
 * @retval >=0 id associated with data
 * @retval -1 failure
 */
non_null()
int bs_list_find(const BS_List *list, const uint8_t *data);

/** @brief Add an element with associated id to the list
 *
 * @retval true  success
 * @retval false failure (data already in list)
 */
non_null()
bool bs_list_add(BS_List *list, const uint8_t *data, int id);

/** @brief Remove element from the list
 *
 * @retval true  success
 * @retval false failure (element not found or id does not match)
 */
non_null()
bool bs_list_remove(BS_List *list, const uint8_t *data, int id);

#ifdef __cplusplus
}  // extern "C"
#endif

#endif
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2018 The TokTok team.
 * Copyright © 2013 Tox project.
 */

/**
 * An implementation of a simple text chat only messenger on the tox network
 * core.
 */
#ifndef C_TOXCORE_TOXCORE_MESSENGER_H
#define C_TOXCORE_TOXCORE_MESSENGER_H


#define MAX_NAME_LENGTH 128
/* TODO(irungentoo): this must depend on other variable. */
#define MAX_STATUSMESSAGE_LENGTH 1007
/* Used for TCP relays in Messenger struct (may need to be `% 2 == 0`)*/
#define NUM_SAVED_TCP_RELAYS 8
/* This cannot be bigger than 256 */
#define MAX_CONCURRENT_FILE_PIPES 256


#define FRIEND_ADDRESS_SIZE (CRYPTO_PUBLIC_KEY_SIZE + sizeof(uint32_t) + sizeof(uint16_t))

typedef enum Message_Type {
    MESSAGE_NORMAL,
    MESSAGE_ACTION,
    MESSAGE_HIGH_LEVEL_ACK = 2,
} Message_Type;

#ifndef MESSENGER_DEFINED
#define MESSENGER_DEFINED
typedef struct Messenger Messenger;
#endif  // MESSENGER_DEFINED

// Returns the size of the data
typedef uint32_t m_state_size_cb(const Messenger *m);

// Returns the new pointer to data
typedef uint8_t *m_state_save_cb(const Messenger *m, uint8_t *data);

// Returns if there were any erros during loading
typedef State_Load_Status m_state_load_cb(Messenger *m, const uint8_t *data, uint32_t length);

typedef struct Messenger_State_Plugin {
    State_Type type;
    m_state_size_cb *size;
    m_state_save_cb *save;
    m_state_load_cb *load;
} Messenger_State_Plugin;

typedef struct Messenger_Options {
    bool ipv6enabled;
    bool udp_disabled;
    TCP_Proxy_Info proxy_info;
    uint16_t port_range[2];
    uint16_t tcp_server_port;

    bool hole_punching_enabled;
    bool local_discovery_enabled;
    bool dht_announcements_enabled;

    logger_cb *log_callback;
    void *log_context;
    void *log_user_data;

    Messenger_State_Plugin *state_plugins;
    uint8_t state_plugins_length;
} Messenger_Options;

/* this means no special capabilities, in other words clients that are older
 * and did not implement this feature yet
 */
#define TOX_CAPABILITY_BASIC 0
/* ATTENTION: if you are adding new flags in your fork or toxcore,
 * or in c-toxcore master,
 * please coordinate with us first!
 * thank you, the Tox Devs.
 */
#define TOX_CAPABILITY_CAPABILITIES ((uint64_t)1) << 0
#define TOX_CAPABILITY_MSGV2 ((uint64_t)1) << 1
#define TOX_CAPABILITY_TOXAV_H264 ((uint64_t)1) << 2
#define TOX_CAPABILITY_MSGV3 ((uint64_t)1) << 3
#define TOX_CAPABILITY_FTV2 ((uint64_t)1) << 4
#define TOX_CAPABILITY_TOXAV_H265 ((uint64_t)1) << 5
#define TOX_CAPABILITY_FTV2A ((uint64_t)1) << 6
/* add new flags/bits here */
/* if the TOX_CAPABILITY_NEXT_IMPLEMENTATION flag is set it means
 * we are using a different system for indicating capabilities now,
 * and TOX_CAPABILITIES_* should be ignored and just the new (not yet known)
 * system should be used
 */
#define TOX_CAPABILITY_NEXT_IMPLEMENTATION ((uint64_t)1) << 63
/* hardcoded capabilities of this version/branch of toxcore */
#ifdef TOX_CAPABILITIES_ACTIVE
#define TOX_CAPABILITIES_CURRENT (uint64_t)(TOX_CAPABILITY_CAPABILITIES | TOX_CAPABILITY_MSGV2 | TOX_CAPABILITY_MSGV3 | TOX_CAPABILITY_TOXAV_H264 | TOX_CAPABILITY_TOXAV_H265 | TOX_CAPABILITY_FTV2 | TOX_CAPABILITY_FTV2A)
#else
#define TOX_CAPABILITIES_CURRENT (uint64_t)(TOX_CAPABILITY_CAPABILITIES | TOX_CAPABILITY_TOXAV_H264 | TOX_CAPABILITY_TOXAV_H265)
#endif
/* size of the FLAGS in bytes */
#define TOX_CAPABILITIES_SIZE sizeof(uint64_t)

struct Receipts {
    uint32_t packet_num;
    uint32_t msg_id;
    struct Receipts *next;
};

/** Status definitions. */
typedef enum Friend_Status {
    NOFRIEND,
    FRIEND_ADDED,
    FRIEND_REQUESTED,
    FRIEND_CONFIRMED,
    FRIEND_ONLINE,
} Friend_Status;

/** @brief Errors for m_addfriend
 *
 * FAERR - Friend Add Error
 */
typedef enum Friend_Add_Error {
    FAERR_TOOLONG = -1,
    FAERR_NOMESSAGE = -2,
    FAERR_OWNKEY = -3,
    FAERR_ALREADYSENT = -4,
    FAERR_BADCHECKSUM = -6,
    FAERR_SETNEWNOSPAM = -7,
    FAERR_NOMEM = -8,
} Friend_Add_Error;


/** Default start timeout in seconds between friend requests. */
#define FRIENDREQUEST_TIMEOUT 5

typedef enum Connection_Status {
    CONNECTION_NONE,
    CONNECTION_TCP,
    CONNECTION_UDP,
} Connection_Status;

/**
 * Represents userstatuses someone can have.
 */
typedef enum Userstatus {
    USERSTATUS_NONE,
    USERSTATUS_AWAY,
    USERSTATUS_BUSY,
    USERSTATUS_INVALID,
} Userstatus;

#define FILE_ID_LENGTH 32
#define FILE_OFFSET_LENGTH 8

struct File_Transfers {
    uint64_t size;
    uint64_t transferred;
    uint8_t status; /* 0 == no transfer, 1 = not accepted, 3 = transferring, 4 = broken, 5 = finished */
    uint8_t paused; /* 0: not paused, 1 = paused by us, 2 = paused by other, 3 = paused by both. */
    uint32_t last_packet_number; /* number of the last packet sent. */
    uint64_t requested; /* total data requested by the request chunk callback */
    uint8_t id[FILE_ID_LENGTH];
    uint32_t file_type;
    bool received_seek_control;
    uint8_t received_seek_control_counter;
    uint32_t file_receiver_last_received_chunk_this_many_iterations_ago;
    uint32_t file_sender_started_this_many_iterations_ago;
    bool ft_send_ackd;
    uint8_t filename[255]; // "MAX_FILENAME_LENGTH 255" in Messenger.c and "TOX_MAX_FILENAME_LENGTH 255" in tox.h -> how can we keep that in sync?
    uint32_t filename_length;
};
typedef enum Filestatus {
    FILESTATUS_NONE,
    FILESTATUS_NOT_ACCEPTED,
    FILESTATUS_TRANSFERRING,
    // FILESTATUS_BROKEN,
    FILESTATUS_FINISHED,
} Filestatus;

typedef enum File_Pause {
    FILE_PAUSE_NOT,
    FILE_PAUSE_US,
    FILE_PAUSE_OTHER,
    FILE_PAUSE_BOTH,
} File_Pause;

typedef enum Filecontrol {
    FILECONTROL_ACCEPT = 0,
    FILECONTROL_PAUSE = 1,
    FILECONTROL_KILL = 2,
    FILECONTROL_SEEK = 3,
    FILECONTROL_FINISHED = 4,
    FILECONTROL_SEND_ACK = 8, // HINT: leave some free values just in case upstream will use then for something
} Filecontrol;

typedef enum Filekind {
    FILEKIND_DATA,
    FILEKIND_AVATAR,
    FILEKIND_FTV2 = 16,
} Filekind;


typedef void m_self_connection_status_cb(Messenger *m, Onion_Connection_Status connection_status, void *user_data);
typedef void m_friend_status_cb(Messenger *m, uint32_t friend_number, unsigned int status, void *user_data);
typedef void m_friend_connection_status_cb(Messenger *m, uint32_t friend_number, unsigned int connection_status,
        void *user_data);
typedef void m_friend_message_cb(Messenger *m, uint32_t friend_number, unsigned int message_type,
                                 const uint8_t *message, size_t length, void *user_data);
typedef void m_file_recv_control_cb(Messenger *m, uint32_t friend_number, uint32_t file_number, unsigned int control,
                                    void *user_data);
typedef void m_friend_request_cb(Messenger *m, const uint8_t *public_key, const uint8_t *message, size_t length,
                                 void *user_data);
typedef void m_friend_name_cb(Messenger *m, uint32_t friend_number, const uint8_t *name, size_t length,
                              void *user_data);
typedef void m_friend_status_message_cb(Messenger *m, uint32_t friend_number, const uint8_t *message, size_t length,
                                        void *user_data);
typedef void m_friend_typing_cb(Messenger *m, uint32_t friend_number, bool is_typing, void *user_data);
typedef void m_friend_read_receipt_cb(Messenger *m, uint32_t friend_number, uint32_t message_id, void *user_data);
typedef void m_file_recv_cb(Messenger *m, uint32_t friend_number, uint32_t file_number, uint32_t kind,
                            uint64_t file_size, const uint8_t *filename, size_t filename_length, void *user_data);
typedef void m_file_chunk_request_cb(Messenger *m, uint32_t friend_number, uint32_t file_number, uint64_t position,
                                     size_t length, void *user_data);
typedef void m_file_recv_chunk_cb(Messenger *m, uint32_t friend_number, uint32_t file_number, uint64_t position,
                                  const uint8_t *data, size_t length, void *user_data);
typedef void m_friend_lossy_packet_cb(Messenger *m, uint32_t friend_number, uint8_t packet_id, const uint8_t *data,
                                      size_t length, void *user_data);
typedef void m_friend_lossless_packet_cb(Messenger *m, uint32_t friend_number, uint8_t packet_id, const uint8_t *data,
        size_t length, void *user_data);
typedef void m_conference_invite_cb(Messenger *m, uint32_t friend_number, const uint8_t *cookie, uint16_t length,
                                    void *user_data);
typedef void m_group_invite_cb(const Messenger *m, uint32_t friendnumber, const uint8_t *data, size_t length,
                               const uint8_t *group_name, size_t group_name_length, void *userdata);
typedef int m_lossy_rtp_packet_cb(Messenger *m, uint32_t friendnumber, const uint8_t *data, uint16_t len, void *object);

typedef struct RTP_Packet_Handler {
    m_lossy_rtp_packet_cb *function;
    void *object;
} RTP_Packet_Handler;

typedef struct Friend {
    uint8_t real_pk[CRYPTO_PUBLIC_KEY_SIZE];
    int friendcon_id;

    uint64_t friendrequest_lastsent; // Time at which the last friend request was sent.
    uint32_t friendrequest_timeout; // The timeout between successful friendrequest sending attempts.
    uint8_t status; // 0 if no friend, 1 if added, 2 if friend request sent, 3 if confirmed friend, 4 if online.
    uint8_t info[MAX_FRIEND_REQUEST_DATA_SIZE]; // the data that is sent during the friend requests we do.
    uint8_t name[MAX_NAME_LENGTH];
    uint16_t name_length;
    bool name_sent; // false if we didn't send our name to this friend, true if we have.
    uint8_t statusmessage[MAX_STATUSMESSAGE_LENGTH];
    uint16_t statusmessage_length;
    bool statusmessage_sent;
    Userstatus userstatus;
    bool userstatus_sent;
    bool user_istyping;
    bool user_istyping_sent;
    bool is_typing;
    uint16_t info_size; // Length of the info.
    uint32_t message_id; // a semi-unique id used in read receipts.
    uint32_t friendrequest_nospam; // The nospam number used in the friend request.
    uint64_t last_seen_time;
    Connection_Status last_connection_udp_tcp;
    struct File_Transfers file_sending[MAX_CONCURRENT_FILE_PIPES];
    uint32_t num_sending_files;
    uint32_t num_receiving_files;
    struct File_Transfers file_receiving[MAX_CONCURRENT_FILE_PIPES];

    struct Receipts *receipts_start;
    struct Receipts *receipts_end;
    uint64_t toxcore_capabilities;
} Friend;

struct Messenger {
    Logger *log;
    Mono_Time *mono_time;
    const Random *rng;
    const Network *ns;

    Networking_Core *net;
    Net_Crypto *net_crypto;
    DHT *dht;

    Forwarding *forwarding;
    Announcements *announce;

    Onion *onion;
    Onion_Announce *onion_a;
    Onion_Client *onion_c;

    Friend_Connections *fr_c;

    TCP_Server *tcp_server;
    Friend_Requests *fr;
    uint8_t name[MAX_NAME_LENGTH];
    uint16_t name_length;

    uint8_t statusmessage[MAX_STATUSMESSAGE_LENGTH];
    uint16_t statusmessage_length;

    Userstatus userstatus;

    Friend *friendlist;
    uint32_t numfriends;

    uint64_t lastdump;

    GC_Session *group_handler;
    GC_Announces_List *group_announce;

    bool has_added_relays; // If the first connection has occurred in do_messenger

    uint16_t num_loaded_relays;
    Node_format loaded_relays[NUM_SAVED_TCP_RELAYS]; // Relays loaded from config

    m_friend_request_cb *friend_request;
    m_friend_message_cb *friend_message;
    m_friend_name_cb *friend_namechange;
    m_friend_status_message_cb *friend_statusmessagechange;
    m_friend_status_cb *friend_userstatuschange;
    m_friend_typing_cb *friend_typingchange;
    m_friend_read_receipt_cb *read_receipt;
    m_friend_connection_status_cb *friend_connectionstatuschange;

    struct Group_Chats *conferences_object; /* Set by new_groupchats()*/
    m_conference_invite_cb *conference_invite;

    m_group_invite_cb *group_invite;

    m_file_recv_cb *file_sendrequest;
    m_file_recv_control_cb *file_filecontrol;
    m_file_recv_chunk_cb *file_filedata;
    m_file_chunk_request_cb *file_reqchunk;

    m_friend_lossy_packet_cb *lossy_packethandler;
    m_friend_lossless_packet_cb *lossless_packethandler;

    m_self_connection_status_cb *core_connection_change;
    Onion_Connection_Status last_connection_status;

    Messenger_Options options;
};

/**
 * Determines if the friendnumber passed is valid in the Messenger object.
 *
 * @param friendnumber The index in the friend list.
 */
non_null()
bool friend_is_valid(const Messenger *m, int32_t friendnumber);

/**
 * Format: `[real_pk (32 bytes)][nospam number (4 bytes)][checksum (2 bytes)]`
 *
 * @param[out] address FRIEND_ADDRESS_SIZE byte address to give to others.
 */
non_null()
void getaddress(const Messenger *m, uint8_t *address);

/**
 * Add a friend.
 *
 * Set the data that will be sent along with friend request.
 *
 * @param address is the address of the friend (returned by getaddress of the friend
 *   you wish to add) it must be FRIEND_ADDRESS_SIZE bytes.
 *   TODO(irungentoo): add checksum.
 * @param data is the data.
 * @param length is the length.
 *
 * @return the friend number if success.
 * @retval FA_TOOLONG if message length is too long.
 * @retval FAERR_NOMESSAGE if no message (message length must be >= 1 byte).
 * @retval FAERR_OWNKEY if user's own key.
 * @retval FAERR_ALREADYSENT if friend request already sent or already a friend.
 * @retval FAERR_BADCHECKSUM if bad checksum in address.
 * @retval FAERR_SETNEWNOSPAM if the friend was already there but the nospam was different.
 *   (the nospam for that friend was set to the new one).
 * @retval FAERR_NOMEM if increasing the friend list size fails.
 */
non_null()
int32_t m_addfriend(Messenger *m, const uint8_t *address, const uint8_t *data, uint16_t length);


/** @brief Add a friend without sending a friendrequest.
 * @return the friend number if success.
 * @retval -3 if user's own key.
 * @retval -4 if friend request already sent or already a friend.
 * @retval -6 if bad checksum in address.
 * @retval -8 if increasing the friend list size fails.
 */
non_null()
int32_t m_addfriend_norequest(Messenger *m, const uint8_t *real_pk);

/** @brief Initializes the friend connection and onion connection for a groupchat.
 *
 * @retval true on success.
 */
non_null()
bool m_create_group_connection(Messenger *m, GC_Chat *chat);

/*
 * Kills the friend connection for a groupchat.
 */
non_null()
void m_kill_group_connection(Messenger *m, const GC_Chat *chat);

/** @return the friend number associated to that public key.
 * @retval -1 if no such friend.
 */
non_null()
int32_t getfriend_id(const Messenger *m, const uint8_t *real_pk);

/** @brief Copies the public key associated to that friend id into real_pk buffer.
 *
 * Make sure that real_pk is of size CRYPTO_PUBLIC_KEY_SIZE.
 *
 * @retval 0 if success.
 * @retval -1 if failure.
 */
non_null()
int get_real_pk(const Messenger *m, int32_t friendnumber, uint8_t *real_pk);

/** @return friend connection id on success.
 * @retval -1 if failure.
 */
non_null()
int getfriendcon_id(const Messenger *m, int32_t friendnumber);

/** @brief Remove a friend.
 *
 * @retval 0 if success.
 * @retval -1 if failure.
 */
non_null()
int m_delfriend(Messenger *m, int32_t friendnumber);

/** @brief Checks friend's connection status.
 *
 * @retval CONNECTION_UDP (2) if friend is directly connected to us (Online UDP).
 * @retval CONNECTION_TCP (1) if friend is connected to us (Online TCP).
 * @retval CONNECTION_NONE (0) if friend is not connected to us (Offline).
 * @retval -1 on failure.
 */
non_null()
int m_get_friend_connectionstatus(const Messenger *m, int32_t friendnumber);

void m_get_friend_connection_ip(const Messenger *m, int32_t friendnumber, uint8_t *ip_str);

/**
 * Checks if there exists a friend with given friendnumber.
 *
 * @param friendnumber The index in the friend list.
 *
 * @retval true if friend exists.
 * @retval false if friend doesn't exist.
 */
non_null()
bool m_friend_exists(const Messenger *m, int32_t friendnumber);

/** @brief Send a message of type to an online friend.
 *
 * @retval -1 if friend not valid.
 * @retval -2 if too large.
 * @retval -3 if friend not online.
 * @retval -4 if send failed (because queue is full).
 * @retval -5 if bad type.
 * @retval 0 if success.
 *
 * The value in message_id will be passed to your read_receipt callback when the other receives the message.
 */
non_null(1, 4) nullable(6)
int m_send_message_generic(Messenger *m, int32_t friendnumber, uint8_t type, const uint8_t *message, uint32_t length,
                           uint32_t *message_id);


/** @brief Set the name and name_length of a friend.
 *
 * name must be a string of maximum MAX_NAME_LENGTH length.
 * length must be at least 1 byte.
 * length is the length of name with the NULL terminator.
 *
 * @retval 0 if success.
 * @retval -1 if failure.
 */
non_null()
int setfriendname(Messenger *m, int32_t friendnumber, const uint8_t *name, uint16_t length);

/** @brief Set our nickname.
 *
 * name must be a string of maximum MAX_NAME_LENGTH length.
 * length must be at least 1 byte.
 * length is the length of name with the NULL terminator.
 *
 * @retval 0 if success.
 * @retval -1 if failure.
 */
non_null()
int setname(Messenger *m, const uint8_t *name, uint16_t length);

/**
 * @brief Get your nickname.
 *
 * m - The messenger context to use.
 * name needs to be a valid memory location with a size of at least MAX_NAME_LENGTH bytes.
 *
 * @return length of the name.
 * @retval 0 on error.
 */
non_null()
uint16_t getself_name(const Messenger *m, uint8_t *name);

/** @brief Get name of friendnumber and put it in name.
 *
 * name needs to be a valid memory location with a size of at least MAX_NAME_LENGTH (128) bytes.
 *
 * @return length of name if success.
 * @retval -1 if failure.
 */
non_null()
int getname(const Messenger *m, int32_t friendnumber, uint8_t *name);

/** @return the length of name, including null on success.
 * @retval -1 on failure.
 */
non_null() int m_get_name_size(const Messenger *m, int32_t friendnumber);
non_null() int m_get_self_name_size(const Messenger *m);

/** @brief Set our user status.
 * You are responsible for freeing status after.
 *
 * @retval 0 on success.
 * @retval -1 on failure.
 */
non_null() int m_set_statusmessage(Messenger *m, const uint8_t *status, uint16_t length);
non_null() int m_set_userstatus(Messenger *m, uint8_t status);

/**
 * Guaranteed to be at most MAX_STATUSMESSAGE_LENGTH.
 *
 * @return the length of friendnumber's status message, including null on success.
 * @retval -1 on failure.
 */
non_null() int m_get_statusmessage_size(const Messenger *m, int32_t friendnumber);
non_null() int m_get_self_statusmessage_size(const Messenger *m);

/** @brief Copy friendnumber's status message into buf, truncating if size is over maxlen.
 *
 * Get the size you need to allocate from m_get_statusmessage_size.
 * The self variant will copy our own status message.
 *
 * @return the length of the copied data on success
 * @retval -1 on failure.
 */
non_null() int m_copy_statusmessage(const Messenger *m, int32_t friendnumber, uint8_t *buf, uint32_t maxlen);
non_null() int m_copy_self_statusmessage(const Messenger *m, uint8_t *buf);

/** @brief return one of Userstatus values.
 *
 * Values unknown to your application should be represented as USERSTATUS_NONE.
 * As above, the self variant will return our own Userstatus.
 * If friendnumber is invalid, this shall return USERSTATUS_INVALID.
 */
non_null() uint8_t m_get_userstatus(const Messenger *m, int32_t friendnumber);
non_null() uint8_t m_get_self_userstatus(const Messenger *m);

/* get capabilities of friend's toxcore
 * return TOX_CAPABILITY_BASIC on any error
 */
uint64_t m_get_friend_toxcore_capabilities(const Messenger *m, int32_t friendnumber);

/** @brief returns timestamp of last time friendnumber was seen online or 0 if never seen.
 * if friendnumber is invalid this function will return UINT64_MAX.
 */
non_null() uint64_t m_get_last_online(const Messenger *m, int32_t friendnumber);

/** @brief Set our typing status for a friend.
 * You are responsible for turning it on or off.
 *
 * @retval 0 on success.
 * @retval -1 on failure.
 */
non_null()
int m_set_usertyping(Messenger *m, int32_t friendnumber, bool is_typing);

/** @brief Get the typing status of a friend.
 *
 * @retval -1 if friend number is invalid.
 * @retval 0 if friend is not typing.
 * @retval 1 if friend is typing.
 */
non_null()
int m_get_istyping(const Messenger *m, int32_t friendnumber);

/** Set the function that will be executed when a friend request is received. */
non_null(1) nullable(2)
void m_callback_friendrequest(Messenger *m, m_friend_request_cb *function);

/** Set the function that will be executed when a message from a friend is received. */
non_null() void m_callback_friendmessage(Messenger *m, m_friend_message_cb *function);

/** @brief Set the callback for name changes.
 * You are not responsible for freeing newname.
 */
non_null() void m_callback_namechange(Messenger *m, m_friend_name_cb *function);

/** @brief Set the callback for status message changes.
 *
 * You are not responsible for freeing newstatus
 */
non_null() void m_callback_statusmessage(Messenger *m, m_friend_status_message_cb *function);

/** @brief Set the callback for status type changes. */
non_null() void m_callback_userstatus(Messenger *m, m_friend_status_cb *function);

/** @brief Set the callback for typing changes. */
non_null() void m_callback_typingchange(Messenger *m, m_friend_typing_cb *function);

/** @brief Set the callback for read receipts.
 *
 * If you are keeping a record of returns from m_sendmessage,
 * receipt might be one of those values, meaning the message
 * has been received on the other side.
 * Since core doesn't track ids for you, receipt may not correspond to any message.
 * In that case, you should discard it.
 */
non_null() void m_callback_read_receipt(Messenger *m, m_friend_read_receipt_cb *function);

/** @brief Set the callback for connection status changes.
 *
 * Status:
 * - 0: friend went offline after being previously online.
 * - 1: friend went online.
 *
 * Note that this callback is not called when adding friends, thus the
 * "after being previously online" part.
 * It's assumed that when adding friends, their connection status is offline.
 */
non_null() void m_callback_connectionstatus(Messenger *m, m_friend_connection_status_cb *function);

non_null() void m_callback_core_connection(Messenger *m, m_self_connection_status_cb *function);

/*** CONFERENCES */

/** @brief Set the callback for conference invites. */
non_null(1) nullable(2)
void m_callback_conference_invite(Messenger *m, m_conference_invite_cb *function);

/* Set the callback for group invites.
 */
non_null(1) nullable(2)
void m_callback_group_invite(Messenger *m, m_group_invite_cb *function);


/** @brief Send a conference invite packet.
 *
 * return true on success
 * return false on failure
 */
non_null()
bool send_conference_invite_packet(const Messenger *m, int32_t friendnumber, const uint8_t *data, uint16_t length);

/* Send a group invite packet.
 *
 *  WARNING: Return-value semantics are different than for
 *  send_conference_invite_packet().
 *
 *  return true on success
 */
non_null()
bool send_group_invite_packet(const Messenger *m, uint32_t friendnumber, const uint8_t *data, uint16_t length);


/*** FILE SENDING */


/** @brief Set the callback for file send requests. */
non_null() void callback_file_sendrequest(Messenger *m, m_file_recv_cb *function);


/** @brief Set the callback for file control requests. */
non_null() void callback_file_control(Messenger *m, m_file_recv_control_cb *function);

/** @brief Set the callback for file data. */
non_null() void callback_file_data(Messenger *m, m_file_recv_chunk_cb *function);

/** @brief Set the callback for file request chunk. */
non_null() void callback_file_reqchunk(Messenger *m, m_file_chunk_request_cb *function);


/** @brief Copy the file transfer file id to file_id
 *
 * @retval 0 on success.
 * @retval -1 if friend not valid.
 * @retval -2 if filenumber not valid
 */
non_null()
int file_get_id(const Messenger *m, int32_t friendnumber, uint32_t filenumber, uint8_t *file_id);

/** @brief Send a file send request.
 *
 * Maximum filename length is 255 bytes.
 *
 * @return file number on success
 * @retval -1 if friend not found.
 * @retval -2 if filename length invalid.
 * @retval -3 if no more file sending slots left.
 * @retval -4 if could not send packet (friend offline).
 */
non_null()
long int new_filesender(const Messenger *m, int32_t friendnumber, uint32_t file_type, uint64_t filesize,
                        const uint8_t *file_id, const uint8_t *filename, uint16_t filename_length);

/** @brief Send a file control request.
 *
 * @retval 0 on success
 * @retval -1 if friend not valid.
 * @retval -2 if friend not online.
 * @retval -3 if file number invalid.
 * @retval -4 if file control is bad.
 * @retval -5 if file already paused.
 * @retval -6 if resume file failed because it was only paused by the other.
 * @retval -7 if resume file failed because it wasn't paused.
 * @retval -8 if packet failed to send.
 */
non_null()
int file_control(const Messenger *m, int32_t friendnumber, uint32_t filenumber, unsigned int control);

/** @brief Send a seek file control request.
 *
 * @retval 0 on success
 * @retval -1 if friend not valid.
 * @retval -2 if friend not online.
 * @retval -3 if file number invalid.
 * @retval -4 if not receiving file.
 * @retval -5 if file status wrong.
 * @retval -6 if position bad.
 * @retval -8 if packet failed to send.
 */
non_null()
int file_seek(const Messenger *m, int32_t friendnumber, uint32_t filenumber, uint64_t position);

/** @brief Send file data.
 *
 * @retval 0 on success
 * @retval -1 if friend not valid.
 * @retval -2 if friend not online.
 * @retval -3 if filenumber invalid.
 * @retval -4 if file transfer not transferring.
 * @retval -5 if bad data size.
 * @retval -6 if packet queue full.
 * @retval -7 if wrong position.
 */
non_null(1) nullable(5)
int send_file_data(const Messenger *m, int32_t friendnumber, uint32_t filenumber, uint64_t position, const uint8_t *data, uint16_t length);

/*** CUSTOM PACKETS */

/** @brief Set handlers for custom lossy packets. */
non_null() void custom_lossy_packet_registerhandler(Messenger *m, m_friend_lossy_packet_cb *lossy_packethandler);

/** @brief High level function to send custom lossy packets.
 *
 * @retval -1 if friend invalid.
 * @retval -2 if length wrong.
 * @retval -3 if first byte invalid.
 * @retval -4 if friend offline.
 * @retval -5 if packet failed to send because of other error.
 * @retval 0 on success.
 */
non_null()
int m_send_custom_lossy_packet(const Messenger *m, int32_t friendnumber, const uint8_t *data, uint32_t length);


/** @brief Set handlers for custom lossless packets. */
non_null()
void custom_lossless_packet_registerhandler(Messenger *m, m_friend_lossless_packet_cb *lossless_packethandler);

/** @brief High level function to send custom lossless packets.
 *
 * @retval -1 if friend invalid.
 * @retval -2 if length wrong.
 * @retval -3 if first byte invalid.
 * @retval -4 if friend offline.
 * @retval -5 if packet failed to send because of other error.
 * @retval 0 on success.
 */
non_null()
int send_custom_lossless_packet(const Messenger *m, int32_t friendnumber, const uint8_t *data, uint32_t length);

/*** Messenger constructor/destructor/operations. */

typedef enum Messenger_Error {
    MESSENGER_ERROR_NONE,
    MESSENGER_ERROR_PORT,
    MESSENGER_ERROR_TCP_SERVER,
    MESSENGER_ERROR_OTHER,
} Messenger_Error;

/** @brief Run this at startup.
 *
 * @return allocated instance of Messenger on success.
 * @retval 0 if there are problems.
 *
 * if error is not NULL it will be set to one of the values in the enum above.
 */
non_null()
Messenger *new_messenger(Mono_Time *mono_time, const Random *rng, const Network *ns, Messenger_Options *options, Messenger_Error *error);

/** @brief Run this before closing shop.
 *
 * Free all datastructures.
 */
nullable(1)
void kill_messenger(Messenger *m);

/** @brief The main loop that needs to be run at least 20 times per second. */
non_null(1) nullable(2)
void do_messenger(Messenger *m, void *userdata);

/**
 * @brief Return the time in milliseconds before `do_messenger()` should be called again
 *   for optimal performance.
 *
 * @return time (in ms) before the next `do_messenger()` needs to be run on success.
 */
non_null()
uint32_t messenger_run_interval(const Messenger *m);

/* SAVING AND LOADING FUNCTIONS: */

/** @brief Registers a state plugin for saving, loading, and getting the size of a section of the save.
 *
 * @retval true on success
 * @retval false on error
 */
non_null()
bool m_register_state_plugin(Messenger *m, State_Type type,
                             m_state_size_cb *size_callback,
                             m_state_load_cb *load_callback,
                             m_state_save_cb *save_callback);

/** return size of the messenger data (for saving). */
non_null()
uint32_t messenger_size(const Messenger *m);

/** Save the messenger in data (must be allocated memory of size at least `Messenger_size()`) */
non_null()
uint8_t *messenger_save(const Messenger *m, uint8_t *data);

/** @brief Load a state section.
 *
 * @param data Data to load.
 * @param length Length of data.
 * @param type Type of section (`STATE_TYPE_*`).
 * @param status Result of loading section is stored here if the section is handled.
 * @return true iff section handled.
 */
non_null()
bool messenger_load_state_section(Messenger *m, const uint8_t *data, uint32_t length, uint16_t type,
                                  State_Load_Status *status);

/** @brief Return the number of friends in the instance m.
 *
 * You should use this to determine how much memory to allocate
 * for copy_friendlist.
 */
non_null()
uint32_t count_friendlist(const Messenger *m);

/** @brief Copy a list of valid friend IDs into the array out_list.
 * If out_list is NULL, returns 0.
 * Otherwise, returns the number of elements copied.
 * If the array was too small, the contents
 * of out_list will be truncated to list_size.
 */
non_null()
uint32_t copy_friendlist(const Messenger *m, uint32_t *out_list, uint32_t list_size);

non_null()
void print_all_tcp_relays(const Messenger *m, char *relays_report_string);

non_null()
void print_all_udp_connections(const Messenger *m, char *connections_report_string);

#endif
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2018 The TokTok team.
 * Copyright © 2013 Tox project.
 */

/** @file
 * @brief Implementation of an efficient array to store that we pinged something.
 */
#ifndef C_TOXCORE_TOXCORE_PING_ARRAY_H
#define C_TOXCORE_TOXCORE_PING_ARRAY_H

#include <stddef.h>
#include <stdint.h>


#ifdef __cplusplus
extern "C" {
#endif

typedef struct Ping_Array Ping_Array;

/**
 * @brief Initialize a Ping_Array.
 *
 * @param size represents the total size of the array and should be a power of 2.
 * @param timeout represents the maximum timeout in seconds for the entry.
 *
 * @return pointer to allocated Ping_Array on success, nullptr on failure.
 */
struct Ping_Array *ping_array_new(uint32_t size, uint32_t timeout);

/**
 * @brief Free all the allocated memory in a @ref Ping_Array.
 */
nullable(1)
void ping_array_kill(Ping_Array *array);

/**
 * @brief Add a data with length to the @ref Ping_Array list and return a ping_id.
 *
 * @return ping_id on success, 0 on failure.
 */
non_null()
uint64_t ping_array_add(Ping_Array *array, const Mono_Time *mono_time, const Random *rng,
                        const uint8_t *data, uint32_t length);

/**
 * @brief Check if @p ping_id is valid and not timed out.
 *
 * On success, copies the data into data of length,
 *
 * @return length of data copied on success, -1 on failure.
 */
non_null()
int32_t ping_array_check(Ping_Array *array, const Mono_Time *mono_time, uint8_t *data, size_t length,
                         uint64_t ping_id);

#ifdef __cplusplus
}  // extern "C"
#endif

#endif // C_TOXCORE_TOXCORE_PING_ARRAY_H
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2018 The TokTok team.
 * Copyright © 2013 Tox project.
 * Copyright © 2013 plutooo
 */

/**
 * Buffered pinging using cyclic arrays.
 */
#ifndef C_TOXCORE_TOXCORE_PING_H
#define C_TOXCORE_TOXCORE_PING_H

#include <stdint.h>


typedef struct Ping Ping;

non_null()
Ping *ping_new(const Mono_Time *mono_time, const Random *rng, DHT *dht);

nullable(1)
void ping_kill(Ping *ping);

/** @brief Add nodes to the to_ping list.
 * All nodes in this list are pinged every TIME_TO_PING seconds
 * and are then removed from the list.
 * If the list is full the nodes farthest from our public_key are replaced.
 * The purpose of this list is to enable quick integration of new nodes into the
 * network while preventing amplification attacks.
 *
 * @retval 0 if node was added.
 * @retval -1 if node was not added.
 */
non_null()
int32_t ping_add(Ping *ping, const uint8_t *public_key, const IP_Port *ip_port);

/** @brief Ping all the valid nodes in the to_ping list every TIME_TO_PING seconds.
 * This function must be run at least once every TIME_TO_PING seconds.
 */
non_null()
void ping_iterate(Ping *ping);

non_null()
void ping_send_request(Ping *ping, const IP_Port *ipp, const uint8_t *public_key);

#endif // C_TOXCORE_TOXCORE_PING_H
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2019-2021 The TokTok team.
 */
#ifndef C_TOXCORE_TOXCORE_TIMED_AUTH_H
#define C_TOXCORE_TOXCORE_TIMED_AUTH_H


#define TIMED_AUTH_SIZE CRYPTO_HMAC_SIZE

/**
 * @brief Write timed authentication code of data to timed_auth.
 *
 * @param timed_auth Must be of size TIMED_AUTH_SIZE.
 */

non_null(1, 3, 6) nullable(4)
void generate_timed_auth(const Mono_Time *mono_time, uint16_t timeout, const uint8_t *key,
                         const uint8_t *data, uint16_t length, uint8_t *timed_auth);

/**
 * @brief Check timed_auth. This succeeds if `timed_auth` was generated by
 * `generate_timed_auth` at most `timeout` seconds ago, and fails if at least
 * `2*timeout` seconds ago. More precisely, it succeeds iff
 * `current_time / timeout` is equal to or one more than
 * `creation_time / timeout`.
 *
 * @param timed_auth Must be of size TIMED_AUTH_SIZE.
 * @return true on success, false otherwise.
 */
non_null(1, 3, 6) nullable(4)
bool check_timed_auth(const Mono_Time *mono_time, uint16_t timeout, const uint8_t *key,
                      const uint8_t *data, uint16_t length, const uint8_t *timed_auth);
#endif
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2022 The TokTok team.
 */

#ifndef C_TOXCORE_TOXCORE_TOX_DISPATCH_H
#define C_TOXCORE_TOXCORE_TOX_DISPATCH_H


#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief The events dispatch table.
 *
 * This holds all the callbacks registered with `tox_events_callback_*`
 * functions below.
 */
typedef struct Tox_Dispatch Tox_Dispatch;

typedef enum Tox_Err_Dispatch_New {
    /**
     * The function returned successfully.
     */
    TOX_ERR_DISPATCH_NEW_OK,

    /**
     * The function failed to allocate memory for the dispatch table.
     */
    TOX_ERR_DISPATCH_NEW_MALLOC,
} Tox_Err_Dispatch_New;

/**
 * @brief Creates a new empty event dispatch table.
 */
Tox_Dispatch *tox_dispatch_new(Tox_Err_Dispatch_New *error);

/**
 * @brief Deallocate an event dispatch table.
 */
void tox_dispatch_free(Tox_Dispatch *dispatch);

/**
 * @brief Invoke registered callbacks for each of the events.
 *
 * @param dispatch The events dispatch table.
 * @param events The events object received from @ref tox_events_iterate.
 * @param tox The tox object to pass down to the callbacks.
 * @param user_data User data pointer to pass down to the callbacks.
 */
void tox_dispatch_invoke(const Tox_Dispatch *dispatch, const Tox_Events *events, Tox *tox, void *user_data);

typedef void tox_events_conference_connected_cb(
    Tox *tox, const Tox_Event_Conference_Connected *event, void *user_data);
typedef void tox_events_conference_invite_cb(
    Tox *tox, const Tox_Event_Conference_Invite *event, void *user_data);
typedef void tox_events_conference_message_cb(
    Tox *tox, const Tox_Event_Conference_Message *event, void *user_data);
typedef void tox_events_conference_peer_list_changed_cb(
    Tox *tox, const Tox_Event_Conference_Peer_List_Changed *event, void *user_data);
typedef void tox_events_conference_peer_name_cb(
    Tox *tox, const Tox_Event_Conference_Peer_Name *event, void *user_data);
typedef void tox_events_conference_title_cb(
    Tox *tox, const Tox_Event_Conference_Title *event, void *user_data);
typedef void tox_events_file_chunk_request_cb(
    Tox *tox, const Tox_Event_File_Chunk_Request *event, void *user_data);
typedef void tox_events_file_recv_cb(
    Tox *tox, const Tox_Event_File_Recv *event, void *user_data);
typedef void tox_events_file_recv_chunk_cb(
    Tox *tox, const Tox_Event_File_Recv_Chunk *event, void *user_data);
typedef void tox_events_file_recv_control_cb(
    Tox *tox, const Tox_Event_File_Recv_Control *event, void *user_data);
typedef void tox_events_friend_connection_status_cb(
    Tox *tox, const Tox_Event_Friend_Connection_Status *event, void *user_data);
typedef void tox_events_friend_lossless_packet_cb(
    Tox *tox, const Tox_Event_Friend_Lossless_Packet *event, void *user_data);
typedef void tox_events_friend_lossy_packet_cb(
    Tox *tox, const Tox_Event_Friend_Lossy_Packet *event, void *user_data);
typedef void tox_events_friend_message_cb(
    Tox *tox, const Tox_Event_Friend_Message *event, void *user_data);
typedef void tox_events_friend_name_cb(
    Tox *tox, const Tox_Event_Friend_Name *event, void *user_data);
typedef void tox_events_friend_read_receipt_cb(
    Tox *tox, const Tox_Event_Friend_Read_Receipt *event, void *user_data);
typedef void tox_events_friend_request_cb(
    Tox *tox, const Tox_Event_Friend_Request *event, void *user_data);
typedef void tox_events_friend_status_cb(
    Tox *tox, const Tox_Event_Friend_Status *event, void *user_data);
typedef void tox_events_friend_status_message_cb(
    Tox *tox, const Tox_Event_Friend_Status_Message *event, void *user_data);
typedef void tox_events_friend_typing_cb(
    Tox *tox, const Tox_Event_Friend_Typing *event, void *user_data);
typedef void tox_events_self_connection_status_cb(
    Tox *tox, const Tox_Event_Self_Connection_Status *event, void *user_data);

void tox_events_callback_conference_connected(
    Tox_Dispatch *dispatch, tox_events_conference_connected_cb *callback);
void tox_events_callback_conference_invite(
    Tox_Dispatch *dispatch, tox_events_conference_invite_cb *callback);
void tox_events_callback_conference_message(
    Tox_Dispatch *dispatch, tox_events_conference_message_cb *callback);
void tox_events_callback_conference_peer_list_changed(
    Tox_Dispatch *dispatch, tox_events_conference_peer_list_changed_cb *callback);
void tox_events_callback_conference_peer_name(
    Tox_Dispatch *dispatch, tox_events_conference_peer_name_cb *callback);
void tox_events_callback_conference_title(
    Tox_Dispatch *dispatch, tox_events_conference_title_cb *callback);
void tox_events_callback_file_chunk_request(
    Tox_Dispatch *dispatch, tox_events_file_chunk_request_cb *callback);
void tox_events_callback_file_recv(
    Tox_Dispatch *dispatch, tox_events_file_recv_cb *callback);
void tox_events_callback_file_recv_chunk(
    Tox_Dispatch *dispatch, tox_events_file_recv_chunk_cb *callback);
void tox_events_callback_file_recv_control(
    Tox_Dispatch *dispatch, tox_events_file_recv_control_cb *callback);
void tox_events_callback_friend_connection_status(
    Tox_Dispatch *dispatch, tox_events_friend_connection_status_cb *callback);
void tox_events_callback_friend_lossless_packet(
    Tox_Dispatch *dispatch, tox_events_friend_lossless_packet_cb *callback);
void tox_events_callback_friend_lossy_packet(
    Tox_Dispatch *dispatch, tox_events_friend_lossy_packet_cb *callback);
void tox_events_callback_friend_message(
    Tox_Dispatch *dispatch, tox_events_friend_message_cb *callback);
void tox_events_callback_friend_name(
    Tox_Dispatch *dispatch, tox_events_friend_name_cb *callback);
void tox_events_callback_friend_read_receipt(
    Tox_Dispatch *dispatch, tox_events_friend_read_receipt_cb *callback);
void tox_events_callback_friend_request(
    Tox_Dispatch *dispatch, tox_events_friend_request_cb *callback);
void tox_events_callback_friend_status(
    Tox_Dispatch *dispatch, tox_events_friend_status_cb *callback);
void tox_events_callback_friend_status_message(
    Tox_Dispatch *dispatch, tox_events_friend_status_message_cb *callback);
void tox_events_callback_friend_typing(
    Tox_Dispatch *dispatch, tox_events_friend_typing_cb *callback);
void tox_events_callback_self_connection_status(
    Tox_Dispatch *dispatch, tox_events_self_connection_status_cb *callback);

#ifdef __cplusplus
}
#endif

#endif // C_TOXCORE_TOXCORE_TOX_DISPATCH_H
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2020 The TokTok team.
 * Copyright © 2013 Tox project.
 */

#ifndef C_TOXCORE_TOXCORE_TOX_PRIVATE_H
#define C_TOXCORE_TOXCORE_TOX_PRIVATE_H

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>


#ifdef __cplusplus
extern "C" {
#endif

typedef uint64_t tox_mono_time_cb(void *user_data);

struct Tox_System {
    tox_mono_time_cb *mono_time_callback;
    void *mono_time_user_data;
    const struct Random *rng;
    const struct Network *ns;
};

Tox_System tox_default_system(void);

void tox_lock(const Tox *tox);
void tox_unlock(const Tox *tox);

/**
 * Set the callback for the `friend_lossy_packet` event for a specific packet ID.
 * Pass NULL to unset.
 *
 * allowed packet ID range:
 * from `PACKET_ID_RANGE_LOSSY_START` to `PACKET_ID_RANGE_LOSSY_END` (both inclusive)
 */
// void tox_callback_friend_lossy_packet_per_pktid(Tox *tox, tox_friend_lossy_packet_cb *callback, uint8_t pktid);

/**
 * Set the callback for the `friend_lossless_packet` event for a specific packet ID.
 * Pass NULL to unset.
 *
 * allowed packet ID range:
 * from `PACKET_ID_RANGE_LOSSLESS_CUSTOM_START` to `PACKET_ID_RANGE_LOSSLESS_CUSTOM_END` (both inclusive)
 * and
 * `PACKET_ID_MSI`
 */
// void tox_callback_friend_lossless_packet_per_pktid(Tox *tox, tox_friend_lossless_packet_cb *callback, uint8_t pktid);

void tox_set_av_object(Tox *tox, void *object);
void *tox_get_av_object(const Tox *tox);


/*******************************************************************************
 *
 * :: DHT network queries.
 *
 ******************************************************************************/

/**
 * The minimum size of an IP string buffer in bytes.
 */
#define TOX_DHT_NODE_IP_STRING_SIZE      96

uint32_t tox_dht_node_ip_string_size(void);

/**
 * The size of a DHT node public key in bytes.
 */
#define TOX_DHT_NODE_PUBLIC_KEY_SIZE     32

uint32_t tox_dht_node_public_key_size(void);

/**
 * @param public_key The node's public key.
 * @param ip The node's IP address, represented as a null terminated string.
 * @param port The node's port.
 */
typedef void tox_dht_get_nodes_response_cb(Tox *tox, const uint8_t *public_key, const char *ip, uint16_t port,
        void *user_data);


/**
 * Set the callback for the `dht_get_nodes_response` event. Pass NULL to unset.
 *
 * This event is triggered when a getnodes response is received from a DHT peer.
 */
void tox_callback_dht_get_nodes_response(Tox *tox, tox_dht_get_nodes_response_cb *callback);


typedef enum Tox_Err_Dht_Get_Nodes {
    /**
     * The function returned successfully.
     */
    TOX_ERR_DHT_GET_NODES_OK,

    /**
     * UDP is disabled in tox options; the DHT can only be queried when UDP is enabled.
     */
    TOX_ERR_DHT_GET_NODES_UDP_DISABLED,

    /**
     * One of the arguments to the function was NULL when it was not expected.
     */
    TOX_ERR_DHT_GET_NODES_NULL,

    /**
     * The supplied port is invalid.
     */
    TOX_ERR_DHT_GET_NODES_BAD_PORT,

    /**
     * The supplied IP address is invalid.
     */
    TOX_ERR_DHT_GET_NODES_BAD_IP,

    /**
     * The getnodes request failed. This usually means the packet failed to send.
     */
    TOX_ERR_DHT_GET_NODES_FAIL,
} Tox_Err_Dht_Get_Nodes;

/**
 * This function sends a getnodes request to a DHT node for its peers that
 * are "close" to the passed target public key according to the distance metric used
 * by the DHT implementation.
 *
 * @param public_key The public key of the node that we wish to query. This key must be
 *   at least `TOX_DHT_NODE_PUBLIC_KEY_SIZE` bytes in length.
 * @param ip A NULL terminated string representing the IP address of the node we wish to query.
 * @param port The port of the node we wish to query.
 * @param target_public_key The public key for which we want to find close nodes.
 *
 * @return true on success.
 */
bool tox_dht_get_nodes(const Tox *tox, const uint8_t *public_key, const char *ip, uint16_t port,
                       const uint8_t *target_public_key, Tox_Err_Dht_Get_Nodes *error);

#ifdef __cplusplus
}
#endif

#endif // C_TOXCORE_TOXCORE_TOX_PRIVATE_H
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2022 The TokTok team.
 * Copyright © 2013 Tox project.
 */

#ifndef C_TOXCORE_TOXCORE_TOX_STRUCT_H
#define C_TOXCORE_TOXCORE_TOX_STRUCT_H


#ifdef __cplusplus
extern "C" {
#endif

struct Tox {
    Messenger *m;
    Mono_Time *mono_time;
    Random rng;
    Network ns;
    pthread_mutex_t *mutex;

    tox_log_cb *log_callback;
    tox_self_connection_status_cb *self_connection_status_callback;
    tox_friend_name_cb *friend_name_callback;
    tox_friend_status_message_cb *friend_status_message_callback;
    tox_friend_status_cb *friend_status_callback;
    tox_friend_connection_status_cb *friend_connection_status_callback;
    tox_friend_typing_cb *friend_typing_callback;
    tox_friend_read_receipt_cb *friend_read_receipt_callback;
    tox_friend_request_cb *friend_request_callback;
    tox_friend_message_cb *friend_message_callback;
    tox_file_recv_control_cb *file_recv_control_callback;
    tox_file_chunk_request_cb *file_chunk_request_callback;
    tox_file_recv_cb *file_recv_callback;
    tox_file_recv_chunk_cb *file_recv_chunk_callback;
    tox_conference_invite_cb *conference_invite_callback;
    tox_conference_connected_cb *conference_connected_callback;
    tox_conference_message_cb *conference_message_callback;
    tox_conference_title_cb *conference_title_callback;
    tox_conference_peer_name_cb *conference_peer_name_callback;
    tox_conference_peer_list_changed_cb *conference_peer_list_changed_callback;
    tox_dht_get_nodes_response_cb *dht_get_nodes_response_callback;
    tox_friend_lossy_packet_cb *friend_lossy_packet_callback_per_pktid[UINT8_MAX + 1];
    tox_friend_lossless_packet_cb *friend_lossless_packet_callback_per_pktid[UINT8_MAX + 1];
    tox_group_peer_name_cb *group_peer_name_callback;
    tox_group_peer_status_cb *group_peer_status_callback;
    tox_group_connection_status_cb *group_connection_status_callback;
    tox_group_topic_cb *group_topic_callback;
    tox_group_privacy_state_cb *group_privacy_state_callback;
    tox_group_topic_lock_cb *group_topic_lock_callback;
    tox_group_voice_state_cb *group_voice_state_callback;
    tox_group_peer_limit_cb *group_peer_limit_callback;
    tox_group_password_cb *group_password_callback;
    tox_group_message_cb *group_message_callback;
    tox_group_private_message_cb *group_private_message_callback;
    tox_group_custom_packet_cb *group_custom_packet_callback;
    tox_group_custom_private_packet_cb *group_custom_private_packet_callback;
    tox_group_invite_cb *group_invite_callback;
    tox_group_peer_join_cb *group_peer_join_callback;
    tox_group_peer_exit_cb *group_peer_exit_callback;
    tox_group_self_join_cb *group_self_join_callback;
    tox_group_join_fail_cb *group_join_fail_callback;
    tox_group_moderation_cb *group_moderation_callback;

    void *toxav_object; // workaround to store a ToxAV object (setter and getter functions are available)
};

#ifdef __cplusplus
}
#endif

#endif // C_TOXCORE_TOXCORE_TOX_STRUCT_H
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2022 The TokTok team.
 */

#ifndef C_TOXCORE_TOXCORE_TOX_UNPACK_H
#define C_TOXCORE_TOXCORE_TOX_UNPACK_H


non_null() bool tox_unpack_conference_type(Bin_Unpack *bu, Tox_Conference_Type *val);
non_null() bool tox_unpack_connection(Bin_Unpack *bu, Tox_Connection *val);
non_null() bool tox_unpack_file_control(Bin_Unpack *bu, Tox_File_Control *val);
non_null() bool tox_unpack_message_type(Bin_Unpack *bu, Tox_Message_Type *val);
non_null() bool tox_unpack_user_status(Bin_Unpack *bu, Tox_User_Status *val);

#endif  // C_TOXCORE_TOXCORE_TOX_UNPACK_H
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2018 The TokTok team.
 * Copyright © 2013 Tox project.
 * Copyright © 2013 plutooo
 */

/**
 * Utilities.
 */
#ifndef C_TOXCORE_TOXCORE_UTIL_H
#define C_TOXCORE_TOXCORE_UTIL_H

#include <pthread.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>


#ifdef __cplusplus
extern "C" {
#endif

bool is_power_of_2(uint64_t x);

/** @brief Frees all pointers in a uint8_t pointer array, as well as the array itself. */
nullable(1)
void free_uint8_t_pointer_array(uint8_t **ary, size_t n_items);

/** Returns -1 if failed or 0 if success */
non_null() int create_recursive_mutex(pthread_mutex_t *mutex);

/**
 * @brief Checks whether two buffers are the same length and contents.
 *
 * Calls `memcmp` after checking the sizes are equal.
 *
 * @retval true if sizes and contents are equal.
 * @retval false otherwise.
 */
non_null() bool memeq(const uint8_t *a, size_t a_size, const uint8_t *b, size_t b_size);

// Safe min/max functions with specific types. This forces the conversion to the
// desired type before the comparison expression, giving the choice of
// conversion to the caller. Use these instead of inline comparisons or MIN/MAX
// macros (effectively inline comparisons).
int16_t max_s16(int16_t a, int16_t b);
int32_t max_s32(int32_t a, int32_t b);
int64_t max_s64(int64_t a, int64_t b);

int16_t min_s16(int16_t a, int16_t b);
int32_t min_s32(int32_t a, int32_t b);
int64_t min_s64(int64_t a, int64_t b);

uint16_t max_u16(uint16_t a, uint16_t b);
uint32_t max_u32(uint32_t a, uint32_t b);
uint64_t max_u64(uint64_t a, uint64_t b);

uint16_t min_u16(uint16_t a, uint16_t b);
uint32_t min_u32(uint32_t a, uint32_t b);
uint64_t min_u64(uint64_t a, uint64_t b);

/** @brief Returns a 32-bit hash of key of size len */
non_null()
uint32_t jenkins_one_at_a_time_hash(const uint8_t *key, size_t len);

/** @brief Computes a checksum of a byte array.
 *
 * @param data The byte array used to compute the checksum.
 * @param length The length in bytes of the passed data.
 *
 * @retval The resulting checksum.
 */
non_null()
uint16_t data_checksum(const uint8_t *data, uint32_t length);

#ifdef __cplusplus
}  // extern "C"
#endif

#endif // C_TOXCORE_TOXCORE_UTIL_H
/*
 * Copyright © 2018 Zoff
 *
 * This file is part of Tox, the free peer to peer instant messenger.
 *
 * Tox is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Tox is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Tox.  If not, see <http://www.gnu.org/licenses/>.
 */

#ifndef TOXUTIL_H
#define TOXUTIL_H

//!TOKSTYLE-

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>

#ifdef __cplusplus
extern "C" {
#endif

#define TOX_CAPABILITY_BASIC 0
#define TOX_CAPABILITY_CAPABILITIES ((uint64_t)1) << 0
#define TOX_CAPABILITY_MSGV2 ((uint64_t)1) << 1
#define TOX_CAPABILITY_TOXAV_H264 ((uint64_t)1) << 2

void tox_utils_callback_self_connection_status(Tox *tox, tox_self_connection_status_cb *callback);
void tox_utils_self_connection_status_cb(Tox *tox,
        TOX_CONNECTION connection_status, void *user_data);

void tox_utils_callback_friend_connection_status(Tox *tox,
        tox_friend_connection_status_cb *callback);
void tox_utils_friend_connection_status_cb(Tox *tox, uint32_t friendnumber,
        TOX_CONNECTION connection_status, void *user_data);

void tox_utils_callback_friend_lossless_packet(Tox *tox,
        tox_friend_lossless_packet_cb *callback);
void tox_utils_friend_lossless_packet_cb(Tox *tox, uint32_t friend_number,
        const uint8_t *data, size_t length, void *user_data);

void tox_utils_callback_file_recv_control(Tox *tox, tox_file_recv_control_cb *callback);
void tox_utils_file_recv_control_cb(Tox *tox, uint32_t friend_number, uint32_t file_number,
                                    TOX_FILE_CONTROL control, void *user_data);

void tox_utils_callback_file_chunk_request(Tox *tox, tox_file_chunk_request_cb *callback);
void tox_utils_file_chunk_request_cb(Tox *tox, uint32_t friend_number, uint32_t file_number,
                                     uint64_t position, size_t length, void *user_data);

void tox_utils_callback_file_recv(Tox *tox, tox_file_recv_cb *callback);
void tox_utils_file_recv_cb(Tox *tox, uint32_t friend_number, uint32_t file_number,
                            uint32_t kind, uint64_t file_size,
                            const uint8_t *filename, size_t filename_length, void *user_data);

void tox_utils_callback_file_recv_chunk(Tox *tox, tox_file_recv_chunk_cb *callback);
void tox_utils_file_recv_chunk_cb(Tox *tox, uint32_t friend_number, uint32_t file_number,
                                  uint64_t position, const uint8_t *data, size_t length,
                                  void *user_data);


// ---- Msg V2 API ----

// HINT: receive a message in new messageV2 format
//       (you still need to register the "old" callback "tox_friend_message_cb"
//       to receive old format messages)
// params: message       raw messageV2 data incl. header
//         length        length of raw messageV2 data incl. header
typedef void tox_util_friend_message_v2_cb(Tox *tox, uint32_t friend_number,
        const uint8_t *message, size_t length);

void tox_utils_callback_friend_message_v2(Tox *tox, tox_util_friend_message_v2_cb *callback);


// HINT: receive a sync message in new messageV2 format
// params: message       raw messageV2 data incl. header
//         length        length of raw messageV2 data incl. header
typedef void tox_util_friend_sync_message_v2_cb(Tox *tox, uint32_t friend_number,
        const uint8_t *message, size_t length);

void tox_utils_callback_friend_sync_message_v2(Tox *tox, tox_util_friend_sync_message_v2_cb *callback);


// HINT: receive message receipt (ACK)
// params: friend_number friend
//         ts_sec        unixtimestamp when message was received by the friend (in seconds since epoch)
//         msgid         buffer of the message hash, exactly TOX_PUBLIC_KEY_SIZE byte long
typedef void tox_utils_friend_read_receipt_message_v2_cb(Tox *tox, uint32_t friend_number,
        uint32_t ts_sec, const uint8_t *msgid);

void tox_utils_callback_friend_read_receipt_message_v2(Tox *tox,
        tox_utils_friend_read_receipt_message_v2_cb *callback);


// HINT: use only this API function to send messages (it will automatically send old format if needed)
// params: friend_number friend to send message to
//         type          type of message (only used for old style messages)
//         ts_sec        unixtimestamp when message was sent (in seconds since epoch)
//         message       buffer with message text
//         length        bytes in buffer of message text
//         raw_message_back buffer of TOX_MAX_FILETRANSFER_SIZE_MSGV2 size
//                       the raw message (incl. header) will be put there
//         raw_msg_len_back number of bytes the raw message actually uses in the buffer
//         msgid_back    buffer of the message hash, exactly TOX_PUBLIC_KEY_SIZE byte long
//         error         error code used for both old and new style messages
// return: int64_t       always -1 for new style messages (to indicate new style was used)
//         int64_t       return value of tox_friend_send_message() for old style messages
//                       (can't be negative)
int64_t tox_util_friend_send_message_v2(Tox *tox, uint32_t friend_number, TOX_MESSAGE_TYPE type,
                                        uint32_t ts_sec, const uint8_t *message, size_t length,
                                        uint8_t *raw_message_back, uint32_t *raw_msg_len_back,
                                        uint8_t *msgid_back,
                                        TOX_ERR_FRIEND_SEND_MESSAGE *error);

// resend a message
// params: friend_number friend to send message to
//         raw_message   buffer of the raw message (incl. header)
//         raw_msg_len   number of bytes length of raw message
// return: bool          true -> if message was sent OK
bool tox_util_friend_resend_message_v2(Tox *tox, uint32_t friend_number,
                                       const uint8_t *raw_message,
                                       const uint32_t raw_msg_len,
                                       TOX_ERR_FRIEND_SEND_MESSAGE *error);

// send a sync message
// params: friend_number friend to send message to
//         raw_message   buffer of the raw message (incl. header)
//         raw_msg_len   number of bytes length of raw message
// return: bool          true -> if message was sent OK
bool tox_util_friend_send_sync_message_v2(Tox *tox, uint32_t friend_number,
        const uint8_t *raw_message, const uint32_t raw_msg_len,
        TOX_ERR_FRIEND_SEND_MESSAGE *error);
// send message receipt
// params: friend_number friend to send message to
//         msgid         buffer of the message hash, exactly TOX_PUBLIC_KEY_SIZE byte long
//         ts_sec        unixtimestamp when message was received (in seconds since epoch)
bool tox_util_friend_send_msg_receipt_v2(Tox *tox, uint32_t friend_number, uint8_t *msgid, uint32_t ts_sec);


// ---- Msg V2 API ----


Tox *tox_utils_new(const struct Tox_Options *options, TOX_ERR_NEW *error);
void tox_utils_kill(Tox *tox);
bool tox_utils_friend_delete(Tox *tox, uint32_t friend_number, TOX_ERR_FRIEND_DELETE *error);


#ifdef __cplusplus
}
#endif

//!TOKSTYLE+

#endif
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2018 The TokTok team.
 * Copyright © 2013 Tox project.
 * Copyright © 2013 plutooo
 */
#ifndef C_TOXCORE_TOXAV_RING_BUFFER_H
#define C_TOXCORE_TOXAV_RING_BUFFER_H

#include <stdbool.h>
#include <stdint.h>

#ifdef __cplusplus
extern "C" {
#endif

/* Ring buffer */
typedef struct RingBuffer RingBuffer;
bool rb_full(const RingBuffer *b);
bool rb_empty(const RingBuffer *b);
void *rb_write(RingBuffer *b, void *p, uint64_t data_type_);
bool rb_read(RingBuffer *b, void **p, uint64_t *data_type_);
RingBuffer *rb_new(int size);
void rb_kill(RingBuffer *b);
uint16_t rb_size(const RingBuffer *b);
uint16_t rb_data(const RingBuffer *b, void **dest);

#ifdef __cplusplus
}
#endif

#endif // C_TOXCORE_TOXAV_RING_BUFFER_H
/*
 * Copyright © 2016-2018 The TokTok team.
 * Copyright © 2013-2015 Tox project.
 *
 * This file is part of Tox, the free peer to peer instant messenger.
 *
 * Tox is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Tox is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Tox.  If not, see <http://www.gnu.org/licenses/>.
 */
#ifndef C_TOXCORE_TOXAV_BWCONTROLLER_H
#define C_TOXCORE_TOXAV_BWCONTROLLER_H

#include <stdint.h>
#include <stdbool.h>


typedef struct BWController_s BWController;

typedef void m_cb(BWController *bwc, uint32_t friend_number, float todo, void *user_data);

BWController *bwc_new(Tox *tox, Mono_Time *mono_time_given, uint32_t friendnumber, m_cb *mcb, void *mcb_user_data);

void bwc_kill(BWController *bwc);

void bwc_add_lost_v3(BWController *bwc, uint32_t bytes, bool dummy);
void bwc_add_recv(BWController *bwc, uint32_t recv_bytes);
void bwc_allow_receiving(Tox *tox);
void bwc_stop_receiving(Tox *tox);

#endif // C_TOXCORE_TOXAV_BWCONTROLLER_H
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2018 The TokTok team.
 * Copyright © 2013-2015 Tox project.
 */
#ifndef C_TOXCORE_TOXAV_MSI_H
#define C_TOXCORE_TOXAV_MSI_H



#include <inttypes.h>
#include <pthread.h>

/**
 * Error codes.
 */
typedef enum MSIError {
    MSI_E_NONE, // 0
    MSI_E_INVALID_MESSAGE,
    MSI_E_INVALID_PARAM,
    MSI_E_INVALID_STATE, // 3
    MSI_E_STRAY_MESSAGE, // 4
    MSI_E_SYSTEM,
    MSI_E_HANDLE,
    MSI_E_UNDISCLOSED, /* NOTE: must be last enum otherwise parsing will not work */
} MSIError;

/**
 * Supported capabilities
 */
typedef enum MSICapabilities {
    MSI_CAP_S_AUDIO = 4,  /* sending audio */
    MSI_CAP_S_VIDEO = 8,  /* sending video */
    MSI_CAP_R_AUDIO = 16, /* receiving audio */
    MSI_CAP_R_VIDEO = 32, /* receiving video */
} MSICapabilities;


/**
 * Call state identifiers.
 */
typedef enum MSICallState {
    MSI_CALL_INACTIVE = 0, /* Default */
    MSI_CALL_ACTIVE = 1,
    MSI_CALL_REQUESTING = 2, /* when sending call invite */
    MSI_CALL_REQUESTED = 3, /* when getting call invite */
} MSICallState;

/**
 * Callbacks ids that handle the states
 */
typedef enum MSICallbackID {
    MSI_ON_INVITE = 0, /* Incoming call */
    MSI_ON_START = 1, /* Call (RTP transmission) started */
    MSI_ON_END = 2, /* Call that was active ended */
    MSI_ON_ERROR = 3, /* On protocol error */
    MSI_ON_PEERTIMEOUT = 4, /* Peer timed out; stop the call */
    MSI_ON_CAPABILITIES = 5, /* Peer requested capabilities change */
} MSICallbackID;

/**
 * The call struct. Please do not modify outside msi.c
 */
typedef struct MSICall_s {
    struct MSISession_s *session;           /* Session pointer */

    MSICallState         state;
    uint8_t              peer_capabilities; /* Peer capabilities */
    uint8_t              self_capabilities; /* Self capabilities */
    uint16_t             peer_vfpsz;        /* Video frame piece size */
    uint32_t             friend_number;     /* Index of this call in MSISession */
    MSIError             error;             /* Last error */

    struct ToxAVCall  *av_call;           /* Pointer to av call handler */

    struct MSICall_s    *next;
    struct MSICall_s    *prev;
} MSICall;


/**
 * Expected return on success is 0, if any other number is
 * returned the call is considered errored and will be handled
 * as such which means it will be terminated without any notice.
 */
typedef int msi_action_cb(void *av, MSICall *call);

/**
 * Control session struct. Please do not modify outside msi.c
 */
typedef struct MSISession_s {
    /* Call handlers */
    MSICall       **calls;
    uint32_t        calls_tail;
    uint32_t        calls_head;

    void           *av;
    Tox            *tox;

    pthread_mutex_t mutex[1];
    msi_action_cb *callbacks[7];
} MSISession;

/**
 * Start the control session.
 */
MSISession *msi_new(Tox *tox);
/**
 * Terminate control session. NOTE: all calls will be freed
 */
int msi_kill(Tox *tox, MSISession *session, const Logger *log);
/**
 * Callback setter.
 */
void msi_register_callback(MSISession *session, msi_action_cb *callback, MSICallbackID id);
/**
 * Send invite request to friend_number.
 */
int msi_invite(MSISession *session, MSICall **call, uint32_t friend_number, uint8_t capabilities);
/**
 * Hangup call. NOTE: `call` will be freed
 */
int msi_hangup(MSICall *call);
/**
 * Answer call request.
 */
int msi_answer(MSICall *call, uint8_t capabilities);
/**
 * Change capabilities of the call.
 */
int msi_change_capabilities(MSICall *call, uint8_t capabilities);

int invoke_callback(MSICall *call, MSICallbackID cb);
void kill_call(MSICall *call);

bool check_peer_offline_status(Tox *tox, MSISession *session, uint32_t friend_number);

#endif // C_TOXCORE_TOXAV_MSI_H
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2018 The TokTok team.
 * Copyright © 2013-2015 Tox project.
 */
#ifndef C_TOXCORE_TOXAV_RTP_H
#define C_TOXCORE_TOXAV_RTP_H



#include <stdbool.h>

#ifdef __cplusplus
extern "C" {
#endif

#define TOXAV_SKIP_FPS_RELEASE_AFTER_MS 13000 /* 13 seconds */


/**
 * RTPHeader serialised size in bytes.
 */
#define RTP_HEADER_SIZE 80

/**
 * Number of 32 bit padding fields between \ref RTPHeader::offset_lower and
 * everything before it.
 */
#define RTP_PADDING_FIELDS 4

#define PACKET_TOXAV_COMM_CHANNEL 172

/**
 * Payload type identifier. Also used as rtp callback prefix.
 */
typedef enum RTP_Type {
    RTP_TYPE_AUDIO = 192,
    RTP_TYPE_VIDEO = 193,
} RTP_Type;

#ifndef TOXAV_DEFINED
#define TOXAV_DEFINED
#undef ToxAV
typedef struct ToxAV ToxAV;
#endif /* TOXAV_DEFINED */

enum {
    video_frame_type_NORMALFRAME = 0,
    video_frame_type_KEYFRAME = 1,
};


#define USED_RTP_WORKBUFFER_COUNT 3
#define VIDEO_FRAGMENT_NUM_NO_FRAG (-1)


#define VP8E_SET_CPUUSED_VALUE (16)
/*
Codec control function to set encoder internal speed settings.
Changes in this value influences, among others, the encoder's selection of motion estimation methods.
Values greater than 0 will increase encoder speed at the expense of quality.

Note
    Valid range for VP8: -16..16
    Valid range for VP9: -8..8
 */
/**
 * A bit mask (up to 64 bits) specifying features of the current frame affecting
 * the behaviour of the decoder.
 */
typedef enum RTPFlags {
    /**
     * Support frames larger than 64KiB. The full 32 bit length and offset are
     * set in \ref RTPHeader::data_length_full and \ref RTPHeader::offset_full.
     */
    RTP_LARGE_FRAME = 1 << 0,
    /**
     * Whether the packet is part of a key frame.
     */
    RTP_KEY_FRAME = 1 << 1,

    /**
     * Whether H264 codec was used to encode this video frame
     */
    RTP_ENCODER_IS_H264 = 1 << 2,

    /**
     * Whether we have record-timestamp for this video frame
     */
    RTP_ENCODER_HAS_RECORD_TIMESTAMP = 1 << 3,

    /**
     * The orientation angle of this video frame
     *
     * possible values:
     *
     * 0   -> b0=0,b1=0
     * 90  -> b0=1,b1=0
     * 180 -> b0=0,b1=1
     * 270 -> b0=1,b1=1
     */
    RTP_ENCODER_VIDEO_ROTATION_ANGLE_BIT0 = 1 << 4,
    RTP_ENCODER_VIDEO_ROTATION_ANGLE_BIT1 = 1 << 5,

    /**
     * Whether H265 codec was used to encode this video frame
     */
    RTP_ENCODER_IS_H265 = 1 << 6,

} RTPFlags;


struct RTPHeader {
    /* Standard RTP header */
    unsigned ve: 2; /* Version has only 2 bits! */ // was called "protocol_version" in V3
    unsigned pe: 1; /* Padding */
    unsigned xe: 1; /* Extra header */
    unsigned cc: 4; /* Contributing sources count */

    unsigned ma: 1; /* Marker */
    unsigned pt: 7; /* Payload type */

    uint16_t sequnum;
    uint32_t timestamp;
    uint32_t ssrc;

    /* Non-standard Tox-specific fields */

    /**
     * Bit mask of \ref RTPFlags setting features of the current frame.
     */
    uint64_t flags;

    /**
     * The full 32 bit data offset of the current data chunk. The \ref
     * offset_lower data member contains the lower 16 bits of this value. For
     * frames smaller than 64KiB, \ref offset_full and \ref offset_lower are
     * equal.
     */
    uint32_t offset_full;
    /**
     * The full 32 bit payload length without header and packet id.
     */
    uint32_t data_length_full;
    /**
     * Only the receiver uses this field (why do we have this?).
     */
    uint32_t received_length_full;


    // ---------------------------- //
    //      custom fields here      //
    // ---------------------------- //
    uint64_t frame_record_timestamp; /* when was this frame actually recorded (this is a relative value!) */
    int32_t  fragment_num; /* if using fragments, this is the fragment/partition number */
    uint32_t real_frame_num; /* unused for now */
    uint32_t encoder_bit_rate_used; /* what was the encoder bit rate used to encode this frame */
    uint32_t client_video_capture_delay_ms; /* how long did the client take to capture a video frame in ms */
    uint32_t rtp_packet_number; /* rtp packet number */
    // ---------------------------- //
    //      custom fields here      //
    // ---------------------------- //


    // ---------------------------- //
    //    dont change below here    //
    // ---------------------------- //

    /**
     * Data offset of the current part (lower bits).
     */
    uint16_t offset_lower; // used to be called "cpart"
    /**
     * Total message length (lower bits).
     */
    uint16_t data_length_lower; // used to be called "tlen"
};


struct RTPMessage {
    /**
     * This is used in the old code that doesn't deal with large frames, i.e.
     * the audio code or receiving code for old 16 bit messages. We use it to
     * record the number of bytes received so far in a multi-part message. The
     * multi-part message in the old code is stored in \ref RTPSession::mp.
     */
    uint16_t len;

    struct RTPHeader header;
    uint8_t data[];
};

/**
 * One slot in the work buffer list. Represents one frame that is currently
 * being assembled.
 */
struct RTPWorkBuffer {
    /**
     * Whether this slot contains a key frame. This is true iff
     * `buf->header.flags & RTP_KEY_FRAME`.
     */
    bool is_keyframe;
    /**
     * The number of bytes received so far, regardless of which pieces. I.e. we
     * could have received the first 1000 bytes and the last 1000 bytes with
     * 4000 bytes in the middle still to come, and this number would be 2000.
     */
    uint32_t received_len;
    /**
     * The message currently being assembled.
     */
    struct RTPMessage *buf;
};

struct RTPWorkBufferList {
    int8_t next_free_entry;
    struct RTPWorkBuffer work_buffer[USED_RTP_WORKBUFFER_COUNT];
};

#define DISMISS_FIRST_LOST_VIDEO_PACKET_COUNT 10
#define INCOMING_PACKETS_TS_ENTRIES 10

typedef int rtp_m_cb(Mono_Time *mono_time, void *cs, struct RTPMessage *msg);

/**
 * RTP control session.
 */
typedef struct RTPSession {
    uint8_t  payload_type;
    uint16_t sequnum;      /* Sending sequence number */
    uint16_t rsequnum;     /* Receiving sequence number */
    uint32_t rtimestamp;
    uint32_t rtp_packet_num;
    uint32_t ssrc; //  this seems to be unused!?
    struct RTPMessage *mp; /* Expected parted message */
    struct RTPWorkBufferList *work_buffer_list;
    uint8_t  first_packets_counter; /* dismiss first few lost video packets */
    uint32_t incoming_packets_ts[INCOMING_PACKETS_TS_ENTRIES];
    int64_t incoming_packets_ts_last_ts;
    uint16_t incoming_packets_ts_index;
    uint32_t incoming_packets_ts_average;
    Tox *tox;
    ToxAV *toxav;
    uint32_t friend_number;
    bool rtp_receive_active;
    BWController *bwc;
    void *cs;
    rtp_m_cb *mcb;
} RTPSession;


void handle_rtp_packet(Tox *tox, uint32_t friendnumber, const uint8_t *data, size_t length, void *object);

/**
 * Serialise an RTPHeader to bytes to be sent over the network.
 *
 * @param rdata A byte array of length RTP_HEADER_SIZE. Does not need to be
 *   initialised. All RTP_HEADER_SIZE bytes will be initialised after a call
 *   to this function.
 * @param header The RTPHeader to serialise.
 */
size_t rtp_header_pack(uint8_t *rdata, const struct RTPHeader *header);

/**
 * Deserialise an RTPHeader from bytes received over the network.
 *
 * @param data A byte array of length RTP_HEADER_SIZE.
 * @param header The RTPHeader to write the unpacked values to.
 */
size_t rtp_header_unpack(const uint8_t *data, struct RTPHeader *header);

RTPSession *rtp_new(int payload_type, Tox *tox, ToxAV *toxav, uint32_t friendnumber,
                    BWController *bwc, void *cs, rtp_m_cb *mcb);
void rtp_kill(Tox *tox, RTPSession *session);
void rtp_allow_receiving_mark(Tox *tox, RTPSession *session);
void rtp_stop_receiving_mark(Tox *tox, RTPSession *session);
void rtp_allow_receiving(Tox *tox);
void rtp_stop_receiving(Tox *tox);
/**
 * Send a frame of audio or video data, chunked in \ref RTPMessage instances.
 *
 * @param session The A/V session to send the data for.
 * @param data A byte array of length \p length.
 * @param length The number of bytes to send from @p data.
 * @param is_keyframe Whether this video frame is a key frame. If it is an
 *   audio frame, this parameter is ignored.
 */
int rtp_send_data(RTPSession *session, const uint8_t *data, uint32_t length, bool is_keyframe,
                  uint64_t frame_record_timestamp, int32_t fragment_num,
                  uint32_t codec_used, uint32_t bit_rate_used,
                  uint32_t client_capture_delay_ms,
                  uint32_t video_frame_orientation_angle,
                  Logger *log);

#ifdef __cplusplus
}  // extern "C"
#endif

#endif // C_TOXCORE_TOXAV_RTP_H
/*
 * Copyright © 2018 zoff@zoff.cc
 *
 * This file is part of Tox, the free peer to peer instant messenger.
 *
 * Tox is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Tox is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Tox.  If not, see <http://www.gnu.org/licenses/>.
 */

#ifndef TS_BUFFER_H
#define TS_BUFFER_H

#include <stdbool.h>
#include <stdint.h>

#ifndef TOX_DEFINED
#define TOX_DEFINED
#undef Tox
typedef struct Tox Tox;
#endif /* TOX_DEFINED */


/* TimeStamp Buffer */
typedef struct TSBuffer TSBuffer;

bool tsb_full(const TSBuffer *b);
bool tsb_empty(const TSBuffer *b);
void tsb_get_range_in_buffer(Tox *tox, TSBuffer *b, uint32_t *timestamp_min, uint32_t *timestamp_max);
void *tsb_write(TSBuffer *b, void *p, const uint64_t data_type, const uint32_t timestamp);
bool tsb_read(TSBuffer *b, void **p, uint64_t *data_type, uint32_t *timestamp_out,
              const uint32_t timestamp_in, const uint32_t timestamp_range,
              uint16_t *removed_entries_back, uint16_t *is_skipping);
TSBuffer *tsb_new(const int size);
void tsb_kill(TSBuffer *b);
void tsb_drain(TSBuffer *b);
uint16_t tsb_size(const TSBuffer *b);

#endif /* TS_BUFFER_H */
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2018 The TokTok team.
 * Copyright © 2013-2015 Tox project.
 */
#ifndef C_TOXCORE_TOXAV_HACKS_H
#define C_TOXCORE_TOXAV_HACKS_H


#ifndef TOXAV_CALL_DEFINED
#define TOXAV_CALL_DEFINED
typedef struct ToxAVCall ToxAVCall;
#endif /* TOXAV_CALL_DEFINED */

ToxAVCall *call_get(ToxAV *av, uint32_t friend_number);
RTPSession *rtp_session_get(ToxAVCall *call, int payload_type);
MSISession *tox_av_msi_get(ToxAV *av);
BWController *bwc_controller_get(ToxAVCall *call);
Mono_Time *toxav_get_av_mono_time(ToxAV *toxav);
Logger *toxav_get_logger(ToxAV *toxav);
pthread_mutex_t *call_mutex_get(ToxAVCall *call);
pthread_mutex_t *endcall_mutex_get(ToxAV *av);

#endif // C_TOXCORE_TOXAV_HACKS_H
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2018 The TokTok team.
 * Copyright © 2014 Tox project.
 */
#ifndef C_TOXCORE_TOXAV_GROUPAV_H
#define C_TOXCORE_TOXAV_GROUPAV_H

// Audio encoding/decoding
#include <opus.h>


#define GROUP_AUDIO_PACKET_ID 192

// TODO(iphydf): Use this better typed one instead of the void-pointer one below.
// typedef void audio_data_cb(Tox *tox, uint32_t groupnumber, uint32_t peernumber, const int16_t *pcm,
//                            uint32_t samples, uint8_t channels, uint32_t sample_rate, void *userdata);
typedef void audio_data_cb(void *tox, uint32_t groupnumber, uint32_t peernumber, const int16_t *pcm,
                           uint32_t samples, uint8_t channels, uint32_t sample_rate, void *userdata);

/** @brief Create and connect to a new toxav group.
 *
 * @return group number on success.
 * @retval -1 on failure.
 */
int add_av_groupchat(const Logger *log, Tox *tox, Group_Chats *g_c, audio_data_cb *audio_callback, void *userdata);

/** @brief Join a AV group (you need to have been invited first).
 *
 * @return group number on success
 * @retval -1 on failure.
 */
int join_av_groupchat(const Logger *log, Tox *tox, Group_Chats *g_c, uint32_t friendnumber, const uint8_t *data,
                      uint16_t length, audio_data_cb *audio_callback, void *userdata);


/** @brief Send audio to the group chat.
 *
 * @retval 0 on success.
 * @retval -1 on failure.
 */
int group_send_audio(Group_Chats *g_c, uint32_t groupnumber, const int16_t *pcm, unsigned int samples, uint8_t channels,
                     uint32_t sample_rate);

/** @brief Enable A/V in a groupchat.
 *
 * @retval 0 on success.
 * @retval -1 on failure.
 */
int groupchat_enable_av(const Logger *log, Tox *tox, Group_Chats *g_c, uint32_t groupnumber,
                        audio_data_cb *audio_callback, void *userdata);

/** @brief Disable A/V in a groupchat.
 *
 * @retval 0 on success.
 * @retval -1 on failure.
 */
int groupchat_disable_av(const Group_Chats *g_c, uint32_t groupnumber);

/** Return whether A/V is enabled in the groupchat. */
bool groupchat_av_enabled(const Group_Chats *g_c, uint32_t groupnumber);

#endif // C_TOXCORE_TOXAV_GROUPAV_H
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2018 The TokTok team.
 * Copyright © 2013-2015 Tox project.
 */
#ifndef C_TOXCORE_TOXAV_TOXAV_H
#define C_TOXCORE_TOXAV_TOXAV_H

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>

#ifdef __cplusplus
extern "C" {
#endif

/** \page av Public audio/video API for Tox clients.
 *
 * This API can handle multiple calls. Each call has its state, in very rare
 * occasions the library can change the state of the call without apps knowledge.
 *
 */
/** \subsection events Events and callbacks
 *
 * As in Core API, events are handled by callbacks. One callback can be
 * registered per event. All events have a callback function type named
 * `toxav_{event}_cb` and a function to register it named `toxav_callback_{event}`.
 * Passing a NULL callback will result in no callback being registered for that
 * event. Only one callback per event can be registered, so if a client needs
 * multiple event listeners, it needs to implement the dispatch functionality
 * itself. Unlike Core API, lack of some event handlers will cause the the
 * library to drop calls before they are started. Hanging up call from a
 * callback causes undefined behaviour.
 *
 */
/** \subsection threading Threading implications
 *
 * Only toxav_iterate is thread-safe, all other functions must run from the
 * tox thread.
 *
 * A common way to run ToxAV (multiple or single instance) is to have a thread,
 * separate from tox instance thread, running a simple toxav_iterate loop,
 * sleeping for toxav_iteration_interval * milliseconds on each iteration.
 *
 * An important thing to note is that events are triggered from both tox and
 * toxav thread (see above). Audio and video receive frame events are triggered
 * from toxav thread while all the other events are triggered from tox thread.
 *
 * Tox thread has priority with mutex mechanisms. Any api function can
 * fail if mutexes are held by tox thread in which case they will set SYNC
 * error code.
 */
/**
 * External Tox type.
 */
#ifndef TOX_DEFINED
#define TOX_DEFINED
typedef struct Tox Tox;
#endif /* TOX_DEFINED */

/**
 * ToxAV.
 */
/**
 * The ToxAV instance type. Each ToxAV instance can be bound to only one Tox
 * instance, and Tox instance can have only one ToxAV instance. One must make
 * sure to close ToxAV instance prior closing Tox instance otherwise undefined
 * behaviour occurs. Upon closing of ToxAV instance, all active calls will be
 * forcibly terminated without notifying peers.
 *
 */
#ifndef TOXAV_DEFINED
#define TOXAV_DEFINED
typedef struct ToxAV ToxAV;
#endif /* TOXAV_DEFINED */


/*******************************************************************************
 *
 * :: Creation and destruction
 *
 ******************************************************************************/



typedef enum TOXAV_ERR_NEW {

    /**
     * The function returned successfully.
     */
    TOXAV_ERR_NEW_OK,

    /**
     * One of the arguments to the function was NULL when it was not expected.
     */
    TOXAV_ERR_NEW_NULL,

    /**
     * Memory allocation failure while trying to allocate structures required for
     * the A/V session.
     */
    TOXAV_ERR_NEW_MALLOC,

    /**
     * Attempted to create a second session for the same Tox instance.
     */
    TOXAV_ERR_NEW_MULTIPLE,

} TOXAV_ERR_NEW;


/**
 * Start new A/V session. There can only be only one session per Tox instance.
 */
ToxAV *toxav_new(Tox *tox, TOXAV_ERR_NEW *error);

/**
 * Releases all resources associated with the A/V session.
 *
 * If any calls were ongoing, these will be forcibly terminated without
 * notifying peers. After calling this function, no other functions may be
 * called and the av pointer becomes invalid.
 */
void toxav_kill(ToxAV *av);

/**
 * Returns the Tox instance the A/V object was created for.
 */
Tox *toxav_get_tox(const ToxAV *av);


/*******************************************************************************
 *
 * :: A/V event loop
 *
 ******************************************************************************/



/**
 * Returns the interval in milliseconds when the next toxav_iterate call should
 * be. If no call is active at the moment, this function returns 200.
 */
uint32_t toxav_iteration_interval(const ToxAV *av);

/**
 * Main loop for the session. This function needs to be called in intervals of
 * toxav_iteration_interval() milliseconds. It is best called in the separate
 * thread from tox_iterate.
 */
void toxav_iterate(ToxAV *av);

void toxav_audio_iterate_seperation(ToxAV *av, bool active);
void toxav_audio_iterate(ToxAV *av);


/*******************************************************************************
 *
 * :: Call setup
 *
 ******************************************************************************/



typedef enum TOXAV_ERR_CALL {

    /**
     * The function returned successfully.
     */
    TOXAV_ERR_CALL_OK,

    /**
     * A resource allocation error occurred while trying to create the structures
     * required for the call.
     */
    TOXAV_ERR_CALL_MALLOC,

    /**
     * Synchronization error occurred.
     */
    TOXAV_ERR_CALL_SYNC,

    /**
     * The friend number did not designate a valid friend.
     */
    TOXAV_ERR_CALL_FRIEND_NOT_FOUND,

    /**
     * The friend was valid, but not currently connected.
     */
    TOXAV_ERR_CALL_FRIEND_NOT_CONNECTED,

    /**
     * Attempted to call a friend while already in an audio or video call with
     * them.
     */
    TOXAV_ERR_CALL_FRIEND_ALREADY_IN_CALL,

    /**
     * Audio or video bit rate is invalid.
     */
    TOXAV_ERR_CALL_INVALID_BIT_RATE,

} TOXAV_ERR_CALL;


/**
 * Call a friend. This will start ringing the friend.
 *
 * It is the client's responsibility to stop ringing after a certain timeout,
 * if such behaviour is desired. If the client does not stop ringing, the
 * library will not stop until the friend is disconnected. Audio and video
 * receiving are both enabled by default.
 *
 * @param friend_number The friend number of the friend that should be called.
 * @param audio_bit_rate Audio bit rate in Kb/sec. Set this to 0 to disable
 * audio sending.
 * @param video_bit_rate Video bit rate in Kb/sec. Set this to 0 to disable
 * video sending.
 */
bool toxav_call(ToxAV *av, uint32_t friend_number, uint32_t audio_bit_rate, uint32_t video_bit_rate,
                TOXAV_ERR_CALL *error);

/**
 * The function type for the call callback.
 *
 * @param friend_number The friend number from which the call is incoming.
 * @param audio_enabled True if friend is sending audio.
 * @param video_enabled True if friend is sending video.
 */
typedef void toxav_call_cb(ToxAV *av, uint32_t friend_number, bool audio_enabled, bool video_enabled, void *user_data);


/**
 * Set the callback for the `call` event. Pass NULL to unset.
 *
 */
void toxav_callback_call(ToxAV *av, toxav_call_cb *callback, void *user_data);

typedef enum TOXAV_ERR_ANSWER {

    /**
     * The function returned successfully.
     */
    TOXAV_ERR_ANSWER_OK,

    /**
     * Synchronization error occurred.
     */
    TOXAV_ERR_ANSWER_SYNC,

    /**
     * Failed to initialize codecs for call session. Note that codec initiation
     * will fail if there is no receive callback registered for either audio or
     * video.
     */
    TOXAV_ERR_ANSWER_CODEC_INITIALIZATION,

    /**
     * The friend number did not designate a valid friend.
     */
    TOXAV_ERR_ANSWER_FRIEND_NOT_FOUND,

    /**
     * The friend was valid, but they are not currently trying to initiate a call.
     * This is also returned if this client is already in a call with the friend.
     */
    TOXAV_ERR_ANSWER_FRIEND_NOT_CALLING,

    /**
     * Audio or video bit rate is invalid.
     */
    TOXAV_ERR_ANSWER_INVALID_BIT_RATE,

} TOXAV_ERR_ANSWER;


/**
 * Accept an incoming call.
 *
 * If answering fails for any reason, the call will still be pending and it is
 * possible to try and answer it later. Audio and video receiving are both
 * enabled by default.
 *
 * @param friend_number The friend number of the friend that is calling.
 * @param audio_bit_rate Audio bit rate in Kb/sec. Set this to 0 to disable
 * audio sending.
 * @param video_bit_rate Video bit rate in Kb/sec. Set this to 0 to disable
 * video sending.
 */
bool toxav_answer(ToxAV *av, uint32_t friend_number, uint32_t audio_bit_rate, uint32_t video_bit_rate,
                  TOXAV_ERR_ANSWER *error);





typedef enum TOXAV_CALL_COMM_INFO {
    TOXAV_CALL_COMM_DECODER_IN_USE_VP8 = 0,
    TOXAV_CALL_COMM_DECODER_IN_USE_H264 = 1,
    TOXAV_CALL_COMM_DECODER_IN_USE_H265 = 16,
    TOXAV_CALL_COMM_ENCODER_IN_USE_VP8 = 2,
    TOXAV_CALL_COMM_ENCODER_IN_USE_H264 = 3,
    TOXAV_CALL_COMM_ENCODER_IN_USE_H264_OMX_PI = 6,
    TOXAV_CALL_COMM_ENCODER_IN_USE_H265 = 15,
    TOXAV_CALL_COMM_DECODER_CURRENT_BITRATE = 4,
    TOXAV_CALL_COMM_ENCODER_CURRENT_BITRATE = 5,
    TOXAV_CALL_COMM_NETWORK_ROUND_TRIP_MS = 7,
    TOXAV_CALL_COMM_PLAY_DELAY = 8,
    TOXAV_CALL_COMM_PLAY_BUFFER_ENTRIES = 9,
    TOXAV_CALL_COMM_INCOMING_FPS = 10,
    TOXAV_CALL_COMM_REMOTE_RECORD_DELAY = 11,
    TOXAV_CALL_COMM_DECODER_H264_PROFILE = 12,
    TOXAV_CALL_COMM_DECODER_H264_LEVEL = 13,
    TOXAV_CALL_COMM_PLAY_VIDEO_ORIENTATION = 14,
} TOXAV_CALL_COMM_INFO;



/**
 * The function type for the call_comm callback.
 *
 * @param friend_number The friend number from which the call is incoming.
 * @param comm_value enum value of for the information.
 */
typedef void toxav_call_comm_cb(ToxAV *av, uint32_t friend_number, TOXAV_CALL_COMM_INFO comm_value,
                                int64_t comm_number, void *user_data);


/**
 * Set the callback for the `call_comm` event. Pass NULL to unset.
 *
 */
void toxav_callback_call_comm(ToxAV *av, toxav_call_comm_cb *callback, void *user_data);





/*******************************************************************************
 *
 * :: Call state graph
 *
 ******************************************************************************/



enum TOXAV_FRIEND_CALL_STATE {

    /**
     * The empty bit mask. None of the bits specified below are set.
     */
    TOXAV_FRIEND_CALL_STATE_NONE = 0,

    /**
     * Set by the AV core if an error occurred on the remote end or if friend
     * timed out. This is the final state after which no more state
     * transitions can occur for the call. This call state will never be triggered
     * in combination with other call states.
     */
    TOXAV_FRIEND_CALL_STATE_ERROR = 1,

    /**
     * The call has finished. This is the final state after which no more state
     * transitions can occur for the call. This call state will never be
     * triggered in combination with other call states.
     */
    TOXAV_FRIEND_CALL_STATE_FINISHED = 2,

    /**
     * The flag that marks that friend is sending audio.
     */
    TOXAV_FRIEND_CALL_STATE_SENDING_A = 4,

    /**
     * The flag that marks that friend is sending video.
     */
    TOXAV_FRIEND_CALL_STATE_SENDING_V = 8,

    /**
     * The flag that marks that friend is receiving audio.
     */
    TOXAV_FRIEND_CALL_STATE_ACCEPTING_A = 16,

    /**
     * The flag that marks that friend is receiving video.
     */
    TOXAV_FRIEND_CALL_STATE_ACCEPTING_V = 32,

};


/**
 * The function type for the call_state callback.
 *
 * @param friend_number The friend number for which the call state changed.
 * @param state The bitmask of the new call state which is guaranteed to be
 * different than the previous state. The state is set to 0 when the call is
 * paused. The bitmask represents all the activities currently performed by the
 * friend.
 */
typedef void toxav_call_state_cb(ToxAV *av, uint32_t friend_number, uint32_t state, void *user_data);


/**
 * Set the callback for the `call_state` event. Pass NULL to unset.
 *
 */
void toxav_callback_call_state(ToxAV *av, toxav_call_state_cb *callback, void *user_data);


/*******************************************************************************
 *
 * :: Call control
 *
 ******************************************************************************/



typedef enum TOXAV_CALL_CONTROL {

    /**
     * Resume a previously paused call. Only valid if the pause was caused by this
     * client, if not, this control is ignored. Not valid before the call is accepted.
     */
    TOXAV_CALL_CONTROL_RESUME,

    /**
     * Put a call on hold. Not valid before the call is accepted.
     */
    TOXAV_CALL_CONTROL_PAUSE,

    /**
     * Reject a call if it was not answered, yet. Cancel a call after it was
     * answered.
     */
    TOXAV_CALL_CONTROL_CANCEL,

    /**
     * Request that the friend stops sending audio. Regardless of the friend's
     * compliance, this will cause the audio_receive_frame event to stop being
     * triggered on receiving an audio frame from the friend.
     */
    TOXAV_CALL_CONTROL_MUTE_AUDIO,

    /**
     * Calling this control will notify client to start sending audio again.
     */
    TOXAV_CALL_CONTROL_UNMUTE_AUDIO,

    /**
     * Request that the friend stops sending video. Regardless of the friend's
     * compliance, this will cause the video_receive_frame event to stop being
     * triggered on receiving a video frame from the friend.
     */
    TOXAV_CALL_CONTROL_HIDE_VIDEO,

    /**
     * Calling this control will notify client to start sending video again.
     */
    TOXAV_CALL_CONTROL_SHOW_VIDEO,

} TOXAV_CALL_CONTROL;


typedef enum TOXAV_ERR_CALL_CONTROL {

    /**
     * The function returned successfully.
     */
    TOXAV_ERR_CALL_CONTROL_OK,

    /**
     * Synchronization error occurred.
     */
    TOXAV_ERR_CALL_CONTROL_SYNC,

    /**
     * The friend_number passed did not designate a valid friend.
     */
    TOXAV_ERR_CALL_CONTROL_FRIEND_NOT_FOUND,

    /**
     * This client is currently not in a call with the friend. Before the call is
     * answered, only CANCEL is a valid control.
     */
    TOXAV_ERR_CALL_CONTROL_FRIEND_NOT_IN_CALL,

    /**
     * Happens if user tried to pause an already paused call or if trying to
     * resume a call that is not paused.
     */
    TOXAV_ERR_CALL_CONTROL_INVALID_TRANSITION,

} TOXAV_ERR_CALL_CONTROL;


/**
 * Sends a call control command to a friend.
 *
 * @param friend_number The friend number of the friend this client is in a call
 * with.
 * @param control The control command to send.
 *
 * @return true on success.
 */
bool toxav_call_control(ToxAV *av, uint32_t friend_number, TOXAV_CALL_CONTROL control, TOXAV_ERR_CALL_CONTROL *error);


/*******************************************************************************
 *
 * :: Controlling bit rates
 *
 ******************************************************************************/



typedef enum TOXAV_ERR_BIT_RATE_SET {

    /**
     * The function returned successfully.
     */
    TOXAV_ERR_BIT_RATE_SET_OK,

    /**
     * Synchronization error occurred.
     */
    TOXAV_ERR_BIT_RATE_SET_SYNC,

    /**
     * The bit rate passed was not one of the supported values.
     */
    TOXAV_ERR_BIT_RATE_SET_INVALID_BIT_RATE,

    /**
     * The friend_number passed did not designate a valid friend.
     */
    TOXAV_ERR_BIT_RATE_SET_FRIEND_NOT_FOUND,

    /**
     * This client is currently not in a call with the friend.
     */
    TOXAV_ERR_BIT_RATE_SET_FRIEND_NOT_IN_CALL,

} TOXAV_ERR_BIT_RATE_SET;



/**
 * Set the bit rate to be used in subsequent audio/video frames.
 *
 * @param friend_number The friend number of the friend for which to set the
 * bit rate.
 * @param audio_bit_rate The new audio bit rate in Kb/sec. Set to 0 to disable
 * audio sending. Set to -1 to leave unchanged.
 * @param video_bit_rate The new video bit rate in Kb/sec. Set to 0 to disable
 * video sending. Set to -1 to leave unchanged.
 *
 */
bool toxav_bit_rate_set(ToxAV *av, uint32_t friend_number, int32_t audio_bit_rate, int32_t video_bit_rate,
                        TOXAV_ERR_BIT_RATE_SET *error);

/**
 * Set the bit rate to be used in subsequent video frames.
 *
 * @param friend_number The friend number of the friend for which to set the
 * bit rate.
 * @param bit_rate The new video bit rate in Kb/sec. Set to 0 to disable.
 *
 * @return true on success.
 */
bool toxav_video_set_bit_rate(ToxAV *av, uint32_t friend_number, uint32_t bit_rate, TOXAV_ERR_BIT_RATE_SET *error);

/**
 * Set the bit rate to be used in subsequent video frames.
 *
 * @param friend_number The friend number of the friend for which to set the
 * bit rate.
 * @param bit_rate The new audio bit rate in Kb/sec. Set to 0 to disable.
 *
 * @return true on success.
 */
bool toxav_audio_set_bit_rate(ToxAV *av, uint32_t friend_number, uint32_t bit_rate, TOXAV_ERR_BIT_RATE_SET *error);

/**
 * The function type for the bit_rate_status callback. The event is triggered
 * when the network becomes too saturated for current bit rates at which
 * point core suggests new bit rates.
 *
 * @param friend_number The friend number of the friend for which to set the
 * bit rate.
 * @param audio_bit_rate Suggested maximum audio bit rate in Kb/sec.
 * @param video_bit_rate Suggested maximum video bit rate in Kb/sec.
 */
typedef void toxav_bit_rate_status_cb(ToxAV *av, uint32_t friend_number, uint32_t audio_bit_rate,
                                      uint32_t video_bit_rate, void *user_data);


/**
 * Set the callback for the `bit_rate_status` event. Pass NULL to unset.
 *
 */
void toxav_callback_bit_rate_status(ToxAV *av, toxav_bit_rate_status_cb *callback, void *user_data);


/*******************************************************************************
 *
 * :: A/V sending
 *
 ******************************************************************************/



typedef enum TOXAV_ERR_SEND_FRAME {

    /**
     * The function returned successfully.
     */
    TOXAV_ERR_SEND_FRAME_OK,

    /**
     * In case of video, one of Y, U, or V was NULL. In case of audio, the samples
     * data pointer was NULL.
     */
    TOXAV_ERR_SEND_FRAME_NULL,

    /**
     * The friend_number passed did not designate a valid friend.
     */
    TOXAV_ERR_SEND_FRAME_FRIEND_NOT_FOUND,

    /**
     * This client is currently not in a call with the friend.
     */
    TOXAV_ERR_SEND_FRAME_FRIEND_NOT_IN_CALL,

    /**
     * Synchronization error occurred.
     */
    TOXAV_ERR_SEND_FRAME_SYNC,

    /**
     * One of the frame parameters was invalid. E.g. the resolution may be too
     * small or too large, or the audio sampling rate may be unsupported.
     */
    TOXAV_ERR_SEND_FRAME_INVALID,

    /**
     * Either friend turned off audio or video receiving or we turned off sending
     * for the said payload.
     */
    TOXAV_ERR_SEND_FRAME_PAYLOAD_TYPE_DISABLED,

    /**
     * Failed to push frame through rtp interface.
     */
    TOXAV_ERR_SEND_FRAME_RTP_FAILED,

} TOXAV_ERR_SEND_FRAME;



/**
 * The function type for the audio_bit_rate callback. The event is triggered
 * when the network becomes too saturated for current bit rates at which
 * point core suggests new bit rates.
 *
 * @param friend_number The friend number of the friend for which to set the
 * bit rate.
 * @param audio_bit_rate Suggested maximum audio bit rate in Kb/sec.
 */
typedef void toxav_audio_bit_rate_cb(ToxAV *av, uint32_t friend_number, uint32_t audio_bit_rate, void *user_data);


/**
 * Set the callback for the `audio_bit_rate` event. Pass NULL to unset.
 *
 */
void toxav_callback_audio_bit_rate(ToxAV *av, toxav_audio_bit_rate_cb *callback, void *user_data);


/**
 * Send an audio frame to a friend.
 *
 * The expected format of the PCM data is: [s1c1][s1c2][...][s2c1][s2c2][...]...
 * Meaning: sample 1 for channel 1, sample 1 for channel 2, ...
 * For mono audio, this has no meaning, every sample is subsequent. For stereo,
 * this means the expected format is LRLRLR... with samples for left and right
 * alternating.
 *
 * @param friend_number The friend number of the friend to which to send an
 * audio frame.
 * @param pcm An array of audio samples. The size of this array must be
 * sample_count * channels.
 * @param sample_count Number of samples in this frame. Valid numbers here are
 * ((sample rate) * (audio length) / 1000), where audio length can be
 * 2.5, 5, 10, 20, 40 or 60 millseconds.
 * @param channels Number of audio channels. Supported values are 1 and 2.
 * @param sampling_rate Audio sampling rate used in this frame. Valid sampling
 * rates are 8000, 12000, 16000, 24000, or 48000.
 */
bool toxav_audio_send_frame(ToxAV *av, uint32_t friend_number, const int16_t *pcm, size_t sample_count,
                            uint8_t channels, uint32_t sampling_rate, TOXAV_ERR_SEND_FRAME *error);

bool toxav_audio_send_frame_age(ToxAV *av, uint32_t friend_number, const int16_t *pcm, size_t sample_count,
                            uint8_t channels, uint32_t sampling_rate, TOXAV_ERR_SEND_FRAME *error, int32_t age_ms);


/**
 * Send a video frame to a friend.
 *
 * Y - plane should be of size: height * width
 * U - plane should be of size: (height/2) * (width/2)
 * V - plane should be of size: (height/2) * (width/2)
 *
 * @param friend_number The friend number of the friend to which to send a video
 * frame.
 * @param width Width of the frame in pixels.
 * @param height Height of the frame in pixels.
 * @param y Y (Luminance) plane data.
 * @param u U (Chroma) plane data.
 * @param v V (Chroma) plane data.
 */
bool toxav_video_send_frame(ToxAV *av, uint32_t friend_number, uint16_t width, uint16_t height, const uint8_t *y,
                            const uint8_t *u, const uint8_t *v, TOXAV_ERR_SEND_FRAME *error);

/**
 * Send a video frame to a friend.
 *
 * Y - plane should be of size: height * width
 * U - plane should be of size: (height/2) * (width/2)
 * V - plane should be of size: (height/2) * (width/2)
 *
 * @param friend_number The friend number of the friend to which to send a video
 * frame.
 * @param width Width of the frame in pixels.
 * @param height Height of the frame in pixels.
 * @param y Y (Luminance) plane data.
 * @param u U (Chroma) plane data.
 * @param v V (Chroma) plane data.
 */
bool toxav_video_send_frame_age(ToxAV *av, uint32_t friend_number, uint16_t width, uint16_t height, const uint8_t *y,
                            const uint8_t *u, const uint8_t *v, TOXAV_ERR_SEND_FRAME *error, int32_t age_ms);


bool toxav_video_send_frame_h264(ToxAV *av, uint32_t friend_number, uint16_t width, uint16_t height, const uint8_t *buf,
                                 uint32_t data_len, TOXAV_ERR_SEND_FRAME *error);

bool toxav_video_send_frame_h264_age(ToxAV *av, uint32_t friend_number, uint16_t width, uint16_t height, const uint8_t *buf,
                                 uint32_t data_len, TOXAV_ERR_SEND_FRAME *error, int32_t age_ms);


/**
 * The function type for the video_bit_rate callback. The event is triggered
 * when the network becomes too saturated for current bit rates at which
 * point core suggests new bit rates.
 *
 * @param friend_number The friend number of the friend for which to set the
 * bit rate.
 * @param video_bit_rate Suggested maximum video bit rate in Kb/sec.
 */
typedef void toxav_video_bit_rate_cb(ToxAV *av, uint32_t friend_number, uint32_t video_bit_rate, void *user_data);


/**
 * Set the callback for the `video_bit_rate` event. Pass NULL to unset.
 *
 */
void toxav_callback_video_bit_rate(ToxAV *av, toxav_video_bit_rate_cb *callback, void *user_data);

/*******************************************************************************
 *
 * :: A/V receiving
 *
 ******************************************************************************/



/**
 * The function type for the audio_receive_frame callback. The callback can be
 * called multiple times per single iteration depending on the amount of queued
 * frames in the buffer. The received format is the same as in send function.
 *
 * @param friend_number The friend number of the friend who sent an audio frame.
 * @param pcm An array of audio samples (sample_count * channels elements).
 * @param sample_count The number of audio samples per channel in the PCM array.
 * @param channels Number of audio channels.
 * @param sampling_rate Sampling rate used in this frame.
 *
 */
typedef void toxav_audio_receive_frame_cb(ToxAV *av, uint32_t friend_number, const int16_t *pcm, size_t sample_count,
        uint8_t channels, uint32_t sampling_rate, void *user_data);


/**
 * Set the callback for the `audio_receive_frame` event. Pass NULL to unset.
 *
 */
void toxav_callback_audio_receive_frame(ToxAV *av, toxav_audio_receive_frame_cb *callback, void *user_data);


typedef void toxav_audio_receive_frame_pts_cb(ToxAV *av, uint32_t friend_number, const int16_t *pcm, size_t sample_count,
        uint8_t channels, uint32_t sampling_rate, void *user_data, uint64_t pts);

void toxav_callback_audio_receive_frame_pts(ToxAV *av, toxav_audio_receive_frame_pts_cb *callback, void *user_data);

/**
 * The function type for the video_receive_frame callback.
 *
 * The size of plane data is derived from width and height as documented
 * below.
 *
 * Strides represent padding for each plane that may or may not be present.
 * You must handle strides in your image processing code. Strides are
 * negative if the image is bottom-up hence why you MUST abs() it when
 * calculating plane buffer size.
 *
 * @param friend_number The friend number of the friend who sent a video frame.
 * @param width Width of the frame in pixels.
 * @param height Height of the frame in pixels.
 * @param y Luminosity plane. Size = MAX(width, abs(ystride)) * height.
 * @param u U chroma plane. Size = MAX(width/2, abs(ustride)) * (height/2).
 * @param v V chroma plane. Size = MAX(width/2, abs(vstride)) * (height/2).
 *
 * @param ystride Luminosity plane stride.
 * @param ustride U chroma plane stride.
 * @param vstride V chroma plane stride.
 */
typedef void toxav_video_receive_frame_cb(ToxAV *av, uint32_t friend_number, uint16_t width, uint16_t height,
        const uint8_t *y, const uint8_t *u, const uint8_t *v, int32_t ystride, int32_t ustride, int32_t vstride,
        void *user_data);


/**
 * Set the callback for the `video_receive_frame` event. Pass NULL to unset.
 *
 */
void toxav_callback_video_receive_frame(ToxAV *av, toxav_video_receive_frame_cb *callback, void *user_data);



typedef void toxav_video_receive_frame_pts_cb(ToxAV *av, uint32_t friend_number, uint16_t width, uint16_t height,
        const uint8_t *y, const uint8_t *u, const uint8_t *v, int32_t ystride, int32_t ustride, int32_t vstride,
        void *user_data, uint64_t pts);

void toxav_callback_video_receive_frame_pts(ToxAV *av, toxav_video_receive_frame_pts_cb *callback, void *user_data);





typedef void toxav_video_receive_frame_h264_cb(ToxAV *av, uint32_t friend_number,
        const uint8_t *buf, const uint32_t buf_size, void *user_data);


/**
 * Set the callback for the `video_receive_frame_h264` event. Pass NULL to unset.
 *
 */
void toxav_callback_video_receive_frame_h264(ToxAV *av, toxav_video_receive_frame_h264_cb *callback, void *user_data);


/**
 * NOTE Compatibility with old toxav group calls. TODO(iphydf): remove
 *
 * TODO(iphydf): Use proper new API guidelines for these. E.g. don't use inline
 * function types, don't have per-callback userdata, especially don't have one
 * userdata per group.
 */
/* Create a new toxav group.
 *
 * return group number on success.
 * return -1 on failure.
 *
 * Audio data callback format:
 *   audio_callback(Tox *tox, uint32_t groupnumber, uint32_t peernumber, const int16_t *pcm, unsigned int samples, uint8_t channels, uint32_t sample_rate, void *userdata)
 *
 * Note that total size of pcm in bytes is equal to (samples * channels * sizeof(int16_t)).
 */
int toxav_add_av_groupchat(Tox *tox,
                           void (*audio_callback)(void *, uint32_t, uint32_t, const int16_t *, unsigned int, uint8_t, uint32_t, void *),
                           void *userdata);

/* Join a AV group (you need to have been invited first.)
 *
 * returns group number on success
 * returns -1 on failure.
 *
 * Audio data callback format (same as the one for toxav_add_av_groupchat()):
 *   audio_callback(Tox *tox, uint32_t groupnumber, uint32_t peernumber, const int16_t *pcm, unsigned int samples, uint8_t channels, uint32_t sample_rate, void *userdata)
 *
 * Note that total size of pcm in bytes is equal to (samples * channels * sizeof(int16_t)).
 */
int toxav_join_av_groupchat(Tox *tox, uint32_t friendnumber, const uint8_t *data, uint16_t length,
                            void (*audio_callback)(void *, uint32_t, uint32_t, const int16_t *, unsigned int, uint8_t, uint32_t, void *),
                            void *userdata);

/* Send audio to the group chat.
 *
 * return 0 on success.
 * return -1 on failure.
 *
 * Note that total size of pcm in bytes is equal to (samples * channels * sizeof(int16_t)).
 *
 * Valid number of samples are ((sample rate) * (audio length (Valid ones are: 2.5, 5, 10, 20, 40 or 60 ms)) / 1000)
 * Valid number of channels are 1 or 2.
 * Valid sample rates are 8000, 12000, 16000, 24000, or 48000.
 *
 * Recommended values are: samples = 960, channels = 1, sample_rate = 48000
 */
int toxav_group_send_audio(Tox *tox, uint32_t groupnumber, const int16_t *pcm, unsigned int samples, uint8_t channels,
                           uint32_t sample_rate);

/* Enable A/V in a groupchat.
 *
 * A/V must be enabled on a groupchat for audio to be sent to it and for
 * received audio to be handled.
 *
 * An A/V group created with toxav_add_av_groupchat or toxav_join_av_groupchat
 * will start with A/V enabled.
 *
 * An A/V group loaded from a savefile will start with A/V disabled.
 *
 * return 0 on success.
 * return -1 on failure.
 *
 * Audio data callback format (same as the one for toxav_add_av_groupchat()):
 *   audio_callback(Tox *tox, uint32_t groupnumber, uint32_t peernumber, const int16_t *pcm, unsigned int samples, uint8_t channels, uint32_t sample_rate, void *userdata)
 *
 * Note that total size of pcm in bytes is equal to (samples * channels * sizeof(int16_t)).
 */
int toxav_groupchat_enable_av(Tox *tox, uint32_t groupnumber,
                              void (*audio_callback)(void *, uint32_t, uint32_t, const int16_t *, unsigned int, uint8_t, uint32_t, void *),
                              void *userdata);

/* Disable A/V in a groupchat.
 *
 * return 0 on success.
 * return -1 on failure.
 */
int toxav_groupchat_disable_av(Tox *tox, uint32_t groupnumber);

/* Return whether A/V is enabled in the groupchat.
 */
bool toxav_groupchat_av_enabled(Tox *tox, uint32_t groupnumber);


/*******************************************************************************
 *
 * :: A/V generic encoder/decoder options
 *
 ******************************************************************************/

#define HAVE_TOXAV_OPTION_SET   1

typedef enum TOXAV_ERR_OPTION_SET {

    /**
     * The function returned successfully.
     */
    TOXAV_ERR_OPTION_SET_OK,

    /**
     * Some other error occurred
     */
    TOXAV_ERR_OPTION_SET_OTHER_ERROR,

    /**
     * The option passed does not exist
     */
    TOXAV_ERR_OPTION_SET_INVALID_OPTION,

    /**
     * The value passed was not one of the supported values.
     */
    TOXAV_ERR_OPTION_SET_INVALID_VALUE,

} TOXAV_ERR_OPTION_SET;


typedef enum TOXAV_OPTIONS_VP8_QUALITY_VALUE {
    TOXAV_ENCODER_VP8_QUALITY_NORMAL = 0,
    TOXAV_ENCODER_VP8_QUALITY_HIGH = 1,
} TOXAV_OPTIONS_VP8_QUALITY_VALUE;

typedef enum TOXAV_ENCODER_CODEC_USED_VALUE {
    TOXAV_ENCODER_CODEC_USED_VP8 = 0,
    TOXAV_ENCODER_CODEC_USED_VP9 = 1,
    TOXAV_ENCODER_CODEC_USED_H264 = 2,
    TOXAV_ENCODER_CODEC_USED_H265 = 3,
} TOXAV_ENCODER_CODEC_USED_VALUE;

typedef enum TOXAV_ENCODER_KF_METHOD_VALUE {
    TOXAV_ENCODER_KF_METHOD_NORMAL = 0,
    TOXAV_ENCODER_KF_METHOD_PATTERN = 1,
} TOXAV_ENCODER_KF_METHOD_VALUE;

typedef enum TOXAV_CLIENT_INPUT_VIDEO_ORIENTATION_VALUE {
    TOXAV_CLIENT_INPUT_VIDEO_ORIENTATION_0 = 0,
    TOXAV_CLIENT_INPUT_VIDEO_ORIENTATION_90 = 1,
    TOXAV_CLIENT_INPUT_VIDEO_ORIENTATION_180 = 2,
    TOXAV_CLIENT_INPUT_VIDEO_ORIENTATION_270 = 3,
} TOXAV_CLIENT_INPUT_VIDEO_ORIENTATION_VALUE;


typedef enum TOXAV_OPTIONS_OPTION {
    TOXAV_ENCODER_CPU_USED = 0,
    TOXAV_ENCODER_VP8_QUALITY = 1,
    TOXAV_ENCODER_MIN_SOFTDEADLINE = 2,
    TOXAV_ENCODER_MAX_SOFTDEADLINE = 3,
    TOXAV_DECODER_MIN_SOFTDEADLINE = 4,
    TOXAV_DECODER_MAX_SOFTDEADLINE = 5,
    TOXAV_ENCODER_RC_MAX_QUANTIZER = 6,
    TOXAV_ENCODER_RC_MIN_QUANTIZER = 8,
    TOXAV_DECODER_ERROR_CONCEALMENT = 7,
    TOXAV_ENCODER_CODEC_USED = 9,
    TOXAV_ENCODER_KF_METHOD = 10,
    TOXAV_ENCODER_VIDEO_BITRATE_AUTOSET = 11,
    TOXAV_ENCODER_VIDEO_MAX_BITRATE = 12,
    TOXAV_DECODER_VIDEO_BUFFER_MS = 13,
    TOXAV_CLIENT_VIDEO_CAPTURE_DELAY_MS = 14,
    TOXAV_CLIENT_INPUT_VIDEO_ORIENTATION = 15,
    TOXAV_DECODER_VIDEO_ADD_DELAY_MS = 16,
    TOXAV_ENCODER_VIDEO_MIN_BITRATE = 17,
} TOXAV_OPTIONS_OPTION;



/**
 * Set generic AV encoder/decoder settings.
 *
 */
bool toxav_option_set(ToxAV *av, uint32_t friend_number, TOXAV_OPTIONS_OPTION option, int32_t value,
                        TOXAV_ERR_OPTION_SET *error);


/**
 * NGC Group Video.
 */
void* toxav_ngc_video_init(const uint16_t v_bitrate, const uint16_t max_quantizer);
void toxav_ngc_video_kill(void *vngc);
bool toxav_ngc_video_encode(void *vngc, const uint16_t vbitrate, const uint32_t max_quantizer,
                            const uint16_t width, const uint16_t height,
                            const uint8_t *y, const uint8_t *u, const uint8_t *v,
                            uint8_t *encoded_frame_bytes, uint32_t *encoded_frame_size_bytes);
bool toxav_ngc_video_decode(void *vngc, uint8_t *encoded_frame_bytes, uint32_t encoded_frame_size_bytes,
                            uint16_t width, uint16_t height,
                            uint8_t *y, uint8_t *u, uint8_t *v,
                            int32_t *ystride, int32_t *ustride, int32_t *vstride,
                            uint8_t flush_decoder);


/**
 * NGC Group Audio.
 */
void* toxav_ngc_audio_init(const int32_t bit_rate, const int32_t sampling_rate, const int32_t channel_count);
void toxav_ngc_audio_kill(void *angc);
bool toxav_ngc_audio_encode(void *angc, const int16_t *pcm, const int32_t sample_count_per_frame,
                        uint8_t *encoded_frame_bytes, uint32_t *encoded_frame_size_bytes);
int32_t toxav_ngc_audio_decode(void *angc, const uint8_t *encoded_frame_bytes,
                        uint32_t encoded_frame_size_bytes,
                        int16_t *pcm_decoded);



#ifdef __cplusplus
}
#endif

typedef void toxav_group_audio_cb(Tox *tox, uint32_t groupnumber, uint32_t peernumber, const int16_t *pcm,
                                  uint32_t samples, uint8_t channels, uint32_t sample_rate, void *user_data);

typedef TOXAV_ERR_CALL Toxav_Err_Call;
typedef TOXAV_ERR_NEW Toxav_Err_New;
typedef TOXAV_ERR_ANSWER Toxav_Err_Answer;
typedef TOXAV_ERR_CALL_CONTROL Toxav_Err_Call_Control;
typedef TOXAV_ERR_BIT_RATE_SET Toxav_Err_Bit_Rate_Set;
typedef TOXAV_ERR_SEND_FRAME Toxav_Err_Send_Frame;
typedef TOXAV_CALL_CONTROL Toxav_Call_Control;

#endif // C_TOXCORE_TOXAV_TOXAV_H
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2018 The TokTok team.
 * Copyright © 2013-2015 Tox project.
 */
#ifndef C_TOXCORE_TOXAV_VIDEO_H
#define C_TOXCORE_TOXAV_VIDEO_H





// for VPX ----------
#include <vpx/vpx_decoder.h>
#include <vpx/vpx_encoder.h>
#include <vpx/vpx_image.h>
#include <vpx/vp8cx.h>
#include <vpx/vp8dx.h>
// for VPX ----------

#ifdef __cplusplus
extern "C" {
#endif
// for H264 ----------
#include <x264.h>
#include <libavcodec/avcodec.h>
#include <libavutil/common.h>
// for H264 ----------

#ifdef HAVE_H265_ENCODER
// for H265 ----------
#include <x265.h>
// for H265 ----------
#endif

#ifdef __cplusplus
}
#endif

// TODO: don't hardcode this, let the application choose it
// VPX Info: Time to spend encoding, in microseconds (it's a *soft* deadline)
#define WANTED_MAX_ENCODER_FPS (40)
#define MAX_ENCODE_TIME_US (1000000 / WANTED_MAX_ENCODER_FPS) // to allow x fps
/*
VPX_DL_REALTIME       (1)       deadline parameter analogous to VPx REALTIME mode.
VPX_DL_GOOD_QUALITY   (1000000) deadline parameter analogous to VPx GOOD QUALITY mode.
VPX_DL_BEST_QUALITY   (0)       deadline parameter analogous to VPx BEST QUALITY mode.
*/

#define AV_BUFFERING_MS_MIN 2
#define AV_BUFFERING_MS_MAX 800

#ifdef HW_CODEC_CONFIG_RPI3_TBW_TV
// more buffering for TV usecase
#undef MIN_AV_BUFFERING_MS
#undef AV_BUFFERING_DELTA_MS
#define MIN_AV_BUFFERING_MS 90
#define AV_BUFFERING_DELTA_MS 5
#endif

#define GUESS_REMOTE_ENCODER_DELAY_MS 100 // guess how long the remote end took to encode 1 video frame in ms

typedef enum PACKET_TOXAV_COMM_CHANNEL_FUNCTION {
    PACKET_TOXAV_COMM_CHANNEL_REQUEST_KEYFRAME = 0,
    PACKET_TOXAV_COMM_CHANNEL_HAVE_H264_VIDEO = 1,
    PACKET_TOXAV_COMM_CHANNEL_DUMMY_NTP_REQUEST = 3,
    PACKET_TOXAV_COMM_CHANNEL_DUMMY_NTP_ANSWER = 4,
} PACKET_TOXAV_COMM_CHANNEL_FUNCTION;


// Zoff --
// -- VP8 codec ----------------
#define VIDEO_CODEC_DECODER_INTERFACE_VP8 (vpx_codec_vp8_dx())
#define VIDEO_CODEC_ENCODER_INTERFACE_VP8 (vpx_codec_vp8_cx())
// -- VP9 codec ----------------
#define VIDEO_CODEC_DECODER_INTERFACE_VP9 (vpx_codec_vp9_dx())
#define VIDEO_CODEC_ENCODER_INTERFACE_VP9 (vpx_codec_vp9_cx())
// Zoff --

#define VIDEO_CODEC_DECODER_MAX_WIDTH  (800) // (16384) // thats just some initial dummy value
#define VIDEO_CODEC_DECODER_MAX_HEIGHT (600) // (16384) // so don't worry

#define VPX_MAX_ENCODER_THREADS (3)
#define VPX_MAX_DECODER_THREADS (1)
#define VIDEO__VP9E_SET_TILE_COLUMNS (1)
#define VIDEO__VP9E_SET_TILE_ROWS (1)
#define VIDEO__VP9_KF_MAX_DIST (60)
#define VIDEO__VP8_DECODER_ERROR_CONCEALMENT 0
#define VIDEO__VP8_DECODER_POST_PROCESSING_ENABLED 0 // 0, 1, 2, 3 # 0->none, 3->maximum
// #define VIDEO_CODEC_ENCODER_USE_FRAGMENTS 1
#define VIDEO_CODEC_FRAGMENT_NUMS (5)
// #define VIDEO_CODEC_FRAGMENT_VPX_NUMS VP8_ONE_TOKENPARTITION
#define VIDEO_CODEC_FRAGMENT_VPX_NUMS VP8_FOUR_TOKENPARTITION
// #define VIDEO_CODEC_FRAGMENT_VPX_NUMS VP8_EIGHT_TOKENPARTITION
#define VIDEO_MAX_FRAGMENT_BUFFER_COUNT (100)
#define TOXAV_ENCODER_VP8_RC_MAX_QUANTIZER_NORMAL 50
#define TOXAV_ENCODER_VP8_RC_MAX_QUANTIZER_HIGH 43
#define TOXAV_ENCODER_VP8_RC_MIN_QUANTIZER_NORMAL 2
#define TOXAV_ENCODER_VP8_RC_MIN_QUANTIZER_HIGH 0
#define TOXAV_ENCODER_VP_RC_RESIZE_UP_THRESH 60
#define TOXAV_ENCODER_VP_RC_RESIZE_DOWN_THRESH 30

// #define VIDEO_PTS_TIMESTAMPS 1

#define VIDEO_SEND_X_KEYFRAMES_FIRST (1) // force the first n frames to be keyframes!
#define VPX_MAX_DIST_START (100)


#ifdef VIDEO_CODEC_ENCODER_USE_FRAGMENTS
#define VIDEO_RINGBUFFER_BUFFER_ELEMENTS (8 * VIDEO_CODEC_FRAGMENT_NUMS) // this buffer has normally max. ~2 entry
#define VIDEO_RINGBUFFER_FILL_THRESHOLD (2 * VIDEO_CODEC_FRAGMENT_NUMS) // start decoding at lower quality
#define VIDEO_RINGBUFFER_DROP_THRESHOLD (5 * VIDEO_CODEC_FRAGMENT_NUMS) // start dropping incoming frames (except index frames)
#else
// -------------------------------------
//  can buffer ~ (VIDEO_RINGBUFFER_BUFFER_ELEMENTS * 40ms@25fps) --> can hold this much video data in ms for audio-to-video delay
#define VIDEO_RINGBUFFER_BUFFER_ELEMENTS (142) // this buffer has normally max. ~2 entry
// -------------------------------------
#define VIDEO_RINGBUFFER_FILL_THRESHOLD (2) // start decoding at lower quality
#define VIDEO_RINGBUFFER_DROP_THRESHOLD (5) // start dropping incoming frames (except index frames)
#endif

#define VIDEO_MIN_REQUEST_KEYFRAME_INTERVAL_MS_FOR_NF 5000 // x sec. between KEYFRAME requests
#define VIDEO_MIN_REQUEST_KEYFRAME_INTERVAL_MS_FOR_KF 1000 // y sec. between KEYFRAME requests

#define VIDEO_DECODER_SOFT_DEADLINE_AUTOTUNE 1
// #define VIDEO_DECODER_AUTOSWITCH_CODEC 1 // sometimes this does not work correctly
#define VIDEO_DECODER_MINFPS_AUTOTUNE (10)
#define VIDEO_DECODER_LEEWAY_IN_MS_AUTOTUNE (5)

// #define VIDEO_ENCODER_SOFT_DEADLINE_AUTOTUNE 1
#define VIDEO_ENCODER_MINFPS_AUTOTUNE (15)
#define VIDEO_ENCODER_LEEWAY_IN_MS_AUTOTUNE (10)

#define VPX_DECODER_USED TOXAV_ENCODER_CODEC_USED_VP8 // this will switch automatically

#define VIDEO_DECODER_SOFT_DEADLINE_AUTOTUNE_ENTRIES 20
#define VIDEO_ENCODER_SOFT_DEADLINE_AUTOTUNE_ENTRIES 20
#define VIDEO_INCOMING_FRAMES_GAP_MS_ENTRIES 20
#define VIDEO_DECODER_CAUSED_DELAY_MS_ENTRIES 20
#define VIDEO_BUF_MS_ENTRIES 20
#define VIDEO_BUF_MS_ENTRIES_LONG 200

#include <pthread.h>

struct TSBuffer;

#ifndef TOXAV_DEFINED
#define TOXAV_DEFINED
#undef ToxAV
typedef struct ToxAV ToxAV;
#endif /* TOXAV_DEFINED */

struct OMXContext;

typedef struct VCSession_s {
    /* encoding */
    vpx_codec_ctx_t encoder[1];
    uint32_t frame_counter;
    x264_t *h264_encoder;
    x264_picture_t h264_in_pic;
    x264_picture_t h264_out_pic;
    int h264_enc_width;
    int h264_enc_height;
    uint32_t h264_enc_bitrate;

#ifdef HAVE_H265_ENCODER
// ------ h265 encoder ------
    x265_encoder *h265_encoder;
    x265_picture *h265_in_pic;
    x265_picture *h265_out_pic;
    int h265_enc_width;
    int h265_enc_height;
// ------ h265 encoder ------
#endif

// ------ ffmpeg encoder ------
    AVCodecContext *h264_encoder2;
    AVPacket *h264_out_pic2;
// ------ ffmpeg encoder ------

    char *encoder_codec_used_name;
    int x264_software_encoder_used;

    /* decoding */
    vpx_codec_ctx_t decoder[1];
    AVCodecContext *h264_decoder;
    AVCodecContext *h265_decoder;
    struct TSBuffer *vbuf_raw; /* Un-decoded data */

    uint32_t tsb_range_ms;
    uint64_t linfts; /* Last received frame time stamp */
    uint32_t lcfd; /* Last calculated frame duration for incoming video payload */

    uint8_t show_own_video;
    uint64_t last_decoded_frame_ts;
    uint64_t last_encoded_frame_ts;
    uint8_t  flag_end_video_fragment;
    int32_t  last_seen_fragment_num;
    int32_t  last_seen_fragment_seqnum;
    uint16_t count_old_video_frames_seen;
    uint32_t last_requested_keyframe_ts;
    uint32_t last_sent_keyframe_ts;
    uint32_t decoder_soft_deadline[VIDEO_DECODER_SOFT_DEADLINE_AUTOTUNE_ENTRIES];
    uint8_t  decoder_soft_deadline_index;
    uint32_t encoder_soft_deadline[VIDEO_ENCODER_SOFT_DEADLINE_AUTOTUNE_ENTRIES];
    uint8_t  encoder_soft_deadline_index;
    uint32_t incoming_video_frames_gap_ms[VIDEO_INCOMING_FRAMES_GAP_MS_ENTRIES];
    uint8_t  incoming_video_frames_gap_ms_index;
    uint32_t incoming_video_frames_gap_last_ts;
    uint32_t incoming_video_frames_gap_ms_mean_value;

    uint32_t video_decoder_caused_delay_ms_array[VIDEO_DECODER_CAUSED_DELAY_MS_ENTRIES];
    uint8_t video_decoder_caused_delay_ms_array_index;
    uint32_t video_decoder_caused_delay_ms_mean_value;

    uint32_t video_buf_ms_array[VIDEO_BUF_MS_ENTRIES];
    uint8_t video_buf_ms_array_index;
    int32_t video_buf_ms_mean_value;

    uint32_t video_buf_ms_array_long[VIDEO_BUF_MS_ENTRIES_LONG];
    uint8_t video_buf_ms_array_index_long;
    int32_t video_buf_ms_mean_value_long;

    uint8_t send_keyframe_request_received;
    uint8_t h264_video_capabilities_received;

    int64_t timestamp_difference_to_sender__for_video;
    int64_t timestamp_difference_adjustment;
    uint32_t rountrip_time_ms;
    int32_t has_rountrip_time_ms;
    int32_t pinned_to_rountrip_time_ms;
    int32_t video_play_delay;
    int32_t video_play_delay_real;
    uint32_t video_frame_buffer_entries;
    uint64_t last_incoming_frame_ts;
    uint64_t last_parsed_h264_sps_ts;
    uint32_t parsed_h264_sps_profile_i;
    uint32_t parsed_h264_sps_level_i;
    uint32_t video_incoming_frame_orientation;
    uint32_t video_received_first_frame;

    uint32_t dummy_ntp_local_start;
    uint32_t dummy_ntp_local_end;
    uint32_t dummy_ntp_remote_start;
    uint32_t dummy_ntp_remote_end;

    // options ---
    int32_t video_encoder_cpu_used;
    int32_t video_encoder_cpu_used_prev;
    int32_t video_encoder_vp8_quality;
    int32_t video_encoder_vp8_quality_prev;
    int32_t video_rc_max_quantizer;
    int32_t video_rc_max_quantizer_prev;
    int32_t video_rc_min_quantizer;
    int32_t video_rc_min_quantizer_prev;
    int32_t video_keyframe_method;
    int32_t video_keyframe_method_prev;
    uint8_t video_bitrate_autoset;
    int32_t video_max_bitrate;
    int32_t video_min_bitrate;
    int32_t video_encoder_coded_used;
    int32_t video_encoder_coded_used_hw_accel;
    int32_t video_encoder_coded_used_prev;
    int32_t video_decoder_error_concealment;
    int32_t video_decoder_error_concealment_prev;
    int32_t video_decoder_codec_used;
    int32_t startup_video_timespan;
    uint8_t encoder_frame_has_record_timestamp;
    int32_t video_decoder_buffer_ms;
    int32_t video_decoder_add_delay_ms;
    int32_t client_video_capture_delay_ms;
    int32_t video_decoder_caused_delay_ms;
    int32_t remote_client_video_capture_delay_ms;
    int32_t video_encoder_frame_orientation_angle;
    int32_t global_decode_first_frame_delayed_by;
    uint64_t global_decode_first_frame_delayed_ms;
    int32_t global_decode_first_frame_got;
    // options ---

    void *vpx_frames_buf_list[VIDEO_MAX_FRAGMENT_BUFFER_COUNT];
    uint16_t fragment_buf_counter;

    Logger *log;
    ToxAV *av;
    uint32_t friend_number;
    uint32_t incoming_video_bitrate_last_changed;
    uint32_t incoming_video_bitrate_last_cb_ts;
    uint32_t network_round_trip_time_last_cb_ts;
    int32_t network_round_trip_adjustment;
    uint32_t last_requested_lower_fps_ts;

    /* Video frame receive callback */
    toxav_video_receive_frame_cb *vcb;
    void *vcb_user_data;
    toxav_video_receive_frame_pts_cb *vcb_pts;
    void *vcb_pts_user_data;
    toxav_video_receive_frame_h264_cb *vcb_h264;
    void *vcb_h264_user_data;

    pthread_mutex_t queue_mutex[1];
} VCSession;



VCSession *vc_new(Mono_Time *mono_time, const Logger *log, ToxAV *av, uint32_t friend_number,
                  toxav_video_receive_frame_cb *cb, void *cb_data);
void vc_kill(VCSession *vc);
uint8_t vc_iterate(VCSession *vc, Tox *tox, uint8_t skip_video_flag, uint64_t *a_r_timestamp,
                   uint64_t *a_l_timestamp,
                   uint64_t *v_r_timestamp, uint64_t *v_l_timestamp, BWController *bwc,
                   int64_t *timestamp_difference_adjustment_,
                   int64_t *timestamp_difference_to_sender_,
                   int32_t *video_has_rountrip_time_ms);
int vc_queue_message(Mono_Time *mono_time, void *vcp, struct RTPMessage *msg);
int vc_reconfigure_encoder(Logger *log, VCSession *vc, uint32_t bit_rate, uint16_t width, uint16_t height,
                           int16_t kf_max_dist);
int vc_reconfigure_encoder_bitrate_only(VCSession *vc, uint32_t bit_rate);

#endif // C_TOXCORE_TOXAV_VIDEO_H
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2018 The TokTok team.
 * Copyright © 2013-2015 Tox project.
 */
#ifndef C_TOXCORE_TOXAV_AUDIO_H
#define C_TOXCORE_TOXAV_AUDIO_H



#include <opus.h>
#include <pthread.h>


#define AUDIO_JITTERBUFFER_COUNT 500 // ~ (5ms * AUDIO_JITTERBUFFER_COUNT) --> to hold that many ms audio data for audio-to-video delay
#define AUDIO_JITTERBUFFER_FILL_THRESHOLD (98) // this should be lower than the above value!
#define AUDIO_JITTERBUFFER_SKIP_THRESHOLD (99)

#define AUDIO_JITTERBUFFER_MIN_FILLED (0)

#define AUDIO_MAX_SAMPLING_RATE (48000)
#define AUDIO_MAX_CHANNEL_COUNT (2)

#define AUDIO_START_SAMPLING_RATE (48000)
#define AUDIO_START_BITRATE_RATE (48000)
#define AUDIO_START_CHANNEL_COUNT (2)
#define AUDIO_OPUS_PACKET_LOSS_PERC (2) // allow upto XX % loss of audio packets

#ifdef RPIZEROW
#define AUDIO_OPUS_COMPLEXITY (0)
#else
#define AUDIO_OPUS_COMPLEXITY (10)
#endif

#define AUDIO_DECODER__START_SAMPLING_RATE (48000)
#define AUDIO_DECODER__START_CHANNEL_COUNT (2)

#define AUDIO_MAX_FRAME_DURATION_MS (120)

#define AUDIO_LOST_FRAME_INDICATOR (4)

// ((sampling_rate_in_hz * frame_duration_in_ms) / 1000) * 2 // because PCM16 needs 2 bytes for 1 sample
#define AUDIO_MAX_BUFFER_SIZE_PCM16_FOR_FRAME_PER_CHANNEL ((AUDIO_MAX_SAMPLING_RATE * AUDIO_MAX_FRAME_DURATION_MS) / 1000)
#define AUDIO_MAX_BUFFER_SIZE_BYTES_FOR_FRAME_PER_CHANNEL (AUDIO_MAX_BUFFER_SIZE_PCM16_FOR_FRAME_PER_CHANNEL * 2)

/* debugging */
// #define AUDIO_DEBUGGING_SKIP_FRAMES 1
// #define AUDIO_DEBUGGING_SIMULATE_SOME_DATA_LOSS 1
/* debugging */

typedef struct ACSession_s {
    Mono_Time *mono_time;

    /* encoding */
    OpusEncoder *encoder;
    int32_t le_sample_rate; /* Last encoder sample rate */
    int32_t le_channel_count; /* Last encoder channel count */
    int32_t le_bit_rate; /* Last encoder bit rate */

    /* decoding */
    OpusDecoder *decoder;
    int32_t lp_channel_count; /* Last packet channel count */
    int32_t lp_sampling_rate; /* Last packet sample rate */
    int32_t lp_frame_duration; /* Last packet frame duration */
    int32_t ld_sample_rate; /* Last decoder sample rate */
    int32_t ld_channel_count; /* Last decoder channel count */
    uint64_t ldrts; /* Last decoder reconfiguration time stamp */
    int32_t lp_seqnum_new; /* last incoming packet sequence number */
    void *j_buf; /* it's a Ringbuffer now */
    int16_t temp_audio_buffer[AUDIO_MAX_BUFFER_SIZE_PCM16_FOR_FRAME_PER_CHANNEL *
                                                                                AUDIO_MAX_CHANNEL_COUNT];

    int64_t timestamp_difference_to_sender;
    uint64_t last_incoming_frame_ts;
    uint8_t encoder_frame_has_record_timestamp;
    uint32_t audio_received_first_frame;

    pthread_mutex_t queue_mutex[1];

    ToxAV *av;
    Tox *tox;
    uint32_t friend_number;
    /* Audio frame receive callback */
    toxav_audio_receive_frame_cb *acb;
    void *acb_user_data;

    toxav_audio_receive_frame_pts_cb *acb_pts;
    void *acb_pts_user_data;
} ACSession;

ACSession *ac_new(Mono_Time *mono_time, const Logger *log, ToxAV *av, Tox *tox, uint32_t friend_number,
                  toxav_audio_receive_frame_cb *cb, void *cb_data,
                  toxav_audio_receive_frame_pts_cb *cb_pts, void *cb_pts_data);
void ac_kill(ACSession *ac);
uint8_t ac_iterate(ACSession *ac, uint64_t *a_r_timestamp, uint64_t *a_l_timestamp, uint64_t *v_r_timestamp,
                   uint64_t *v_l_timestamp,
                   int64_t *timestamp_difference_adjustment_,
                   int64_t *timestamp_difference_to_sender_,
                   int video_send_cap,
                   int32_t *video_has_rountrip_time_ms);
int ac_queue_message(Mono_Time *mono_time, void *acp, struct RTPMessage *msg);
int ac_reconfigure_encoder(ACSession *ac, int32_t bit_rate, int32_t sampling_rate, uint8_t channels);

#endif // C_TOXCORE_TOXAV_AUDIO_H
/*
 * Copyright © 2016-2017 The TokTok team.
 * Copyright © 2013-2015 Tox project.
 *
 * This file is part of Tox, the free peer to peer instant messenger.
 *
 * Tox is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Tox is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Tox.  If not, see <http://www.gnu.org/licenses/>.
 */
#ifndef C_TOXCORE_TOXAV_TOX_GENERIC_H
#define C_TOXCORE_TOXAV_TOX_GENERIC_H

#define DISABLE_H264_DECODER_FEATURE    0

// H264 settings -----------
#define VIDEO_BITRATE_INITIAL_VALUE_H264 180
#define VIDEO_BITRATE_MIN_AUTO_VALUE_H264 95
#define VIDEO_BITRATE_SCALAR_AUTO_VALUE_H264 1400
#define VIDEO_BITRATE_SCALAR_INC_BY_AUTO_VALUE_H264 20
#define VIDEO_BITRATE_SCALAR2_AUTO_VALUE_H264 5000
#define VIDEO_BITRATE_SCALAR2_INC_BY_AUTO_VALUE_H264 15
#define VIDEO_BITRATE_SCALAR3_AUTO_VALUE_H264 7000

#define VIDEO_BITRATE_SCALAR_DEC_BY_AUTO_VALUE_H264 60

// default max video bitrate
#define VIDEO_BITRATE_MAX_AUTO_VALUE_H264 2700

#ifdef HW_CODEC_CONFIG_RPI3_TBW_BIDI
// max video bitrate on ToxPhone
#undef VIDEO_BITRATE_MAX_AUTO_VALUE_H264
#define VIDEO_BITRATE_MAX_AUTO_VALUE_H264 2700
#endif

#ifdef HW_CODEC_CONFIG_UTOX_LINNVENC
// max video bitrate for ToxTV
#undef VIDEO_BITRATE_MAX_AUTO_VALUE_H264
#define VIDEO_BITRATE_MAX_AUTO_VALUE_H264 6000

#undef VIDEO_BITRATE_INITIAL_VALUE_H264
#define VIDEO_BITRATE_INITIAL_VALUE_H264 180
#endif

#ifdef HW_CODEC_CONFIG_HIGHVBITRATE
// max video bitrate for TV
#undef VIDEO_BITRATE_MAX_AUTO_VALUE_H264
#define VIDEO_BITRATE_MAX_AUTO_VALUE_H264 6000

#undef VIDEO_BITRATE_INITIAL_VALUE_H264
#define VIDEO_BITRATE_INITIAL_VALUE_H264 300
#endif



// -- these control how agressive the bandwidth control is --
#define VIDEO_BITRATE_AUTO_INC_THRESHOLD 1.1 // threshold loss % to increase bitrate (in %)
#define VIDEO_BITRATE_AUTO_DEC_THRESHOLD 2.8 // threshold loss % to lower the bitrate (in %)
#define VIDEO_BITRATE_AUTO_INC_TO 1.02 // increase video bitrate by n%
#define VIDEO_BITRATE_AUTO_DEC_FACTOR 0.93 //
// -- these control how agressive the bandwidth control is --

#define VIDEO_MAX_KF_H264 60
#define VIDEO_BUF_FACTOR_H264 1
#define VIDEO_F_RATE_TOLERANCE_H264 1.3
#define VIDEO_BITRATE_FACTOR_H264 0.7
// H264 settings -----------

#define TOXAV_ENCODER_CODEC_HW_ACCEL_NONE 0
#define TOXAV_ENCODER_CODEC_HW_ACCEL_OMX_PI 1

#define VIDEO_BITRATE_MAX_AUTO_VALUE_VP8 6000
#define VIDEO_BITRATE_MIN_AUTO_VALUE_VP8 200
#define VIDEO_BITRATE_CORRECTION_FACTOR_VP8 (float)1

#ifndef TOXAV_CALL_DEFINED
#define TOXAV_CALL_DEFINED
typedef struct ToxAVCall ToxAVCall;
#endif /* TOXAV_CALL_DEFINED */

struct ToxAVCall {
    ToxAV *av;

    pthread_mutex_t mutex_audio[1];
    RTPSession *audio_rtp;
    ACSession *audio;

    pthread_mutex_t mutex_video[1];
    RTPSession *video_rtp;
    VCSession *video;

    BWController *bwc;

    uint8_t skip_video_flag;

    bool active;
    MSICall *msi_call;
    uint32_t friend_number;

    uint32_t audio_bit_rate; /* Sending audio bit rate */
    uint32_t video_bit_rate; /* Sending video bit rate */
    uint32_t video_bit_rate_not_yet_set;
    uint32_t video_bit_rate_last_last_changed; // only for callback info
    uint32_t video_bit_rate_last_last_changed_cb_ts;

    uint64_t last_incoming_video_frame_rtimestamp;
    uint64_t last_incoming_video_frame_ltimestamp;

    uint64_t last_incoming_audio_frame_rtimestamp;
    uint64_t last_incoming_audio_frame_ltimestamp;

    int64_t call_timestamp_difference_to_sender;
    int64_t call_timestamp_difference_adjustment;
    // uint32_t call_rountrip_time_ms;
    int32_t call_video_has_rountrip_time_ms;

    uint64_t reference_rtimestamp;
    uint64_t reference_ltimestamp;
    int64_t reference_diff_timestamp;
    uint8_t reference_diff_timestamp_set;

    /** Required for monitoring changes in states */
    uint8_t previous_self_capabilities;

    pthread_mutex_t toxav_call_mutex[1];

    struct ToxAVCall *prev;
    struct ToxAVCall *next;
};


struct ToxAV {
    Tox *tox;
    MSISession *msi;

    bool toxav_audio_iterate_seperation_active;

    /* Two-way storage: first is array of calls and second is list of calls with head and tail */
    ToxAVCall **calls;
    uint32_t calls_tail;
    uint32_t calls_head;
    pthread_mutex_t mutex[1];
    pthread_mutex_t toxav_endcall_mutex[1];

    /* Call callback */
    toxav_call_cb *ccb;
    void *ccb_user_data;
    /* Call_comm callback */
    toxav_call_comm_cb *call_comm_cb;
    void *call_comm_cb_user_data;
    /* Call state callback */
    toxav_call_state_cb *scb;
    void *scb_user_data;
    /* Audio frame receive callback */
    toxav_audio_receive_frame_cb *acb;
    void *acb_user_data;
    toxav_audio_receive_frame_pts_cb *acb_pts;
    void *acb_pts_user_data;
    /* Video frame receive callback */
    toxav_video_receive_frame_cb *vcb;
    void *vcb_user_data;
    toxav_video_receive_frame_pts_cb *vcb_pts;
    void *vcb_pts_user_data;
    toxav_video_receive_frame_h264_cb *vcb_h264;
    void *vcb_h264_user_data;
    /* Bit rate control callback */
    toxav_bit_rate_status_cb *bcb;
    void *bcb_user_data;
    /* Bit rate control callback */
    toxav_audio_bit_rate_cb *abcb;
    void *abcb_user_data;
    /* Bit rate control callback */
    toxav_video_bit_rate_cb *vbcb;
    void *vbcb_user_data;

    /** Decode time measures */
    int32_t dmssc; /** Measure count */
    int32_t dmsst; /** Last cycle total */
    int32_t dmssa; /** Average decoding time in ms */

    uint32_t interval; /** Calculated interval */

    Mono_Time *toxav_mono_time; // ToxAV's own mono_time instance
};

#endif // C_TOXCORE_TOXAV_TOX_GENERIC_H
/*
 * Copyright © 2018 zoff@zoff.cc and mail@strfry.org
 *
 * This file is part of Tox, the free peer to peer instant messenger.
 *
 * Tox is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Tox is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Tox.  If not, see <http://www.gnu.org/licenses/>.
 */
#ifndef C_TOXCORE_TOXAV_TOXAV_CODECS_H
#define C_TOXCORE_TOXAV_TOXAV_CODECS_H

// ----------- COMMON STUFF -----------
/*
  Soft deadline the decoder should attempt to meet, in "us" (microseconds). Set to zero for unlimited.
  By convention, the value 1 is used to mean "return as fast as possible."
*/
// TODO: don't hardcode this, let the application choose it
#define WANTED_MAX_DECODER_FPS (20)
#define MAX_DECODE_TIME_US (1000000 / WANTED_MAX_DECODER_FPS) // to allow x fps
/*
VPX_DL_REALTIME       (1)
deadline parameter analogous to VPx REALTIME mode.

VPX_DL_GOOD_QUALITY   (1000000)
deadline parameter analogous to VPx GOOD QUALITY mode.

VPX_DL_BEST_QUALITY   (0)
deadline parameter analogous to VPx BEST QUALITY mode.
*/

// initialize encoder with this value. Target bandwidth to use for this stream, in kilobits per second.
#define VIDEO_BITRATE_INITIAL_VALUE 180
#define VIDEO_BITRATE_INITIAL_VALUE_VP9 180

struct vpx_frame_user_data {
    uint64_t record_timestamp;
};
// ----------- COMMON STUFF -----------





// ----------- VPX  -----------
VCSession *vc_new_vpx(Logger *log, ToxAV *av, uint32_t friend_number, toxav_video_receive_frame_cb *cb, void *cb_data,
                      VCSession *vc);

int vc_reconfigure_encoder_vpx(Logger *log, VCSession *vc, uint32_t bit_rate,
                               uint16_t width, uint16_t height,
                               int16_t kf_max_dist);

void decode_frame_vpx(VCSession *vc, Tox *tox, uint8_t skip_video_flag, uint64_t *a_r_timestamp,
                      uint64_t *a_l_timestamp,
                      uint64_t *v_r_timestamp, uint64_t *v_l_timestamp,
                      const struct RTPHeader *header_v3,
                      struct RTPMessage *p, vpx_codec_err_t rc,
                      uint32_t full_data_len,
                      uint8_t *ret_value);

uint32_t encode_frame_vpx(ToxAV *av, uint32_t friend_number, uint16_t width, uint16_t height,
                          const uint8_t *y,
                          const uint8_t *u, const uint8_t *v, ToxAVCall *call,
                          uint64_t *video_frame_record_timestamp,
                          int vpx_encode_flags,
                          x264_nal_t **nal,
                          int *i_frame_size);

uint32_t send_frames_vpx(ToxAV *av, uint32_t friend_number, uint16_t width, uint16_t height,
                         const uint8_t *y,
                         const uint8_t *u, const uint8_t *v, ToxAVCall *call,
                         uint64_t *video_frame_record_timestamp,
                         int vpx_encode_flags,
                         x264_nal_t **nal,
                         int *i_frame_size,
                         TOXAV_ERR_SEND_FRAME *rc);

void vc_kill_vpx(VCSession *vc);


// ----------- H264 -----------
VCSession *vc_new_h264(Logger *log, ToxAV *av, uint32_t friend_number, toxav_video_receive_frame_cb *cb, void *cb_data,
                       VCSession *vc);

int vc_reconfigure_encoder_h264(Logger *log, VCSession *vc, uint32_t bit_rate,
                                uint16_t width, uint16_t height,
                                int16_t kf_max_dist);

void decode_frame_h264(VCSession *vc, Tox *tox, uint8_t skip_video_flag, uint64_t *a_r_timestamp,
                       uint64_t *a_l_timestamp,
                       uint64_t *v_r_timestamp, uint64_t *v_l_timestamp,
                       const struct RTPHeader *header_v3,
                       struct RTPMessage *p, vpx_codec_err_t rc,
                       uint32_t full_data_len,
                       uint8_t *ret_value);

uint32_t encode_frame_h264(ToxAV *av, uint32_t friend_number, uint16_t width, uint16_t height,
                           const uint8_t *y,
                           const uint8_t *u, const uint8_t *v, ToxAVCall *call,
                           uint64_t *video_frame_record_timestamp,
                           int vpx_encode_flags,
                           x264_nal_t **nal,
                           int *i_frame_size);

uint32_t send_frames_h264(ToxAV *av, uint32_t friend_number, uint16_t width, uint16_t height,
                          const uint8_t *y,
                          const uint8_t *u, const uint8_t *v, ToxAVCall *call,
                          uint64_t *video_frame_record_timestamp,
                          int vpx_encode_flags,
                          x264_nal_t **nal,
                          int *i_frame_size,
                          TOXAV_ERR_SEND_FRAME *rc);

void vc_kill_h264(VCSession *vc);

// ----------- H265 -----------
VCSession *vc_new_h265(Logger *log, ToxAV *av, uint32_t friend_number, toxav_video_receive_frame_cb *cb, void *cb_data,
                       VCSession *vc);

int vc_reconfigure_encoder_h265(Logger *log, VCSession *vc, uint32_t bit_rate,
                                uint16_t width, uint16_t height,
                                int16_t kf_max_dist);

void decode_frame_h265(VCSession *vc, Tox *tox, uint8_t skip_video_flag, uint64_t *a_r_timestamp,
                       uint64_t *a_l_timestamp,
                       uint64_t *v_r_timestamp, uint64_t *v_l_timestamp,
                       const struct RTPHeader *header_v3,
                       struct RTPMessage *p, vpx_codec_err_t rc,
                       uint32_t full_data_len,
                       uint8_t *ret_value);

#ifdef HAVE_H265_ENCODER
uint32_t encode_frame_h265(ToxAV *av, uint32_t friend_number, uint16_t width, uint16_t height,
                           const uint8_t *y,
                           const uint8_t *u, const uint8_t *v, ToxAVCall *call,
                           uint64_t *video_frame_record_timestamp,
                           int vpx_encode_flags,
                           int *x265_num_nals,
                           x264_nal_t **nal,
                           int *i_frame_size, x265_nal** h265_nals);

uint32_t send_frames_h265(ToxAV *av, uint32_t friend_number, uint16_t width, uint16_t height,
                          const uint8_t *y,
                          const uint8_t *u, const uint8_t *v, ToxAVCall *call,
                          uint64_t *video_frame_record_timestamp,
                          int vpx_encode_flags,
                          x264_nal_t **nal,
                          int *i_frame_size,
                          int x265_num_nals,
                          x265_nal** h265_nals,
                          TOXAV_ERR_SEND_FRAME *rc);
#endif

void vc_kill_h265(VCSession *vc);

#endif // C_TOXCORE_TOXAV_TOXAV_CODECS_H
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2020-2021 The TokTok team.
 */

/**
 * "Server side" of the DHT announcements protocol.
 */


#include <assert.h>
#include <stdlib.h>
#include <string.h>


// Settings for the shared key cache
#define MAX_KEYS_PER_SLOT 4
#define KEYS_TIMEOUT 600

uint8_t announce_response_of_request_type(uint8_t request_type)
{
    switch (request_type) {
        case NET_PACKET_DATA_SEARCH_REQUEST:
            return NET_PACKET_DATA_SEARCH_RESPONSE;

        case NET_PACKET_DATA_RETRIEVE_REQUEST:
            return NET_PACKET_DATA_RETRIEVE_RESPONSE;

        case NET_PACKET_STORE_ANNOUNCE_REQUEST:
            return NET_PACKET_STORE_ANNOUNCE_RESPONSE;

        default: {
            assert(false);
            return NET_PACKET_MAX;
        }
    }
}

typedef struct Announce_Entry {
    uint64_t store_until;
    uint8_t data_public_key[CRYPTO_PUBLIC_KEY_SIZE];
    uint8_t *data;
    uint32_t length;
} Announce_Entry;

struct Announcements {
    const Logger *log;
    const Random *rng;
    Forwarding *forwarding;
    const Mono_Time *mono_time;
    DHT *dht;
    Networking_Core *net;
    const uint8_t *public_key;
    const uint8_t *secret_key;

    Shared_Key_Cache *shared_keys;
    uint8_t hmac_key[CRYPTO_HMAC_KEY_SIZE];

    int32_t synch_offset;

    uint64_t start_time;

    Announce_Entry entries[ANNOUNCE_BUCKETS * ANNOUNCE_BUCKET_SIZE];
};

void announce_set_synch_offset(Announcements *announce, int32_t synch_offset)
{
    announce->synch_offset = synch_offset;
}

/**
 * An entry is considered to be "deleted" for the purposes of the protocol
 * once it has timed out.
 */
non_null()
static bool entry_is_empty(const Announcements *announce, const Announce_Entry *entry)
{
    return mono_time_get(announce->mono_time) >= entry->store_until;
}

non_null()
static void delete_entry(Announce_Entry *entry)
{
    entry->store_until = 0;
}

/** Return bits (at most 8) from pk starting at index as uint8_t */
non_null()
static uint8_t truncate_pk_at_index(const uint8_t *pk, uint16_t index, uint16_t bits)
{
    assert(bits < 8);
    const uint8_t i = index / 8;
    const uint8_t j = index % 8;
    return ((uint8_t)((i < CRYPTO_PUBLIC_KEY_SIZE ? pk[i] : 0) << j) >> (8 - bits)) |
           ((i + 1 < CRYPTO_PUBLIC_KEY_SIZE ? pk[i + 1] : 0) >> (16 - bits - j));
}

uint16_t announce_get_bucketnum(const uint8_t *base, const uint8_t *pk)
{
    const uint16_t index = bit_by_bit_cmp(base, pk);

    return truncate_pk_at_index(base, index + 1, ANNOUNCE_BUCKET_PREFIX_LENGTH) ^
           truncate_pk_at_index(pk, index + 1, ANNOUNCE_BUCKET_PREFIX_LENGTH);
}

non_null()
static Announce_Entry *bucket_of_key(Announcements *announce, const uint8_t *pk)
{
    return &announce->entries[announce_get_bucketnum(announce->public_key, pk) * ANNOUNCE_BUCKET_SIZE];
}

non_null()
static Announce_Entry *get_stored(Announcements *announce, const uint8_t *data_public_key)
{
    Announce_Entry *const bucket = bucket_of_key(announce, data_public_key);

    for (uint32_t i = 0; i < ANNOUNCE_BUCKET_SIZE; ++i) {
        if (pk_equal(bucket[i].data_public_key, data_public_key)) {
            if (entry_is_empty(announce, &bucket[i])) {
                break;
            }

            return &bucket[i];
        }
    }

    return nullptr;
}

non_null()
static const Announce_Entry *bucket_of_key_const(const Announcements *announce, const uint8_t *pk)
{
    return &announce->entries[announce_get_bucketnum(announce->public_key, pk) * ANNOUNCE_BUCKET_SIZE];
}

non_null()
static const Announce_Entry *get_stored_const(const Announcements *announce, const uint8_t *data_public_key)
{
    const Announce_Entry *const bucket = bucket_of_key_const(announce, data_public_key);

    for (uint32_t i = 0; i < ANNOUNCE_BUCKET_SIZE; ++i) {
        if (pk_equal(bucket[i].data_public_key, data_public_key)) {
            if (entry_is_empty(announce, &bucket[i])) {
                break;
            }

            return &bucket[i];
        }
    }

    return nullptr;
}


bool announce_on_stored(const Announcements *announce, const uint8_t *data_public_key,
                        announce_on_retrieve_cb *on_retrieve_callback, void *object)
{
    const Announce_Entry *const entry = get_stored_const(announce, data_public_key);

    if (entry == nullptr || entry->data == nullptr) {
        return false;
    }

    if (on_retrieve_callback != nullptr) {
        on_retrieve_callback(object, entry->data, entry->length);
    }

    return true;
}

/**
 * Return existing entry for this key if it exists, else an empty
 * slot in the key's bucket if one exists, else an entry in the key's bucket
 * of greatest 2-adic distance greater than that of the key bucket if one
 * exists, else nullptr.
 */
non_null()
static Announce_Entry *find_entry_slot(Announcements *announce, const uint8_t *data_public_key)
{
    Announce_Entry *const bucket = bucket_of_key(announce, data_public_key);

    Announce_Entry *slot = nullptr;
    uint16_t min_index = bit_by_bit_cmp(announce->public_key, data_public_key);

    for (uint32_t i = 0; i < ANNOUNCE_BUCKET_SIZE; ++i) {
        if (pk_equal(bucket[i].data_public_key, data_public_key)) {
            return &bucket[i];
        }

        if (entry_is_empty(announce, &bucket[i])) {
            slot = &bucket[i];
            min_index = 0;
            continue;
        }

        const uint16_t index = bit_by_bit_cmp(announce->public_key, bucket[i].data_public_key);

        if (index < min_index) {
            slot = &bucket[i];
            min_index = index;
        }
    }

    return slot;
}

non_null()
static bool would_accept_store_request(Announcements *announce, const uint8_t *data_public_key)
{
    return find_entry_slot(announce, data_public_key) != nullptr;
}

bool announce_store_data(Announcements *announce, const uint8_t *data_public_key,
                         const uint8_t *data, uint32_t length, uint32_t timeout)
{
    if (length > MAX_ANNOUNCEMENT_SIZE) {
        return false;
    }

    Announce_Entry *entry = find_entry_slot(announce, data_public_key);

    if (entry == nullptr) {
        return false;
    }

    if (length > 0) {
        assert(data != nullptr);

        if (entry->data != nullptr) {
            free(entry->data);
        }

        entry->data = (uint8_t *)malloc(length);

        if (entry->data == nullptr) {
            return false;
        }

        memcpy(entry->data, data, length);
    }

    entry->length = length;
    memcpy(entry->data_public_key, data_public_key, CRYPTO_PUBLIC_KEY_SIZE);
    entry->store_until = mono_time_get(announce->mono_time) + timeout;

    return true;
}

non_null()
static uint32_t calculate_timeout(const Announcements *announce, uint32_t requested_timeout)
{
    const uint64_t uptime = mono_time_get(announce->mono_time) - announce->start_time;
    const uint32_t max_announcement_timeout = max_u32(
                (uint32_t)min_u64(
                    MAX_MAX_ANNOUNCEMENT_TIMEOUT,
                    uptime / MAX_ANNOUNCEMENT_TIMEOUT_UPTIME_RATIO),
                MIN_MAX_ANNOUNCEMENT_TIMEOUT);

    return min_u32(max_announcement_timeout, requested_timeout);
}

#define DATA_SEARCH_TO_AUTH_MAX_SIZE (CRYPTO_PUBLIC_KEY_SIZE * 2 + MAX_PACKED_IPPORT_SIZE + MAX_SENDBACK_SIZE)

non_null(1, 2, 3, 4, 7) nullable(5)
static int create_data_search_to_auth(const Logger *logger, const uint8_t *data_public_key,
                                      const uint8_t *requester_key,
                                      const IP_Port *source, const uint8_t *sendback, uint16_t sendback_length,
                                      uint8_t *dest, uint16_t max_length)
{
    if (max_length < DATA_SEARCH_TO_AUTH_MAX_SIZE
            || sendback_length > MAX_SENDBACK_SIZE) {
        return -1;
    }

    memcpy(dest, data_public_key, CRYPTO_PUBLIC_KEY_SIZE);
    memcpy(dest + CRYPTO_PUBLIC_KEY_SIZE, requester_key, CRYPTO_PUBLIC_KEY_SIZE);

    const int ipport_length = pack_ip_port(logger, dest + CRYPTO_PUBLIC_KEY_SIZE * 2, MAX_PACKED_IPPORT_SIZE, source);

    if (ipport_length == -1) {
        return -1;
    }

    if (sendback_length > 0) {
        assert(sendback != nullptr);
        memcpy(dest + CRYPTO_PUBLIC_KEY_SIZE * 2 + ipport_length, sendback, sendback_length);
    }

    return CRYPTO_PUBLIC_KEY_SIZE * 2 + ipport_length + sendback_length;
}

#define DATA_SEARCH_TIMEOUT 60

non_null()
static int create_reply_plain_data_search_request(Announcements *announce,
        const IP_Port *source,
        const uint8_t *data, uint16_t length,
        uint8_t *reply, uint16_t reply_max_length,
        uint8_t *to_auth, uint16_t to_auth_length)
{
    if (length != CRYPTO_PUBLIC_KEY_SIZE &&
            length != CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_SHA256_SIZE) {
        return -1;
    }

    const uint8_t *const data_public_key = data;

    const uint8_t *previous_hash = nullptr;

    if (length == CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_SHA256_SIZE) {
        previous_hash = data + CRYPTO_PUBLIC_KEY_SIZE;
    }

    const int nodes_max_length = (int)reply_max_length -
                                 (CRYPTO_PUBLIC_KEY_SIZE + 1 + CRYPTO_SHA256_SIZE + TIMED_AUTH_SIZE + 1 + 1);

    if (nodes_max_length < 0) {
        return -1;
    }

    uint8_t *p = reply;

    memcpy(p, data_public_key, CRYPTO_PUBLIC_KEY_SIZE);
    p += CRYPTO_PUBLIC_KEY_SIZE;

    const Announce_Entry *const stored = get_stored_const(announce, data_public_key);

    if (stored == nullptr) {
        *p = 0;
        ++p;
    } else {
        *p = 1;
        ++p;
        crypto_sha256(p, stored->data, stored->length);
        p += CRYPTO_SHA256_SIZE;
    }

    generate_timed_auth(announce->mono_time, DATA_SEARCH_TIMEOUT, announce->hmac_key,
                        to_auth, to_auth_length, p);
    p += TIMED_AUTH_SIZE;

    *p = would_accept_store_request(announce, data_public_key);
    ++p;

    Node_format nodes_list[MAX_SENT_NODES];
    const int num_nodes = get_close_nodes(announce->dht, data_public_key, nodes_list,
                                          net_family_unspec(), ip_is_lan(&source->ip), true);

    if (num_nodes < 0 || num_nodes > MAX_SENT_NODES) {
        return -1;
    }

    *p = num_nodes;
    ++p;

    p += pack_nodes(announce->log, p, nodes_max_length, nodes_list, num_nodes);

    const uint32_t reply_len = p - reply;

    if (previous_hash != nullptr) {
        uint8_t hash[CRYPTO_SHA256_SIZE];

        crypto_sha256(hash, reply, reply_len);

        if (crypto_sha256_eq(hash, previous_hash)) {
            return CRYPTO_PUBLIC_KEY_SIZE;
        }
    }

    return reply_len;
}

non_null()
static int create_reply_plain_data_retrieve_request(Announcements *announce,
        const IP_Port *source,
        const uint8_t *data, uint16_t length,
        uint8_t *reply, uint16_t reply_max_length,
        uint8_t *to_auth, uint16_t to_auth_length)
{
    if (length != CRYPTO_PUBLIC_KEY_SIZE + 1 + TIMED_AUTH_SIZE) {
        return -1;
    }

    if (data[CRYPTO_PUBLIC_KEY_SIZE] != 0) {
        return -1;
    }

    const uint8_t *const data_public_key = data;
    const uint8_t *const auth = data + CRYPTO_PUBLIC_KEY_SIZE + 1;

    if (!check_timed_auth(announce->mono_time, DATA_SEARCH_TIMEOUT, announce->hmac_key,
                          to_auth, to_auth_length, auth)) {
        return -1;
    }

    const Announce_Entry *const entry = get_stored_const(announce, data_public_key);

    if (entry == nullptr) {
        return -1;
    }

    const uint16_t reply_len = CRYPTO_PUBLIC_KEY_SIZE + 1 + entry->length;

    if (reply_max_length < reply_len) {
        return -1;
    }

    memcpy(reply, data_public_key, CRYPTO_PUBLIC_KEY_SIZE);
    reply[CRYPTO_PUBLIC_KEY_SIZE] = 1;
    memcpy(reply + CRYPTO_PUBLIC_KEY_SIZE + 1, entry->data, entry->length);

    return reply_len;
}

non_null()
static int create_reply_plain_store_announce_request(Announcements *announce,
        const IP_Port *source,
        const uint8_t *data, uint16_t length,
        uint8_t *reply, uint16_t reply_max_length,
        uint8_t *to_auth, uint16_t to_auth_length)
{
    const int plain_len = (int)length - (CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_MAC_SIZE);
    const int announcement_len = (int)plain_len - (TIMED_AUTH_SIZE + sizeof(uint32_t) + 1);

    const uint8_t *const data_public_key = data;

    if (announcement_len < 0) {
        return -1;
    }

    VLA(uint8_t, plain, plain_len);

    const uint8_t* shared_key = shared_key_cache_lookup(announce->shared_keys, data_public_key);

    if (shared_key == nullptr) {
        /* Error looking up/deriving the shared key */
        return -1;
    }

    if (decrypt_data_symmetric(shared_key,
                               data + CRYPTO_PUBLIC_KEY_SIZE,
                               data + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE,
                               plain_len + CRYPTO_MAC_SIZE,
                               plain) != plain_len) {
        return -1;
    }

    const uint8_t *const auth = plain;
    uint32_t requested_timeout;
    net_unpack_u32(plain + TIMED_AUTH_SIZE, &requested_timeout);
    const uint32_t timeout = calculate_timeout(announce, requested_timeout);
    const uint8_t announcement_type = plain[TIMED_AUTH_SIZE + sizeof(uint32_t)];
    const uint8_t *announcement = plain + TIMED_AUTH_SIZE + sizeof(uint32_t) + 1;

    if (!check_timed_auth(announce->mono_time, DATA_SEARCH_TIMEOUT, announce->hmac_key,
                          to_auth, to_auth_length, auth)) {
        return -1;
    }

    if (announcement_type > 1) {
        return -1;
    }

    if (announcement_type == 1) {
        if (announcement_len != CRYPTO_SHA256_SIZE) {
            return -1;
        }

        Announce_Entry *stored = get_stored(announce, data_public_key);

        if (stored == nullptr) {
            return -1;
        }

        uint8_t stored_hash[CRYPTO_SHA256_SIZE];
        crypto_sha256(stored_hash, stored->data, stored->length);

        if (!crypto_sha256_eq(announcement, stored_hash)) {
            delete_entry(stored);
            return -1;
        } else {
            stored->store_until = mono_time_get(announce->mono_time) + timeout;
        }
    } else {
        if (!announce_store_data(announce, data_public_key, announcement, announcement_len, timeout)) {
            return -1;
        }
    }

    const uint16_t reply_len = CRYPTO_PUBLIC_KEY_SIZE + sizeof(uint32_t) + sizeof(uint64_t);

    if (reply_max_length < reply_len) {
        return -1;
    }

    memcpy(reply, data_public_key, CRYPTO_PUBLIC_KEY_SIZE);
    net_pack_u32(reply + CRYPTO_PUBLIC_KEY_SIZE, timeout);
    net_pack_u64(reply + CRYPTO_PUBLIC_KEY_SIZE + sizeof(uint32_t),
                 mono_time_get(announce->mono_time) + announce->synch_offset);
    return reply_len;
}

non_null(1, 2, 3, 7, 9) nullable(5)
static int create_reply_plain(Announcements *announce,
                              const uint8_t *requester_key, const IP_Port *source, uint8_t type,
                              const uint8_t *sendback, uint16_t sendback_length,
                              const uint8_t *data, uint16_t length,
                              uint8_t *reply, uint16_t reply_max_length)
{
    if (length < CRYPTO_PUBLIC_KEY_SIZE) {
        return -1;
    }

    const uint8_t *const data_public_key = data;

    uint8_t to_auth[DATA_SEARCH_TO_AUTH_MAX_SIZE];
    const int to_auth_length = create_data_search_to_auth(announce->log, data_public_key, requester_key, source,
                               sendback, sendback_length, to_auth, DATA_SEARCH_TO_AUTH_MAX_SIZE);

    if (to_auth_length == -1) {
        return -1;
    }

    switch (type) {
        case NET_PACKET_DATA_SEARCH_REQUEST:
            return create_reply_plain_data_search_request(announce, source, data, length, reply, reply_max_length, to_auth,
                    (uint16_t)to_auth_length);

        case NET_PACKET_DATA_RETRIEVE_REQUEST:
            return create_reply_plain_data_retrieve_request(announce, source, data, length, reply, reply_max_length, to_auth,
                    (uint16_t)to_auth_length);

        case NET_PACKET_STORE_ANNOUNCE_REQUEST:
            return create_reply_plain_store_announce_request(announce, source, data, length, reply, reply_max_length, to_auth,
                    (uint16_t)to_auth_length);

        default:
            return -1;
    }
}

non_null(1, 2, 5, 7) nullable(3)
static int create_reply(Announcements *announce, const IP_Port *source,
                        const uint8_t *sendback, uint16_t sendback_length,
                        const uint8_t *data, uint16_t length,
                        uint8_t *reply, uint16_t reply_max_length)
{
    const int plain_len = (int)length - (1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_MAC_SIZE);

    if (plain_len < (int)sizeof(uint64_t)) {
        return -1;
    }

    VLA(uint8_t, plain, plain_len);
    const uint8_t *shared_key = dht_get_shared_key_recv(announce->dht, data + 1);

    if (decrypt_data_symmetric(shared_key,
                               data + 1 + CRYPTO_PUBLIC_KEY_SIZE,
                               data + 1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE,
                               plain_len + CRYPTO_MAC_SIZE,
                               plain) != plain_len) {
        return -1;
    }

    const int plain_reply_max_len = (int)reply_max_length -
                                    (1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_MAC_SIZE);

    if (plain_reply_max_len < sizeof(uint64_t)) {
        return -1;
    }

    VLA(uint8_t, plain_reply, plain_reply_max_len);

    const int plain_reply_noping_len = create_reply_plain(announce,
                                       data + 1, source, data[0],
                                       sendback, sendback_length,
                                       plain, plain_len - sizeof(uint64_t),
                                       plain_reply, plain_reply_max_len - sizeof(uint64_t));

    if (plain_reply_noping_len == -1) {
        return -1;
    }

    memcpy(plain_reply + plain_reply_noping_len,
           plain + (plain_len - sizeof(uint64_t)), sizeof(uint64_t));

    const uint16_t plain_reply_len = plain_reply_noping_len + sizeof(uint64_t);

    const uint8_t response_type = announce_response_of_request_type(data[0]);

    return dht_create_packet(announce->rng, announce->public_key, shared_key, response_type,
                             plain_reply, plain_reply_len, reply, reply_max_length);
}

non_null(1, 2, 3, 5) nullable(7)
static void forwarded_request_callback(void *object, const IP_Port *forwarder,
                                       const uint8_t *sendback, uint16_t sendback_length,
                                       const uint8_t *data, uint16_t length, void *userdata)
{
    Announcements *announce = (Announcements *) object;

    uint8_t reply[MAX_FORWARD_DATA_SIZE];

    const int len = create_reply(announce, forwarder,
                                 sendback, sendback_length,
                                 data, length, reply, sizeof(reply));

    if (len == -1) {
        return;
    }

    forward_reply(announce->net, forwarder, sendback, sendback_length, reply, len);
}

non_null(1, 2, 3) nullable(5)
static int handle_dht_announce_request(void *object, const IP_Port *source,
                                       const uint8_t *data, uint16_t length, void *userdata)
{
    Announcements *announce = (Announcements *) object;

    uint8_t reply[MAX_FORWARD_DATA_SIZE];

    const int len = create_reply(announce, source,
                                 nullptr, 0,
                                 data, length, reply, sizeof(reply));

    if (len == -1) {
        return -1;
    }

    return sendpacket(announce->net, source, reply, len) == len ? 0 : -1;
}

Announcements *new_announcements(const Logger *log, const Random *rng, const Mono_Time *mono_time,
                                 Forwarding *forwarding)
{
    if (log == nullptr || mono_time == nullptr || forwarding == nullptr) {
        return nullptr;
    }

    Announcements *announce = (Announcements *)calloc(1, sizeof(Announcements));

    if (announce == nullptr) {
        return nullptr;
    }

    announce->log = log;
    announce->rng = rng;
    announce->forwarding = forwarding;
    announce->mono_time = mono_time;
    announce->dht = forwarding_get_dht(forwarding);
    announce->net = dht_get_net(announce->dht);
    announce->public_key = dht_get_self_public_key(announce->dht);
    announce->secret_key = dht_get_self_secret_key(announce->dht);
    new_hmac_key(announce->rng, announce->hmac_key);
    announce->shared_keys = shared_key_cache_new(mono_time, announce->secret_key, KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
    if (announce->shared_keys == nullptr) {
        free(announce);
        return nullptr;
    }

    announce->start_time = mono_time_get(announce->mono_time);

    set_callback_forwarded_request(forwarding, forwarded_request_callback, announce);

    networking_registerhandler(announce->net, NET_PACKET_DATA_SEARCH_REQUEST, handle_dht_announce_request, announce);
    networking_registerhandler(announce->net, NET_PACKET_DATA_RETRIEVE_REQUEST, handle_dht_announce_request, announce);
    networking_registerhandler(announce->net, NET_PACKET_STORE_ANNOUNCE_REQUEST, handle_dht_announce_request, announce);

    return announce;
}

void kill_announcements(Announcements *announce)
{
    if (announce == nullptr) {
        return;
    }

    set_callback_forwarded_request(announce->forwarding, nullptr, nullptr);

    networking_registerhandler(announce->net, NET_PACKET_DATA_SEARCH_REQUEST, nullptr, nullptr);
    networking_registerhandler(announce->net, NET_PACKET_DATA_RETRIEVE_REQUEST, nullptr, nullptr);
    networking_registerhandler(announce->net, NET_PACKET_STORE_ANNOUNCE_REQUEST, nullptr, nullptr);

    crypto_memzero(announce->hmac_key, CRYPTO_HMAC_KEY_SIZE);
    shared_key_cache_free(announce->shared_keys);

    for (uint32_t i = 0; i < ANNOUNCE_BUCKETS * ANNOUNCE_BUCKET_SIZE; ++i) {
        if (announce->entries[i].data != nullptr) {
            free(announce->entries[i].data);
        }
    }

    free(announce);
}
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2022 The TokTok team.
 */


#include <assert.h>
#include <stdlib.h>
#include <string.h>


struct Bin_Pack {
    uint8_t *bytes;
    uint32_t bytes_size;
    uint32_t bytes_pos;
    cmp_ctx_t ctx;
};

non_null()
static bool null_reader(cmp_ctx_t *ctx, void *data, size_t limit)
{
    assert(limit == 0);
    return false;
}

non_null()
static bool null_skipper(cmp_ctx_t *ctx, size_t limit)
{
    assert(limit == 0);
    return false;
}

non_null()
static size_t buf_writer(cmp_ctx_t *ctx, const void *data, size_t count)
{
    Bin_Pack *bp = (Bin_Pack *)ctx->buf;
    assert(bp != nullptr);
    const uint32_t new_pos = bp->bytes_pos + count;
    if (new_pos < bp->bytes_pos) {
        // 32 bit overflow.
        return 0;
    }
    if (bp->bytes != nullptr) {
        if (new_pos > bp->bytes_size) {
            // Buffer too small.
            return 0;
        }
        memcpy(bp->bytes + bp->bytes_pos, data, count);
    }
    bp->bytes_pos += count;
    return count;
}

non_null(1) nullable(2)
static void bin_pack_init(Bin_Pack *bp, uint8_t *buf, uint32_t buf_size)
{
    bp->bytes = buf;
    bp->bytes_size = buf_size;
    bp->bytes_pos = 0;
    cmp_init(&bp->ctx, bp, null_reader, null_skipper, buf_writer);
}

bool bin_pack_obj(bin_pack_cb *callback, const void *obj, uint8_t *buf, uint32_t buf_size)
{
    Bin_Pack bp;
    bin_pack_init(&bp, buf, buf_size);
    return callback(&bp, obj);
}

uint32_t bin_pack_obj_size(bin_pack_cb *callback, const void *obj)
{
    Bin_Pack bp;
    bin_pack_init(&bp, nullptr, 0);
    callback(&bp, obj);
    return bp.bytes_pos;
}

Bin_Pack *bin_pack_new(uint8_t *buf, uint32_t buf_size)
{
    Bin_Pack *bp = (Bin_Pack *)calloc(1, sizeof(Bin_Pack));
    if (bp == nullptr) {
        return nullptr;
    }
    bin_pack_init(bp, buf, buf_size);
    return bp;
}

void bin_pack_free(Bin_Pack *bp)
{
    free(bp);
}

bool bin_pack_array(Bin_Pack *bp, uint32_t size)
{
    return cmp_write_array(&bp->ctx, size);
}

bool bin_pack_bool(Bin_Pack *bp, bool val)
{
    return cmp_write_bool(&bp->ctx, val);
}

bool bin_pack_u08(Bin_Pack *bp, uint8_t val)
{
    return cmp_write_uinteger(&bp->ctx, val);
}

bool bin_pack_u16(Bin_Pack *bp, uint16_t val)
{
    return cmp_write_uinteger(&bp->ctx, val);
}

bool bin_pack_u32(Bin_Pack *bp, uint32_t val)
{
    return cmp_write_uinteger(&bp->ctx, val);
}

bool bin_pack_u64(Bin_Pack *bp, uint64_t val)
{
    return cmp_write_uinteger(&bp->ctx, val);
}

bool bin_pack_bin(Bin_Pack *bp, const uint8_t *data, uint32_t length)
{
    return cmp_write_bin(&bp->ctx, data, length);
}

bool bin_pack_nil(Bin_Pack *bp)
{
    return cmp_write_nil(&bp->ctx);
}

bool bin_pack_bin_marker(Bin_Pack *bp, uint32_t size)
{
    return cmp_write_bin_marker(&bp->ctx, size);
}

bool bin_pack_u08_b(Bin_Pack *bp, uint8_t val)
{
    return bp->ctx.write(&bp->ctx, &val, 1) == 1;
}

bool bin_pack_u16_b(Bin_Pack *bp, uint16_t val)
{
    return bin_pack_u08_b(bp, (val >> 8) & 0xff)
           && bin_pack_u08_b(bp, val & 0xff);
}

bool bin_pack_u32_b(Bin_Pack *bp, uint32_t val)
{
    return bin_pack_u16_b(bp, (val >> 16) & 0xffff)
           && bin_pack_u16_b(bp, val & 0xffff);
}

bool bin_pack_u64_b(Bin_Pack *bp, uint64_t val)
{
    return bin_pack_u32_b(bp, (val >> 32) & 0xffffffff)
           && bin_pack_u32_b(bp, val & 0xffffffff);
}

bool bin_pack_bin_b(Bin_Pack *bp, const uint8_t *data, uint32_t length)
{
    return bp->ctx.write(&bp->ctx, data, length) == length;
}

/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2022 The TokTok team.
 */


#include <assert.h>
#include <stdlib.h>
#include <string.h>


struct Bin_Unpack {
    const uint8_t *bytes;
    uint32_t bytes_size;
    cmp_ctx_t ctx;
};

non_null()
static bool buf_reader(cmp_ctx_t *ctx, void *data, size_t limit)
{
    Bin_Unpack *reader = (Bin_Unpack *)ctx->buf;
    assert(reader != nullptr && reader->bytes != nullptr);
    if (limit > reader->bytes_size) {
        return false;
    }
    memcpy(data, reader->bytes, limit);
    reader->bytes += limit;
    reader->bytes_size -= limit;
    return true;
}

non_null()
static bool buf_skipper(cmp_ctx_t *ctx, size_t limit)
{
    Bin_Unpack *reader = (Bin_Unpack *)ctx->buf;
    assert(reader != nullptr && reader->bytes != nullptr);
    if (limit > reader->bytes_size) {
        return false;
    }
    reader->bytes += limit;
    reader->bytes_size -= limit;
    return true;
}

non_null()
static size_t null_writer(cmp_ctx_t *ctx, const void *data, size_t count)
{
    assert(count == 0);
    return 0;
}

Bin_Unpack *bin_unpack_new(const uint8_t *buf, uint32_t buf_size)
{
    Bin_Unpack *bu = (Bin_Unpack *)calloc(1, sizeof(Bin_Unpack));
    if (bu == nullptr) {
        return nullptr;
    }
    bu->bytes = buf;
    bu->bytes_size = buf_size;
    cmp_init(&bu->ctx, bu, buf_reader, buf_skipper, null_writer);
    return bu;
}

void bin_unpack_free(Bin_Unpack *bu)
{
    free(bu);
}

bool bin_unpack_array(Bin_Unpack *bu, uint32_t *size)
{
    return cmp_read_array(&bu->ctx, size) && *size <= bu->bytes_size;
}

bool bin_unpack_array_fixed(Bin_Unpack *bu, uint32_t required_size)
{
    uint32_t size;
    return cmp_read_array(&bu->ctx, &size) && size == required_size;
}

bool bin_unpack_bool(Bin_Unpack *bu, bool *val)
{
    return cmp_read_bool(&bu->ctx, val);
}

bool bin_unpack_u08(Bin_Unpack *bu, uint8_t *val)
{
    return cmp_read_uchar(&bu->ctx, val);
}

bool bin_unpack_u16(Bin_Unpack *bu, uint16_t *val)
{
    return cmp_read_ushort(&bu->ctx, val);
}

bool bin_unpack_u32(Bin_Unpack *bu, uint32_t *val)
{
    return cmp_read_uint(&bu->ctx, val);
}

bool bin_unpack_u64(Bin_Unpack *bu, uint64_t *val)
{
    return cmp_read_ulong(&bu->ctx, val);
}

bool bin_unpack_nil(Bin_Unpack *bu)
{
    return cmp_read_nil(&bu->ctx);
}

bool bin_unpack_bin(Bin_Unpack *bu, uint8_t **data_ptr, uint32_t *data_length_ptr)
{
    uint32_t bin_size;
    if (!bin_unpack_bin_size(bu, &bin_size) || bin_size > bu->bytes_size) {
        // There aren't as many bytes as this bin claims to want to allocate.
        return false;
    }
    uint8_t *const data = (uint8_t *)malloc(bin_size);

    if (!bin_unpack_bin_b(bu, data, bin_size)) {
        free(data);
        return false;
    }

    *data_ptr = data;
    *data_length_ptr = bin_size;
    return true;
}

bool bin_unpack_bin_fixed(Bin_Unpack *bu, uint8_t *data, uint32_t data_length)
{
    uint32_t bin_size;
    if (!bin_unpack_bin_size(bu, &bin_size) || bin_size != data_length) {
        return false;
    }

    return bin_unpack_bin_b(bu, data, bin_size);
}

bool bin_unpack_bin_size(Bin_Unpack *bu, uint32_t *size)
{
    return cmp_read_bin_size(&bu->ctx, size);
}

bool bin_unpack_u08_b(Bin_Unpack *bu, uint8_t *val)
{
    return bin_unpack_bin_b(bu, val, 1);
}

bool bin_unpack_u16_b(Bin_Unpack *bu, uint16_t *val)
{
    uint8_t hi = 0;
    uint8_t lo = 0;
    if (!(bin_unpack_u08_b(bu, &hi)
          && bin_unpack_u08_b(bu, &lo))) {
        return false;
    }
    *val = ((uint16_t)hi << 8) | lo;
    return true;
}

bool bin_unpack_u32_b(Bin_Unpack *bu, uint32_t *val)
{
    uint16_t hi = 0;
    uint16_t lo = 0;
    if (!(bin_unpack_u16_b(bu, &hi)
          && bin_unpack_u16_b(bu, &lo))) {
        return false;
    }
    *val = ((uint32_t)hi << 16) | lo;
    return true;
}

bool bin_unpack_u64_b(Bin_Unpack *bu, uint64_t *val)
{
    uint32_t hi = 0;
    uint32_t lo = 0;
    if (!(bin_unpack_u32_b(bu, &hi)
          && bin_unpack_u32_b(bu, &lo))) {
        return false;
    }
    *val = ((uint64_t)hi << 32) | lo;
    return true;
}

bool bin_unpack_bin_b(Bin_Unpack *bu, uint8_t *data, uint32_t length)
{
    return bu->ctx.read(&bu->ctx, data, length);
}
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2022 The TokTok team.
 */
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2018 The TokTok team.
 * Copyright © 2013 Tox project.
 */

/**
 * Functions for the core crypto.
 *
 * NOTE: This code has to be perfect. We don't mess around with encryption.
 */

#include <assert.h>
#include <stdlib.h>
#include <string.h>

#ifndef VANILLA_NACL
// We use libsodium by default.
#include <sodium.h>
#else
#include <crypto_auth.h>
#include <crypto_box.h>
#include <crypto_hash_sha256.h>
#include <crypto_hash_sha512.h>
#include <crypto_scalarmult_curve25519.h>
#include <crypto_verify_16.h>
#include <crypto_verify_32.h>
#include <randombytes.h>
#endif


#ifndef crypto_box_MACBYTES
#define crypto_box_MACBYTES (crypto_box_ZEROBYTES - crypto_box_BOXZEROBYTES)
#endif

#ifndef VANILLA_NACL
// Need dht because of ENC_SECRET_KEY_SIZE and ENC_PUBLIC_KEY_SIZE
#define ENC_PUBLIC_KEY_SIZE CRYPTO_PUBLIC_KEY_SIZE
#define ENC_SECRET_KEY_SIZE CRYPTO_SECRET_KEY_SIZE
#endif

static_assert(CRYPTO_PUBLIC_KEY_SIZE == crypto_box_PUBLICKEYBYTES,
              "CRYPTO_PUBLIC_KEY_SIZE should be equal to crypto_box_PUBLICKEYBYTES");
static_assert(CRYPTO_SECRET_KEY_SIZE == crypto_box_SECRETKEYBYTES,
              "CRYPTO_SECRET_KEY_SIZE should be equal to crypto_box_SECRETKEYBYTES");
static_assert(CRYPTO_SHARED_KEY_SIZE == crypto_box_BEFORENMBYTES,
              "CRYPTO_SHARED_KEY_SIZE should be equal to crypto_box_BEFORENMBYTES");
static_assert(CRYPTO_SYMMETRIC_KEY_SIZE == crypto_box_BEFORENMBYTES,
              "CRYPTO_SYMMETRIC_KEY_SIZE should be equal to crypto_box_BEFORENMBYTES");
static_assert(CRYPTO_MAC_SIZE == crypto_box_MACBYTES,
              "CRYPTO_MAC_SIZE should be equal to crypto_box_MACBYTES");
static_assert(CRYPTO_NONCE_SIZE == crypto_box_NONCEBYTES,
              "CRYPTO_NONCE_SIZE should be equal to crypto_box_NONCEBYTES");
static_assert(CRYPTO_HMAC_SIZE == crypto_auth_BYTES,
              "CRYPTO_HMAC_SIZE should be equal to crypto_auth_BYTES");
static_assert(CRYPTO_HMAC_KEY_SIZE == crypto_auth_KEYBYTES,
              "CRYPTO_HMAC_KEY_SIZE should be equal to crypto_auth_KEYBYTES");
static_assert(CRYPTO_SHA256_SIZE == crypto_hash_sha256_BYTES,
              "CRYPTO_SHA256_SIZE should be equal to crypto_hash_sha256_BYTES");
static_assert(CRYPTO_SHA512_SIZE == crypto_hash_sha512_BYTES,
              "CRYPTO_SHA512_SIZE should be equal to crypto_hash_sha512_BYTES");
static_assert(CRYPTO_PUBLIC_KEY_SIZE == 32,
              "CRYPTO_PUBLIC_KEY_SIZE is required to be 32 bytes for pk_equal to work");

#ifndef VANILLA_NACL
static_assert(CRYPTO_SIGNATURE_SIZE == crypto_sign_BYTES,
              "CRYPTO_SIGNATURE_SIZE should be equal to crypto_sign_BYTES");
static_assert(CRYPTO_SIGN_PUBLIC_KEY_SIZE == crypto_sign_PUBLICKEYBYTES,
              "CRYPTO_SIGN_PUBLIC_KEY_SIZE should be equal to crypto_sign_PUBLICKEYBYTES");
static_assert(CRYPTO_SIGN_SECRET_KEY_SIZE == crypto_sign_SECRETKEYBYTES,
              "CRYPTO_SIGN_SECRET_KEY_SIZE should be equal to crypto_sign_SECRETKEYBYTES");
#endif /* VANILLA_NACL */

bool create_extended_keypair(uint8_t *pk, uint8_t *sk)
{
#ifdef VANILLA_NACL
    return false;
#else
    /* create signature key pair */
    crypto_sign_keypair(pk + ENC_PUBLIC_KEY_SIZE, sk + ENC_SECRET_KEY_SIZE);

    /* convert public signature key to public encryption key */
    const int res1 = crypto_sign_ed25519_pk_to_curve25519(pk, pk + ENC_PUBLIC_KEY_SIZE);

    /* convert secret signature key to secret encryption key */
    const int res2 = crypto_sign_ed25519_sk_to_curve25519(sk, sk + ENC_SECRET_KEY_SIZE);

    return res1 == 0 && res2 == 0;
#endif
}

const uint8_t *get_enc_key(const uint8_t *key)
{
    return key;
}

const uint8_t *get_sig_pk(const uint8_t *key)
{
    return key + ENC_PUBLIC_KEY_SIZE;
}

void set_sig_pk(uint8_t *key, const uint8_t *sig_pk)
{
    memcpy(key + ENC_PUBLIC_KEY_SIZE, sig_pk, SIG_PUBLIC_KEY_SIZE);
}

const uint8_t *get_sig_sk(const uint8_t *key)
{
    return key + ENC_SECRET_KEY_SIZE;
}

const uint8_t *get_chat_id(const uint8_t *key)
{
    return key + ENC_PUBLIC_KEY_SIZE;
}

#if !defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION)
static uint8_t *crypto_malloc(size_t bytes)
{
    uint8_t *ptr = (uint8_t *)malloc(bytes);

    if (ptr != nullptr) {
        crypto_memlock(ptr, bytes);
    }

    return ptr;
}

nullable(1)
static void crypto_free(uint8_t *ptr, size_t bytes)
{
    if (ptr != nullptr) {
        crypto_memzero(ptr, bytes);
        crypto_memunlock(ptr, bytes);
    }

    free(ptr);
}
#endif  // !defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION)

void crypto_memzero(void *data, size_t length)
{
#if defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION) || defined(VANILLA_NACL)
    memset(data, 0, length);
#else
    sodium_memzero(data, length);
#endif
}

bool crypto_memlock(void *data, size_t length)
{
#if defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION) || defined(VANILLA_NACL)
    return false;
#else

    if (sodium_mlock(data, length) != 0) {
        return false;
    }

    return true;
#endif
}

bool crypto_memunlock(void *data, size_t length)
{
#if defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION) || defined(VANILLA_NACL)
    return false;
#else

    if (sodium_munlock(data, length) != 0) {
        return false;
    }

    return true;
#endif
}

bool pk_equal(const uint8_t *pk1, const uint8_t *pk2)
{
#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
    // Hope that this is better for the fuzzer
    return memcmp(pk1, pk2, CRYPTO_PUBLIC_KEY_SIZE) == 0;
#else
    return crypto_verify_32(pk1, pk2) == 0;
#endif
}

void pk_copy(uint8_t *dest, const uint8_t *src)
{
    memcpy(dest, src, CRYPTO_PUBLIC_KEY_SIZE);
}

bool crypto_sha512_eq(const uint8_t *cksum1, const uint8_t *cksum2)
{
#if defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION)
    // Hope that this is better for the fuzzer
    return memcmp(cksum1, cksum2, CRYPTO_SHA512_SIZE) == 0;
#elif defined(VANILLA_NACL)
    const int lo = crypto_verify_32(cksum1, cksum2) == 0 ? 1 : 0;
    const int hi = crypto_verify_32(cksum1 + 8, cksum2 + 8) == 0 ? 1 : 0;
    return (lo & hi) == 1;
#else
    return crypto_verify_64(cksum1, cksum2) == 0;
#endif
}

bool crypto_sha256_eq(const uint8_t *cksum1, const uint8_t *cksum2)
{
#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
    // Hope that this is better for the fuzzer
    return memcmp(cksum1, cksum2, CRYPTO_SHA256_SIZE) == 0;
#else
    return crypto_verify_32(cksum1, cksum2) == 0;
#endif
}

uint8_t random_u08(const Random *rng)
{
    uint8_t randnum;
    random_bytes(rng, &randnum, 1);
    return randnum;
}

uint16_t random_u16(const Random *rng)
{
    uint16_t randnum;
    random_bytes(rng, (uint8_t *)&randnum, sizeof(randnum));
    return randnum;
}

uint32_t random_u32(const Random *rng)
{
    uint32_t randnum;
    random_bytes(rng, (uint8_t *)&randnum, sizeof(randnum));
    return randnum;
}

uint64_t random_u64(const Random *rng)
{
    uint64_t randnum;
    random_bytes(rng, (uint8_t *)&randnum, sizeof(randnum));
    return randnum;
}

uint32_t random_range_u32(const Random *rng, uint32_t upper_bound)
{
    return rng->funcs->random_uniform(rng->obj, upper_bound);
}

bool crypto_signature_create(uint8_t *signature, const uint8_t *message, uint64_t message_length,
                             const uint8_t *secret_key)
{
#ifdef VANILLA_NACL
    return false;
#else
    return crypto_sign_detached(signature, nullptr, message, message_length, secret_key) == 0;
#endif // VANILLA_NACL
}

bool crypto_signature_verify(const uint8_t *signature, const uint8_t *message, uint64_t message_length,
                             const uint8_t *public_key)
{
#ifdef VANILLA_NACL
    return false;
#else
    return crypto_sign_verify_detached(signature, message, message_length, public_key) == 0;
#endif
}

bool public_key_valid(const uint8_t *public_key)
{
    /* Last bit of key is always zero. */
    return public_key[31] < 128;
}

int32_t encrypt_precompute(const uint8_t *public_key, const uint8_t *secret_key,
                           uint8_t *shared_key)
{
#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
    memcpy(shared_key, public_key, CRYPTO_SHARED_KEY_SIZE);
    return 0;
#else
    return crypto_box_beforenm(shared_key, public_key, secret_key);
#endif
}

int32_t encrypt_data_symmetric(const uint8_t *shared_key, const uint8_t *nonce,
                               const uint8_t *plain, size_t length, uint8_t *encrypted)
{
    if (length == 0 || shared_key == nullptr || nonce == nullptr || plain == nullptr || encrypted == nullptr) {
        return -1;
    }

#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
    // Don't encrypt anything.
    memcpy(encrypted, plain, length);
    // Zero MAC to avoid uninitialized memory reads.
    memset(encrypted + length, 0, crypto_box_MACBYTES);
#else

    const size_t size_temp_plain = length + crypto_box_ZEROBYTES;
    const size_t size_temp_encrypted = length + crypto_box_MACBYTES + crypto_box_BOXZEROBYTES;

    uint8_t *temp_plain = crypto_malloc(size_temp_plain);
    uint8_t *temp_encrypted = crypto_malloc(size_temp_encrypted);

    if (temp_plain == nullptr || temp_encrypted == nullptr) {
        crypto_free(temp_plain, size_temp_plain);
        crypto_free(temp_encrypted, size_temp_encrypted);
        return -1;
    }

    // crypto_box_afternm requires the entire range of the output array be
    // initialised with something. It doesn't matter what it's initialised with,
    // so we'll pick 0x00.
    memset(temp_encrypted, 0, size_temp_encrypted);

    memset(temp_plain, 0, crypto_box_ZEROBYTES);
    // Pad the message with 32 0 bytes.
    memcpy(temp_plain + crypto_box_ZEROBYTES, plain, length);

    if (crypto_box_afternm(temp_encrypted, temp_plain, length + crypto_box_ZEROBYTES, nonce,
                           shared_key) != 0) {
        crypto_free(temp_plain, size_temp_plain);
        crypto_free(temp_encrypted, size_temp_encrypted);
        return -1;
    }

    // Unpad the encrypted message.
    memcpy(encrypted, temp_encrypted + crypto_box_BOXZEROBYTES, length + crypto_box_MACBYTES);

    crypto_free(temp_plain, size_temp_plain);
    crypto_free(temp_encrypted, size_temp_encrypted);
#endif
    assert(length < INT32_MAX - crypto_box_MACBYTES);
    return (int32_t)(length + crypto_box_MACBYTES);
}

int32_t decrypt_data_symmetric(const uint8_t *shared_key, const uint8_t *nonce,
                               const uint8_t *encrypted, size_t length, uint8_t *plain)
{
    if (length <= crypto_box_BOXZEROBYTES || shared_key == nullptr || nonce == nullptr || encrypted == nullptr
            || plain == nullptr) {
        return -1;
    }

#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
    assert(length >= crypto_box_MACBYTES);
    memcpy(plain, encrypted, length - crypto_box_MACBYTES);  // Don't encrypt anything
#else

    const size_t size_temp_plain = length + crypto_box_ZEROBYTES;
    const size_t size_temp_encrypted = length + crypto_box_BOXZEROBYTES;

    uint8_t *temp_plain = crypto_malloc(size_temp_plain);
    uint8_t *temp_encrypted = crypto_malloc(size_temp_encrypted);

    if (temp_plain == nullptr || temp_encrypted == nullptr) {
        crypto_free(temp_plain, size_temp_plain);
        crypto_free(temp_encrypted, size_temp_encrypted);
        return -1;
    }

    // crypto_box_open_afternm requires the entire range of the output array be
    // initialised with something. It doesn't matter what it's initialised with,
    // so we'll pick 0x00.
    memset(temp_plain, 0, size_temp_plain);

    memset(temp_encrypted, 0, crypto_box_BOXZEROBYTES);
    // Pad the message with 16 0 bytes.
    memcpy(temp_encrypted + crypto_box_BOXZEROBYTES, encrypted, length);

    if (crypto_box_open_afternm(temp_plain, temp_encrypted, length + crypto_box_BOXZEROBYTES, nonce,
                                shared_key) != 0) {
        crypto_free(temp_plain, size_temp_plain);
        crypto_free(temp_encrypted, size_temp_encrypted);
        return -1;
    }

    memcpy(plain, temp_plain + crypto_box_ZEROBYTES, length - crypto_box_MACBYTES);

    crypto_free(temp_plain, size_temp_plain);
    crypto_free(temp_encrypted, size_temp_encrypted);
#endif
    assert(length > crypto_box_MACBYTES);
    assert(length < INT32_MAX);
    return (int32_t)(length - crypto_box_MACBYTES);
}

int32_t encrypt_data(const uint8_t *public_key, const uint8_t *secret_key, const uint8_t *nonce,
                     const uint8_t *plain, size_t length, uint8_t *encrypted)
{
    if (public_key == nullptr || secret_key == nullptr) {
        return -1;
    }

    uint8_t k[crypto_box_BEFORENMBYTES];
    encrypt_precompute(public_key, secret_key, k);
    const int ret = encrypt_data_symmetric(k, nonce, plain, length, encrypted);
    crypto_memzero(k, sizeof(k));
    return ret;
}

int32_t decrypt_data(const uint8_t *public_key, const uint8_t *secret_key, const uint8_t *nonce,
                     const uint8_t *encrypted, size_t length, uint8_t *plain)
{
    if (public_key == nullptr || secret_key == nullptr) {
        return -1;
    }

    uint8_t k[crypto_box_BEFORENMBYTES];
    encrypt_precompute(public_key, secret_key, k);
    const int ret = decrypt_data_symmetric(k, nonce, encrypted, length, plain);
    crypto_memzero(k, sizeof(k));
    return ret;
}

void increment_nonce(uint8_t *nonce)
{
    /* TODO(irungentoo): use `increment_nonce_number(nonce, 1)` or
     * sodium_increment (change to little endian).
     *
     * NOTE don't use breaks inside this loop.
     * In particular, make sure, as far as possible,
     * that loop bounds and their potential underflow or overflow
     * are independent of user-controlled input (you may have heard of the Heartbleed bug).
     */
    uint_fast16_t carry = 1U;

    for (uint32_t i = crypto_box_NONCEBYTES; i != 0; --i) {
        carry += (uint_fast16_t)nonce[i - 1];
        nonce[i - 1] = (uint8_t)carry;
        carry >>= 8;
    }
}

void increment_nonce_number(uint8_t *nonce, uint32_t increment)
{
    /* NOTE don't use breaks inside this loop
     * In particular, make sure, as far as possible,
     * that loop bounds and their potential underflow or overflow
     * are independent of user-controlled input (you may have heard of the Heartbleed bug).
     */
    uint8_t num_as_nonce[crypto_box_NONCEBYTES] = {0};
    num_as_nonce[crypto_box_NONCEBYTES - 4] = increment >> 24;
    num_as_nonce[crypto_box_NONCEBYTES - 3] = increment >> 16;
    num_as_nonce[crypto_box_NONCEBYTES - 2] = increment >> 8;
    num_as_nonce[crypto_box_NONCEBYTES - 1] = increment;

    uint_fast16_t carry = 0U;

    for (uint32_t i = crypto_box_NONCEBYTES; i != 0; --i) {
        carry += (uint_fast16_t)nonce[i - 1] + (uint_fast16_t)num_as_nonce[i - 1];
        nonce[i - 1] = (uint8_t)carry;
        carry >>= 8;
    }
}

void random_nonce(const Random *rng, uint8_t *nonce)
{
    random_bytes(rng, nonce, crypto_box_NONCEBYTES);
}

void new_symmetric_key_implicit_random(uint8_t *key)
{
    randombytes(key, CRYPTO_SYMMETRIC_KEY_SIZE);
}

void new_symmetric_key(const Random *rng, uint8_t *key)
{
    random_bytes(rng, key, CRYPTO_SYMMETRIC_KEY_SIZE);
}

int32_t crypto_new_keypair(const Random *rng, uint8_t *public_key, uint8_t *secret_key)
{
#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
    random_bytes(rng, secret_key, CRYPTO_SECRET_KEY_SIZE);
    memset(public_key, 0, CRYPTO_PUBLIC_KEY_SIZE);  // Make MSAN happy
    crypto_derive_public_key(public_key, secret_key);
    return 0;
#else
    return crypto_box_keypair(public_key, secret_key);
#endif
}

void crypto_derive_public_key(uint8_t *public_key, const uint8_t *secret_key)
{
    crypto_scalarmult_curve25519_base(public_key, secret_key);
}

void new_hmac_key(const Random *rng, uint8_t *key)
{
    random_bytes(rng, key, CRYPTO_HMAC_KEY_SIZE);
}

void crypto_hmac(uint8_t auth[CRYPTO_HMAC_SIZE], const uint8_t key[CRYPTO_HMAC_KEY_SIZE], const uint8_t *data,
                 size_t length)
{
#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
    memcpy(auth, key, 16);
    memcpy(auth + 16, data, length < 16 ? length : 16);
#else
    crypto_auth(auth, data, length, key);
#endif
}

bool crypto_hmac_verify(const uint8_t auth[CRYPTO_HMAC_SIZE], const uint8_t key[CRYPTO_HMAC_KEY_SIZE],
                        const uint8_t *data, size_t length)
{
#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
    return memcmp(auth, key, 16) == 0 && memcmp(auth + 16, data, length < 16 ? length : 16) == 0;
#else
    return crypto_auth_verify(auth, data, length, key) == 0;
#endif
}

void crypto_sha256(uint8_t *hash, const uint8_t *data, size_t length)
{
#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
    memset(hash, 0, CRYPTO_SHA256_SIZE);
    memcpy(hash, data, length < CRYPTO_SHA256_SIZE ? length : CRYPTO_SHA256_SIZE);
#else
    crypto_hash_sha256(hash, data, length);
#endif
}

void crypto_sha512(uint8_t *hash, const uint8_t *data, size_t length)
{
#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
    memset(hash, 0, CRYPTO_SHA512_SIZE);
    memcpy(hash, data, length < CRYPTO_SHA512_SIZE ? length : CRYPTO_SHA512_SIZE);
#else
    crypto_hash_sha512(hash, data, length);
#endif
}

non_null()
static void sys_random_bytes(void *obj, uint8_t *bytes, size_t length)
{
    randombytes(bytes, length);
}

non_null()
static uint32_t sys_random_uniform(void *obj, uint32_t upper_bound)
{
#ifdef VANILLA_NACL
    if (upper_bound == 0) {
        return 0;
    }

    uint32_t randnum;
    sys_random_bytes(obj, (uint8_t *)&randnum, sizeof(randnum));
    return randnum % upper_bound;
#else
    return randombytes_uniform(upper_bound);
#endif
}

static const Random_Funcs system_random_funcs = {
    sys_random_bytes,
    sys_random_uniform,
};

static const Random system_random_obj = {&system_random_funcs};

const Random *system_random(void)
{
#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
    if ((true)) {
        return nullptr;
    }
#endif
#ifndef VANILLA_NACL
    // It is safe to call this function more than once and from different
    // threads -- subsequent calls won't have any effects.
    if (sodium_init() == -1) {
        return nullptr;
    }
#endif
    return &system_random_obj;
}

void random_bytes(const Random *rng, uint8_t *bytes, size_t length)
{
    rng->funcs->random_bytes(rng->obj, bytes, length);
}
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2018 The TokTok team.
 * Copyright © 2013 Tox project.
 */

/**
 * An implementation of the DHT as seen in docs/updates/DHT.md
 */

#include <assert.h>
#include <stdlib.h>
#include <string.h>


/** The timeout after which a node is discarded completely. */
#define KILL_NODE_TIMEOUT (BAD_NODE_TIMEOUT + PING_INTERVAL)

/** Ping interval in seconds for each random sending of a get nodes request. */
#define GET_NODE_INTERVAL 20

#define MAX_PUNCHING_PORTS 48

/** Interval in seconds between punching attempts*/
#define PUNCH_INTERVAL 3

/** Time in seconds after which punching parameters will be reset */
#define PUNCH_RESET_TIME 40

#define MAX_NORMAL_PUNCHING_TRIES 5

#define NAT_PING_REQUEST    0
#define NAT_PING_RESPONSE   1

/** Number of get node requests to send to quickly find close nodes. */
#define MAX_BOOTSTRAP_TIMES 5

// TODO(sudden6): find out why we need multiple callbacks and if we really need 32
#define DHT_FRIEND_MAX_LOCKS 32

/* Settings for the shared key cache */
#define MAX_KEYS_PER_SLOT 4
#define KEYS_TIMEOUT 600

typedef struct DHT_Friend_Callback {
    dht_ip_cb *ip_callback;
    void *data;
    int32_t number;
} DHT_Friend_Callback;

struct DHT_Friend {
    uint8_t     public_key[CRYPTO_PUBLIC_KEY_SIZE];
    Client_data client_list[MAX_FRIEND_CLIENTS];

    /* Time at which the last get_nodes request was sent. */
    uint64_t    lastgetnode;
    /* number of times get_node packets were sent. */
    uint32_t    bootstrap_times;

    /* Symmetric NAT hole punching stuff. */
    NAT         nat;

    /* Each set bit represents one installed callback */
    uint32_t lock_flags;
    DHT_Friend_Callback callbacks[DHT_FRIEND_MAX_LOCKS];

    Node_format to_bootstrap[MAX_SENT_NODES];
    unsigned int num_to_bootstrap;
};

static const DHT_Friend empty_dht_friend = {{0}};
const Node_format empty_node_format = {{0}};

static_assert(sizeof (empty_dht_friend.lock_flags) * 8 == DHT_FRIEND_MAX_LOCKS, "Bitfield size and number of locks don't match");

typedef struct Cryptopacket_Handler {
    cryptopacket_handler_cb *function;
    void *object;
} Cryptopacket_Handler;

struct DHT {
    const Logger *log;
    const Network *ns;
    Mono_Time *mono_time;
    const Random *rng;
    Networking_Core *net;

    bool hole_punching_enabled;
    bool lan_discovery_enabled;

    Client_data    close_clientlist[LCLIENT_LIST];
    uint64_t       close_lastgetnodes;
    uint32_t       close_bootstrap_times;

    /* DHT keypair */
    uint8_t self_public_key[CRYPTO_PUBLIC_KEY_SIZE];
    uint8_t self_secret_key[CRYPTO_SECRET_KEY_SIZE];

    DHT_Friend    *friends_list;
    uint16_t       num_friends;

    Node_format   *loaded_nodes_list;
    uint32_t       loaded_num_nodes;
    unsigned int   loaded_nodes_index;

    Shared_Key_Cache *shared_keys_recv;
    Shared_Key_Cache *shared_keys_sent;

    struct Ping   *ping;
    Ping_Array    *dht_ping_array;
    uint64_t       cur_time;

    Cryptopacket_Handler cryptopackethandlers[256];

    Node_format to_bootstrap[MAX_CLOSE_TO_BOOTSTRAP_NODES];
    unsigned int num_to_bootstrap;

    dht_get_nodes_response_cb *get_nodes_response;
};

const uint8_t *dht_friend_public_key(const DHT_Friend *dht_friend)
{
    return dht_friend->public_key;
}

const Client_data *dht_friend_client(const DHT_Friend *dht_friend, size_t index)
{
    return &dht_friend->client_list[index];
}

const uint8_t *dht_get_self_public_key(const DHT *dht)
{
    return dht->self_public_key;
}
const uint8_t *dht_get_self_secret_key(const DHT *dht)
{
    return dht->self_secret_key;
}

void dht_set_self_public_key(DHT *dht, const uint8_t *key)
{
    memcpy(dht->self_public_key, key, CRYPTO_PUBLIC_KEY_SIZE);
}
void dht_set_self_secret_key(DHT *dht, const uint8_t *key)
{
    memcpy(dht->self_secret_key, key, CRYPTO_SECRET_KEY_SIZE);
}

Networking_Core *dht_get_net(const DHT *dht)
{
    return dht->net;
}
struct Ping *dht_get_ping(const DHT *dht)
{
    return dht->ping;
}
const Client_data *dht_get_close_clientlist(const DHT *dht)
{
    return dht->close_clientlist;
}
const Client_data *dht_get_close_client(const DHT *dht, uint32_t client_num)
{
    assert(client_num < sizeof(dht->close_clientlist) / sizeof(dht->close_clientlist[0]));
    return &dht->close_clientlist[client_num];
}
uint16_t dht_get_num_friends(const DHT *dht)
{
    return dht->num_friends;
}

DHT_Friend *dht_get_friend(DHT *dht, uint32_t friend_num)
{
    assert(friend_num < dht->num_friends);
    return &dht->friends_list[friend_num];
}
const uint8_t *dht_get_friend_public_key(const DHT *dht, uint32_t friend_num)
{
    assert(friend_num < dht->num_friends);
    return dht->friends_list[friend_num].public_key;
}

non_null()
static bool assoc_timeout(uint64_t cur_time, const IPPTsPng *assoc)
{
    return (assoc->timestamp + BAD_NODE_TIMEOUT) <= cur_time;
}

/** @brief Converts an IPv4-in-IPv6 to IPv4 and returns the new IP_Port.
 *
 * If the ip_port is already IPv4 this function returns a copy of the original ip_port.
 */
non_null()
static IP_Port ip_port_normalize(const IP_Port *ip_port)
{
    IP_Port res = *ip_port;

    if (net_family_is_ipv6(res.ip.family) && ipv6_ipv4_in_v6(&res.ip.ip.v6)) {
        res.ip.family = net_family_ipv4();
        res.ip.ip.v4.uint32 = res.ip.ip.v6.uint32[3];
    }

    return res;
}

/** @brief Compares pk1 and pk2 with pk.
 *
 * @retval 0 if both are same distance.
 * @retval 1 if pk1 is closer.
 * @retval 2 if pk2 is closer.
 */
int id_closest(const uint8_t *pk, const uint8_t *pk1, const uint8_t *pk2)
{
    for (size_t i = 0; i < CRYPTO_PUBLIC_KEY_SIZE; ++i) {
        const uint8_t distance1 = pk[i] ^ pk1[i];
        const uint8_t distance2 = pk[i] ^ pk2[i];

        if (distance1 < distance2) {
            return 1;
        }

        if (distance1 > distance2) {
            return 2;
        }
    }

    return 0;
}

/** Return index of first unequal bit number between public keys pk1 and pk2. */
unsigned int bit_by_bit_cmp(const uint8_t *pk1, const uint8_t *pk2)
{
    unsigned int i;
    unsigned int j = 0;

    for (i = 0; i < CRYPTO_PUBLIC_KEY_SIZE; ++i) {
        if (pk1[i] == pk2[i]) {
            continue;
        }

        for (j = 0; j < 8; ++j) {
            const uint8_t mask = 1 << (7 - j);

            if ((pk1[i] & mask) != (pk2[i] & mask)) {
                break;
            }
        }

        break;
    }

    return i * 8 + j;
}

/**
 * Copy shared_key to encrypt/decrypt DHT packet from public_key into shared_key
 * for packets that we receive.
 */
const uint8_t *dht_get_shared_key_recv(DHT *dht, const uint8_t *public_key)
{
    return shared_key_cache_lookup(dht->shared_keys_recv, public_key);
}

/**
 * Copy shared_key to encrypt/decrypt DHT packet from public_key into shared_key
 * for packets that we send.
 */
const uint8_t *dht_get_shared_key_sent(DHT *dht, const uint8_t *public_key)
{
    return shared_key_cache_lookup(dht->shared_keys_sent, public_key);
}

#define CRYPTO_SIZE (1 + CRYPTO_PUBLIC_KEY_SIZE * 2 + CRYPTO_NONCE_SIZE)

/**
 * @brief Create a request to peer.
 *
 * Packs the data and sender public key and encrypts the packet.
 *
 * @param[in] send_public_key public key of the sender.
 * @param[in] send_secret_key secret key of the sender.
 * @param[out] packet an array of @ref MAX_CRYPTO_REQUEST_SIZE big.
 * @param[in] recv_public_key public key of the receiver.
 * @param[in] data represents the data we send with the request.
 * @param[in] data_length the length of the data.
 * @param[in] request_id the id of the request (32 = friend request, 254 = ping request).
 *
 * @attention Constraints:
 * @code
 * sizeof(packet) >= MAX_CRYPTO_REQUEST_SIZE
 * @endcode
 *
 * @retval -1 on failure.
 * @return the length of the created packet on success.
 */
int create_request(const Random *rng, const uint8_t *send_public_key, const uint8_t *send_secret_key,
                   uint8_t *packet, const uint8_t *recv_public_key,
                   const uint8_t *data, uint32_t data_length, uint8_t request_id)
{
    if (send_public_key == nullptr || packet == nullptr || recv_public_key == nullptr || data == nullptr) {
        return -1;
    }

    if (MAX_CRYPTO_REQUEST_SIZE < data_length + CRYPTO_SIZE + 1 + CRYPTO_MAC_SIZE) {
        return -1;
    }

    uint8_t *const nonce = packet + 1 + CRYPTO_PUBLIC_KEY_SIZE * 2;
    random_nonce(rng, nonce);
    uint8_t temp[MAX_CRYPTO_REQUEST_SIZE] = {0};
    temp[0] = request_id;
    memcpy(temp + 1, data, data_length);
    const int len = encrypt_data(recv_public_key, send_secret_key, nonce, temp, data_length + 1,
                                 packet + CRYPTO_SIZE);

    if (len == -1) {
        crypto_memzero(temp, MAX_CRYPTO_REQUEST_SIZE);
        return -1;
    }

    packet[0] = NET_PACKET_CRYPTO;
    memcpy(packet + 1, recv_public_key, CRYPTO_PUBLIC_KEY_SIZE);
    memcpy(packet + 1 + CRYPTO_PUBLIC_KEY_SIZE, send_public_key, CRYPTO_PUBLIC_KEY_SIZE);

    crypto_memzero(temp, MAX_CRYPTO_REQUEST_SIZE);
    return len + CRYPTO_SIZE;
}

/**
 * @brief Decrypts and unpacks a DHT request packet.
 *
 * Puts the senders public key in the request in @p public_key, the data from
 * the request in @p data.
 *
 * @param[in] self_public_key public key of the receiver (us).
 * @param[in] self_secret_key secret key of the receiver (us).
 * @param[out] public_key public key of the sender, copied from the input packet.
 * @param[out] data decrypted request data, copied from the input packet, must
 *   have room for @ref MAX_CRYPTO_REQUEST_SIZE bytes.
 * @param[in] packet is the request packet.
 * @param[in] packet_length length of the packet.
 *
 * @attention Constraints:
 * @code
 * sizeof(data) >= MAX_CRYPTO_REQUEST_SIZE
 * @endcode
 *
 * @retval -1 if not valid request.
 * @return the length of the unpacked data.
 */
int handle_request(const uint8_t *self_public_key, const uint8_t *self_secret_key, uint8_t *public_key, uint8_t *data,
                   uint8_t *request_id, const uint8_t *packet, uint16_t packet_length)
{
    if (self_public_key == nullptr || public_key == nullptr || data == nullptr || request_id == nullptr
            || packet == nullptr) {
        return -1;
    }

    if (packet_length <= CRYPTO_SIZE + CRYPTO_MAC_SIZE || packet_length > MAX_CRYPTO_REQUEST_SIZE) {
        return -1;
    }

    if (!pk_equal(packet + 1, self_public_key)) {
        return -1;
    }

    memcpy(public_key, packet + 1 + CRYPTO_PUBLIC_KEY_SIZE, CRYPTO_PUBLIC_KEY_SIZE);
    const uint8_t *const nonce = packet + 1 + CRYPTO_PUBLIC_KEY_SIZE * 2;
    uint8_t temp[MAX_CRYPTO_REQUEST_SIZE];
    int32_t len1 = decrypt_data(public_key, self_secret_key, nonce,
                                packet + CRYPTO_SIZE, packet_length - CRYPTO_SIZE, temp);

    if (len1 == -1 || len1 == 0) {
        crypto_memzero(temp, MAX_CRYPTO_REQUEST_SIZE);
        return -1;
    }

    assert(len1 == packet_length - CRYPTO_SIZE - CRYPTO_MAC_SIZE);
    // Because coverity can't figure out this equation:
    assert(len1 <= MAX_CRYPTO_REQUEST_SIZE - CRYPTO_SIZE - CRYPTO_MAC_SIZE);

    request_id[0] = temp[0];
    --len1;
    memcpy(data, temp + 1, len1);
    crypto_memzero(temp, MAX_CRYPTO_REQUEST_SIZE);
    return len1;
}

/** @return packet size of packed node with ip_family on success.
 * @retval -1 on failure.
 */
int packed_node_size(Family ip_family)
{
    if (net_family_is_ipv4(ip_family) || net_family_is_tcp_ipv4(ip_family)) {
        return PACKED_NODE_SIZE_IP4;
    }

    if (net_family_is_ipv6(ip_family) || net_family_is_tcp_ipv6(ip_family)) {
        return PACKED_NODE_SIZE_IP6;
    }

    return -1;
}


/** @brief Pack an IP_Port structure into data of max size length.
 *
 * Packed_length is the offset of data currently packed.
 *
 * @return size of packed IP_Port data on success.
 * @retval -1 on failure.
 */
int pack_ip_port(const Logger *logger, uint8_t *data, uint16_t length, const IP_Port *ip_port)
{
    if (data == nullptr) {
        return -1;
    }

    bool is_ipv4;
    uint8_t family;

    if (net_family_is_ipv4(ip_port->ip.family)) {
        // TODO(irungentoo): use functions to convert endianness
        is_ipv4 = true;
        family = TOX_AF_INET;
    } else if (net_family_is_tcp_ipv4(ip_port->ip.family)) {
        is_ipv4 = true;
        family = TOX_TCP_INET;
    } else if (net_family_is_ipv6(ip_port->ip.family)) {
        is_ipv4 = false;
        family = TOX_AF_INET6;
    } else if (net_family_is_tcp_ipv6(ip_port->ip.family)) {
        is_ipv4 = false;
        family = TOX_TCP_INET6;
    } else {
        Ip_Ntoa ip_str;
        // TODO(iphydf): Find out why we're trying to pack invalid IPs, stop
        // doing that, and turn this into an error.
        LOGGER_TRACE(logger, "cannot pack invalid IP: %s", net_ip_ntoa(&ip_port->ip, &ip_str));
        return -1;
    }

    if (is_ipv4) {
        const uint32_t size = 1 + SIZE_IP4 + sizeof(uint16_t);

        if (size > length) {
            return -1;
        }

        data[0] = family;
        memcpy(data + 1, &ip_port->ip.ip.v4, SIZE_IP4);
        memcpy(data + 1 + SIZE_IP4, &ip_port->port, sizeof(uint16_t));
        return size;
    } else {
        const uint32_t size = 1 + SIZE_IP6 + sizeof(uint16_t);

        if (size > length) {
            return -1;
        }

        data[0] = family;
        memcpy(data + 1, &ip_port->ip.ip.v6, SIZE_IP6);
        memcpy(data + 1 + SIZE_IP6, &ip_port->port, sizeof(uint16_t));
        return size;
    }
}

/** @brief Encrypt plain and write resulting DHT packet into packet with max size length.
 *
 * @return size of packet on success.
 * @retval -1 on failure.
 */
int dht_create_packet(const Random *rng, const uint8_t public_key[CRYPTO_PUBLIC_KEY_SIZE],
                      const uint8_t *shared_key, const uint8_t type,
                      const uint8_t *plain, size_t plain_length,
                      uint8_t *packet, size_t length)
{
    uint8_t *encrypted = (uint8_t *)malloc(plain_length + CRYPTO_MAC_SIZE);
    uint8_t nonce[CRYPTO_NONCE_SIZE];

    if (encrypted == nullptr) {
        return -1;
    }

    random_nonce(rng, nonce);

    const int encrypted_length = encrypt_data_symmetric(shared_key, nonce, plain, plain_length, encrypted);

    if (encrypted_length == -1) {
        free(encrypted);
        return -1;
    }

    if (length < 1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + encrypted_length) {
        free(encrypted);
        return -1;
    }

    packet[0] = type;
    memcpy(packet + 1, public_key, CRYPTO_PUBLIC_KEY_SIZE);
    memcpy(packet + 1 + CRYPTO_PUBLIC_KEY_SIZE, nonce, CRYPTO_NONCE_SIZE);
    memcpy(packet + 1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE, encrypted, encrypted_length);

    free(encrypted);
    return 1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + encrypted_length;
}

/** @brief Unpack IP_Port structure from data of max size length into ip_port.
 *
 * len_processed is the offset of data currently unpacked.
 *
 * @return size of unpacked ip_port on success.
 * @retval -1 on failure.
 */
int unpack_ip_port(IP_Port *ip_port, const uint8_t *data, uint16_t length, bool tcp_enabled)
{
    if (data == nullptr) {
        return -1;
    }

    bool is_ipv4;
    Family host_family;

    if (data[0] == TOX_AF_INET) {
        is_ipv4 = true;
        host_family = net_family_ipv4();
    } else if (data[0] == TOX_TCP_INET) {
        if (!tcp_enabled) {
            return -1;
        }

        is_ipv4 = true;
        host_family = net_family_tcp_ipv4();
    } else if (data[0] == TOX_AF_INET6) {
        is_ipv4 = false;
        host_family = net_family_ipv6();
    } else if (data[0] == TOX_TCP_INET6) {
        if (!tcp_enabled) {
            return -1;
        }

        is_ipv4 = false;
        host_family = net_family_tcp_ipv6();
    } else {
        return -1;
    }

    *ip_port = empty_ip_port;

    if (is_ipv4) {
        const uint32_t size = 1 + SIZE_IP4 + sizeof(uint16_t);

        if (size > length) {
            return -1;
        }

        ip_port->ip.family = host_family;
        memcpy(&ip_port->ip.ip.v4, data + 1, SIZE_IP4);
        memcpy(&ip_port->port, data + 1 + SIZE_IP4, sizeof(uint16_t));
        return size;
    } else {
        const uint32_t size = 1 + SIZE_IP6 + sizeof(uint16_t);

        if (size > length) {
            return -1;
        }

        ip_port->ip.family = host_family;
        memcpy(&ip_port->ip.ip.v6, data + 1, SIZE_IP6);
        memcpy(&ip_port->port, data + 1 + SIZE_IP6, sizeof(uint16_t));
        return size;
    }
}

/** @brief Pack number of nodes into data of maxlength length.
 *
 * @return length of packed nodes on success.
 * @retval -1 on failure.
 */
int pack_nodes(const Logger *logger, uint8_t *data, uint16_t length, const Node_format *nodes, uint16_t number)
{
    uint32_t packed_length = 0;

    for (uint32_t i = 0; i < number && packed_length < length; ++i) {
        const int ipp_size = pack_ip_port(logger, data + packed_length, length - packed_length, &nodes[i].ip_port);

        if (ipp_size == -1) {
            return -1;
        }

        packed_length += ipp_size;

        if (packed_length + CRYPTO_PUBLIC_KEY_SIZE > length) {
            return -1;
        }

        memcpy(data + packed_length, nodes[i].public_key, CRYPTO_PUBLIC_KEY_SIZE);
        packed_length += CRYPTO_PUBLIC_KEY_SIZE;

#ifndef NDEBUG
        const uint32_t increment = ipp_size + CRYPTO_PUBLIC_KEY_SIZE;
        assert(increment == PACKED_NODE_SIZE_IP4 || increment == PACKED_NODE_SIZE_IP6);
#endif
    }

    return packed_length;
}

/** @brief Unpack data of length into nodes of size max_num_nodes.
 * Put the length of the data processed in processed_data_len.
 * tcp_enabled sets if TCP nodes are expected (true) or not (false).
 *
 * @return number of unpacked nodes on success.
 * @retval -1 on failure.
 */
int unpack_nodes(Node_format *nodes, uint16_t max_num_nodes, uint16_t *processed_data_len, const uint8_t *data,
                 uint16_t length, bool tcp_enabled)
{
    uint32_t num = 0;
    uint32_t len_processed = 0;

    while (num < max_num_nodes && len_processed < length) {
        const int ipp_size = unpack_ip_port(&nodes[num].ip_port, data + len_processed, length - len_processed, tcp_enabled);

        if (ipp_size == -1) {
            return -1;
        }

        len_processed += ipp_size;

        if (len_processed + CRYPTO_PUBLIC_KEY_SIZE > length) {
            return -1;
        }

        memcpy(nodes[num].public_key, data + len_processed, CRYPTO_PUBLIC_KEY_SIZE);
        len_processed += CRYPTO_PUBLIC_KEY_SIZE;
        ++num;

#ifndef NDEBUG
        const uint32_t increment = ipp_size + CRYPTO_PUBLIC_KEY_SIZE;
        assert(increment == PACKED_NODE_SIZE_IP4 || increment == PACKED_NODE_SIZE_IP6);
#endif
    }

    if (processed_data_len != nullptr) {
        *processed_data_len = len_processed;
    }

    return num;
}

/** @brief Find index in an array with public_key equal to pk.
 *
 * @return index or UINT32_MAX if not found.
 */
non_null(3) nullable(1)
static uint32_t index_of_client_pk(const Client_data *array, uint32_t size, const uint8_t *pk)
{
    assert(size == 0 || array != nullptr);

    for (uint32_t i = 0; i < size; ++i) {
        if (pk_equal(array[i].public_key, pk)) {
            return i;
        }
    }

    return UINT32_MAX;
}

non_null(3) nullable(1)
static uint32_t index_of_friend_pk(const DHT_Friend *array, uint32_t size, const uint8_t *pk)
{
    assert(size == 0 || array != nullptr);

    for (uint32_t i = 0; i < size; ++i) {
        if (pk_equal(array[i].public_key, pk)) {
            return i;
        }
    }

    return UINT32_MAX;
}

non_null(3) nullable(1)
static uint32_t index_of_node_pk(const Node_format *array, uint32_t size, const uint8_t *pk)
{
    assert(size == 0 || array != nullptr);

    for (uint32_t i = 0; i < size; ++i) {
        if (pk_equal(array[i].public_key, pk)) {
            return i;
        }
    }

    return UINT32_MAX;
}

/** @brief Find index of Client_data with ip_port equal to param ip_port.
 *
 * @return index or UINT32_MAX if not found.
 */
non_null(3) nullable(1)
static uint32_t index_of_client_ip_port(const Client_data *array, uint32_t size, const IP_Port *ip_port)
{
    assert(size == 0 || array != nullptr);

    for (uint32_t i = 0; i < size; ++i) {
        if ((net_family_is_ipv4(ip_port->ip.family) && ipport_equal(&array[i].assoc4.ip_port, ip_port)) ||
                (net_family_is_ipv6(ip_port->ip.family) && ipport_equal(&array[i].assoc6.ip_port, ip_port))) {
            return i;
        }
    }

    return UINT32_MAX;
}

/** Update ip_port of client if it's needed. */
non_null()
static void update_client(const Logger *log, const Mono_Time *mono_time, int index, Client_data *client,
                          const IP_Port *ip_port)
{
    IPPTsPng *assoc;
    int ip_version;

    if (net_family_is_ipv4(ip_port->ip.family)) {
        assoc = &client->assoc4;
        ip_version = 4;
    } else if (net_family_is_ipv6(ip_port->ip.family)) {
        assoc = &client->assoc6;
        ip_version = 6;
    } else {
        return;
    }

    if (!ipport_equal(&assoc->ip_port, ip_port)) {
        Ip_Ntoa ip_str_from;
        Ip_Ntoa ip_str_to;
        LOGGER_TRACE(log, "coipil[%u]: switching ipv%d from %s:%u to %s:%u",
                     index, ip_version,
                     net_ip_ntoa(&assoc->ip_port.ip, &ip_str_from),
                     net_ntohs(assoc->ip_port.port),
                     net_ip_ntoa(&ip_port->ip, &ip_str_to),
                     net_ntohs(ip_port->port));
    }

    if (!ip_is_lan(&assoc->ip_port.ip) && ip_is_lan(&ip_port->ip)) {
        return;
    }

    assoc->ip_port = *ip_port;
    assoc->timestamp = mono_time_get(mono_time);
}

/** @brief Check if client with public_key is already in list of length length.
 *
 * If it is then set its corresponding timestamp to current time.
 * If the id is already in the list with a different ip_port, update it.
 * TODO(irungentoo): Maybe optimize this.
 */
non_null()
static bool client_or_ip_port_in_list(const Logger *log, const Mono_Time *mono_time, Client_data *list, uint16_t length,
                                      const uint8_t *public_key, const IP_Port *ip_port)
{
    const uint64_t temp_time = mono_time_get(mono_time);
    uint32_t index = index_of_client_pk(list, length, public_key);

    /* if public_key is in list, find it and maybe overwrite ip_port */
    if (index != UINT32_MAX) {
        update_client(log, mono_time, index, &list[index], ip_port);
        return true;
    }

    /* public_key not in list yet: see if we can find an identical ip_port, in
     * that case we kill the old public_key by overwriting it with the new one
     * TODO(irungentoo): maybe we SHOULDN'T do that if that public_key is in a friend_list
     * and the one who is the actual friend's public_key/address set?
     * MAYBE: check the other address, if valid, don't nuke? */
    index = index_of_client_ip_port(list, length, ip_port);

    if (index == UINT32_MAX) {
        return false;
    }

    IPPTsPng *assoc;
    int ip_version;

    if (net_family_is_ipv4(ip_port->ip.family)) {
        assoc = &list[index].assoc4;
        ip_version = 4;
    } else {
        assoc = &list[index].assoc6;
        ip_version = 6;
    }

    /* Initialize client timestamp. */
    assoc->timestamp = temp_time;
    memcpy(list[index].public_key, public_key, CRYPTO_PUBLIC_KEY_SIZE);

    LOGGER_DEBUG(log, "coipil[%u]: switching public_key (ipv%d)", index, ip_version);

    /* kill the other address, if it was set */
    const IPPTsPng empty_ipptspng = {{{{0}}}};
    *assoc = empty_ipptspng;
    return true;
}

bool add_to_list(Node_format *nodes_list, uint32_t length, const uint8_t *pk, const IP_Port *ip_port,
                 const uint8_t *cmp_pk)
{
    for (uint32_t i = 0; i < length; ++i) {
        if (id_closest(cmp_pk, nodes_list[i].public_key, pk) == 2) {
            uint8_t pk_bak[CRYPTO_PUBLIC_KEY_SIZE];
            memcpy(pk_bak, nodes_list[i].public_key, CRYPTO_PUBLIC_KEY_SIZE);
            const IP_Port ip_port_bak = nodes_list[i].ip_port;
            memcpy(nodes_list[i].public_key, pk, CRYPTO_PUBLIC_KEY_SIZE);
            nodes_list[i].ip_port = *ip_port;

            if (i != length - 1) {
                add_to_list(nodes_list, length, pk_bak, &ip_port_bak, cmp_pk);
            }

            return true;
        }
    }

    return false;
}

/**
 * helper for `get_close_nodes()`. argument list is a monster :D
 */
non_null()
static void get_close_nodes_inner(uint64_t cur_time, const uint8_t *public_key, Node_format *nodes_list,
                                  Family sa_family, const Client_data *client_list, uint32_t client_list_length,
                                  uint32_t *num_nodes_ptr, bool is_LAN,
                                  bool want_announce)
{
    if (!net_family_is_ipv4(sa_family) && !net_family_is_ipv6(sa_family) && !net_family_is_unspec(sa_family)) {
        return;
    }

    uint32_t num_nodes = *num_nodes_ptr;

    for (uint32_t i = 0; i < client_list_length; ++i) {
        const Client_data *const client = &client_list[i];

        /* node already in list? */
        if (index_of_node_pk(nodes_list, MAX_SENT_NODES, client->public_key) != UINT32_MAX) {
            continue;
        }

        const IPPTsPng *ipptp;

        if (net_family_is_ipv4(sa_family)) {
            ipptp = &client->assoc4;
        } else if (net_family_is_ipv6(sa_family)) {
            ipptp = &client->assoc6;
        } else if (client->assoc4.timestamp >= client->assoc6.timestamp) {
            ipptp = &client->assoc4;
        } else {
            ipptp = &client->assoc6;
        }

        /* node not in a good condition? */
        if (assoc_timeout(cur_time, ipptp)) {
            continue;
        }

        /* don't send LAN ips to non LAN peers */
        if (ip_is_lan(&ipptp->ip_port.ip) && !is_LAN) {
            continue;
        }

#ifdef CHECK_ANNOUNCE_NODE

        if (want_announce && !client->announce_node) {
            continue;
        }

#endif

        if (num_nodes < MAX_SENT_NODES) {
            memcpy(nodes_list[num_nodes].public_key, client->public_key, CRYPTO_PUBLIC_KEY_SIZE);
            nodes_list[num_nodes].ip_port = ipptp->ip_port;
            ++num_nodes;
        } else {
            // TODO(zugz): this could be made significantly more efficient by
            // using a version of add_to_list which works with a sorted list.
            add_to_list(nodes_list, MAX_SENT_NODES, client->public_key, &ipptp->ip_port, public_key);
        }
    }

    *num_nodes_ptr = num_nodes;
}

/**
 * Find MAX_SENT_NODES nodes closest to the public_key for the send nodes request:
 * put them in the nodes_list and return how many were found.
 *
 * want_announce: return only nodes which implement the dht announcements protocol.
 */
non_null()
static int get_somewhat_close_nodes(const DHT *dht, const uint8_t *public_key, Node_format *nodes_list,
                                    Family sa_family, bool is_LAN, bool want_announce)
{
    uint32_t num_nodes = 0;
    get_close_nodes_inner(dht->cur_time, public_key, nodes_list, sa_family,
                          dht->close_clientlist, LCLIENT_LIST, &num_nodes, is_LAN, want_announce);

    for (uint32_t i = 0; i < dht->num_friends; ++i) {
        get_close_nodes_inner(dht->cur_time, public_key, nodes_list, sa_family,
                              dht->friends_list[i].client_list, MAX_FRIEND_CLIENTS,
                              &num_nodes, is_LAN, want_announce);
    }

    return num_nodes;
}

int get_close_nodes(const DHT *dht, const uint8_t *public_key, Node_format *nodes_list, Family sa_family,
                    bool is_LAN, bool want_announce)
{
    memset(nodes_list, 0, MAX_SENT_NODES * sizeof(Node_format));
    return get_somewhat_close_nodes(dht, public_key, nodes_list, sa_family,
                                    is_LAN, want_announce);
}

typedef struct DHT_Cmp_Data {
    uint64_t cur_time;
    const uint8_t *base_public_key;
    Client_data entry;
} DHT_Cmp_Data;

non_null()
static int dht_cmp_entry(const void *a, const void *b)
{
    const DHT_Cmp_Data *cmp1 = (const DHT_Cmp_Data *)a;
    const DHT_Cmp_Data *cmp2 = (const DHT_Cmp_Data *)b;
    const Client_data entry1 = cmp1->entry;
    const Client_data entry2 = cmp2->entry;
    const uint8_t *cmp_public_key = cmp1->base_public_key;

    const bool t1 = assoc_timeout(cmp1->cur_time, &entry1.assoc4) && assoc_timeout(cmp1->cur_time, &entry1.assoc6);
    const bool t2 = assoc_timeout(cmp2->cur_time, &entry2.assoc4) && assoc_timeout(cmp2->cur_time, &entry2.assoc6);

    if (t1 && t2) {
        return 0;
    }

    if (t1) {
        return -1;
    }

    if (t2) {
        return 1;
    }

    const int closest = id_closest(cmp_public_key, entry1.public_key, entry2.public_key);

    if (closest == 1) {
        return 1;
    }

    if (closest == 2) {
        return -1;
    }

    return 0;
}

#ifdef CHECK_ANNOUNCE_NODE
non_null()
static void set_announce_node_in_list(Client_data *list, uint32_t list_len, const uint8_t *public_key)
{
    const uint32_t index = index_of_client_pk(list, list_len, public_key);

    if (index != UINT32_MAX) {
        list[index].announce_node = true;
    }
}

void set_announce_node(DHT *dht, const uint8_t *public_key)
{
    unsigned int index = bit_by_bit_cmp(public_key, dht->self_public_key);

    if (index >= LCLIENT_LENGTH) {
        index = LCLIENT_LENGTH - 1;
    }

    set_announce_node_in_list(dht->close_clientlist + index * LCLIENT_NODES, LCLIENT_NODES, public_key);

    for (int32_t i = 0; i < dht->num_friends; ++i) {
        set_announce_node_in_list(dht->friends_list[i].client_list, MAX_FRIEND_CLIENTS, public_key);
    }
}

/** @brief Send data search request, searching for a random key. */
non_null()
static bool send_announce_ping(DHT *dht, const uint8_t *public_key, const IP_Port *ip_port)
{
    uint8_t plain[CRYPTO_PUBLIC_KEY_SIZE + sizeof(uint64_t)];

    uint8_t unused_secret_key[CRYPTO_SECRET_KEY_SIZE];
    crypto_new_keypair(dht->rng, plain, unused_secret_key);

    const uint64_t ping_id = ping_array_add(dht->dht_ping_array,
                                            dht->mono_time,
                                            dht->rng,
                                            public_key, CRYPTO_PUBLIC_KEY_SIZE);
    memcpy(plain + CRYPTO_PUBLIC_KEY_SIZE, &ping_id, sizeof(ping_id));

    const uint8_t *shared_key = dht_get_shared_key_sent(dht, public_key);

    uint8_t request[1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + sizeof(plain) + CRYPTO_MAC_SIZE];

    if (dht_create_packet(dht->rng, dht->self_public_key, shared_key, NET_PACKET_DATA_SEARCH_REQUEST,
                          plain, sizeof(plain), request, sizeof(request)) != sizeof(request)) {
        return false;
    }

    return sendpacket(dht->net, ip_port, request, sizeof(request)) == sizeof(request);
}

/** @brief If the response is valid, set the sender as an announce node. */
non_null(1, 2, 3) nullable(5)
static int handle_data_search_response(void *object, const IP_Port *source,
                                       const uint8_t *packet, uint16_t length,
                                       void *userdata)
{
    DHT *dht = (DHT *) object;

    const int32_t plain_len = (int32_t)length - (1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_MAC_SIZE);

    if (plain_len < (int32_t)(CRYPTO_PUBLIC_KEY_SIZE + sizeof(uint64_t))) {
        return 1;
    }

    VLA(uint8_t, plain, plain_len);
    const uint8_t *public_key = packet + 1;
    const uint8_t *shared_key = dht_get_shared_key_recv(dht, public_key);

    if (decrypt_data_symmetric(shared_key,
                               packet + 1 + CRYPTO_PUBLIC_KEY_SIZE,
                               packet + 1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE,
                               plain_len + CRYPTO_MAC_SIZE,
                               plain) != plain_len) {
        return 1;
    }

    uint64_t ping_id;
    memcpy(&ping_id, plain + (plain_len - sizeof(uint64_t)), sizeof(ping_id));

    uint8_t ping_data[CRYPTO_PUBLIC_KEY_SIZE];

    if (ping_array_check(dht->dht_ping_array,
                         dht->mono_time, ping_data,
                         sizeof(ping_data), ping_id) != sizeof(ping_data)) {
        return 1;
    }

    if (!pk_equal(ping_data, public_key)) {
        return 1;
    }

    set_announce_node(dht, public_key);

    return 0;

}
#endif

/** @brief Is it ok to store node with public_key in client.
 *
 * return false if node can't be stored.
 * return true if it can.
 */
non_null()
static bool store_node_ok(const Client_data *client, uint64_t cur_time, const uint8_t *public_key,
                          const uint8_t *comp_public_key)
{
    return (assoc_timeout(cur_time, &client->assoc4)
            && assoc_timeout(cur_time, &client->assoc6))
           || id_closest(comp_public_key, client->public_key, public_key) == 2;
}

non_null()
static void sort_client_list(Client_data *list, uint64_t cur_time, unsigned int length,
                             const uint8_t *comp_public_key)
{
    // Pass comp_public_key to qsort with each Client_data entry, so the
    // comparison function can use it as the base of comparison.
    DHT_Cmp_Data *cmp_list = (DHT_Cmp_Data *)calloc(length, sizeof(DHT_Cmp_Data));

    if (cmp_list == nullptr) {
        return;
    }

    for (uint32_t i = 0; i < length; ++i) {
        cmp_list[i].cur_time = cur_time;
        cmp_list[i].base_public_key = comp_public_key;
        cmp_list[i].entry = list[i];
    }

    qsort(cmp_list, length, sizeof(DHT_Cmp_Data), dht_cmp_entry);

    for (uint32_t i = 0; i < length; ++i) {
        list[i] = cmp_list[i].entry;
    }

    free(cmp_list);
}

non_null()
static void update_client_with_reset(const Mono_Time *mono_time, Client_data *client, const IP_Port *ip_port)
{
    IPPTsPng *ipptp_write = nullptr;
    IPPTsPng *ipptp_clear = nullptr;

    if (net_family_is_ipv4(ip_port->ip.family)) {
        ipptp_write = &client->assoc4;
        ipptp_clear = &client->assoc6;
    } else {
        ipptp_write = &client->assoc6;
        ipptp_clear = &client->assoc4;
    }

    ipptp_write->ip_port = *ip_port;
    ipptp_write->timestamp = mono_time_get(mono_time);

    ip_reset(&ipptp_write->ret_ip_port.ip);
    ipptp_write->ret_ip_port.port = 0;
    ipptp_write->ret_timestamp = 0;
    ipptp_write->ret_ip_self = false;

    /* zero out other address */
    memset(ipptp_clear, 0, sizeof(*ipptp_clear));
}

/**
 * Replace a first bad (or empty) node with this one
 * or replace a possibly bad node (tests failed or not done yet)
 * that is further than any other in the list
 * from the comp_public_key
 * or replace a good node that is further
 * than any other in the list from the comp_public_key
 * and further than public_key.
 *
 * Do not replace any node if the list has no bad or possibly bad nodes
 * and all nodes in the list are closer to comp_public_key
 * than public_key.
 *
 * @return true when the item was stored, false otherwise
 */
non_null()
static bool replace_all(const DHT *dht,
                        Client_data    *list,
                        uint16_t        length,
                        const uint8_t  *public_key,
                        const IP_Port  *ip_port,
                        const uint8_t  *comp_public_key)
{
    if (!net_family_is_ipv4(ip_port->ip.family) && !net_family_is_ipv6(ip_port->ip.family)) {
        return false;
    }

    if (!store_node_ok(&list[1], dht->cur_time, public_key, comp_public_key) &&
            !store_node_ok(&list[0], dht->cur_time, public_key, comp_public_key)) {
        return false;
    }

    sort_client_list(list, dht->cur_time, length, comp_public_key);

    Client_data *const client = &list[0];
    pk_copy(client->public_key, public_key);

    update_client_with_reset(dht->mono_time, client, ip_port);
    return true;
}

/** @brief Add node to close list.
 *
 * simulate is set to 1 if we want to check if a node can be added to the list without adding it.
 *
 * return false on failure.
 * return true on success.
 */
non_null()
static bool add_to_close(DHT *dht, const uint8_t *public_key, const IP_Port *ip_port, bool simulate)
{
    unsigned int index = bit_by_bit_cmp(public_key, dht->self_public_key);

    if (index >= LCLIENT_LENGTH) {
        index = LCLIENT_LENGTH - 1;
    }

    for (uint32_t i = 0; i < LCLIENT_NODES; ++i) {
        /* TODO(iphydf): write bounds checking test to catch the case that
         * index is left as >= LCLIENT_LENGTH */
        Client_data *const client = &dht->close_clientlist[(index * LCLIENT_NODES) + i];

        if (!assoc_timeout(dht->cur_time, &client->assoc4) ||
                !assoc_timeout(dht->cur_time, &client->assoc6)) {
            continue;
        }

        if (simulate) {
            return true;
        }

        pk_copy(client->public_key, public_key);
        update_client_with_reset(dht->mono_time, client, ip_port);
#ifdef CHECK_ANNOUNCE_NODE
        client->announce_node = false;
        send_announce_ping(dht, public_key, ip_port);
#endif
        return true;
    }

    return false;
}

/** Return 1 if node can be added to close list, 0 if it can't. */
bool node_addable_to_close_list(DHT *dht, const uint8_t *public_key, const IP_Port *ip_port)
{
    return add_to_close(dht, public_key, ip_port, true);
}

non_null()
static bool is_pk_in_client_list(const Client_data *list, unsigned int client_list_length, uint64_t cur_time,
                                 const uint8_t *public_key, const IP_Port *ip_port)
{
    const uint32_t index = index_of_client_pk(list, client_list_length, public_key);

    if (index == UINT32_MAX) {
        return false;
    }

    const IPPTsPng *assoc = net_family_is_ipv4(ip_port->ip.family)
                            ? &list[index].assoc4
                            : &list[index].assoc6;

    return !assoc_timeout(cur_time, assoc);
}

non_null()
static bool is_pk_in_close_list(const DHT *dht, const uint8_t *public_key, const IP_Port *ip_port)
{
    unsigned int index = bit_by_bit_cmp(public_key, dht->self_public_key);

    if (index >= LCLIENT_LENGTH) {
        index = LCLIENT_LENGTH - 1;
    }

    return is_pk_in_client_list(dht->close_clientlist + index * LCLIENT_NODES, LCLIENT_NODES, dht->cur_time, public_key,
                                ip_port);
}

/** @brief Check if the node obtained with a get_nodes with public_key should be pinged.
 *
 * NOTE: for best results call it after addto_lists.
 *
 * return false if the node should not be pinged.
 * return true if it should.
 */
non_null()
static bool ping_node_from_getnodes_ok(DHT *dht, const uint8_t *public_key, const IP_Port *ip_port)
{
    bool ret = false;

    if (add_to_close(dht, public_key, ip_port, true)) {
        ret = true;
    }

    {
        unsigned int *const num = &dht->num_to_bootstrap;
        const uint32_t index = index_of_node_pk(dht->to_bootstrap, *num, public_key);
        const bool in_close_list = is_pk_in_close_list(dht, public_key, ip_port);

        if (ret && index == UINT32_MAX && !in_close_list) {
            if (*num < MAX_CLOSE_TO_BOOTSTRAP_NODES) {
                memcpy(dht->to_bootstrap[*num].public_key, public_key, CRYPTO_PUBLIC_KEY_SIZE);
                dht->to_bootstrap[*num].ip_port = *ip_port;
                ++*num;
            } else {
                // TODO(irungentoo): ipv6 vs v4
                add_to_list(dht->to_bootstrap, MAX_CLOSE_TO_BOOTSTRAP_NODES, public_key, ip_port, dht->self_public_key);
            }
        }
    }

    for (uint32_t i = 0; i < dht->num_friends; ++i) {
        DHT_Friend *dht_friend = &dht->friends_list[i];

        bool store_ok = false;

        if (store_node_ok(&dht_friend->client_list[1], dht->cur_time, public_key, dht_friend->public_key)) {
            store_ok = true;
        }

        if (store_node_ok(&dht_friend->client_list[0], dht->cur_time, public_key, dht_friend->public_key)) {
            store_ok = true;
        }

        unsigned int *const friend_num = &dht_friend->num_to_bootstrap;
        const uint32_t index = index_of_node_pk(dht_friend->to_bootstrap, *friend_num, public_key);
        const bool pk_in_list = is_pk_in_client_list(dht_friend->client_list, MAX_FRIEND_CLIENTS, dht->cur_time, public_key,
                                ip_port);

        if (store_ok && index == UINT32_MAX && !pk_in_list) {
            if (*friend_num < MAX_SENT_NODES) {
                Node_format *const format = &dht_friend->to_bootstrap[*friend_num];
                memcpy(format->public_key, public_key, CRYPTO_PUBLIC_KEY_SIZE);
                format->ip_port = *ip_port;
                ++*friend_num;
            } else {
                add_to_list(dht_friend->to_bootstrap, MAX_SENT_NODES, public_key, ip_port, dht_friend->public_key);
            }

            ret = true;
        }
    }

    return ret;
}

/** @brief Attempt to add client with ip_port and public_key to the friends client list
 * and close_clientlist.
 *
 * @return 1+ if the item is used in any list, 0 else
 */
uint32_t addto_lists(DHT *dht, const IP_Port *ip_port, const uint8_t *public_key)
{
    IP_Port ipp_copy = ip_port_normalize(ip_port);

    uint32_t used = 0;

    /* NOTE: Current behavior if there are two clients with the same id is
     * to replace the first ip by the second.
     */
    const bool in_close_list = client_or_ip_port_in_list(dht->log, dht->mono_time, dht->close_clientlist, LCLIENT_LIST,
                               public_key, &ipp_copy);

    /* add_to_close should be called only if !in_list (don't extract to variable) */
    if (in_close_list || !add_to_close(dht, public_key, &ipp_copy, false)) {
        ++used;
    }

    const DHT_Friend *friend_foundip = nullptr;

    for (uint32_t i = 0; i < dht->num_friends; ++i) {
        const bool in_list = client_or_ip_port_in_list(dht->log, dht->mono_time, dht->friends_list[i].client_list,
                             MAX_FRIEND_CLIENTS, public_key, &ipp_copy);

        /* replace_all should be called only if !in_list (don't extract to variable) */
        if (in_list
                || replace_all(dht, dht->friends_list[i].client_list, MAX_FRIEND_CLIENTS, public_key, &ipp_copy,
                               dht->friends_list[i].public_key)) {
            const DHT_Friend *dht_friend = &dht->friends_list[i];

            if (pk_equal(public_key, dht_friend->public_key)) {
                friend_foundip = dht_friend;
            }

            ++used;
        }
    }

    if (friend_foundip == nullptr) {
        return used;
    }

    for (uint32_t i = 0; i < DHT_FRIEND_MAX_LOCKS; ++i) {
        const bool has_lock = (friend_foundip->lock_flags & (UINT32_C(1) << i)) > 0;
        if (has_lock && friend_foundip->callbacks[i].ip_callback != nullptr) {
            friend_foundip->callbacks[i].ip_callback(friend_foundip->callbacks[i].data,
                    friend_foundip->callbacks[i].number, &ipp_copy);
        }
    }

    return used;
}

non_null()
static bool update_client_data(const Mono_Time *mono_time, Client_data *array, size_t size, const IP_Port *ip_port,
                               const uint8_t *pk, bool node_is_self)
{
    const uint64_t temp_time = mono_time_get(mono_time);
    const uint32_t index = index_of_client_pk(array, size, pk);

    if (index == UINT32_MAX) {
        return false;
    }

    Client_data *const data = &array[index];
    IPPTsPng *assoc;

    if (net_family_is_ipv4(ip_port->ip.family)) {
        assoc = &data->assoc4;
    } else if (net_family_is_ipv6(ip_port->ip.family)) {
        assoc = &data->assoc6;
    } else {
        return true;
    }

    assoc->ret_ip_port = *ip_port;
    assoc->ret_timestamp = temp_time;
    assoc->ret_ip_self = node_is_self;

    return true;
}

/**
 * If public_key is a friend or us, update ret_ip_port
 * nodepublic_key is the id of the node that sent us this info.
 */
non_null()
static void returnedip_ports(DHT *dht, const IP_Port *ip_port, const uint8_t *public_key, const uint8_t *nodepublic_key)
{
    IP_Port ipp_copy = ip_port_normalize(ip_port);

    if (pk_equal(public_key, dht->self_public_key)) {
        update_client_data(dht->mono_time, dht->close_clientlist, LCLIENT_LIST, &ipp_copy, nodepublic_key, true);
        return;
    }

    for (uint32_t i = 0; i < dht->num_friends; ++i) {
        if (pk_equal(public_key, dht->friends_list[i].public_key)) {
            Client_data *const client_list = dht->friends_list[i].client_list;

            if (update_client_data(dht->mono_time, client_list, MAX_FRIEND_CLIENTS, &ipp_copy, nodepublic_key, false)) {
                return;
            }
        }
    }
}

bool dht_getnodes(DHT *dht, const IP_Port *ip_port, const uint8_t *public_key, const uint8_t *client_id)
{
    /* Check if packet is going to be sent to ourself. */
    if (pk_equal(public_key, dht->self_public_key)) {
        return false;
    }

    uint8_t plain_message[sizeof(Node_format) * 2] = {0};

    Node_format receiver;
    memcpy(receiver.public_key, public_key, CRYPTO_PUBLIC_KEY_SIZE);
    receiver.ip_port = *ip_port;

    if (pack_nodes(dht->log, plain_message, sizeof(plain_message), &receiver, 1) == -1) {
        return false;
    }

    uint64_t ping_id = 0;

    ping_id = ping_array_add(dht->dht_ping_array, dht->mono_time, dht->rng, plain_message, sizeof(receiver));

    if (ping_id == 0) {
        LOGGER_ERROR(dht->log, "adding ping id failed");
        return false;
    }

    uint8_t plain[CRYPTO_PUBLIC_KEY_SIZE + sizeof(ping_id)];
    uint8_t data[1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + sizeof(plain) + CRYPTO_MAC_SIZE];

    memcpy(plain, client_id, CRYPTO_PUBLIC_KEY_SIZE);
    memcpy(plain + CRYPTO_PUBLIC_KEY_SIZE, &ping_id, sizeof(ping_id));

    const uint8_t *shared_key = dht_get_shared_key_sent(dht, public_key);

    const int len = dht_create_packet(dht->rng,
                                      dht->self_public_key, shared_key, NET_PACKET_GET_NODES,
                                      plain, sizeof(plain), data, sizeof(data));

    if (len != sizeof(data)) {
        LOGGER_ERROR(dht->log, "getnodes packet encryption failed");
        return false;
    }

    return sendpacket(dht->net, ip_port, data, len) > 0;
}

/** Send a send nodes response: message for IPv6 nodes */
non_null()
static int sendnodes_ipv6(const DHT *dht, const IP_Port *ip_port, const uint8_t *public_key, const uint8_t *client_id,
                          const uint8_t *sendback_data, uint16_t length, const uint8_t *shared_encryption_key)
{
    /* Check if packet is going to be sent to ourself. */
    if (pk_equal(public_key, dht->self_public_key)) {
        return -1;
    }

    if (length != sizeof(uint64_t)) {
        return -1;
    }

    const size_t node_format_size = sizeof(Node_format);

    Node_format nodes_list[MAX_SENT_NODES];
    const uint32_t num_nodes =
        get_close_nodes(dht, client_id, nodes_list, net_family_unspec(), ip_is_lan(&ip_port->ip), false);

    VLA(uint8_t, plain, 1 + node_format_size * MAX_SENT_NODES + length);

    int nodes_length = 0;

    if (num_nodes > 0) {
        nodes_length = pack_nodes(dht->log, plain + 1, node_format_size * MAX_SENT_NODES, nodes_list, num_nodes);

        if (nodes_length <= 0) {
            return -1;
        }
    }

    plain[0] = num_nodes;
    memcpy(plain + 1 + nodes_length, sendback_data, length);

    const uint32_t crypto_size = 1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_MAC_SIZE;
    VLA(uint8_t, data, 1 + nodes_length + length + crypto_size);

    const int len = dht_create_packet(dht->rng,
                                      dht->self_public_key, shared_encryption_key, NET_PACKET_SEND_NODES_IPV6,
                                      plain, 1 + nodes_length + length, data, SIZEOF_VLA(data));

    if (len != SIZEOF_VLA(data)) {
        return -1;
    }

    return sendpacket(dht->net, ip_port, data, len);
}

#define CRYPTO_NODE_SIZE (CRYPTO_PUBLIC_KEY_SIZE + sizeof(uint64_t))

non_null()
static int handle_getnodes(void *object, const IP_Port *source, const uint8_t *packet, uint16_t length, void *userdata)
{
    if (length != (CRYPTO_SIZE + CRYPTO_MAC_SIZE + sizeof(uint64_t))) {
        return 1;
    }

    DHT *const dht = (DHT *)object;

    /* Check if packet is from ourself. */
    if (pk_equal(packet + 1, dht->self_public_key)) {
        return 1;
    }

    uint8_t plain[CRYPTO_NODE_SIZE];
    const uint8_t *shared_key = dht_get_shared_key_recv(dht, packet + 1);
    const int len = decrypt_data_symmetric(
                        shared_key,
                        packet + 1 + CRYPTO_PUBLIC_KEY_SIZE,
                        packet + 1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE,
                        CRYPTO_NODE_SIZE + CRYPTO_MAC_SIZE,
                        plain);

    if (len != CRYPTO_NODE_SIZE) {
        return 1;
    }

    sendnodes_ipv6(dht, source, packet + 1, plain, plain + CRYPTO_PUBLIC_KEY_SIZE, sizeof(uint64_t), shared_key);

    ping_add(dht->ping, packet + 1, source);

    return 0;
}

/** Return true if we sent a getnode packet to the peer associated with the supplied info. */
non_null()
static bool sent_getnode_to_node(DHT *dht, const uint8_t *public_key, const IP_Port *node_ip_port, uint64_t ping_id)
{
    uint8_t data[sizeof(Node_format) * 2];

    if (ping_array_check(dht->dht_ping_array, dht->mono_time, data, sizeof(data), ping_id) != sizeof(Node_format)) {
        return false;
    }

    Node_format test;

    if (unpack_nodes(&test, 1, nullptr, data, sizeof(data), false) != 1) {
        return false;
    }

    return ipport_equal(&test.ip_port, node_ip_port) && pk_equal(test.public_key, public_key);
}

non_null()
static bool handle_sendnodes_core(void *object, const IP_Port *source, const uint8_t *packet, uint16_t length,
                                  Node_format *plain_nodes, uint16_t size_plain_nodes, uint32_t *num_nodes_out)
{
    DHT *const dht = (DHT *)object;
    const uint32_t cid_size = 1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + 1 + sizeof(uint64_t) + CRYPTO_MAC_SIZE;

    if (length < cid_size) { /* too short */
        return false;
    }

    const uint32_t data_size = length - cid_size;

    if (data_size == 0) {
        return false;
    }

    if (data_size > sizeof(Node_format) * MAX_SENT_NODES) { /* invalid length */
        return false;
    }

    VLA(uint8_t, plain, 1 + data_size + sizeof(uint64_t));
    const uint8_t *shared_key = dht_get_shared_key_sent(dht, packet + 1);
    const int len = decrypt_data_symmetric(
                        shared_key,
                        packet + 1 + CRYPTO_PUBLIC_KEY_SIZE,
                        packet + 1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE,
                        1 + data_size + sizeof(uint64_t) + CRYPTO_MAC_SIZE,
                        plain);

    if ((unsigned int)len != SIZEOF_VLA(plain)) {
        return false;
    }

    if (plain[0] > size_plain_nodes) {
        return false;
    }

    uint64_t ping_id;
    memcpy(&ping_id, plain + 1 + data_size, sizeof(ping_id));

    if (!sent_getnode_to_node(dht, packet + 1, source, ping_id)) {
        return false;
    }

    uint16_t length_nodes = 0;
    const int num_nodes = unpack_nodes(plain_nodes, plain[0], &length_nodes, plain + 1, data_size, false);

    if (length_nodes != data_size) {
        return false;
    }

    if (num_nodes != plain[0]) {
        return false;
    }

    if (num_nodes < 0) {
        return false;
    }

    /* store the address the *request* was sent to */
    addto_lists(dht, source, packet + 1);

    *num_nodes_out = num_nodes;

    return true;
}

non_null()
static int handle_sendnodes_ipv6(void *object, const IP_Port *source, const uint8_t *packet, uint16_t length,
                                 void *userdata)
{
    DHT *const dht = (DHT *)object;
    Node_format plain_nodes[MAX_SENT_NODES];
    uint32_t num_nodes;

    if (!handle_sendnodes_core(object, source, packet, length, plain_nodes, MAX_SENT_NODES, &num_nodes)) {
        return 1;
    }

    if (num_nodes == 0) {
        return 0;
    }

    for (uint32_t i = 0; i < num_nodes; ++i) {
        if (ipport_isset(&plain_nodes[i].ip_port)) {
            ping_node_from_getnodes_ok(dht, plain_nodes[i].public_key, &plain_nodes[i].ip_port);
            returnedip_ports(dht, &plain_nodes[i].ip_port, plain_nodes[i].public_key, packet + 1);

            if (dht->get_nodes_response != nullptr) {
                dht->get_nodes_response(dht, &plain_nodes[i], userdata);
            }
        }
    }

    return 0;
}

/*----------------------------------------------------------------------------------*/
/*------------------------END of packet handling functions--------------------------*/

non_null(1) nullable(2, 3)
static uint32_t dht_friend_lock(DHT_Friend *const dht_friend, dht_ip_cb *ip_callback,
                            void *data, int32_t number)
{
    // find first free slot
    uint8_t lock_num;
    uint32_t lock_token = 0;
    for (lock_num = 0; lock_num < DHT_FRIEND_MAX_LOCKS; ++lock_num) {
        lock_token = UINT32_C(1) << lock_num;
        if ((dht_friend->lock_flags & lock_token) == 0) {
            break;
        }
    }

    // One of the conditions would be enough, but static analyzers don't get that
    if (lock_token == 0 || lock_num == DHT_FRIEND_MAX_LOCKS) {
        return 0;
    }

    // Claim that slot
    dht_friend->lock_flags |= lock_token;

    dht_friend->callbacks[lock_num].ip_callback = ip_callback;
    dht_friend->callbacks[lock_num].data = data;
    dht_friend->callbacks[lock_num].number = number;

    return lock_token;
}

non_null()
static void dht_friend_unlock(DHT_Friend *const dht_friend, uint32_t lock_token)
{
    // If this triggers, there was a double free
    assert((lock_token & dht_friend->lock_flags) > 0);

    // find used slot
    uint8_t lock_num;
    for (lock_num = 0; lock_num < DHT_FRIEND_MAX_LOCKS; ++lock_num) {
        if (((UINT32_C(1) << lock_num) & lock_token) > 0) {
            break;
        }
    }

    if (lock_num == DHT_FRIEND_MAX_LOCKS) {
        // Gracefully handle double unlock
        return;
    }

    // Clear the slot
    dht_friend->lock_flags &= ~lock_token;

    dht_friend->callbacks[lock_num].ip_callback = nullptr;
    dht_friend->callbacks[lock_num].data = nullptr;
    dht_friend->callbacks[lock_num].number = 0;
}

int dht_addfriend(DHT *dht, const uint8_t *public_key, dht_ip_cb *ip_callback,
                  void *data, int32_t number, uint32_t *lock_token)
{
    const uint32_t friend_num = index_of_friend_pk(dht->friends_list, dht->num_friends, public_key);

    if (friend_num != UINT32_MAX) { /* Is friend already in DHT? */
        DHT_Friend *const dht_friend = &dht->friends_list[friend_num];
        const uint32_t tmp_lock_token = dht_friend_lock(dht_friend, ip_callback, data, number);

        if (tmp_lock_token == 0) {
            return -1;
        }

        return 0;
    }

    DHT_Friend *const temp = (DHT_Friend *)realloc(dht->friends_list, sizeof(DHT_Friend) * (dht->num_friends + 1));

    if (temp == nullptr) {
        return -1;
    }

    dht->friends_list = temp;
    DHT_Friend *const dht_friend = &dht->friends_list[dht->num_friends];
    *dht_friend = empty_dht_friend;
    memcpy(dht_friend->public_key, public_key, CRYPTO_PUBLIC_KEY_SIZE);

    dht_friend->nat.nat_ping_id = random_u64(dht->rng);
    ++dht->num_friends;

    *lock_token = dht_friend_lock(dht_friend, ip_callback, data, number);
    assert(*lock_token != 0); // Friend was newly allocated

    dht_friend->num_to_bootstrap = get_close_nodes(dht, dht_friend->public_key, dht_friend->to_bootstrap, net_family_unspec(),
                                   true, false);

    return 0;
}

int dht_delfriend(DHT *dht, const uint8_t *public_key, uint32_t lock_token)
{
    const uint32_t friend_num = index_of_friend_pk(dht->friends_list, dht->num_friends, public_key);

    if (friend_num == UINT32_MAX) {
        return -1;
    }

    DHT_Friend *const dht_friend = &dht->friends_list[friend_num];
    dht_friend_unlock(dht_friend, lock_token);
    if (dht_friend->lock_flags > 0) {
        /* DHT friend is still in use.*/
        return 0;
    }

    --dht->num_friends;

    if (dht->num_friends != friend_num) {
        dht->friends_list[friend_num] = dht->friends_list[dht->num_friends];
    }

    if (dht->num_friends == 0) {
        free(dht->friends_list);
        dht->friends_list = nullptr;
        return 0;
    }

    DHT_Friend *const temp = (DHT_Friend *)realloc(dht->friends_list, sizeof(DHT_Friend) * dht->num_friends);

    if (temp == nullptr) {
        return -1;
    }

    dht->friends_list = temp;
    return 0;
}

/* TODO(irungentoo): Optimize this. */
int dht_getfriendip(const DHT *dht, const uint8_t *public_key, IP_Port *ip_port)
{
    ip_reset(&ip_port->ip);
    ip_port->port = 0;

    const uint32_t friend_index = index_of_friend_pk(dht->friends_list, dht->num_friends, public_key);

    if (friend_index == UINT32_MAX) {
        return -1;
    }

    const DHT_Friend *const frnd = &dht->friends_list[friend_index];
    const uint32_t client_index = index_of_client_pk(frnd->client_list, MAX_FRIEND_CLIENTS, public_key);

    if (client_index == UINT32_MAX) {
        return 0;
    }

    const Client_data *const client = &frnd->client_list[client_index];
    const IPPTsPng *const assocs[] = { &client->assoc6, &client->assoc4, nullptr };

    for (const IPPTsPng * const *it = assocs; *it != nullptr; ++it) {
        const IPPTsPng *const assoc = *it;

        if (!assoc_timeout(dht->cur_time, assoc)) {
            *ip_port = assoc->ip_port;
            return 1;
        }
    }

    return -1;
}

/** returns number of nodes not in kill-timeout */
non_null()
static uint8_t do_ping_and_sendnode_requests(DHT *dht, uint64_t *lastgetnode, const uint8_t *public_key,
        Client_data *list, uint32_t list_count, uint32_t *bootstrap_times, bool sortable)
{
    uint8_t not_kill = 0;
    const uint64_t temp_time = mono_time_get(dht->mono_time);

    uint32_t num_nodes = 0;
    Client_data **client_list = (Client_data **)calloc(list_count * 2, sizeof(Client_data *));
    IPPTsPng **assoc_list = (IPPTsPng **)calloc(list_count * 2, sizeof(IPPTsPng *));
    unsigned int sort = 0;
    bool sort_ok = false;

    if (client_list == nullptr || assoc_list == nullptr) {
        free(assoc_list);
        free(client_list);
        return 0;
    }

    for (uint32_t i = 0; i < list_count; ++i) {
        /* If node is not dead. */
        Client_data *client = &list[i];

        IPPTsPng *const assocs[] = { &client->assoc6, &client->assoc4 };

        for (uint32_t j = 0; j < sizeof(assocs) / sizeof(assocs[0]); ++j) {
            IPPTsPng *const assoc = assocs[j];

            if (!mono_time_is_timeout(dht->mono_time, assoc->timestamp, KILL_NODE_TIMEOUT)) {
                sort = 0;
                ++not_kill;

                if (mono_time_is_timeout(dht->mono_time, assoc->last_pinged, PING_INTERVAL)) {
                    dht_getnodes(dht, &assoc->ip_port, client->public_key, public_key);
                    assoc->last_pinged = temp_time;
                }

                /* If node is good. */
                if (!assoc_timeout(dht->cur_time, assoc)) {
                    client_list[num_nodes] = client;
                    assoc_list[num_nodes] = assoc;
                    ++num_nodes;
                }
            } else {
                ++sort;

                /* Timed out should be at beginning, if they are not, sort the list. */
                if (sort > 1 && sort < (((j + 1) * 2) - 1)) {
                    sort_ok = true;
                }
            }
        }
    }

    if (sortable && sort_ok) {
        sort_client_list(list, dht->cur_time, list_count, public_key);
    }

    if (num_nodes > 0 && (mono_time_is_timeout(dht->mono_time, *lastgetnode, GET_NODE_INTERVAL)
                          || *bootstrap_times < MAX_BOOTSTRAP_TIMES)) {
        uint32_t rand_node = random_range_u32(dht->rng, num_nodes);

        if ((num_nodes - 1) != rand_node) {
            rand_node += random_range_u32(dht->rng, num_nodes - (rand_node + 1));
        }

        dht_getnodes(dht, &assoc_list[rand_node]->ip_port, client_list[rand_node]->public_key, public_key);

        *lastgetnode = temp_time;
        ++*bootstrap_times;
    }

    free(assoc_list);
    free(client_list);
    return not_kill;
}

/** @brief Ping each client in the "friends" list every PING_INTERVAL seconds.
 *
 * Send a get nodes request  every GET_NODE_INTERVAL seconds to a random good
 * node for each "friend" in our "friends" list.
 */
non_null()
static void do_dht_friends(DHT *dht)
{
    for (size_t i = 0; i < dht->num_friends; ++i) {
        DHT_Friend *const dht_friend = &dht->friends_list[i];

        for (size_t j = 0; j < dht_friend->num_to_bootstrap; ++j) {
            dht_getnodes(dht, &dht_friend->to_bootstrap[j].ip_port, dht_friend->to_bootstrap[j].public_key, dht_friend->public_key);
        }

        dht_friend->num_to_bootstrap = 0;

        do_ping_and_sendnode_requests(dht, &dht_friend->lastgetnode, dht_friend->public_key, dht_friend->client_list,
                                      MAX_FRIEND_CLIENTS,
                                      &dht_friend->bootstrap_times, true);
    }
}

/** @brief Ping each client in the close nodes list every PING_INTERVAL seconds.
 *
 * Send a get nodes request every GET_NODE_INTERVAL seconds to a random good node in the list.
 */
non_null()
static void do_Close(DHT *dht)
{
    for (size_t i = 0; i < dht->num_to_bootstrap; ++i) {
        dht_getnodes(dht, &dht->to_bootstrap[i].ip_port, dht->to_bootstrap[i].public_key, dht->self_public_key);
    }

    dht->num_to_bootstrap = 0;

    const uint8_t not_killed = do_ping_and_sendnode_requests(
                                   dht, &dht->close_lastgetnodes, dht->self_public_key, dht->close_clientlist, LCLIENT_LIST, &dht->close_bootstrap_times,
                                   false);

    if (not_killed != 0) {
        return;
    }

    /* all existing nodes are at least KILL_NODE_TIMEOUT,
     * which means we are mute, as we only send packets to
     * nodes NOT in KILL_NODE_TIMEOUT
     *
     * so: reset all nodes to be BAD_NODE_TIMEOUT, but not
     * KILL_NODE_TIMEOUT, so we at least keep trying pings */
    const uint64_t badonly = mono_time_get(dht->mono_time) - BAD_NODE_TIMEOUT;

    for (size_t i = 0; i < LCLIENT_LIST; ++i) {
        Client_data *const client = &dht->close_clientlist[i];

        IPPTsPng *const assocs[] = { &client->assoc6, &client->assoc4, nullptr };

        for (IPPTsPng * const *it = assocs; *it != nullptr; ++it) {
            IPPTsPng *const assoc = *it;

            if (assoc->timestamp != 0) {
                assoc->timestamp = badonly;
            }
        }
    }
}

bool dht_bootstrap(DHT *dht, const IP_Port *ip_port, const uint8_t *public_key)
{
    if (pk_equal(public_key, dht->self_public_key)) {
        // Bootstrapping off ourselves is ok (onion paths are still set up).
        return true;
    }

    return dht_getnodes(dht, ip_port, public_key, dht->self_public_key);
}

int dht_bootstrap_from_address(DHT *dht, const char *address, bool ipv6enabled,
                               uint16_t port, const uint8_t *public_key)
{
    IP_Port ip_port_v64;
    IP *ip_extra = nullptr;
    IP_Port ip_port_v4;
    ip_init(&ip_port_v64.ip, ipv6enabled);

    if (ipv6enabled) {
        /* setup for getting BOTH: an IPv6 AND an IPv4 address */
        ip_port_v64.ip.family = net_family_unspec();
        ip_reset(&ip_port_v4.ip);
        ip_extra = &ip_port_v4.ip;
    }

    if (addr_resolve_or_parse_ip(dht->ns, address, &ip_port_v64.ip, ip_extra)) {
        ip_port_v64.port = port;
        dht_bootstrap(dht, &ip_port_v64, public_key);

        if ((ip_extra != nullptr) && ip_isset(ip_extra)) {
            ip_port_v4.port = port;
            dht_bootstrap(dht, &ip_port_v4, public_key);
        }

        return 1;
    }

    return 0;
}

/** @brief Send the given packet to node with public_key.
 *
 * @return number of bytes sent.
 * @retval -1 if failure.
 */
int route_packet(const DHT *dht, const uint8_t *public_key, const uint8_t *packet, uint16_t length)
{
    for (uint32_t i = 0; i < LCLIENT_LIST; ++i) {
        if (pk_equal(public_key, dht->close_clientlist[i].public_key)) {
            const Client_data *const client = &dht->close_clientlist[i];
            const IPPTsPng *const assocs[] = { &client->assoc6, &client->assoc4, nullptr };

            for (const IPPTsPng * const *it = assocs; *it != nullptr; ++it) {
                const IPPTsPng *const assoc = *it;

                if (ip_isset(&assoc->ip_port.ip)) {
                    return sendpacket(dht->net, &assoc->ip_port, packet, length);
                }
            }

            break;
        }
    }

    return -1;
}

/** @brief Puts all the different ips returned by the nodes for a friend_num into array ip_portlist.
 *
 * ip_portlist must be at least MAX_FRIEND_CLIENTS big.
 *
 * @return the number of ips returned.
 * @retval 0 if we are connected to friend or if no ips were found.
 * @retval -1 if no such friend.
 */
non_null()
static int friend_iplist(const DHT *dht, IP_Port *ip_portlist, uint16_t friend_num)
{
    if (friend_num >= dht->num_friends) {
        return -1;
    }

    const DHT_Friend *const dht_friend = &dht->friends_list[friend_num];
    IP_Port ipv4s[MAX_FRIEND_CLIENTS];
    int num_ipv4s = 0;
    IP_Port ipv6s[MAX_FRIEND_CLIENTS];
    int num_ipv6s = 0;

    for (size_t i = 0; i < MAX_FRIEND_CLIENTS; ++i) {
        const Client_data *const client = &dht_friend->client_list[i];

        /* If ip is not zero and node is good. */
        if (ip_isset(&client->assoc4.ret_ip_port.ip)
                && !mono_time_is_timeout(dht->mono_time, client->assoc4.ret_timestamp, BAD_NODE_TIMEOUT)) {
            ipv4s[num_ipv4s] = client->assoc4.ret_ip_port;
            ++num_ipv4s;
        }

        if (ip_isset(&client->assoc6.ret_ip_port.ip)
                && !mono_time_is_timeout(dht->mono_time, client->assoc6.ret_timestamp, BAD_NODE_TIMEOUT)) {
            ipv6s[num_ipv6s] = client->assoc6.ret_ip_port;
            ++num_ipv6s;
        }

        if (pk_equal(client->public_key, dht_friend->public_key)) {
            if (!assoc_timeout(dht->cur_time, &client->assoc6)
                    || !assoc_timeout(dht->cur_time, &client->assoc4)) {
                return 0; /* direct connectivity */
            }
        }
    }

#ifdef FRIEND_IPLIST_PAD
    memcpy(ip_portlist, ipv6s, num_ipv6s * sizeof(IP_Port));

    if (num_ipv6s == MAX_FRIEND_CLIENTS) {
        return MAX_FRIEND_CLIENTS;
    }

    int num_ipv4s_used = MAX_FRIEND_CLIENTS - num_ipv6s;

    if (num_ipv4s_used > num_ipv4s) {
        num_ipv4s_used = num_ipv4s;
    }

    memcpy(&ip_portlist[num_ipv6s], ipv4s, num_ipv4s_used * sizeof(IP_Port));
    return num_ipv6s + num_ipv4s_used;

#else /* !FRIEND_IPLIST_PAD */

    /* there must be some secret reason why we can't pad the longer list
     * with the shorter one...
     */
    if (num_ipv6s >= num_ipv4s) {
        memcpy(ip_portlist, ipv6s, num_ipv6s * sizeof(IP_Port));
        return num_ipv6s;
    }

    memcpy(ip_portlist, ipv4s, num_ipv4s * sizeof(IP_Port));
    return num_ipv4s;

#endif /* !FRIEND_IPLIST_PAD */
}


/**
 * Callback invoked for each IP/port of each client of a friend.
 *
 * For each client, the callback is invoked twice: once for IPv4 and once for
 * IPv6. If the callback returns `false` after the IPv4 invocation, it will not
 * be invoked for IPv6.
 *
 * @param dht The main DHT instance.
 * @param ip_port The currently processed IP/port.
 * @param n A pointer to the number that will be returned from `foreach_ip_port`.
 * @param userdata The `userdata` pointer passed to `foreach_ip_port`.
 */
typedef bool foreach_ip_port_cb(const DHT *dht, const IP_Port *ip_port, uint32_t *n, void *userdata);

/**
 * Runs a callback on every active connection for a given DHT friend.
 *
 * This iterates over the client list of a DHT friend and invokes a callback for
 * every non-zero IP/port (IPv4 and IPv6) that's not timed out.
 *
 * @param dht The main DHT instance, passed to the callback.
 * @param dht_friend The friend over whose connections we should iterate.
 * @param callback The callback to invoke for each IP/port.
 * @param userdata Extra pointer passed to the callback.
 */
non_null()
static uint32_t foreach_ip_port(const DHT *dht, const DHT_Friend *dht_friend,
                                foreach_ip_port_cb *callback, void *userdata)
{
    uint32_t n = 0;

    /* extra legwork, because having the outside allocating the space for us
     * is *usually* good(tm) (bites us in the behind in this case though) */
    for (uint32_t i = 0; i < MAX_FRIEND_CLIENTS; ++i) {
        const Client_data *const client = &dht_friend->client_list[i];
        const IPPTsPng *const assocs[] = { &client->assoc4, &client->assoc6, nullptr };

        for (const IPPTsPng * const *it = assocs; *it != nullptr; ++it) {
            const IPPTsPng *const assoc = *it;

            /* If ip is not zero and node is good. */
            if (!ip_isset(&assoc->ret_ip_port.ip)
                    && !mono_time_is_timeout(dht->mono_time, assoc->ret_timestamp, BAD_NODE_TIMEOUT)) {
                continue;
            }

            if (!callback(dht, &assoc->ip_port, &n, userdata)) {
                /* If the callback is happy with just one of the assocs, we
                 * don't give it the second one. */
                break;
            }
        }
    }

    return n;
}

non_null()
static bool send_packet_to_friend(const DHT *dht, const IP_Port *ip_port, uint32_t *n, void *userdata)
{
    const Packet *packet = (const Packet *)userdata;
    const int retval = send_packet(dht->net, ip_port, *packet);

    if ((uint32_t)retval == packet->length) {
        ++*n;
        /* Send one packet per friend: stop the foreach on the first success. */
        return false;
    }

    return true;
}

/**
 * Send the following packet to everyone who tells us they are connected to friend_id.
 *
 * @return ip for friend.
 * @return number of nodes the packet was sent to. (Only works if more than (MAX_FRIEND_CLIENTS / 4).
 */
uint32_t route_to_friend(const DHT *dht, const uint8_t *friend_id, const Packet *packet)
{
    const uint32_t num = index_of_friend_pk(dht->friends_list, dht->num_friends, friend_id);

    if (num == UINT32_MAX) {
        return 0;
    }


    IP_Port ip_list[MAX_FRIEND_CLIENTS];
    const int ip_num = friend_iplist(dht, ip_list, num);

    if (ip_num < MAX_FRIEND_CLIENTS / 4) {
        return 0; /* Reason for that? */
    }

    const DHT_Friend *const dht_friend = &dht->friends_list[num];
    Packet packet_userdata = *packet;  // Copy because it needs to be non-const.

    return foreach_ip_port(dht, dht_friend, send_packet_to_friend, &packet_userdata);
}

non_null()
static bool get_ip_port(const DHT *dht, const IP_Port *ip_port, uint32_t *n, void *userdata)
{
    IP_Port *ip_list = (IP_Port *)userdata;
    ip_list[*n] = *ip_port;
    ++*n;
    return true;
}

/** @brief Send the following packet to one random person who tells us they are connected to friend_id.
 *
 * @return number of nodes the packet was sent to.
 */
non_null()
static uint32_t routeone_to_friend(const DHT *dht, const uint8_t *friend_id, const Packet *packet)
{
    const uint32_t num = index_of_friend_pk(dht->friends_list, dht->num_friends, friend_id);

    if (num == UINT32_MAX) {
        return 0;
    }

    const DHT_Friend *const dht_friend = &dht->friends_list[num];

    IP_Port ip_list[MAX_FRIEND_CLIENTS * 2];

    const int n = foreach_ip_port(dht, dht_friend, get_ip_port, ip_list);

    if (n < 1) {
        return 0;
    }

    const uint32_t rand_idx = random_range_u32(dht->rng, n);
    const int retval = send_packet(dht->net, &ip_list[rand_idx], *packet);

    if ((unsigned int)retval == packet->length) {
        return 1;
    }

    return 0;
}

/*----------------------------------------------------------------------------------*/
/*---------------------BEGINNING OF NAT PUNCHING FUNCTIONS--------------------------*/

non_null()
static int send_NATping(const DHT *dht, const uint8_t *public_key, uint64_t ping_id, uint8_t type)
{
    uint8_t data[sizeof(uint64_t) + 1];
    uint8_t packet_data[MAX_CRYPTO_REQUEST_SIZE];

    data[0] = type;
    memcpy(data + 1, &ping_id, sizeof(uint64_t));
    /* 254 is NAT ping request packet id */
    const int len = create_request(
                        dht->rng, dht->self_public_key, dht->self_secret_key, packet_data, public_key,
                        data, sizeof(uint64_t) + 1, CRYPTO_PACKET_NAT_PING);

    if (len == -1) {
        return -1;
    }

    assert(len <= UINT16_MAX);
    uint32_t num = 0;
    const Packet packet = {packet_data, (uint16_t)len};

    if (type == 0) { /* If packet is request use many people to route it. */
        num = route_to_friend(dht, public_key, &packet);
    } else if (type == 1) { /* If packet is response use only one person to route it */
        num = routeone_to_friend(dht, public_key, &packet);
    }

    if (num == 0) {
        return -1;
    }

    return num;
}

/** Handle a received ping request for. */
non_null()
static int handle_NATping(void *object, const IP_Port *source, const uint8_t *source_pubkey, const uint8_t *packet,
                          uint16_t length, void *userdata)
{
    if (length != sizeof(uint64_t) + 1) {
        return 1;
    }

    DHT *const dht = (DHT *)object;
    uint64_t ping_id;
    memcpy(&ping_id, packet + 1, sizeof(uint64_t));

    const uint32_t friendnumber = index_of_friend_pk(dht->friends_list, dht->num_friends, source_pubkey);

    if (friendnumber == UINT32_MAX) {
        return 1;
    }

    DHT_Friend *const dht_friend = &dht->friends_list[friendnumber];

    if (packet[0] == NAT_PING_REQUEST) {
        /* 1 is reply */
        send_NATping(dht, source_pubkey, ping_id, NAT_PING_RESPONSE);
        dht_friend->nat.recv_nat_ping_timestamp = mono_time_get(dht->mono_time);
        return 0;
    }

    if (packet[0] == NAT_PING_RESPONSE) {
        if (dht_friend->nat.nat_ping_id == ping_id) {
            dht_friend->nat.nat_ping_id = random_u64(dht->rng);
            dht_friend->nat.hole_punching = true;
            return 0;
        }
    }

    return 1;
}

/** @brief Get the most common ip in the ip_portlist.
 * Only return ip if it appears in list min_num or more.
 * len must not be bigger than MAX_FRIEND_CLIENTS.
 *
 * @return ip of 0 if failure.
 */
non_null()
static IP nat_commonip(const IP_Port *ip_portlist, uint16_t len, uint16_t min_num)
{
    IP zero;
    ip_reset(&zero);

    if (len > MAX_FRIEND_CLIENTS) {
        return zero;
    }

    uint16_t numbers[MAX_FRIEND_CLIENTS] = {0};

    for (uint32_t i = 0; i < len; ++i) {
        for (uint32_t j = 0; j < len; ++j) {
            if (ip_equal(&ip_portlist[i].ip, &ip_portlist[j].ip)) {
                ++numbers[i];
            }
        }

        if (numbers[i] >= min_num) {
            return ip_portlist[i].ip;
        }
    }

    return zero;
}

/** @brief Return all the ports for one ip in a list.
 * portlist must be at least len long,
 * where len is the length of ip_portlist.
 *
 * @return number of ports and puts the list of ports in portlist.
 */
non_null()
static uint16_t nat_getports(uint16_t *portlist, const IP_Port *ip_portlist, uint16_t len, const IP *ip)
{
    uint16_t num = 0;

    for (uint32_t i = 0; i < len; ++i) {
        if (ip_equal(&ip_portlist[i].ip, ip)) {
            portlist[num] = net_ntohs(ip_portlist[i].port);
            ++num;
        }
    }

    return num;
}

non_null()
static void punch_holes(DHT *dht, const IP *ip, const uint16_t *port_list, uint16_t numports, uint16_t friend_num)
{
    if (!dht->hole_punching_enabled) {
        return;
    }

    if (numports > MAX_FRIEND_CLIENTS || numports == 0) {
        return;
    }

    const uint16_t first_port = port_list[0];
    uint16_t port_candidate;

    for (port_candidate = 0; port_candidate < numports; ++port_candidate) {
        if (first_port != port_list[port_candidate]) {
            break;
        }
    }

    if (port_candidate == numports) { /* If all ports are the same, only try that one port. */
        IP_Port pinging;
        ip_copy(&pinging.ip, ip);
        pinging.port = net_htons(first_port);
        ping_send_request(dht->ping, &pinging, dht->friends_list[friend_num].public_key);
    } else {
        uint16_t i;
        for (i = 0; i < MAX_PUNCHING_PORTS; ++i) {
            /* TODO(irungentoo): Improve port guessing algorithm. */
            const uint32_t it = i + dht->friends_list[friend_num].nat.punching_index;
            const int8_t sign = (it % 2 != 0) ? -1 : 1;
            const uint32_t delta = sign * (it / (2 * numports));
            const uint32_t index = (it / 2) % numports;
            const uint16_t port = port_list[index] + delta;
            IP_Port pinging;
            ip_copy(&pinging.ip, ip);
            pinging.port = net_htons(port);
            ping_send_request(dht->ping, &pinging, dht->friends_list[friend_num].public_key);
        }

        dht->friends_list[friend_num].nat.punching_index += i;
    }

    if (dht->friends_list[friend_num].nat.tries > MAX_NORMAL_PUNCHING_TRIES) {
        IP_Port pinging;
        ip_copy(&pinging.ip, ip);

        uint16_t i;
        for (i = 0; i < MAX_PUNCHING_PORTS; ++i) {
            uint32_t it = i + dht->friends_list[friend_num].nat.punching_index2;
            const uint16_t port = 1024;
            pinging.port = net_htons(port + it);
            ping_send_request(dht->ping, &pinging, dht->friends_list[friend_num].public_key);
        }

        dht->friends_list[friend_num].nat.punching_index2 += i - (MAX_PUNCHING_PORTS / 2);
    }

    ++dht->friends_list[friend_num].nat.tries;
}

non_null()
static void do_NAT(DHT *dht)
{
    const uint64_t temp_time = mono_time_get(dht->mono_time);

    for (uint32_t i = 0; i < dht->num_friends; ++i) {
        IP_Port ip_list[MAX_FRIEND_CLIENTS];
        const int num = friend_iplist(dht, ip_list, i);

        /* If already connected or friend is not online don't try to hole punch. */
        if (num < MAX_FRIEND_CLIENTS / 2) {
            continue;
        }

        if (dht->friends_list[i].nat.nat_ping_timestamp + PUNCH_INTERVAL < temp_time) {
            send_NATping(dht, dht->friends_list[i].public_key, dht->friends_list[i].nat.nat_ping_id, NAT_PING_REQUEST);
            dht->friends_list[i].nat.nat_ping_timestamp = temp_time;
        }

        if (dht->friends_list[i].nat.hole_punching &&
                dht->friends_list[i].nat.punching_timestamp + PUNCH_INTERVAL < temp_time &&
                dht->friends_list[i].nat.recv_nat_ping_timestamp + PUNCH_INTERVAL * 2 >= temp_time) {

            const IP ip = nat_commonip(ip_list, num, MAX_FRIEND_CLIENTS / 2);

            if (!ip_isset(&ip)) {
                continue;
            }

            if (dht->friends_list[i].nat.punching_timestamp + PUNCH_RESET_TIME < temp_time) {
                dht->friends_list[i].nat.tries = 0;
                dht->friends_list[i].nat.punching_index = 0;
                dht->friends_list[i].nat.punching_index2 = 0;
            }

            uint16_t port_list[MAX_FRIEND_CLIENTS];
            const uint16_t numports = nat_getports(port_list, ip_list, num, &ip);
            punch_holes(dht, &ip, port_list, numports, i);

            dht->friends_list[i].nat.punching_timestamp = temp_time;
            dht->friends_list[i].nat.hole_punching = false;
        }
    }
}

/*----------------------------------------------------------------------------------*/
/*-----------------------END OF NAT PUNCHING FUNCTIONS------------------------------*/

/** @brief Put up to max_num nodes in nodes from the closelist.
 *
 * @return the number of nodes.
 */
non_null()
static uint16_t list_nodes(const Random *rng, const Client_data *list, size_t length,
                           uint64_t cur_time, Node_format *nodes, uint16_t max_num)
{
    if (max_num == 0) {
        return 0;
    }

    uint16_t count = 0;

    for (size_t i = length; i != 0; --i) {
        const IPPTsPng *assoc = nullptr;

        if (!assoc_timeout(cur_time, &list[i - 1].assoc4)) {
            assoc = &list[i - 1].assoc4;
        }

        if (!assoc_timeout(cur_time, &list[i - 1].assoc6)) {
            if (assoc == nullptr) {
                assoc = &list[i - 1].assoc6;
            } else if ((random_u08(rng) % 2) != 0) {
                assoc = &list[i - 1].assoc6;
            }
        }

        if (assoc != nullptr) {
            memcpy(nodes[count].public_key, list[i - 1].public_key, CRYPTO_PUBLIC_KEY_SIZE);
            nodes[count].ip_port = assoc->ip_port;
            ++count;

            if (count >= max_num) {
                return count;
            }
        }
    }

    return count;
}

/** @brief Put up to max_num nodes in nodes from the random friends.
 *
 * Important: this function relies on the first two DHT friends *not* being real
 * friends to avoid leaking information about real friends into the onion paths.
 *
 * @return the number of nodes.
 */
uint16_t randfriends_nodes(const DHT *dht, Node_format *nodes, uint16_t max_num)
{
    if (max_num == 0) {
        return 0;
    }

    uint16_t count = 0;
    const uint32_t r = random_u32(dht->rng);

    assert(DHT_FAKE_FRIEND_NUMBER <= dht->num_friends);

    // Only gather nodes from the initial 2 fake friends.
    for (uint32_t i = 0; i < DHT_FAKE_FRIEND_NUMBER; ++i) {
        count += list_nodes(dht->rng, dht->friends_list[(i + r) % DHT_FAKE_FRIEND_NUMBER].client_list,
                            MAX_FRIEND_CLIENTS, dht->cur_time,
                            nodes + count, max_num - count);

        if (count >= max_num) {
            break;
        }
    }

    return count;
}

/** @brief Put up to max_num nodes in nodes from the closelist.
 *
 * @return the number of nodes.
 */
uint16_t closelist_nodes(const DHT *dht, Node_format *nodes, uint16_t max_num)
{
    return list_nodes(dht->rng, dht->close_clientlist, LCLIENT_LIST, dht->cur_time, nodes, max_num);
}

/*----------------------------------------------------------------------------------*/

void cryptopacket_registerhandler(DHT *dht, uint8_t byte, cryptopacket_handler_cb *cb, void *object)
{
    dht->cryptopackethandlers[byte].function = cb;
    dht->cryptopackethandlers[byte].object = object;
}

non_null()
static int cryptopacket_handle(void *object, const IP_Port *source, const uint8_t *packet, uint16_t length,
                               void *userdata)
{
    DHT *const dht = (DHT *)object;

    assert(packet[0] == NET_PACKET_CRYPTO);

    if (length <= CRYPTO_PUBLIC_KEY_SIZE * 2 + CRYPTO_NONCE_SIZE + 1 + CRYPTO_MAC_SIZE ||
            length > MAX_CRYPTO_REQUEST_SIZE + CRYPTO_MAC_SIZE) {
        return 1;
    }

    // Check if request is for us.
    if (pk_equal(packet + 1, dht->self_public_key)) {
        uint8_t public_key[CRYPTO_PUBLIC_KEY_SIZE];
        uint8_t data[MAX_CRYPTO_REQUEST_SIZE];
        uint8_t number;
        const int len = handle_request(dht->self_public_key, dht->self_secret_key, public_key,
                                       data, &number, packet, length);

        if (len == -1 || len == 0) {
            return 1;
        }

        if (dht->cryptopackethandlers[number].function == nullptr) {
            return 1;
        }

        return dht->cryptopackethandlers[number].function(
                   dht->cryptopackethandlers[number].object, source, public_key,
                   data, len, userdata);
    }

    /* If request is not for us, try routing it. */
    const int retval = route_packet(dht, packet + 1, packet, length);

    if ((unsigned int)retval == length) {
        return 0;
    }

    return 1;
}

void dht_callback_get_nodes_response(DHT *dht, dht_get_nodes_response_cb *function)
{
    dht->get_nodes_response = function;
}

non_null(1, 2, 3) nullable(5)
static int handle_LANdiscovery(void *object, const IP_Port *source, const uint8_t *packet, uint16_t length,
                               void *userdata)
{
    DHT *dht = (DHT *)object;

    if (!dht->lan_discovery_enabled) {
        return 1;
    }

    if (!ip_is_lan(&source->ip)) {
        return 1;
    }

    if (length != CRYPTO_PUBLIC_KEY_SIZE + 1) {
        return 1;
    }

    dht_bootstrap(dht, source, packet + 1);
    return 0;
}

/*----------------------------------------------------------------------------------*/

DHT *new_dht(const Logger *log, const Random *rng, const Network *ns, Mono_Time *mono_time, Networking_Core *net,
             bool hole_punching_enabled, bool lan_discovery_enabled)
{
    if (net == nullptr) {
        return nullptr;
    }

    DHT *const dht = (DHT *)calloc(1, sizeof(DHT));

    if (dht == nullptr) {
        return nullptr;
    }

    dht->ns = ns;
    dht->mono_time = mono_time;
    dht->cur_time = mono_time_get(mono_time);
    dht->log = log;
    dht->net = net;
    dht->rng = rng;

    dht->hole_punching_enabled = hole_punching_enabled;
    dht->lan_discovery_enabled = lan_discovery_enabled;

    dht->ping = ping_new(mono_time, rng, dht);

    if (dht->ping == nullptr) {
        kill_dht(dht);
        return nullptr;
    }

    networking_registerhandler(dht->net, NET_PACKET_GET_NODES, &handle_getnodes, dht);
    networking_registerhandler(dht->net, NET_PACKET_SEND_NODES_IPV6, &handle_sendnodes_ipv6, dht);
    networking_registerhandler(dht->net, NET_PACKET_CRYPTO, &cryptopacket_handle, dht);
    networking_registerhandler(dht->net, NET_PACKET_LAN_DISCOVERY, &handle_LANdiscovery, dht);
    cryptopacket_registerhandler(dht, CRYPTO_PACKET_NAT_PING, &handle_NATping, dht);

#ifdef CHECK_ANNOUNCE_NODE
    networking_registerhandler(dht->net, NET_PACKET_DATA_SEARCH_RESPONSE, &handle_data_search_response, dht);
#endif

    crypto_new_keypair(rng, dht->self_public_key, dht->self_secret_key);

    dht->shared_keys_recv = shared_key_cache_new(mono_time, dht->self_secret_key, KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
    dht->shared_keys_sent = shared_key_cache_new(mono_time, dht->self_secret_key, KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);

    if (dht->shared_keys_recv == nullptr || dht->shared_keys_sent == nullptr) {
        kill_dht(dht);
        return nullptr;
    }


    dht->dht_ping_array = ping_array_new(DHT_PING_ARRAY_SIZE, PING_TIMEOUT);

    if (dht->dht_ping_array == nullptr) {
        kill_dht(dht);
        return nullptr;
    }

    for (uint32_t i = 0; i < DHT_FAKE_FRIEND_NUMBER; ++i) {
        uint8_t random_public_key_bytes[CRYPTO_PUBLIC_KEY_SIZE];
        uint8_t random_secret_key_bytes[CRYPTO_SECRET_KEY_SIZE];

        crypto_new_keypair(rng, random_public_key_bytes, random_secret_key_bytes);

        uint32_t token; // We don't intend to delete these ever, but need to pass the token
        if (dht_addfriend(dht, random_public_key_bytes, nullptr, nullptr, 0, &token) != 0) {
            kill_dht(dht);
            return nullptr;
        }
    }

    if (dht->num_friends != DHT_FAKE_FRIEND_NUMBER) {
        LOGGER_ERROR(log, "the RNG provided seems to be broken: it generated the same keypair twice");
        kill_dht(dht);
        return nullptr;
    }

    return dht;
}

void do_dht(DHT *dht)
{
    const uint64_t cur_time = mono_time_get(dht->mono_time);

    if (dht->cur_time == cur_time) {
        return;
    }

    dht->cur_time = cur_time;

    // Load friends/clients if first call to do_dht
    if (dht->loaded_num_nodes > 0) {
        dht_connect_after_load(dht);
    }

    do_Close(dht);
    do_dht_friends(dht);
    do_NAT(dht);
    ping_iterate(dht->ping);
}

void kill_dht(DHT *dht)
{
    if (dht == nullptr) {
        return;
    }

    networking_registerhandler(dht->net, NET_PACKET_GET_NODES, nullptr, nullptr);
    networking_registerhandler(dht->net, NET_PACKET_SEND_NODES_IPV6, nullptr, nullptr);
    networking_registerhandler(dht->net, NET_PACKET_CRYPTO, nullptr, nullptr);
    networking_registerhandler(dht->net, NET_PACKET_LAN_DISCOVERY, nullptr, nullptr);
    cryptopacket_registerhandler(dht, CRYPTO_PACKET_NAT_PING, nullptr, nullptr);

    shared_key_cache_free(dht->shared_keys_recv);
    shared_key_cache_free(dht->shared_keys_sent);
    ping_array_kill(dht->dht_ping_array);
    ping_kill(dht->ping);
    free(dht->friends_list);
    free(dht->loaded_nodes_list);
    crypto_memzero(dht->self_secret_key, sizeof(dht->self_secret_key));
    free(dht);
}

/* new DHT format for load/save, more robust and forward compatible */
// TODO(irungentoo): Move this closer to Messenger.
#define DHT_STATE_COOKIE_GLOBAL 0x159000d

#define DHT_STATE_COOKIE_TYPE      0x11ce
#define DHT_STATE_TYPE_NODES       4

#define MAX_SAVED_DHT_NODES (((DHT_FAKE_FRIEND_NUMBER * MAX_FRIEND_CLIENTS) + LCLIENT_LIST) * 2)

/** Get the size of the DHT (for saving). */
uint32_t dht_size(const DHT *dht)
{
    uint32_t numv4 = 0;
    uint32_t numv6 = 0;

    for (uint32_t i = 0; i < dht->loaded_num_nodes; ++i) {
        numv4 += net_family_is_ipv4(dht->loaded_nodes_list[i].ip_port.ip.family);
        numv6 += net_family_is_ipv6(dht->loaded_nodes_list[i].ip_port.ip.family);
    }

    for (uint32_t i = 0; i < LCLIENT_LIST; ++i) {
        numv4 += dht->close_clientlist[i].assoc4.timestamp != 0;
        numv6 += dht->close_clientlist[i].assoc6.timestamp != 0;
    }

    for (uint32_t i = 0; i < DHT_FAKE_FRIEND_NUMBER && i < dht->num_friends; ++i) {
        const DHT_Friend *const fr = &dht->friends_list[i];

        for (uint32_t j = 0; j < MAX_FRIEND_CLIENTS; ++j) {
            numv4 += fr->client_list[j].assoc4.timestamp != 0;
            numv6 += fr->client_list[j].assoc6.timestamp != 0;
        }
    }

    const uint32_t size32 = sizeof(uint32_t);
    const uint32_t sizesubhead = size32 * 2;

    return size32 + sizesubhead + packed_node_size(net_family_ipv4()) * numv4 + packed_node_size(net_family_ipv6()) * numv6;
}

/** Save the DHT in data where data is an array of size `dht_size()`. */
void dht_save(const DHT *dht, uint8_t *data)
{
    host_to_lendian_bytes32(data, DHT_STATE_COOKIE_GLOBAL);
    data += sizeof(uint32_t);

    uint8_t *const old_data = data;

    /* get right offset. we write the actual header later. */
    data = state_write_section_header(data, DHT_STATE_COOKIE_TYPE, 0, 0);

    Node_format *clients = (Node_format *)calloc(MAX_SAVED_DHT_NODES, sizeof(Node_format));

    if (clients == nullptr) {
        LOGGER_ERROR(dht->log, "could not allocate %u nodes", MAX_SAVED_DHT_NODES);
        return;
    }

    uint32_t num = 0;

    if (dht->loaded_num_nodes > 0) {
        memcpy(clients, dht->loaded_nodes_list, sizeof(Node_format) * dht->loaded_num_nodes);
        num += dht->loaded_num_nodes;
    }

    for (uint32_t i = 0; i < LCLIENT_LIST; ++i) {
        if (dht->close_clientlist[i].assoc4.timestamp != 0) {
            memcpy(clients[num].public_key, dht->close_clientlist[i].public_key, CRYPTO_PUBLIC_KEY_SIZE);
            clients[num].ip_port = dht->close_clientlist[i].assoc4.ip_port;
            ++num;
        }

        if (dht->close_clientlist[i].assoc6.timestamp != 0) {
            memcpy(clients[num].public_key, dht->close_clientlist[i].public_key, CRYPTO_PUBLIC_KEY_SIZE);
            clients[num].ip_port = dht->close_clientlist[i].assoc6.ip_port;
            ++num;
        }
    }

    for (uint32_t i = 0; i < DHT_FAKE_FRIEND_NUMBER && i < dht->num_friends; ++i) {
        const DHT_Friend *const fr = &dht->friends_list[i];

        for (uint32_t j = 0; j < MAX_FRIEND_CLIENTS; ++j) {
            if (fr->client_list[j].assoc4.timestamp != 0) {
                memcpy(clients[num].public_key, fr->client_list[j].public_key, CRYPTO_PUBLIC_KEY_SIZE);
                clients[num].ip_port = fr->client_list[j].assoc4.ip_port;
                ++num;
            }

            if (fr->client_list[j].assoc6.timestamp != 0) {
                memcpy(clients[num].public_key, fr->client_list[j].public_key, CRYPTO_PUBLIC_KEY_SIZE);
                clients[num].ip_port = fr->client_list[j].assoc6.ip_port;
                ++num;
            }
        }
    }

    state_write_section_header(old_data, DHT_STATE_COOKIE_TYPE, pack_nodes(dht->log, data, sizeof(Node_format) * num,
                               clients, num), DHT_STATE_TYPE_NODES);

    free(clients);
}

/** Bootstrap from this number of nodes every time `dht_connect_after_load()` is called */
#define SAVE_BOOTSTAP_FREQUENCY 8

/** @brief Start sending packets after DHT loaded_friends_list and loaded_clients_list are set.
 *
 * @retval 0 if successful
 * @retval -1 otherwise
 */
int dht_connect_after_load(DHT *dht)
{
    if (dht == nullptr) {
        return -1;
    }

    if (dht->loaded_nodes_list == nullptr) {
        return -1;
    }

    /* DHT is connected, stop. */
    if (dht_non_lan_connected(dht)) {
        free(dht->loaded_nodes_list);
        dht->loaded_nodes_list = nullptr;
        dht->loaded_num_nodes = 0;
        return 0;
    }

    for (uint32_t i = 0; i < dht->loaded_num_nodes && i < SAVE_BOOTSTAP_FREQUENCY; ++i) {
        const unsigned int index = dht->loaded_nodes_index % dht->loaded_num_nodes;
        dht_bootstrap(dht, &dht->loaded_nodes_list[index].ip_port, dht->loaded_nodes_list[index].public_key);
        ++dht->loaded_nodes_index;
    }

    return 0;
}

non_null()
static State_Load_Status dht_load_state_callback(void *outer, const uint8_t *data, uint32_t length, uint16_t type)
{
    DHT *dht = (DHT *)outer;

    switch (type) {
        case DHT_STATE_TYPE_NODES: {
            if (length == 0) {
                break;
            }

            free(dht->loaded_nodes_list);
            // Copy to loaded_clients_list
            dht->loaded_nodes_list = (Node_format *)calloc(MAX_SAVED_DHT_NODES, sizeof(Node_format));

            if (dht->loaded_nodes_list == nullptr) {
                LOGGER_ERROR(dht->log, "could not allocate %u nodes", MAX_SAVED_DHT_NODES);
                dht->loaded_num_nodes = 0;
                break;
            }

            const int num = unpack_nodes(dht->loaded_nodes_list, MAX_SAVED_DHT_NODES, nullptr, data, length, false);

            if (num > 0) {
                dht->loaded_num_nodes = num;
            } else {
                dht->loaded_num_nodes = 0;
            }

            break;
        }

        default: {
            LOGGER_ERROR(dht->log, "Load state (DHT): contains unrecognized part (len %u, type %u)",
                         length, type);
            break;
        }
    }

    return STATE_LOAD_STATUS_CONTINUE;
}

/** @brief Load the DHT from data of size size.
 *
 * @retval -1 if failure.
 * @retval 0 if success.
 */
int dht_load(DHT *dht, const uint8_t *data, uint32_t length)
{
    const uint32_t cookie_len = sizeof(uint32_t);

    if (length > cookie_len) {
        uint32_t data32;
        lendian_bytes_to_host32(&data32, data);

        if (data32 == DHT_STATE_COOKIE_GLOBAL) {
            return state_load(dht->log, dht_load_state_callback, dht, data + cookie_len,
                              length - cookie_len, DHT_STATE_COOKIE_TYPE);
        }
    }

    return -1;
}

/**
 * @retval false if we are not connected to the DHT.
 * @retval true if we are.
 */
bool dht_isconnected(const DHT *dht)
{
    for (uint32_t i = 0; i < LCLIENT_LIST; ++i) {
        const Client_data *const client = &dht->close_clientlist[i];

        if (!assoc_timeout(dht->cur_time, &client->assoc4) ||
                !assoc_timeout(dht->cur_time, &client->assoc6)) {
            return true;
        }
    }

    return false;
}

/**
 * @retval false if we are not connected or only connected to lan peers with the DHT.
 * @retval true if we are.
 */
bool dht_non_lan_connected(const DHT *dht)
{
    for (uint32_t i = 0; i < LCLIENT_LIST; ++i) {
        const Client_data *const client = &dht->close_clientlist[i];

        if (!assoc_timeout(dht->cur_time, &client->assoc4)
                && !ip_is_lan(&client->assoc4.ip_port.ip)) {
            return true;
        }

        if (!assoc_timeout(dht->cur_time, &client->assoc6)
                && !ip_is_lan(&client->assoc6.ip_port.ip)) {
            return true;
        }
    }

    return false;
}

/** @brief Copies our own ip_port structure to `dest`.
 *
 * WAN addresses take priority over LAN addresses.
 *
 * This function will zero the `dest` buffer before use.
 *
 * @retval 0 if our ip port can't be found (this usually means we're not connected to the DHT).
 * @retval 1 if IP is a WAN address.
 * @retval 2 if IP is a LAN address.
 */
unsigned int ipport_self_copy(const DHT *dht, IP_Port *dest)
{
    ipport_reset(dest);

    bool is_lan = false;

    for (uint32_t i = 0; i < LCLIENT_LIST; ++i) {
        const Client_data *client = dht_get_close_client(dht, i);
        const IP_Port *ip_port4 = &client->assoc4.ret_ip_port;

        if (client->assoc4.ret_ip_self && ipport_isset(ip_port4)) {
            ipport_copy(dest, ip_port4);
            is_lan = ip_is_lan(&dest->ip);

            if (!is_lan) {
                break;
            }
        }

        const IP_Port *ip_port6 = &client->assoc6.ret_ip_port;

        if (client->assoc6.ret_ip_self && ipport_isset(ip_port6)) {
            ipport_copy(dest, ip_port6);
            is_lan = ip_is_lan(&dest->ip);

            if (!is_lan) {
                break;
            }
        }
    }

    if (!ipport_isset(dest)) {
        return 0;
    }

    if (is_lan) {
        return 2;
    }

    return 1;
}
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2019-2022 The TokTok team.
 */


#include <assert.h>
#include <stdlib.h>
#include <string.h>


struct Forwarding {
    const Logger *log;
    const Random *rng;
    DHT *dht;
    const Mono_Time *mono_time;
    Networking_Core *net;

    uint8_t hmac_key[CRYPTO_HMAC_KEY_SIZE];

    forward_reply_cb *forward_reply_callback;
    void *forward_reply_callback_object;

    forwarded_request_cb *forwarded_request_callback;
    void *forwarded_request_callback_object;

    forwarded_response_cb *forwarded_response_callback;
    void *forwarded_response_callback_object;
};

DHT *forwarding_get_dht(Forwarding *forwarding)
{
    return forwarding->dht;
}

#define SENDBACK_TIMEOUT 3600

bool send_forward_request(Networking_Core *net, const IP_Port *forwarder,
                          const uint8_t *chain_keys, uint16_t chain_length,
                          const uint8_t *data, uint16_t data_length)
{
    if (chain_length == 0 || chain_length > MAX_FORWARD_CHAIN_LENGTH
            || data_length > MAX_FORWARD_DATA_SIZE) {
        return false;
    }

    const uint16_t len = forward_chain_packet_size(chain_length, data_length);
    VLA(uint8_t, packet, len);

    return create_forward_chain_packet(chain_keys, chain_length, data, data_length, packet)
           && sendpacket(net, forwarder, packet, len) == len;
}

uint16_t forward_chain_packet_size(uint16_t chain_length, uint16_t data_length)
{
    return chain_length * (1 + CRYPTO_PUBLIC_KEY_SIZE) + data_length;
}

bool create_forward_chain_packet(const uint8_t *chain_keys, uint16_t chain_length,
                                 const uint8_t *data, uint16_t data_length,
                                 uint8_t *packet)
{
    if (chain_length == 0 || chain_length > MAX_FORWARD_CHAIN_LENGTH
            || data_length > MAX_FORWARD_DATA_SIZE) {
        return false;
    }

    uint16_t offset = 0;

    for (uint16_t j = 0; j < chain_length; ++j) {
        packet[offset] = NET_PACKET_FORWARD_REQUEST;
        ++offset;
        memcpy(packet + offset, chain_keys + j * CRYPTO_PUBLIC_KEY_SIZE, CRYPTO_PUBLIC_KEY_SIZE);
        offset += CRYPTO_PUBLIC_KEY_SIZE;
    }

    memcpy(packet + offset, data, data_length);
    return true;
}

non_null()
static uint16_t forwarding_packet_length(uint16_t sendback_data_len, uint16_t data_length)
{
    const uint16_t sendback_len = sendback_data_len == 0 ? 0 : TIMED_AUTH_SIZE + sendback_data_len;
    return 1 + 1 + sendback_len + data_length;
}

non_null(1, 4, 6) nullable(2)
static bool create_forwarding_packet(const Forwarding *forwarding,
                                     const uint8_t *sendback_data, uint16_t sendback_data_len,
                                     const uint8_t *data, uint16_t length,
                                     uint8_t *packet)
{
    packet[0] = NET_PACKET_FORWARDING;

    if (sendback_data_len == 0) {
        packet[1] = 0;
        memcpy(packet + 1 + 1, data, length);
    } else {
        const uint16_t sendback_len = TIMED_AUTH_SIZE + sendback_data_len;

        if (sendback_len > MAX_SENDBACK_SIZE) {
            return false;
        }

        packet[1] = sendback_len;
        generate_timed_auth(forwarding->mono_time, SENDBACK_TIMEOUT, forwarding->hmac_key, sendback_data,
                            sendback_data_len, packet + 1 + 1);

        if (sendback_data_len != 0) {
            assert(sendback_data != nullptr);
            memcpy(packet + 1 + 1 + TIMED_AUTH_SIZE, sendback_data, sendback_data_len);
        }

        memcpy(packet + 1 + 1 + sendback_len, data, length);
    }

    return true;
}

bool send_forwarding(const Forwarding *forwarding, const IP_Port *dest,
                     const uint8_t *sendback_data, uint16_t sendback_data_len,
                     const uint8_t *data, uint16_t length)
{
    if (length > MAX_FORWARD_DATA_SIZE) {
        return false;
    }

    const uint16_t len = forwarding_packet_length(sendback_data_len, length);
    VLA(uint8_t, packet, len);
    create_forwarding_packet(forwarding, sendback_data, sendback_data_len, data, length, packet);
    return sendpacket(forwarding->net, dest, packet, len) == len;
}

#define FORWARD_REQUEST_MIN_PACKET_SIZE (1 + CRYPTO_PUBLIC_KEY_SIZE)

non_null(1) nullable(2, 4)
static bool handle_forward_request_dht(const Forwarding *forwarding,
                                       const uint8_t *sendback_data, uint16_t sendback_data_len,
                                       const uint8_t *packet, uint16_t length)
{
    if (length < FORWARD_REQUEST_MIN_PACKET_SIZE) {
        return false;
    }

    const uint8_t *const public_key = packet + 1;
    const uint8_t *const forward_data = packet + (1 + CRYPTO_PUBLIC_KEY_SIZE);
    const uint16_t forward_data_len = length - (1 + CRYPTO_PUBLIC_KEY_SIZE);

    if (TIMED_AUTH_SIZE + sendback_data_len > MAX_SENDBACK_SIZE ||
            forward_data_len > MAX_FORWARD_DATA_SIZE) {
        return false;
    }

    const uint16_t len = forwarding_packet_length(sendback_data_len, forward_data_len);
    VLA(uint8_t, forwarding_packet, len);

    create_forwarding_packet(forwarding, sendback_data, sendback_data_len, forward_data, forward_data_len,
                             forwarding_packet);

    return route_packet(forwarding->dht, public_key, forwarding_packet, len) == len;
}

non_null(1, 2) nullable(3, 5)
static int handle_forward_request(void *object, const IP_Port *source, const uint8_t *packet, uint16_t length,
                                  void *userdata)
{
    const Forwarding *forwarding = (const Forwarding *)object;

    uint8_t sendback_data[1 + MAX_PACKED_IPPORT_SIZE];
    sendback_data[0] = SENDBACK_IPPORT;

    const int ipport_length = pack_ip_port(forwarding->log, sendback_data + 1, MAX_PACKED_IPPORT_SIZE, source);

    if (ipport_length == -1) {
        return 1;
    }

    return handle_forward_request_dht(forwarding, sendback_data, 1 + ipport_length, packet, length) ? 0 : 1;
}

#define MIN_NONEMPTY_SENDBACK_SIZE TIMED_AUTH_SIZE
#define FORWARD_REPLY_MIN_PACKET_SIZE (1 + 1 + MIN_NONEMPTY_SENDBACK_SIZE)

non_null(1, 2) nullable(3, 5)
static int handle_forward_reply(void *object, const IP_Port *source, const uint8_t *packet, uint16_t length,
                                void *userdata)
{
    const Forwarding *forwarding = (const Forwarding *)object;

    if (length < FORWARD_REPLY_MIN_PACKET_SIZE) {
        return 1;
    }

    const uint8_t sendback_len = packet[1];
    const uint8_t *const sendback_auth = packet + 1 + 1;
    const uint8_t *const sendback_data = sendback_auth + TIMED_AUTH_SIZE;

    if (sendback_len > MAX_SENDBACK_SIZE) {
        /* value 0xff is reserved for possible future expansion */
        return 1;
    }

    if (sendback_len < TIMED_AUTH_SIZE + 1) {
        return 1;
    }

    const uint16_t sendback_data_len = sendback_len - TIMED_AUTH_SIZE;

    if (length < 1 + 1 + sendback_len) {
        return 1;
    }

    const uint8_t *const to_forward = packet + (1 + 1 + sendback_len);
    const uint16_t to_forward_len = length - (1 + 1 + sendback_len);

    if (!check_timed_auth(forwarding->mono_time, SENDBACK_TIMEOUT, forwarding->hmac_key, sendback_data, sendback_data_len,
                          sendback_auth)) {
        return 1;
    }

    if (sendback_data[0] == SENDBACK_IPPORT) {
        IP_Port dest;

        if (unpack_ip_port(&dest, sendback_data + 1, sendback_data_len - 1, false)
                != sendback_data_len - 1) {
            return 1;
        }

        return send_forwarding(forwarding, &dest, nullptr, 0, to_forward, to_forward_len) ? 0 : 1;
    }

    if (sendback_data[0] == SENDBACK_FORWARD) {
        IP_Port forwarder;
        const int ipport_length = unpack_ip_port(&forwarder, sendback_data + 1, sendback_data_len - 1, false);

        if (ipport_length == -1) {
            return 1;
        }

        const uint8_t *const forward_sendback = sendback_data + (1 + ipport_length);
        const uint16_t forward_sendback_len = sendback_data_len - (1 + ipport_length);

        return forward_reply(forwarding->net, &forwarder, forward_sendback, forward_sendback_len, to_forward,
                             to_forward_len) ? 0 : 1;
    }

    if (forwarding->forward_reply_callback == nullptr) {
        return 1;
    }

    return forwarding->forward_reply_callback(forwarding->forward_reply_callback_object,
            sendback_data, sendback_data_len,
            to_forward, to_forward_len) ? 0 : 1;
}

#define FORWARDING_MIN_PACKET_SIZE (1 + 1)

non_null(1, 2) nullable(3, 5)
static int handle_forwarding(void *object, const IP_Port *source, const uint8_t *packet, uint16_t length,
                             void *userdata)
{
    const Forwarding *forwarding = (const Forwarding *)object;

    if (length < FORWARDING_MIN_PACKET_SIZE) {
        return 1;
    }

    const uint8_t sendback_len = packet[1];

    if (length < 1 + 1 + sendback_len) {
        return 1;
    }

    const uint8_t *const sendback = packet + 1 + 1;

    const uint8_t *const forwarded = sendback + sendback_len;
    const uint16_t forwarded_len = length - (1 + 1 + sendback_len);

    if (forwarded_len >= 1 && forwarded[0] == NET_PACKET_FORWARD_REQUEST) {
        VLA(uint8_t, sendback_data, 1 + MAX_PACKED_IPPORT_SIZE + sendback_len);
        sendback_data[0] = SENDBACK_FORWARD;

        const int ipport_length = pack_ip_port(forwarding->log, sendback_data + 1, MAX_PACKED_IPPORT_SIZE, source);

        if (ipport_length == -1) {
            return 1;
        }

        memcpy(sendback_data + 1 + ipport_length, sendback, sendback_len);

        return handle_forward_request_dht(forwarding, sendback_data, 1 + ipport_length + sendback_len, forwarded,
                                          forwarded_len) ? 0 : 1;
    }

    if (sendback_len > 0) {
        if (forwarding->forwarded_request_callback == nullptr) {
            return 1;
        }

        forwarding->forwarded_request_callback(forwarding->forwarded_request_callback_object,
                                               source, sendback, sendback_len,
                                               forwarded, forwarded_len, userdata);
        return 0;
    } else {
        if (forwarding->forwarded_response_callback == nullptr) {
            return 1;
        }

        forwarding->forwarded_response_callback(forwarding->forwarded_response_callback_object,
                                                forwarded, forwarded_len, userdata);
        return 0;
    }
}

bool forward_reply(Networking_Core *net, const IP_Port *forwarder,
                   const uint8_t *sendback, uint16_t sendback_length,
                   const uint8_t *data, uint16_t length)
{
    if (sendback_length > MAX_SENDBACK_SIZE ||
            length > MAX_FORWARD_DATA_SIZE) {
        return false;
    }

    const uint16_t len = 1 + 1 + sendback_length + length;
    VLA(uint8_t, packet, len);
    packet[0] = NET_PACKET_FORWARD_REPLY;
    packet[1] = (uint8_t) sendback_length;
    memcpy(packet + 1 + 1, sendback, sendback_length);
    memcpy(packet + 1 + 1 + sendback_length, data, length);
    return sendpacket(net, forwarder, packet, len) == len;
}

void set_callback_forwarded_request(Forwarding *forwarding, forwarded_request_cb *function, void *object)
{
    forwarding->forwarded_request_callback = function;
    forwarding->forwarded_request_callback_object = object;
}

void set_callback_forwarded_response(Forwarding *forwarding, forwarded_response_cb *function, void *object)
{
    forwarding->forwarded_response_callback = function;
    forwarding->forwarded_response_callback_object = object;
}

void set_callback_forward_reply(Forwarding *forwarding, forward_reply_cb *function, void *object)
{
    forwarding->forward_reply_callback = function;
    forwarding->forward_reply_callback_object = object;
}

Forwarding *new_forwarding(const Logger *log, const Random *rng, const Mono_Time *mono_time, DHT *dht)
{
    if (log == nullptr || mono_time == nullptr || dht == nullptr) {
        return nullptr;
    }

    Forwarding *forwarding = (Forwarding *)calloc(1, sizeof(Forwarding));

    if (forwarding == nullptr) {
        return nullptr;
    }

    forwarding->log = log;
    forwarding->rng = rng;
    forwarding->mono_time = mono_time;
    forwarding->dht = dht;
    forwarding->net = dht_get_net(dht);

    networking_registerhandler(forwarding->net, NET_PACKET_FORWARD_REQUEST, &handle_forward_request, forwarding);
    networking_registerhandler(forwarding->net, NET_PACKET_FORWARD_REPLY, &handle_forward_reply, forwarding);
    networking_registerhandler(forwarding->net, NET_PACKET_FORWARDING, &handle_forwarding, forwarding);

    new_hmac_key(forwarding->rng, forwarding->hmac_key);

    return forwarding;
}

void kill_forwarding(Forwarding *forwarding)
{
    if (forwarding == nullptr) {
        return;
    }

    networking_registerhandler(forwarding->net, NET_PACKET_FORWARD_REQUEST, nullptr, nullptr);
    networking_registerhandler(forwarding->net, NET_PACKET_FORWARD_REPLY, nullptr, nullptr);
    networking_registerhandler(forwarding->net, NET_PACKET_FORWARDING, nullptr, nullptr);

    crypto_memzero(forwarding->hmac_key, CRYPTO_HMAC_KEY_SIZE);

    free(forwarding);
}
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2018 The TokTok team.
 * Copyright © 2014 Tox project.
 */

/**
 * Connection to friends.
 */

#include <stdlib.h>
#include <string.h>


#define PORTS_PER_DISCOVERY 10

#ifdef NOGLOBALVARS
static bool global_force_udp_only_mode = false;
#else
extern bool global_force_udp_only_mode;
#endif

typedef struct Friend_Conn_Callbacks {
    fc_status_cb *status_callback;
    fc_data_cb *data_callback;
    fc_lossy_data_cb *lossy_data_callback;

    void *callback_object;
    int callback_id;
} Friend_Conn_Callbacks;

struct Friend_Conn {
    uint8_t status;

    uint8_t real_public_key[CRYPTO_PUBLIC_KEY_SIZE];
    uint8_t dht_temp_pk[CRYPTO_PUBLIC_KEY_SIZE];
    uint32_t dht_lock_token;
    IP_Port dht_ip_port;
    uint64_t dht_pk_lastrecv;
    uint64_t dht_ip_port_lastrecv;

    int onion_friendnum;
    int crypt_connection_id;

    uint64_t ping_lastrecv;
    uint64_t ping_lastsent;
    uint64_t share_relays_lastsent;

    Friend_Conn_Callbacks callbacks[MAX_FRIEND_CONNECTION_CALLBACKS];

    uint16_t lock_count;

    Node_format tcp_relays[FRIEND_MAX_STORED_TCP_RELAYS];
    uint16_t tcp_relay_counter;
    uint32_t tcp_relay_share_index;

    bool hosting_tcp_relay;
};

static const Friend_Conn empty_friend_conn = {0};


struct Friend_Connections {
    const Mono_Time *mono_time;
    const Logger *logger;
    Net_Crypto *net_crypto;
    DHT *dht;
    Broadcast_Info *broadcast;
    Onion_Client *onion_c;

    Friend_Conn *conns;
    uint32_t num_cons;

    fr_request_cb *fr_request_callback;
    void *fr_request_object;

    global_status_cb *global_status_callback;
    void *global_status_callback_object;

    uint64_t last_lan_discovery;
    uint16_t next_lan_port;

    bool local_discovery_enabled;
};

int friend_conn_get_onion_friendnum(const Friend_Conn *fc)
{
    return fc->onion_friendnum;
}

Net_Crypto *friendconn_net_crypto(const Friend_Connections *fr_c)
{
    return fr_c->net_crypto;
}

const IP_Port *friend_conn_get_dht_ip_port(const Friend_Conn *fc)
{
    return &fc->dht_ip_port;
}


/**
 * @retval true if the friendcon_id is valid.
 * @retval false if the friendcon_id is not valid.
 */
non_null()
static bool friendconn_id_valid(const Friend_Connections *fr_c, int friendcon_id)
{
    return (unsigned int)friendcon_id < fr_c->num_cons &&
           fr_c->conns != nullptr &&
           fr_c->conns[friendcon_id].status != FRIENDCONN_STATUS_NONE;
}


/** @brief Set the size of the friend connections list to num.
 *
 * @retval false if realloc fails.
 * @retval true if it succeeds.
 */
non_null()
static bool realloc_friendconns(Friend_Connections *fr_c, uint32_t num)
{
    if (num == 0) {
        free(fr_c->conns);
        fr_c->conns = nullptr;
        return true;
    }

    Friend_Conn *newgroup_cons = (Friend_Conn *)realloc(fr_c->conns, num * sizeof(Friend_Conn));

    if (newgroup_cons == nullptr) {
        return false;
    }

    fr_c->conns = newgroup_cons;
    return true;
}

/** @brief Create a new empty friend connection.
 *
 * @retval -1 on failure.
 * @return friendcon_id on success.
 */
non_null()
static int create_friend_conn(Friend_Connections *fr_c)
{
    for (uint32_t i = 0; i < fr_c->num_cons; ++i) {
        if (fr_c->conns[i].status == FRIENDCONN_STATUS_NONE) {
            return i;
        }
    }

    if (!realloc_friendconns(fr_c, fr_c->num_cons + 1)) {
        return -1;
    }

    const int id = fr_c->num_cons;
    ++fr_c->num_cons;
    fr_c->conns[id] = empty_friend_conn;

    return id;
}

/** @brief Wipe a friend connection.
 *
 * @retval -1 on failure.
 * @retval 0 on success.
 */
non_null()
static int wipe_friend_conn(Friend_Connections *fr_c, int friendcon_id)
{
    if (!friendconn_id_valid(fr_c, friendcon_id)) {
        return -1;
    }

    fr_c->conns[friendcon_id] = empty_friend_conn;

    uint32_t i;

    for (i = fr_c->num_cons; i != 0; --i) {
        if (fr_c->conns[i - 1].status != FRIENDCONN_STATUS_NONE) {
            break;
        }
    }

    if (fr_c->num_cons != i) {
        fr_c->num_cons = i;
        realloc_friendconns(fr_c, fr_c->num_cons);
    }

    return 0;
}

Friend_Conn *get_conn(const Friend_Connections *fr_c, int friendcon_id)
{
    if (!friendconn_id_valid(fr_c, friendcon_id)) {
        return nullptr;
    }

    return &fr_c->conns[friendcon_id];
}

/**
 * @return friendcon_id corresponding to the real public key on success.
 * @retval -1 on failure.
 */
int getfriend_conn_id_pk(const Friend_Connections *fr_c, const uint8_t *real_pk)
{
    for (uint32_t i = 0; i < fr_c->num_cons; ++i) {
        const Friend_Conn *friend_con = get_conn(fr_c, i);

        if (friend_con != nullptr) {
            if (pk_equal(friend_con->real_public_key, real_pk)) {
                return i;
            }
        }
    }

    return -1;
}

/** @brief Add a TCP relay associated to the friend.
 *
 * @retval -1 on failure.
 * @retval 0 on success.
 */
non_null()
static int friend_add_tcp_relay(Friend_Connections *fr_c, int friendcon_id, const IP_Port *ip_port,
                                const uint8_t *public_key)
{
    if (!global_force_udp_only_mode) {
        IP_Port ipp_copy = *ip_port;

        Friend_Conn *const friend_con = get_conn(fr_c, friendcon_id);

        if (friend_con == nullptr) {
            return -1;
        }

        /* Local ip and same pk means that they are hosting a TCP relay. */
        if (ip_is_local(&ipp_copy.ip) && pk_equal(friend_con->dht_temp_pk, public_key)) {
            if (!net_family_is_unspec(friend_con->dht_ip_port.ip.family)) {
                ipp_copy.ip = friend_con->dht_ip_port.ip;
            } else {
                friend_con->hosting_tcp_relay = 0;
            }
        }

        const uint16_t index = friend_con->tcp_relay_counter % FRIEND_MAX_STORED_TCP_RELAYS;

        for (unsigned i = 0; i < FRIEND_MAX_STORED_TCP_RELAYS; ++i) {
            if (!net_family_is_unspec(friend_con->tcp_relays[i].ip_port.ip.family)
                    && pk_equal(friend_con->tcp_relays[i].public_key, public_key)) {
                friend_con->tcp_relays[i] = empty_node_format;
            }
        }

        friend_con->tcp_relays[index].ip_port = ipp_copy;
        memcpy(friend_con->tcp_relays[index].public_key, public_key, CRYPTO_PUBLIC_KEY_SIZE);
        ++friend_con->tcp_relay_counter;

        return add_tcp_relay_peer(fr_c->net_crypto, friend_con->crypt_connection_id, &ipp_copy, public_key);
    } else {
        return -1;
    }
}

/** Connect to number saved relays for friend. */
non_null()
static void connect_to_saved_tcp_relays(Friend_Connections *fr_c, int friendcon_id, unsigned int number)
{
    const Friend_Conn *const friend_con = get_conn(fr_c, friendcon_id);

    if (friend_con == nullptr) {
        return;
    }

    for (unsigned i = 0; (i < FRIEND_MAX_STORED_TCP_RELAYS) && (number != 0); ++i) {
        const uint16_t index = (friend_con->tcp_relay_counter - (i + 1)) % FRIEND_MAX_STORED_TCP_RELAYS;

        if (!net_family_is_unspec(friend_con->tcp_relays[index].ip_port.ip.family)) {
            if (add_tcp_relay_peer(fr_c->net_crypto, friend_con->crypt_connection_id, &friend_con->tcp_relays[index].ip_port,
                                   friend_con->tcp_relays[index].public_key) == 0) {
                --number;
            }
        }
    }
}

non_null()
static unsigned int send_relays(Friend_Connections *fr_c, int friendcon_id)
{
    if (!global_force_udp_only_mode) {
        Friend_Conn *const friend_con = get_conn(fr_c, friendcon_id);

        if (friend_con == nullptr) {
            return 0;
        }

        Node_format nodes[MAX_SHARED_RELAYS] = {{{0}}};
        uint8_t data[1024];

        const uint32_t n = copy_connected_tcp_relays_index(fr_c->net_crypto, nodes, MAX_SHARED_RELAYS,
                           friend_con->tcp_relay_share_index);

        friend_con->tcp_relay_share_index += MAX_SHARED_RELAYS;

        for (uint32_t i = 0; i < n; ++i) {
            /* Associated the relays being sent with this connection.
             * On receiving the peer will do the same which will establish the connection. */
            friend_add_tcp_relay(fr_c, friendcon_id, &nodes[i].ip_port, nodes[i].public_key);
        }

        int length = pack_nodes(fr_c->logger, data + 1, sizeof(data) - 1, nodes, n);

        if (length <= 0) {
            return 0;
        }

        data[0] = PACKET_ID_SHARE_RELAYS;
        ++length;

        if (write_cryptpacket(fr_c->net_crypto, friend_con->crypt_connection_id, data, length, false) != -1) {
            friend_con->share_relays_lastsent = mono_time_get(fr_c->mono_time);
            return 1;
        }

        return 0;
    } else {
        return 1;
    }
}

/** callback for recv TCP relay nodes. */
non_null()
static int tcp_relay_node_callback(void *object, uint32_t number, const IP_Port *ip_port, const uint8_t *public_key)
{
    if (!global_force_udp_only_mode) {
        Friend_Connections *fr_c = (Friend_Connections *)object;
        const Friend_Conn *friend_con = get_conn(fr_c, number);

        if (friend_con == nullptr) {
            return -1;
        }

        if (friend_con->crypt_connection_id != -1) {
            return friend_add_tcp_relay(fr_c, number, ip_port, public_key);
        }

        return add_tcp_relay(fr_c->net_crypto, ip_port, public_key);
    } else {
        return -1;
    }
}

non_null()
static int friend_new_connection(Friend_Connections *fr_c, int friendcon_id);

/** Callback for DHT ip_port changes. */
non_null()
static void dht_ip_callback(void *object, int32_t number, const IP_Port *ip_port)
{
    Friend_Connections *const fr_c = (Friend_Connections *)object;
    Friend_Conn *const friend_con = get_conn(fr_c, number);

    if (friend_con == nullptr) {
        return;
    }

    if (friend_con->crypt_connection_id == -1) {
        friend_new_connection(fr_c, number);
    }

    set_direct_ip_port(fr_c->net_crypto, friend_con->crypt_connection_id, ip_port, true);
    friend_con->dht_ip_port = *ip_port;
    friend_con->dht_ip_port_lastrecv = mono_time_get(fr_c->mono_time);

    if (friend_con->hosting_tcp_relay) {
        friend_add_tcp_relay(fr_c, number, ip_port, friend_con->dht_temp_pk);
        friend_con->hosting_tcp_relay = 0;
    }
}

non_null()
static void change_dht_pk(Friend_Connections *fr_c, int friendcon_id, const uint8_t *dht_public_key)
{
    Friend_Conn *const friend_con = get_conn(fr_c, friendcon_id);

    if (friend_con == nullptr) {
        return;
    }

    friend_con->dht_pk_lastrecv = mono_time_get(fr_c->mono_time);

    if (friend_con->dht_lock_token > 0) {
        if (dht_delfriend(fr_c->dht, friend_con->dht_temp_pk, friend_con->dht_lock_token) != 0) {
            LOGGER_ERROR(fr_c->logger, "a. Could not delete dht peer. Please report this.");
            return;
        }
        friend_con->dht_lock_token = 0;
    }

    dht_addfriend(fr_c->dht, dht_public_key, dht_ip_callback, fr_c, friendcon_id, &friend_con->dht_lock_token);
    memcpy(friend_con->dht_temp_pk, dht_public_key, CRYPTO_PUBLIC_KEY_SIZE);
}

non_null()
static int handle_status(void *object, int number, bool status, void *userdata)
{
    Friend_Connections *const fr_c = (Friend_Connections *)object;
    Friend_Conn *const friend_con = get_conn(fr_c, number);

    if (friend_con == nullptr) {
        return -1;
    }

    bool status_changed = false;

    if (status) {  /* Went online. */
        status_changed = true;
        friend_con->status = FRIENDCONN_STATUS_CONNECTED;
        friend_con->ping_lastrecv = mono_time_get(fr_c->mono_time);
        friend_con->share_relays_lastsent = 0;
        onion_set_friend_online(fr_c->onion_c, friend_con->onion_friendnum, status);
    } else {  /* Went offline. */
        if (friend_con->status != FRIENDCONN_STATUS_CONNECTING) {
            status_changed = true;
            friend_con->dht_pk_lastrecv = mono_time_get(fr_c->mono_time);
            onion_set_friend_online(fr_c->onion_c, friend_con->onion_friendnum, status);
        }

        friend_con->status = FRIENDCONN_STATUS_CONNECTING;
        friend_con->crypt_connection_id = -1;
        friend_con->hosting_tcp_relay = 0;
    }

    if (status_changed) {
        if (fr_c->global_status_callback != nullptr) {
            fr_c->global_status_callback(fr_c->global_status_callback_object, number, status, userdata);
        }

        for (unsigned i = 0; i < MAX_FRIEND_CONNECTION_CALLBACKS; ++i) {
            if (friend_con->callbacks[i].status_callback != nullptr) {
                friend_con->callbacks[i].status_callback(
                    friend_con->callbacks[i].callback_object,
                    friend_con->callbacks[i].callback_id, status, userdata);
            }
        }
    }

    return 0;
}

/** Callback for dht public key changes. */
non_null()
static void dht_pk_callback(void *object, int32_t number, const uint8_t *dht_public_key, void *userdata)
{
    Friend_Connections *const fr_c = (Friend_Connections *)object;
    Friend_Conn *const friend_con = get_conn(fr_c, number);

    if (friend_con == nullptr) {
        return;
    }

    if (pk_equal(friend_con->dht_temp_pk, dht_public_key)) {
        return;
    }

    change_dht_pk(fr_c, number, dht_public_key);

    /* if pk changed, create a new connection.*/
    if (friend_con->crypt_connection_id != -1) {
        crypto_kill(fr_c->net_crypto, friend_con->crypt_connection_id);
        friend_con->crypt_connection_id = -1;
        handle_status(object, number, false, userdata); /* Going offline. */
    }

    friend_new_connection(fr_c, number);
    onion_set_friend_DHT_pubkey(fr_c->onion_c, friend_con->onion_friendnum, dht_public_key);
}

non_null()
static int handle_packet(void *object, int number, const uint8_t *data, uint16_t length, void *userdata)
{
    if (length == 0) {
        return -1;
    }

    Friend_Connections *const fr_c = (Friend_Connections *)object;
    Friend_Conn *friend_con = get_conn(fr_c, number);

    if (friend_con == nullptr) {
        return -1;
    }

    if (data[0] == PACKET_ID_FRIEND_REQUESTS) {
        if (fr_c->fr_request_callback != nullptr) {
            fr_c->fr_request_callback(fr_c->fr_request_object, friend_con->real_public_key, data, length, userdata);
        }

        return 0;
    }

    if (data[0] == PACKET_ID_ALIVE) {
        friend_con->ping_lastrecv = mono_time_get(fr_c->mono_time);
        return 0;
    }

    if (data[0] == PACKET_ID_SHARE_RELAYS) {
        Node_format nodes[MAX_SHARED_RELAYS];
        const int n = unpack_nodes(nodes, MAX_SHARED_RELAYS, nullptr, data + 1, length - 1, true);

        if (n == -1) {
            return -1;
        }

        for (int j = 0; j < n; ++j) {
            friend_add_tcp_relay(fr_c, number, &nodes[j].ip_port, nodes[j].public_key);
        }

        return 0;
    }

    for (unsigned i = 0; i < MAX_FRIEND_CONNECTION_CALLBACKS; ++i) {
        if (friend_con->callbacks[i].data_callback != nullptr) {
            friend_con->callbacks[i].data_callback(
                friend_con->callbacks[i].callback_object,
                friend_con->callbacks[i].callback_id, data, length, userdata);
        }

        friend_con = get_conn(fr_c, number);

        if (friend_con == nullptr) {
            return -1;
        }
    }

    return 0;
}

non_null()
static int handle_lossy_packet(void *object, int number, const uint8_t *data, uint16_t length, void *userdata)
{
    if (length == 0) {
        return -1;
    }

    const Friend_Connections *const fr_c = (const Friend_Connections *)object;
    const Friend_Conn *friend_con = get_conn(fr_c, number);

    if (friend_con == nullptr) {
        return -1;
    }

    for (unsigned i = 0; i < MAX_FRIEND_CONNECTION_CALLBACKS; ++i) {
        if (friend_con->callbacks[i].lossy_data_callback != nullptr) {
            friend_con->callbacks[i].lossy_data_callback(
                friend_con->callbacks[i].callback_object,
                friend_con->callbacks[i].callback_id, data, length, userdata);
        }

        friend_con = get_conn(fr_c, number);

        if (friend_con == nullptr) {
            return -1;
        }
    }

    return 0;
}

non_null()
static int handle_new_connections(void *object, const New_Connection *n_c)
{
    Friend_Connections *const fr_c = (Friend_Connections *)object;
    const int friendcon_id = getfriend_conn_id_pk(fr_c, n_c->public_key);
    Friend_Conn *const friend_con = get_conn(fr_c, friendcon_id);

    if (friend_con == nullptr) {
        return -1;
    }

    if (friend_con->crypt_connection_id != -1) {
        return -1;
    }

    const int id = accept_crypto_connection(fr_c->net_crypto, n_c);

    if (id == -1) {
        return -1;
    }

    connection_status_handler(fr_c->net_crypto, id, &handle_status, fr_c, friendcon_id);
    connection_data_handler(fr_c->net_crypto, id, &handle_packet, fr_c, friendcon_id);
    connection_lossy_data_handler(fr_c->net_crypto, id, &handle_lossy_packet, fr_c, friendcon_id);
    friend_con->crypt_connection_id = id;

    if (!net_family_is_ipv4(n_c->source.ip.family) && !net_family_is_ipv6(n_c->source.ip.family)) {
        set_direct_ip_port(fr_c->net_crypto, friend_con->crypt_connection_id, &friend_con->dht_ip_port, false);
    } else {
        friend_con->dht_ip_port = n_c->source;
        friend_con->dht_ip_port_lastrecv = mono_time_get(fr_c->mono_time);
    }

    if (!pk_equal(friend_con->dht_temp_pk, n_c->dht_public_key)) {
        change_dht_pk(fr_c, friendcon_id, n_c->dht_public_key);
    }

    nc_dht_pk_callback(fr_c->net_crypto, id, &dht_pk_callback, fr_c, friendcon_id);
    return 0;
}

static int friend_new_connection(Friend_Connections *fr_c, int friendcon_id)
{
    Friend_Conn *const friend_con = get_conn(fr_c, friendcon_id);

    if (friend_con == nullptr) {
        return -1;
    }

    if (friend_con->crypt_connection_id != -1) {
        return -1;
    }

    /* If dht_temp_pk does not contains a pk. */
    if (friend_con->dht_lock_token == 0) {
        return -1;
    }

    const int id = new_crypto_connection(fr_c->net_crypto, friend_con->real_public_key, friend_con->dht_temp_pk);

    if (id == -1) {
        return -1;
    }

    friend_con->crypt_connection_id = id;
    connection_status_handler(fr_c->net_crypto, id, &handle_status, fr_c, friendcon_id);
    connection_data_handler(fr_c->net_crypto, id, &handle_packet, fr_c, friendcon_id);
    connection_lossy_data_handler(fr_c->net_crypto, id, &handle_lossy_packet, fr_c, friendcon_id);
    nc_dht_pk_callback(fr_c->net_crypto, id, &dht_pk_callback, fr_c, friendcon_id);

    return 0;
}

non_null()
static int send_ping(const Friend_Connections *fr_c, int friendcon_id)
{
    Friend_Conn *const friend_con = get_conn(fr_c, friendcon_id);

    if (friend_con == nullptr) {
        return -1;
    }

    const uint8_t ping = PACKET_ID_ALIVE;
    const int64_t ret = write_cryptpacket(fr_c->net_crypto, friend_con->crypt_connection_id, &ping, sizeof(ping), false);

    if (ret != -1) {
        friend_con->ping_lastsent = mono_time_get(fr_c->mono_time);
        return 0;
    }

    return -1;
}

/** @brief Increases lock_count for the connection with friendcon_id by 1.
 *
 * @retval 0 on success.
 * @retval -1 on failure.
 */
int friend_connection_lock(const Friend_Connections *fr_c, int friendcon_id)
{
    Friend_Conn *const friend_con = get_conn(fr_c, friendcon_id);

    if (friend_con == nullptr) {
        return -1;
    }

    ++friend_con->lock_count;
    return 0;
}

/**
 * @retval FRIENDCONN_STATUS_CONNECTED if the friend is connected.
 * @retval FRIENDCONN_STATUS_CONNECTING if the friend isn't connected.
 * @retval FRIENDCONN_STATUS_NONE on failure.
 */
unsigned int friend_con_connected(const Friend_Connections *fr_c, int friendcon_id)
{
    const Friend_Conn *const friend_con = get_conn(fr_c, friendcon_id);

    if (friend_con == nullptr) {
        return 0;
    }

    return friend_con->status;
}

/** @brief Copy public keys associated to friendcon_id.
 *
 * @retval 0 on success.
 * @retval -1 on failure.
 */
int get_friendcon_public_keys(uint8_t *real_pk, uint8_t *dht_temp_pk, const Friend_Connections *fr_c, int friendcon_id)
{
    const Friend_Conn *const friend_con = get_conn(fr_c, friendcon_id);

    if (friend_con == nullptr) {
        return -1;
    }

    if (real_pk != nullptr) {
        memcpy(real_pk, friend_con->real_public_key, CRYPTO_PUBLIC_KEY_SIZE);
    }

    if (dht_temp_pk != nullptr) {
        memcpy(dht_temp_pk, friend_con->dht_temp_pk, CRYPTO_PUBLIC_KEY_SIZE);
    }

    return 0;
}

/** Set temp dht key for connection. */
void set_dht_temp_pk(Friend_Connections *fr_c, int friendcon_id, const uint8_t *dht_temp_pk, void *userdata)
{
    dht_pk_callback(fr_c, friendcon_id, dht_temp_pk, userdata);
}

/** @brief Set the callbacks for the friend connection.
 * @param index is the index (0 to (MAX_FRIEND_CONNECTION_CALLBACKS - 1)) we
 *   want the callback to set in the array.
 *
 * @retval 0 on success.
 * @retval -1 on failure
 */
int friend_connection_callbacks(const Friend_Connections *fr_c, int friendcon_id, unsigned int index,
                                fc_status_cb *status_callback,
                                fc_data_cb *data_callback,
                                fc_lossy_data_cb *lossy_data_callback,
                                void *object, int number)
{
    Friend_Conn *const friend_con = get_conn(fr_c, friendcon_id);

    if (friend_con == nullptr) {
        return -1;
    }

    if (index >= MAX_FRIEND_CONNECTION_CALLBACKS) {
        return -1;
    }

    if (object != nullptr && (status_callback == nullptr || data_callback == nullptr || lossy_data_callback == nullptr)) {
        LOGGER_ERROR(fr_c->logger, "non-null user data object but null callbacks");
        return -1;
    }

    friend_con->callbacks[index].status_callback = status_callback;
    friend_con->callbacks[index].data_callback = data_callback;
    friend_con->callbacks[index].lossy_data_callback = lossy_data_callback;

    friend_con->callbacks[index].callback_object = object;
    friend_con->callbacks[index].callback_id = number;

    return 0;
}

/** Set global status callback for friend connections. */
void set_global_status_callback(Friend_Connections *fr_c, global_status_cb *global_status_callback, void *object)
{
    if (object != nullptr && global_status_callback == nullptr) {
        LOGGER_ERROR(fr_c->logger, "non-null user data object but null callback");
        object = nullptr;
    }

    fr_c->global_status_callback = global_status_callback;
    fr_c->global_status_callback_object = object;
}

/** @brief return the crypt_connection_id for the connection.
 *
 * @return crypt_connection_id on success.
 * @retval -1 on failure.
 */
int friend_connection_crypt_connection_id(const Friend_Connections *fr_c, int friendcon_id)
{
    const Friend_Conn *const friend_con = get_conn(fr_c, friendcon_id);

    if (friend_con == nullptr) {
        return -1;
    }

    return friend_con->crypt_connection_id;
}

/** @brief Create a new friend connection.
 * If one to that real public key already exists, increase lock count and return it.
 *
 * @retval -1 on failure.
 * @return connection id on success.
 */
int new_friend_connection(Friend_Connections *fr_c, const uint8_t *real_public_key)
{
    int friendcon_id = getfriend_conn_id_pk(fr_c, real_public_key);

    if (friendcon_id != -1) {
        ++fr_c->conns[friendcon_id].lock_count;
        return friendcon_id;
    }

    friendcon_id = create_friend_conn(fr_c);

    if (friendcon_id == -1) {
        return -1;
    }

    const int32_t onion_friendnum = onion_addfriend(fr_c->onion_c, real_public_key);

    if (onion_friendnum == -1) {
        return -1;
    }

    Friend_Conn *const friend_con = &fr_c->conns[friendcon_id];

    friend_con->crypt_connection_id = -1;
    friend_con->status = FRIENDCONN_STATUS_CONNECTING;
    memcpy(friend_con->real_public_key, real_public_key, CRYPTO_PUBLIC_KEY_SIZE);
    friend_con->onion_friendnum = onion_friendnum;

    recv_tcp_relay_handler(fr_c->onion_c, onion_friendnum, &tcp_relay_node_callback, fr_c, friendcon_id);
    onion_dht_pk_callback(fr_c->onion_c, onion_friendnum, &dht_pk_callback, fr_c, friendcon_id);

    return friendcon_id;
}

/** @brief Kill a friend connection.
 *
 * @retval -1 on failure.
 * @retval 0 on success.
 */
int kill_friend_connection(Friend_Connections *fr_c, int friendcon_id)
{
    Friend_Conn *const friend_con = get_conn(fr_c, friendcon_id);

    if (friend_con == nullptr) {
        return -1;
    }

    if (friend_con->lock_count > 0) {
        --friend_con->lock_count;
        return 0;
    }

    onion_delfriend(fr_c->onion_c, friend_con->onion_friendnum);
    crypto_kill(fr_c->net_crypto, friend_con->crypt_connection_id);

    if (friend_con->dht_lock_token > 0) {
        dht_delfriend(fr_c->dht, friend_con->dht_temp_pk, friend_con->dht_lock_token);
        friend_con->dht_lock_token = 0;
    }

    return wipe_friend_conn(fr_c, friendcon_id);
}


/** @brief Set friend request callback.
 *
 * This function will be called every time a friend request packet is received.
 */
void set_friend_request_callback(Friend_Connections *fr_c, fr_request_cb *fr_request_callback, void *object)
{
    fr_c->fr_request_callback = fr_request_callback;
    fr_c->fr_request_object = object;
    oniondata_registerhandler(fr_c->onion_c, CRYPTO_PACKET_FRIEND_REQ, fr_request_callback, object);
}

/** @brief Send a Friend request packet.
 *
 * @retval -1 if failure.
 * @retval  0 if it sent the friend request directly to the friend.
 * @return the number of peers it was routed through if it did not send it directly.
 */
int send_friend_request_packet(Friend_Connections *fr_c, int friendcon_id, uint32_t nospam_num, const uint8_t *data,
                               uint16_t length)
{
    if (1 + sizeof(nospam_num) + length > ONION_CLIENT_MAX_DATA_SIZE || length == 0) {
        return -1;
    }

    const Friend_Conn *const friend_con = get_conn(fr_c, friendcon_id);

    if (friend_con == nullptr) {
        return -1;
    }

    VLA(uint8_t, packet, 1 + sizeof(nospam_num) + length);
    memcpy(packet + 1, &nospam_num, sizeof(nospam_num));
    memcpy(packet + 1 + sizeof(nospam_num), data, length);

    if (friend_con->status == FRIENDCONN_STATUS_CONNECTED) {
        packet[0] = PACKET_ID_FRIEND_REQUESTS;
        return write_cryptpacket(fr_c->net_crypto, friend_con->crypt_connection_id, packet, SIZEOF_VLA(packet),
                                 false) != -1 ? 1 : 0;
    }

    packet[0] = CRYPTO_PACKET_FRIEND_REQ;
    const int num = send_onion_data(fr_c->onion_c, friend_con->onion_friendnum, packet, SIZEOF_VLA(packet));

    if (num <= 0) {
        return -1;
    }

    return num;
}

/** Create new friend_connections instance. */
Friend_Connections *new_friend_connections(
        const Logger *logger, const Mono_Time *mono_time, const Network *ns,
        Onion_Client *onion_c, bool local_discovery_enabled)
{
    if (onion_c == nullptr) {
        return nullptr;
    }

    Friend_Connections *const temp = (Friend_Connections *)calloc(1, sizeof(Friend_Connections));

    if (temp == nullptr) {
        return nullptr;
    }

    temp->mono_time = mono_time;
    temp->logger = logger;
    temp->dht = onion_get_dht(onion_c);
    temp->net_crypto = onion_get_net_crypto(onion_c);
    temp->onion_c = onion_c;
    temp->local_discovery_enabled = local_discovery_enabled;
    // Don't include default port in port range
    temp->next_lan_port = TOX_PORTRANGE_FROM + 1;

    new_connection_handler(temp->net_crypto, &handle_new_connections, temp);

    if (temp->local_discovery_enabled) {
        temp->broadcast = lan_discovery_init(ns);

        if (temp->broadcast == nullptr) {
            LOGGER_ERROR(logger, "could not initialise LAN discovery");
        }
    }

    return temp;
}

/** Send a LAN discovery packet every LAN_DISCOVERY_INTERVAL seconds. */
non_null()
static void lan_discovery(Friend_Connections *fr_c)
{
    if (fr_c->last_lan_discovery + LAN_DISCOVERY_INTERVAL < mono_time_get(fr_c->mono_time)) {
        const uint16_t first = fr_c->next_lan_port;
        uint16_t last = first + PORTS_PER_DISCOVERY;
        last = last > TOX_PORTRANGE_TO ? TOX_PORTRANGE_TO : last;

        // Always send to default port
        lan_discovery_send(dht_get_net(fr_c->dht), fr_c->broadcast, dht_get_self_public_key(fr_c->dht),
                           net_htons(TOX_PORT_DEFAULT));

        // And check some extra ports
        for (uint16_t port = first; port < last; ++port) {
            lan_discovery_send(dht_get_net(fr_c->dht), fr_c->broadcast, dht_get_self_public_key(fr_c->dht), net_htons(port));
        }

        // Don't include default port in port range
        fr_c->next_lan_port = last != TOX_PORTRANGE_TO ? last : TOX_PORTRANGE_FROM + 1;
        fr_c->last_lan_discovery = mono_time_get(fr_c->mono_time);
    }
}

/** main friend_connections loop. */
void do_friend_connections(Friend_Connections *fr_c, void *userdata)
{
    const uint64_t temp_time = mono_time_get(fr_c->mono_time);

    for (uint32_t i = 0; i < fr_c->num_cons; ++i) {
        Friend_Conn *const friend_con = get_conn(fr_c, i);

        if (friend_con != nullptr) {
            if (friend_con->status == FRIENDCONN_STATUS_CONNECTING) {
                if (friend_con->dht_pk_lastrecv + FRIEND_DHT_TIMEOUT < temp_time) {
                    if (friend_con->dht_lock_token > 0) {
                        dht_delfriend(fr_c->dht, friend_con->dht_temp_pk, friend_con->dht_lock_token);
                        friend_con->dht_lock_token = 0;
                        memset(friend_con->dht_temp_pk, 0, CRYPTO_PUBLIC_KEY_SIZE);
                    }
                }

                if (friend_con->dht_ip_port_lastrecv + FRIEND_DHT_TIMEOUT < temp_time) {
                    friend_con->dht_ip_port.ip.family = net_family_unspec();
                }

                if (friend_con->dht_lock_token > 0) {
                    if (friend_new_connection(fr_c, i) == 0) {
                        set_direct_ip_port(fr_c->net_crypto, friend_con->crypt_connection_id, &friend_con->dht_ip_port, false);
                        connect_to_saved_tcp_relays(fr_c, i, MAX_FRIEND_TCP_CONNECTIONS / 2); /* Only fill it half up. */
                    }
                }
            } else if (friend_con->status == FRIENDCONN_STATUS_CONNECTED) {
                if (friend_con->ping_lastsent + FRIEND_PING_INTERVAL < temp_time) {
                    send_ping(fr_c, i);
                }

                if (friend_con->share_relays_lastsent + SHARE_RELAYS_INTERVAL < temp_time) {
                    send_relays(fr_c, i);
                }

                if (friend_con->ping_lastrecv + FRIEND_CONNECTION_TIMEOUT < temp_time) {
                    /* If we stopped receiving ping packets, kill it. */
                    crypto_kill(fr_c->net_crypto, friend_con->crypt_connection_id);
                    friend_con->crypt_connection_id = -1;
                    handle_status(fr_c, i, false, userdata); /* Going offline. */
                }
            }
        }
    }

    if (fr_c->local_discovery_enabled) {
        lan_discovery(fr_c);
    }
}

/** Free everything related with friend_connections. */
void kill_friend_connections(Friend_Connections *fr_c)
{
    if (fr_c == nullptr) {
        return;
    }

    for (uint32_t i = 0; i < fr_c->num_cons; ++i) {
        kill_friend_connection(fr_c, i);
    }

    lan_discovery_kill(fr_c->broadcast);
    free(fr_c);
}
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2018 The TokTok team.
 * Copyright © 2013 Tox project.
 */

/**
 * Handle friend requests.
 */

#include <stdlib.h>
#include <string.h>


/**
 * NOTE: The following is just a temporary fix for the multiple friend requests received at the same time problem.
 * TODO(irungentoo): Make this better (This will most likely tie in with the way we will handle spam).
 */
#define MAX_RECEIVED_STORED 32

struct Received_Requests {
    uint8_t requests[MAX_RECEIVED_STORED][CRYPTO_PUBLIC_KEY_SIZE];
    uint16_t requests_index;
};

struct Friend_Requests {
    uint32_t nospam;
    fr_friend_request_cb *handle_friendrequest;
    uint8_t handle_friendrequest_isset;
    void *handle_friendrequest_object;

    filter_function_cb *filter_function;
    void *filter_function_userdata;

    struct Received_Requests received;
};

/** Set and get the nospam variable used to prevent one type of friend request spam. */
void set_nospam(Friend_Requests *fr, uint32_t num)
{
    fr->nospam = num;
}

uint32_t get_nospam(const Friend_Requests *fr)
{
    return fr->nospam;
}


/** Set the function that will be executed when a friend request for us is received. */
void callback_friendrequest(Friend_Requests *fr, fr_friend_request_cb *function, void *object)
{
    fr->handle_friendrequest = function;
    fr->handle_friendrequest_isset = 1;
    fr->handle_friendrequest_object = object;
}

/** @brief Set the function used to check if a friend request should be displayed to the user or not.
 * It must return 0 if the request is ok (anything else if it is bad).
 */
void set_filter_function(Friend_Requests *fr, filter_function_cb *function, void *userdata)
{
    fr->filter_function = function;
    fr->filter_function_userdata = userdata;
}

/** Add to list of received friend requests. */
non_null()
static void addto_receivedlist(Friend_Requests *fr, const uint8_t *real_pk)
{
    if (fr->received.requests_index >= MAX_RECEIVED_STORED) {
        fr->received.requests_index = 0;
    }

    pk_copy(fr->received.requests[fr->received.requests_index], real_pk);
    ++fr->received.requests_index;
}

/** @brief Check if a friend request was already received.
 *
 * @retval false if it did not.
 * @retval true if it did.
 */
non_null()
static bool request_received(const Friend_Requests *fr, const uint8_t *real_pk)
{
    for (uint32_t i = 0; i < MAX_RECEIVED_STORED; ++i) {
        if (pk_equal(fr->received.requests[i], real_pk)) {
            return true;
        }
    }

    return false;
}

/** @brief Remove real_pk from received_requests list.
 *
 * @retval 0 if it removed it successfully.
 * @retval -1 if it didn't find it.
 */
int remove_request_received(Friend_Requests *fr, const uint8_t *real_pk)
{
    for (uint32_t i = 0; i < MAX_RECEIVED_STORED; ++i) {
        if (pk_equal(fr->received.requests[i], real_pk)) {
            crypto_memzero(fr->received.requests[i], CRYPTO_PUBLIC_KEY_SIZE);
            return 0;
        }
    }

    return -1;
}


non_null()
static int friendreq_handlepacket(void *object, const uint8_t *source_pubkey, const uint8_t *packet, uint16_t length,
                                  void *userdata)
{
    Friend_Requests *const fr = (Friend_Requests *)object;

    if (length <= 1 + sizeof(fr->nospam) || length > ONION_CLIENT_MAX_DATA_SIZE) {
        return 1;
    }

    ++packet;
    --length;

    if (fr->handle_friendrequest_isset == 0) {
        return 1;
    }

    if (request_received(fr, source_pubkey)) {
        return 1;
    }

    if (memcmp(packet, &fr->nospam, sizeof(fr->nospam)) != 0) {
        return 1;
    }

    if (fr->filter_function != nullptr) {
        if (fr->filter_function(source_pubkey, fr->filter_function_userdata) != 0) {
            return 1;
        }
    }

    addto_receivedlist(fr, source_pubkey);

    const uint32_t message_len = length - sizeof(fr->nospam);
    VLA(uint8_t, message, message_len + 1);
    memcpy(message, packet + sizeof(fr->nospam), message_len);
    message[SIZEOF_VLA(message) - 1] = 0; /* Be sure the message is null terminated. */

    fr->handle_friendrequest(fr->handle_friendrequest_object, source_pubkey, message, message_len, userdata);
    return 0;
}

void friendreq_init(Friend_Requests *fr, Friend_Connections *fr_c)
{
    set_friend_request_callback(fr_c, &friendreq_handlepacket, fr);
}

Friend_Requests *friendreq_new(void)
{
    return (Friend_Requests *)calloc(1, sizeof(Friend_Requests));
}

void friendreq_kill(Friend_Requests *fr)
{
    free(fr);
}
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2020 The TokTok team.
 * Copyright © 2015 Tox project.
 */


#include <stdlib.h>
#include <string.h>


/**
 * Removes `announces` from `gc_announces_list`.
 */
non_null()
static void remove_announces(GC_Announces_List *gc_announces_list, GC_Announces *announces)
{
    if (announces == nullptr || gc_announces_list == nullptr) {
        return;
    }

    if (announces->prev_announce != nullptr) {
        announces->prev_announce->next_announce = announces->next_announce;
    } else {
        gc_announces_list->root_announces = announces->next_announce;
    }

    if (announces->next_announce != nullptr) {
        announces->next_announce->prev_announce = announces->prev_announce;
    }

    free(announces);
}

/**
 * Returns the announce designated by `chat_id`.
 * Returns null if no announce is found.
 */
non_null()
static GC_Announces *get_announces_by_chat_id(const GC_Announces_List *gc_announces_list,  const uint8_t *chat_id)
{
    GC_Announces *announces = gc_announces_list->root_announces;

    while (announces != nullptr) {
        if (memcmp(announces->chat_id, chat_id, CHAT_ID_SIZE) == 0) {
            return announces;
        }

        announces = announces->next_announce;
    }

    return nullptr;
}

int gca_get_announces(const GC_Announces_List *gc_announces_list, GC_Announce *gc_announces, uint8_t max_nodes,
                      const uint8_t *chat_id, const uint8_t *except_public_key)
{
    if (gc_announces == nullptr || gc_announces_list == nullptr || chat_id == nullptr || max_nodes == 0
            || except_public_key == nullptr) {
        return -1;
    }

    const GC_Announces *announces = get_announces_by_chat_id(gc_announces_list, chat_id);

    if (announces == nullptr) {
        return 0;
    }

    uint16_t added_count = 0;

    for (size_t i = 0; i < announces->index && i < GCA_MAX_SAVED_ANNOUNCES_PER_GC && added_count < max_nodes; ++i) {
        const size_t index = i % GCA_MAX_SAVED_ANNOUNCES_PER_GC;

        if (memcmp(except_public_key, &announces->peer_announces[index].base_announce.peer_public_key,
                   ENC_PUBLIC_KEY_SIZE) == 0) {
            continue;
        }

        bool already_added = false;

        for (size_t j = 0; j < added_count; ++j) {
            if (memcmp(&gc_announces[j].peer_public_key, &announces->peer_announces[index].base_announce.peer_public_key,
                       ENC_PUBLIC_KEY_SIZE) == 0) {
                already_added = true;
                break;
            }
        }

        if (!already_added) {
            gc_announces[added_count] = announces->peer_announces[index].base_announce;
            ++added_count;
        }
    }

    return added_count;
}

uint16_t gca_pack_announces_list_size(uint16_t count)
{
    return count * GCA_ANNOUNCE_MAX_SIZE;
}

int gca_pack_announce(const Logger *log, uint8_t *data, uint16_t length, const GC_Announce *announce)
{
    if (length < GCA_ANNOUNCE_MAX_SIZE) {
        LOGGER_ERROR(log, "Invalid announce length: %u", length);
        return -1;
    }

    if (data == nullptr) {
        LOGGER_ERROR(log, "data is null");
        return -1;
    }

    if (announce == nullptr) {
        LOGGER_ERROR(log, "announce is null");
        return -1;
    }

    uint16_t offset = 0;
    memcpy(data + offset, announce->peer_public_key, ENC_PUBLIC_KEY_SIZE);
    offset += ENC_PUBLIC_KEY_SIZE;

    data[offset] = announce->ip_port_is_set ? 1 : 0;
    ++offset;

    data[offset] = announce->tcp_relays_count;
    ++offset;

    if (!announce->ip_port_is_set && announce->tcp_relays_count == 0) {
        LOGGER_ERROR(log, "Failed to pack announce: no valid ip_port or tcp relay");
        return -1;
    }

    if (announce->ip_port_is_set) {
        const int ip_port_length = pack_ip_port(log, data + offset, length - offset, &announce->ip_port);

        if (ip_port_length == -1) {
            LOGGER_ERROR(log, "Failed to pack ip_port");
            return -1;
        }

        offset += ip_port_length;
    }

    const int nodes_length = pack_nodes(log, data + offset, length - offset, announce->tcp_relays,
                                        announce->tcp_relays_count);

    if (nodes_length == -1) {
        LOGGER_ERROR(log, "Failed to pack TCP nodes");
        return -1;
    }

    return nodes_length + offset;
}

/**
 * Unpacks `announce` into `data` buffer of size `length`.
 *
 * Returns the size of the unpacked data on success.
 * Returns -1 on failure.
 */
non_null()
static int gca_unpack_announce(const Logger *log, const uint8_t *data, uint16_t length, GC_Announce *announce)
{
    if (length < ENC_PUBLIC_KEY_SIZE + 2) {
        LOGGER_ERROR(log, "Invalid announce length: %u", length);
        return -1;
    }

    if (data == nullptr) {
        LOGGER_ERROR(log, "data is null");
        return -1;
    }

    if (announce == nullptr) {
        LOGGER_ERROR(log, "announce is null");
        return -1;
    }

    uint16_t offset = 0;
    memcpy(announce->peer_public_key, data + offset, ENC_PUBLIC_KEY_SIZE);
    offset += ENC_PUBLIC_KEY_SIZE;

    net_unpack_bool(&data[offset], &announce->ip_port_is_set);
    ++offset;

    announce->tcp_relays_count = data[offset];
    ++offset;

    if (announce->tcp_relays_count > GCA_MAX_ANNOUNCED_TCP_RELAYS) {
        return -1;
    }

    if (announce->ip_port_is_set) {
        if (length - offset == 0) {
            return -1;
        }

        const int ip_port_length = unpack_ip_port(&announce->ip_port, data + offset, length - offset, false);

        if (ip_port_length == -1) {
            LOGGER_ERROR(log, "Failed to unpack ip_port");
            return -1;
        }

        offset += ip_port_length;
    }

    uint16_t nodes_length;
    const int nodes_count = unpack_nodes(announce->tcp_relays, announce->tcp_relays_count, &nodes_length,
                                         data + offset, length - offset, true);

    if (nodes_count != announce->tcp_relays_count) {
        LOGGER_ERROR(log, "Failed to unpack TCP nodes");
        return -1;
    }

    return offset + nodes_length;
}

int gca_pack_public_announce(const Logger *log, uint8_t *data, uint16_t length,
                             const GC_Public_Announce *public_announce)
{
    if (public_announce == nullptr || data == nullptr || length < CHAT_ID_SIZE) {
        return -1;
    }

    memcpy(data, public_announce->chat_public_key, CHAT_ID_SIZE);

    const int packed_size = gca_pack_announce(log, data + CHAT_ID_SIZE, length - CHAT_ID_SIZE,
                            &public_announce->base_announce);

    if (packed_size < 0) {
        LOGGER_ERROR(log, "Failed to pack public group announce");
        return -1;
    }

    return packed_size + CHAT_ID_SIZE;
}

int gca_unpack_public_announce(const Logger *log, const uint8_t *data, uint16_t length,
                               GC_Public_Announce *public_announce)
{
    if (length < CHAT_ID_SIZE) {
        LOGGER_ERROR(log, "invalid public announce length: %u", length);
        return -1;
    }

    if (data == nullptr) {
        LOGGER_ERROR(log, "data is null");
        return -1;
    }

    if (public_announce == nullptr) {
        LOGGER_ERROR(log, "public_announce is null");
        return -1;
    }

    memcpy(public_announce->chat_public_key, data, CHAT_ID_SIZE);

    const int base_announce_size = gca_unpack_announce(log, data + ENC_PUBLIC_KEY_SIZE, length - ENC_PUBLIC_KEY_SIZE,
                                   &public_announce->base_announce);

    if (base_announce_size == -1) {
        LOGGER_ERROR(log, "Failed to unpack group announce");
        return -1;
    }

    return base_announce_size + CHAT_ID_SIZE;
}

int gca_pack_announces_list(const Logger *log, uint8_t *data, uint16_t length, const GC_Announce *announces,
                            uint8_t announces_count, size_t *processed)
{
    if (data == nullptr) {
        LOGGER_ERROR(log, "data is null");
        return -1;
    }

    if (announces == nullptr) {
        LOGGER_ERROR(log, "announces is null");
        return -1;
    }

    uint16_t offset = 0;

    for (size_t i = 0; i < announces_count; ++i) {
        const int packed_length = gca_pack_announce(log, data + offset, length - offset, &announces[i]);

        if (packed_length < 0) {
            LOGGER_ERROR(log, "Failed to pack group announce");
            return -1;
        }

        offset += packed_length;
    }

    if (processed != nullptr) {
        *processed = offset;
    }

    return announces_count;
}

int gca_unpack_announces_list(const Logger *log, const uint8_t *data, uint16_t length, GC_Announce *announces,
                              uint8_t max_count)
{
    if (data == nullptr) {
        LOGGER_ERROR(log, "data is null");
        return -1;
    }

    if (announces == nullptr) {
        LOGGER_ERROR(log, "announces is null");
        return -1;
    }

    uint16_t offset = 0;
    int announces_count = 0;

    for (size_t i = 0; i < max_count && length > offset; ++i) {
        const int unpacked_length = gca_unpack_announce(log, data + offset, length - offset, &announces[i]);

        if (unpacked_length == -1) {
            LOGGER_WARNING(log, "Failed to unpack group announce: %d %d", length, offset);
            return -1;
        }

        offset += unpacked_length;
        ++announces_count;
    }

    return announces_count;
}

GC_Peer_Announce *gca_add_announce(const Mono_Time *mono_time, GC_Announces_List *gc_announces_list,
                                   const GC_Public_Announce *public_announce)
{
    if (gc_announces_list == nullptr || public_announce == nullptr) {
        return nullptr;
    }

    GC_Announces *announces = get_announces_by_chat_id(gc_announces_list, public_announce->chat_public_key);

    // No entry for this chat_id exists so we create one
    if (announces == nullptr) {
        announces = (GC_Announces *)calloc(1, sizeof(GC_Announces));

        if (announces == nullptr) {
            return nullptr;
        }

        announces->index = 0;
        announces->prev_announce = nullptr;

        if (gc_announces_list->root_announces != nullptr) {
            gc_announces_list->root_announces->prev_announce = announces;
        }

        announces->next_announce = gc_announces_list->root_announces;
        gc_announces_list->root_announces = announces;
        memcpy(announces->chat_id, public_announce->chat_public_key, CHAT_ID_SIZE);
    }

    const uint64_t cur_time = mono_time_get(mono_time);

    announces->last_announce_received_timestamp = cur_time;

    const uint64_t index = announces->index % GCA_MAX_SAVED_ANNOUNCES_PER_GC;

    GC_Peer_Announce *gc_peer_announce = &announces->peer_announces[index];

    gc_peer_announce->base_announce = public_announce->base_announce;

    gc_peer_announce->timestamp = cur_time;

    ++announces->index;

    return gc_peer_announce;
}

bool gca_is_valid_announce(const GC_Announce *announce)
{
    if (announce == nullptr) {
        return false;
    }

    return announce->tcp_relays_count > 0 || announce->ip_port_is_set;
}

GC_Announces_List *new_gca_list(void)
{
    GC_Announces_List *announces_list = (GC_Announces_List *)calloc(1, sizeof(GC_Announces_List));
    return announces_list;
}

void kill_gca(GC_Announces_List *announces_list)
{
    if (announces_list == nullptr) {
        return;
    }

    GC_Announces *root = announces_list->root_announces;

    while (root != nullptr) {
        GC_Announces *next = root->next_announce;
        free(root);
        root = next;
    }

    free(announces_list);
}

/* How long we save a peer's announce before we consider it stale and remove it. */
#define GCA_ANNOUNCE_SAVE_TIMEOUT 30

/* How often we run do_gca() */
#define GCA_DO_GCA_TIMEOUT 1

void do_gca(const Mono_Time *mono_time, GC_Announces_List *gc_announces_list)
{
    if (gc_announces_list == nullptr) {
        return;
    }

    if (!mono_time_is_timeout(mono_time, gc_announces_list->last_timeout_check, GCA_DO_GCA_TIMEOUT)) {
        return;
    }

    gc_announces_list->last_timeout_check = mono_time_get(mono_time);

    GC_Announces *announces = gc_announces_list->root_announces;

    while (announces != nullptr) {
        if (mono_time_is_timeout(mono_time, announces->last_announce_received_timestamp, GCA_ANNOUNCE_SAVE_TIMEOUT)) {
            GC_Announces *to_delete = announces;
            announces = announces->next_announce;
            remove_announces(gc_announces_list, to_delete);
            continue;
        }

        announces = announces->next_announce;
    }
}

void cleanup_gca(GC_Announces_List *gc_announces_list, const uint8_t *chat_id)
{
    if (gc_announces_list == nullptr || chat_id == nullptr) {
        return;
    }

    GC_Announces *announces = get_announces_by_chat_id(gc_announces_list, chat_id);

    if (announces != nullptr) {
        remove_announces(gc_announces_list, announces);
    }
}
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2018 The TokTok team.
 * Copyright © 2014 Tox project.
 */

/**
 * Slightly better groupchats implementation.
 */

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


enum {
    /** Connection is to one of the closest DESIRED_CLOSEST peers */
    GROUPCHAT_CONNECTION_REASON_CLOSEST     = 1 << 0,

    /** Connection is to a peer we are introducing to the conference */
    GROUPCHAT_CONNECTION_REASON_INTRODUCING = 1 << 1,

    /** Connection is to a peer who is introducing us to the conference */
    GROUPCHAT_CONNECTION_REASON_INTRODUCER  = 1 << 2,
};

typedef enum Groupchat_Connection_Type {
    GROUPCHAT_CONNECTION_NONE,
    GROUPCHAT_CONNECTION_CONNECTING,
    GROUPCHAT_CONNECTION_ONLINE,
} Groupchat_Connection_Type;

typedef enum Groupchat_Status {
    GROUPCHAT_STATUS_NONE,
    GROUPCHAT_STATUS_VALID,
    GROUPCHAT_STATUS_CONNECTED,
} Groupchat_Status;

#define GROUP_ID_LENGTH CRYPTO_SYMMETRIC_KEY_SIZE

#define DESIRED_CLOSEST 4
#define MAX_GROUP_CONNECTIONS 16
#define MAX_LAST_MESSAGE_INFOS 8
#define MAX_LOSSY_COUNT 256

/** Maximum number of frozen peers to store; `group_set_max_frozen()` overrides. */
#define MAX_FROZEN_DEFAULT 128

typedef struct Message_Info {
    uint32_t message_number;
    uint8_t  message_id;
} Message_Info;

typedef struct Group_Peer {
    uint8_t     real_pk[CRYPTO_PUBLIC_KEY_SIZE];
    uint8_t     temp_pk[CRYPTO_PUBLIC_KEY_SIZE];
    bool        temp_pk_updated;
    bool        is_friend;

    uint64_t    last_active;

    Message_Info
    last_message_infos[MAX_LAST_MESSAGE_INFOS]; /* received messages, strictly decreasing in message_number */
    uint8_t     num_last_message_infos;

    uint8_t     nick[MAX_NAME_LENGTH];
    uint8_t     nick_len;
    bool        nick_updated;

    uint16_t peer_number;

    uint8_t  recv_lossy[MAX_LOSSY_COUNT];
    uint16_t bottom_lossy_number;
    uint16_t top_lossy_number;

    void *object;
} Group_Peer;

typedef struct Groupchat_Connection {
    uint8_t type; /* `GROUPCHAT_CONNECTION_*` */
    uint8_t reasons; /* bit field with flags `GROUPCHAT_CONNECTION_REASON_*` */
    uint32_t number;
    uint16_t group_number;
} Groupchat_Connection;

typedef struct Groupchat_Closest {
    /**
     * Whether this peer is active in the closest_peers array.
     */
    bool active;
    uint8_t real_pk[CRYPTO_PUBLIC_KEY_SIZE];
    uint8_t temp_pk[CRYPTO_PUBLIC_KEY_SIZE];
} Groupchat_Closest;

typedef struct Group_c {
    uint8_t status;

    bool need_send_name;
    bool title_fresh;

    Group_Peer *group;
    uint32_t numpeers;

    Group_Peer *frozen;
    uint32_t numfrozen;

    uint32_t maxfrozen;

    Groupchat_Connection connections[MAX_GROUP_CONNECTIONS];

    uint8_t real_pk[CRYPTO_PUBLIC_KEY_SIZE];
    Groupchat_Closest closest_peers[DESIRED_CLOSEST];
    uint8_t changed;

    uint8_t type;
    uint8_t id[GROUP_ID_LENGTH];

    uint8_t title[MAX_NAME_LENGTH];
    uint8_t title_len;

    uint32_t message_number;
    uint16_t lossy_message_number;
    uint16_t peer_number;

    uint64_t last_sent_ping;

    uint32_t num_introducer_connections;

    void *object;

    peer_on_join_cb *peer_on_join;
    peer_on_leave_cb *peer_on_leave;
    group_on_delete_cb *group_on_delete;
} Group_c;

struct Group_Chats {
    const Mono_Time *mono_time;

    Messenger *m;
    Friend_Connections *fr_c;

    Group_c *chats;
    uint16_t num_chats;

    g_conference_invite_cb *invite_callback;
    g_conference_connected_cb *connected_callback;
    g_conference_message_cb *message_callback;
    peer_name_cb *peer_name_callback;
    peer_list_changed_cb *peer_list_changed_callback;
    title_cb *title_callback;

    lossy_packet_cb *lossy_packethandlers[256];
};

static const Group_c empty_group_c = {0};
static const Group_Peer empty_group_peer = {{0}};

/**
 * Packet type IDs as per the protocol specification.
 */
typedef enum Group_Message_Id {
    GROUP_MESSAGE_PING_ID        = 0,
    GROUP_MESSAGE_NEW_PEER_ID    = 16,
    GROUP_MESSAGE_KILL_PEER_ID   = 17,
    GROUP_MESSAGE_FREEZE_PEER_ID = 18,
    GROUP_MESSAGE_NAME_ID        = 48,
    GROUP_MESSAGE_TITLE_ID       = 49,
} Group_Message_Id;

#define GROUP_MESSAGE_NEW_PEER_LENGTH (sizeof(uint16_t) + CRYPTO_PUBLIC_KEY_SIZE * 2)
#define GROUP_MESSAGE_KILL_PEER_LENGTH (sizeof(uint16_t))

#define MAX_GROUP_MESSAGE_DATA_LEN (MAX_CRYPTO_DATA_SIZE - (1 + MIN_MESSAGE_PACKET_LEN))

typedef enum Invite_Id {
    INVITE_ID             = 0,
    INVITE_ACCEPT_ID      = 1,
    INVITE_MEMBER_ID      = 2,
} Invite_Id;

#define INVITE_PACKET_SIZE (1 + sizeof(uint16_t) + 1 + GROUP_ID_LENGTH)
#define INVITE_ACCEPT_PACKET_SIZE (1 + sizeof(uint16_t) * 2 + 1 + GROUP_ID_LENGTH)
#define INVITE_MEMBER_PACKET_SIZE (1 + sizeof(uint16_t) * 2 + 1 + GROUP_ID_LENGTH + sizeof(uint16_t))

#define ONLINE_PACKET_DATA_SIZE (sizeof(uint16_t) + 1 + GROUP_ID_LENGTH)

typedef enum Peer_Id {
    PEER_INTRODUCED_ID  = 1,
    PEER_QUERY_ID       = 8,
    PEER_RESPONSE_ID    = 9,
    PEER_TITLE_ID       = 10,
} Peer_Id;

#define MIN_MESSAGE_PACKET_LEN (sizeof(uint16_t) * 2 + sizeof(uint32_t) + 1)

static_assert(GROUP_ID_LENGTH == CRYPTO_PUBLIC_KEY_SIZE,
              "GROUP_ID_LENGTH should be equal to CRYPTO_PUBLIC_KEY_SIZE");

const Mono_Time *g_mono_time(const Group_Chats *g_c)
{
    return g_c->mono_time;
}

non_null()
static bool group_id_eq(const uint8_t *a, const uint8_t *b)
{
    return pk_equal(a, b);
}

non_null()
static bool g_title_eq(Group_c *g, const uint8_t *title, uint8_t title_len)
{
    return memeq(g->title, g->title_len, title, title_len);
}

non_null()
static bool g_peer_nick_eq(Group_Peer *peer, const uint8_t *nick, uint8_t nick_len)
{
    return memeq(peer->nick, peer->nick_len, nick, nick_len);
}

/**
 * @retval false if the groupnumber is not valid.
 * @retval true if the groupnumber is valid.
 */
non_null()
static bool is_groupnumber_valid(const Group_Chats *g_c, uint32_t groupnumber)
{
    return groupnumber < g_c->num_chats
           && g_c->chats != nullptr
           && g_c->chats[groupnumber].status != GROUPCHAT_STATUS_NONE;
}


/** @brief Set the size of the groupchat list to num.
 *
 * @retval false if realloc fails.
 * @retval true if it succeeds.
 */
non_null()
static bool realloc_conferences(Group_Chats *g_c, uint16_t num)
{
    if (num == 0) {
        free(g_c->chats);
        g_c->chats = nullptr;
        return true;
    }

    Group_c *newgroup_chats = (Group_c *)realloc(g_c->chats, num * sizeof(Group_c));

    if (newgroup_chats == nullptr) {
        return false;
    }

    g_c->chats = newgroup_chats;
    return true;
}

non_null()
static void setup_conference(Group_c *g)
{
    *g = empty_group_c;
    g->maxfrozen = MAX_FROZEN_DEFAULT;
}

/** @brief Create a new empty groupchat connection.
 *
 * @retval -1 on failure.
 * @return groupnumber on success.
 */
non_null()
static int32_t create_group_chat(Group_Chats *g_c)
{
    for (uint16_t i = 0; i < g_c->num_chats; ++i) {
        if (g_c->chats[i].status == GROUPCHAT_STATUS_NONE) {
            return i;
        }
    }

    if (realloc_conferences(g_c, g_c->num_chats + 1)) {
        const uint16_t id = g_c->num_chats;
        ++g_c->num_chats;
        setup_conference(&g_c->chats[id]);
        return id;
    }

    return -1;
}

non_null()
static void wipe_group_c(Group_c *g)
{
    free(g->frozen);
    free(g->group);
    crypto_memzero(g, sizeof(Group_c));
}

/** @brief Wipe a groupchat.
 *
 * @retval true on success.
 */
non_null()
static bool wipe_group_chat(Group_Chats *g_c, uint32_t groupnumber)
{
    if (groupnumber >= g_c->num_chats || g_c->chats == nullptr) {
        return false;
    }

    wipe_group_c(&g_c->chats[groupnumber]);

    uint16_t i;

    for (i = g_c->num_chats; i != 0; --i) {
        if (g_c->chats[i - 1].status != GROUPCHAT_STATUS_NONE) {
            break;
        }
    }

    if (g_c->num_chats != i) {
        g_c->num_chats = i;
        realloc_conferences(g_c, g_c->num_chats);
    }

    return true;
}

non_null()
static Group_c *get_group_c(const Group_Chats *g_c, uint32_t groupnumber)
{
    if (!is_groupnumber_valid(g_c, groupnumber)) {
        return nullptr;
    }

    return &g_c->chats[groupnumber];
}

/**
 * check if peer with real_pk is in peer array.
 *
 * @return peer index if peer is in group.
 * @retval -1 if peer is not in group.
 *
 * TODO(irungentoo): make this more efficient.
 */
non_null()
static int peer_in_group(const Group_c *g, const uint8_t *real_pk)
{
    for (uint32_t i = 0; i < g->numpeers; ++i) {
        if (pk_equal(g->group[i].real_pk, real_pk)) {
            return i;
        }
    }

    return -1;
}

non_null()
static int frozen_in_group(const Group_c *g, const uint8_t *real_pk)
{
    for (uint32_t i = 0; i < g->numfrozen; ++i) {
        if (pk_equal(g->frozen[i].real_pk, real_pk)) {
            return i;
        }
    }

    return -1;
}

/**
 * check if group with the given type and id is in group array.
 *
 * @return group number if peer is in list.
 * @retval -1 if group is not in list.
 *
 * TODO(irungentoo): make this more efficient and maybe use constant time comparisons?
 */
non_null()
static int32_t get_group_num(const Group_Chats *g_c, const uint8_t type, const uint8_t *id)
{
    for (uint16_t i = 0; i < g_c->num_chats; ++i) {
        if (g_c->chats[i].type == type && group_id_eq(g_c->chats[i].id, id)) {
            return i;
        }
    }

    return -1;
}

int32_t conference_by_id(const Group_Chats *g_c, const uint8_t *id)
{
    for (uint16_t i = 0; i < g_c->num_chats; ++i) {
        if (group_id_eq(g_c->chats[i].id, id)) {
            return i;
        }
    }

    return -1;
}

/**
 * check if peer with peer_number is in peer array.
 *
 * @return peer index if peer is in chat.
 * @retval -1 if peer is not in chat.
 *
 * TODO(irungentoo): make this more efficient.
 */
non_null()
static int get_peer_index(const Group_c *g, uint16_t peer_number)
{
    for (uint32_t i = 0; i < g->numpeers; ++i) {
        if (g->group[i].peer_number == peer_number) {
            return i;
        }
    }

    return -1;
}


non_null()
static uint64_t calculate_comp_value(const uint8_t *pk1, const uint8_t *pk2)
{
    uint64_t cmp1 = 0;
    uint64_t cmp2 = 0;

    for (size_t i = 0; i < sizeof(uint64_t); ++i) {
        cmp1 = (cmp1 << 8) + (uint64_t)pk1[i];
        cmp2 = (cmp2 << 8) + (uint64_t)pk2[i];
    }

    return cmp1 - cmp2;
}

typedef enum Groupchat_Closest_Change {
    GROUPCHAT_CLOSEST_CHANGE_NONE,
    GROUPCHAT_CLOSEST_CHANGE_ADDED,
    GROUPCHAT_CLOSEST_CHANGE_REMOVED,
} Groupchat_Closest_Change;

non_null()
static bool add_to_closest(Group_c *g, const uint8_t *real_pk, const uint8_t *temp_pk)
{
    if (pk_equal(g->real_pk, real_pk)) {
        return false;
    }

    unsigned int index = DESIRED_CLOSEST;

    for (unsigned int i = 0; i < DESIRED_CLOSEST; ++i) {
        if (g->closest_peers[i].active && pk_equal(real_pk, g->closest_peers[i].real_pk)) {
            return true;
        }
    }

    for (unsigned int i = 0; i < DESIRED_CLOSEST; ++i) {
        if (!g->closest_peers[i].active) {
            index = i;
            break;
        }
    }

    if (index == DESIRED_CLOSEST) {
        uint64_t comp_val = calculate_comp_value(g->real_pk, real_pk);
        uint64_t comp_d = 0;

        for (unsigned int i = 0; i < (DESIRED_CLOSEST / 2); ++i) {
            const uint64_t comp = calculate_comp_value(g->real_pk, g->closest_peers[i].real_pk);

            if (comp > comp_val && comp > comp_d) {
                index = i;
                comp_d = comp;
            }
        }

        comp_val = calculate_comp_value(real_pk, g->real_pk);

        for (unsigned int i = DESIRED_CLOSEST / 2; i < DESIRED_CLOSEST; ++i) {
            uint64_t comp = calculate_comp_value(g->closest_peers[i].real_pk, g->real_pk);

            if (comp > comp_val && comp > comp_d) {
                index = i;
                comp_d = comp;
            }
        }
    }

    if (index == DESIRED_CLOSEST) {
        return false;
    }

    uint8_t old_real_pk[CRYPTO_PUBLIC_KEY_SIZE];
    uint8_t old_temp_pk[CRYPTO_PUBLIC_KEY_SIZE];
    bool old = false;

    if (g->closest_peers[index].active) {
        memcpy(old_real_pk, g->closest_peers[index].real_pk, CRYPTO_PUBLIC_KEY_SIZE);
        memcpy(old_temp_pk, g->closest_peers[index].temp_pk, CRYPTO_PUBLIC_KEY_SIZE);
        old = true;
    }

    g->closest_peers[index].active = true;
    memcpy(g->closest_peers[index].real_pk, real_pk, CRYPTO_PUBLIC_KEY_SIZE);
    memcpy(g->closest_peers[index].temp_pk, temp_pk, CRYPTO_PUBLIC_KEY_SIZE);

    if (old) {
        add_to_closest(g, old_real_pk, old_temp_pk);
    }

    if (g->changed == GROUPCHAT_CLOSEST_CHANGE_NONE) {
        g->changed = GROUPCHAT_CLOSEST_CHANGE_ADDED;
    }

    return true;
}

non_null()
static bool pk_in_closest_peers(const Group_c *g, const uint8_t *real_pk)
{
    for (unsigned int i = 0; i < DESIRED_CLOSEST; ++i) {
        if (!g->closest_peers[i].active) {
            continue;
        }

        if (pk_equal(g->closest_peers[i].real_pk, real_pk)) {
            return true;
        }
    }

    return false;
}

non_null()
static void remove_connection_reason(Group_Chats *g_c, Group_c *g, uint16_t i, uint8_t reason);

non_null()
static void purge_closest(Group_Chats *g_c, uint32_t groupnumber)
{
    Group_c *g = get_group_c(g_c, groupnumber);

    if (g == nullptr) {
        return;
    }

    for (uint32_t i = 0; i < MAX_GROUP_CONNECTIONS; ++i) {
        if (g->connections[i].type == GROUPCHAT_CONNECTION_NONE) {
            continue;
        }

        if ((g->connections[i].reasons & GROUPCHAT_CONNECTION_REASON_CLOSEST) == 0) {
            continue;
        }

        uint8_t real_pk[CRYPTO_PUBLIC_KEY_SIZE];
        get_friendcon_public_keys(real_pk, nullptr, g_c->fr_c, g->connections[i].number);

        if (!pk_in_closest_peers(g, real_pk)) {
            remove_connection_reason(g_c, g, i, GROUPCHAT_CONNECTION_REASON_CLOSEST);
        }
    }
}

non_null()
static bool send_packet_online(const Friend_Connections *fr_c, int friendcon_id, uint16_t group_num,
                               uint8_t type, const uint8_t *id);

non_null()
static int add_conn_to_groupchat(Group_Chats *g_c, int friendcon_id, Group_c *g, uint8_t reason,
                                 bool lock);

non_null(1) nullable(3)
static void add_closest_connections(Group_Chats *g_c, uint32_t groupnumber, void *userdata)
{
    Group_c *g = get_group_c(g_c, groupnumber);

    if (g == nullptr) {
        return;
    }

    for (uint32_t i = 0; i < DESIRED_CLOSEST; ++i) {
        if (!g->closest_peers[i].active) {
            continue;
        }

        int friendcon_id = getfriend_conn_id_pk(g_c->fr_c, g->closest_peers[i].real_pk);

        bool fresh = false;

        if (friendcon_id == -1) {
            friendcon_id = new_friend_connection(g_c->fr_c, g->closest_peers[i].real_pk);
            fresh = true;

            if (friendcon_id == -1) {
                continue;
            }

            set_dht_temp_pk(g_c->fr_c, friendcon_id, g->closest_peers[i].temp_pk, userdata);
        }

        const int connection_index = add_conn_to_groupchat(g_c, friendcon_id, g,
                                     GROUPCHAT_CONNECTION_REASON_CLOSEST, !fresh);

        if (connection_index == -1) {
            if (fresh) {
                kill_friend_connection(g_c->fr_c, friendcon_id);
            }

            continue;
        }

        if (friend_con_connected(g_c->fr_c, friendcon_id) == FRIENDCONN_STATUS_CONNECTED
                && g->connections[connection_index].type == GROUPCHAT_CONNECTION_CONNECTING) {
            send_packet_online(g_c->fr_c, friendcon_id, groupnumber, g->type, g->id);
        }
    }
}

non_null(1) nullable(3)
static bool connect_to_closest(Group_Chats *g_c, uint32_t groupnumber, void *userdata)
{
    Group_c *g = get_group_c(g_c, groupnumber);

    if (g == nullptr) {
        return false;
    }

    if (g->changed == GROUPCHAT_CLOSEST_CHANGE_NONE) {
        return true;
    }

    if (g->changed == GROUPCHAT_CLOSEST_CHANGE_REMOVED) {
        for (uint32_t i = 0; i < g->numpeers; ++i) {
            add_to_closest(g, g->group[i].real_pk, g->group[i].temp_pk);
        }
    }

    purge_closest(g_c, groupnumber);

    add_closest_connections(g_c, groupnumber, userdata);

    g->changed = GROUPCHAT_CLOSEST_CHANGE_NONE;

    return true;
}

non_null()
static int get_frozen_index(const Group_c *g, uint16_t peer_number)
{
    for (uint32_t i = 0; i < g->numfrozen; ++i) {
        if (g->frozen[i].peer_number == peer_number) {
            return i;
        }
    }

    return -1;
}

non_null()
static bool delete_frozen(Group_c *g, uint32_t frozen_index)
{
    if (frozen_index >= g->numfrozen) {
        return false;
    }

    --g->numfrozen;

    if (g->numfrozen == 0) {
        free(g->frozen);
        g->frozen = nullptr;
    } else {
        if (g->numfrozen != frozen_index) {
            g->frozen[frozen_index] = g->frozen[g->numfrozen];
        }

        Group_Peer *const frozen_temp = (Group_Peer *)realloc(g->frozen, sizeof(Group_Peer) * g->numfrozen);

        if (frozen_temp == nullptr) {
            return false;
        }

        g->frozen = frozen_temp;
    }

    return true;
}

/** @brief Update last_active timestamp on peer, and thaw the peer if it is frozen.
 *
 * @return peer index if peer is in the conference.
 * @retval -1 otherwise, and on error.
 */
non_null(1) nullable(4)
static int note_peer_active(Group_Chats *g_c, uint32_t groupnumber, uint16_t peer_number, void *userdata)
{
    Group_c *g = get_group_c(g_c, groupnumber);

    if (g == nullptr) {
        return -1;
    }

    const int peer_index = get_peer_index(g, peer_number);

    if (peer_index != -1) {
        g->group[peer_index].last_active = mono_time_get(g_c->mono_time);
        return peer_index;
    }

    const int frozen_index = get_frozen_index(g, peer_number);

    if (frozen_index == -1) {
        return -1;
    }

    /* Now thaw the peer */

    Group_Peer *temp = (Group_Peer *)realloc(g->group, sizeof(Group_Peer) * (g->numpeers + 1));

    if (temp == nullptr) {
        return -1;
    }

    const uint32_t thawed_index = g->numpeers;

    g->group = temp;
    g->group[thawed_index] = g->frozen[frozen_index];
    g->group[thawed_index].temp_pk_updated = false;
    g->group[thawed_index].last_active = mono_time_get(g_c->mono_time);

    add_to_closest(g, g->group[thawed_index].real_pk, g->group[thawed_index].temp_pk);

    ++g->numpeers;

    delete_frozen(g, frozen_index);

    if (g_c->peer_list_changed_callback != nullptr) {
        g_c->peer_list_changed_callback(g_c->m, groupnumber, userdata);
    }

    if (g->peer_on_join != nullptr) {
        g->peer_on_join(g->object, groupnumber, thawed_index);
    }

    g->need_send_name = true;

    return thawed_index;
}

non_null(1) nullable(4)
static bool delpeer(Group_Chats *g_c, uint32_t groupnumber, int peer_index, void *userdata);

non_null(1, 3) nullable(4)
static void delete_any_peer_with_pk(Group_Chats *g_c, uint32_t groupnumber, const uint8_t *real_pk, void *userdata)
{
    Group_c *g = get_group_c(g_c, groupnumber);

    if (g == nullptr) {
        return;
    }

    const int peer_index = peer_in_group(g, real_pk);

    if (peer_index >= 0) {
        delpeer(g_c, groupnumber, peer_index, userdata);
    }

    const int frozen_index = frozen_in_group(g, real_pk);

    if (frozen_index >= 0) {
        delete_frozen(g, frozen_index);
    }
}

/** @brief Add a peer to the group chat, or update an existing peer.
 *
 * fresh indicates whether we should consider this information on the peer to
 * be current, and so should update temp_pk and consider the peer active.
 *
 * do_gc_callback indicates whether we want to trigger callbacks set by the client
 * via the public API. This should be set to false if this function is called
 * from outside of the `tox_iterate()` loop.
 *
 * @return peer_index if success or peer already in chat.
 * @retval -1 if error.
 */
non_null(1, 3, 4) nullable(6)
static int addpeer(Group_Chats *g_c, uint32_t groupnumber, const uint8_t *real_pk, const uint8_t *temp_pk,
                   uint16_t peer_number, void *userdata, bool fresh, bool do_gc_callback)
{
    Group_c *g = get_group_c(g_c, groupnumber);

    if (g == nullptr) {
        return -1;
    }

    const int peer_index = fresh ?
                           note_peer_active(g_c, groupnumber, peer_number, userdata) :
                           get_peer_index(g, peer_number);

    if (peer_index != -1) {
        if (!pk_equal(g->group[peer_index].real_pk, real_pk)) {
            LOGGER_ERROR(g_c->m->log, "peer public key is incorrect for peer %d", peer_number);
            return -1;
        }

        if (fresh || !g->group[peer_index].temp_pk_updated) {
            pk_copy(g->group[peer_index].temp_pk, temp_pk);
            g->group[peer_index].temp_pk_updated = true;
        }

        return peer_index;
    }

    if (!fresh) {
        const int frozen_index = get_frozen_index(g, peer_number);

        if (frozen_index != -1) {
            if (!pk_equal(g->frozen[frozen_index].real_pk, real_pk)) {
                return -1;
            }

            pk_copy(g->frozen[frozen_index].temp_pk, temp_pk);

            return -1;
        }
    }

    delete_any_peer_with_pk(g_c, groupnumber, real_pk, userdata);

    Group_Peer *temp = (Group_Peer *)realloc(g->group, sizeof(Group_Peer) * (g->numpeers + 1));

    if (temp == nullptr) {
        return -1;
    }

    temp[g->numpeers] = empty_group_peer;
    g->group = temp;

    const uint32_t new_index = g->numpeers;

    pk_copy(g->group[new_index].real_pk, real_pk);
    pk_copy(g->group[new_index].temp_pk, temp_pk);
    g->group[new_index].temp_pk_updated = true;
    g->group[new_index].peer_number = peer_number;
    g->group[new_index].last_active = mono_time_get(g_c->mono_time);
    g->group[new_index].is_friend = getfriend_id(g_c->m, real_pk) != -1;
    ++g->numpeers;

    add_to_closest(g, real_pk, temp_pk);

    if (do_gc_callback && g_c->peer_list_changed_callback != nullptr) {
        g_c->peer_list_changed_callback(g_c->m, groupnumber, userdata);
    }

    if (g->peer_on_join != nullptr) {
        g->peer_on_join(g->object, groupnumber, new_index);
    }

    return new_index;
}

non_null()
static void remove_connection(Group_Chats *g_c, Group_c *g, uint16_t i)
{
    if ((g->connections[i].reasons & GROUPCHAT_CONNECTION_REASON_INTRODUCER) != 0) {
        --g->num_introducer_connections;
    }

    kill_friend_connection(g_c->fr_c, g->connections[i].number);
    g->connections[i].type = GROUPCHAT_CONNECTION_NONE;
}

non_null()
static void remove_from_closest(Group_c *g, int peer_index)
{
    for (uint32_t i = 0; i < DESIRED_CLOSEST; ++i) {
        if (g->closest_peers[i].active
                && pk_equal(g->closest_peers[i].real_pk, g->group[peer_index].real_pk)) {
            g->closest_peers[i].active = false;
            g->changed = GROUPCHAT_CLOSEST_CHANGE_REMOVED;
            break;
        }
    }
}

/**
 * Delete a peer from the group chat.
 *
 * return true on success
 */
static bool delpeer(Group_Chats *g_c, uint32_t groupnumber, int peer_index, void *userdata)
{
    Group_c *g = get_group_c(g_c, groupnumber);

    if (g == nullptr) {
        return false;
    }

    remove_from_closest(g, peer_index);

    const int friendcon_id = getfriend_conn_id_pk(g_c->fr_c, g->group[peer_index].real_pk);

    if (friendcon_id != -1) {
        for (uint32_t i = 0; i < MAX_GROUP_CONNECTIONS; ++i) {
            if (g->connections[i].type == GROUPCHAT_CONNECTION_NONE) {
                continue;
            }

            if (g->connections[i].number == (unsigned int)friendcon_id) {
                remove_connection(g_c, g, i);
                break;
            }
        }
    }

    --g->numpeers;

    void *peer_object = g->group[peer_index].object;

    if (g->numpeers == 0) {
        free(g->group);
        g->group = nullptr;
    } else {
        if (g->numpeers != (uint32_t)peer_index) {
            g->group[peer_index] = g->group[g->numpeers];
        }

        Group_Peer *temp = (Group_Peer *)realloc(g->group, sizeof(Group_Peer) * g->numpeers);

        if (temp == nullptr) {
            return false;
        }

        g->group = temp;
    }

    if (g_c->peer_list_changed_callback != nullptr) {
        g_c->peer_list_changed_callback(g_c->m, groupnumber, userdata);
    }

    if (g->peer_on_leave != nullptr) {
        g->peer_on_leave(g->object, groupnumber, peer_object);
    }

    return true;
}

static int cmp_u64(uint64_t a, uint64_t b)
{
    return (a > b ? 1 : 0) - (a < b ? 1 : 0);
}

/** Order peers with friends first and with more recently active earlier */
non_null()
static int cmp_frozen(const void *a, const void *b)
{
    const Group_Peer *pa = (const Group_Peer *)a;
    const Group_Peer *pb = (const Group_Peer *)b;

    if (pa->is_friend ^ pb->is_friend) {
        return pa->is_friend ? -1 : 1;
    }

    return cmp_u64(pb->last_active, pa->last_active);
}

/** @brief Delete frozen peers as necessary to ensure at most `g->maxfrozen` remain.
 *
 * @retval true if any frozen peers are removed.
 */
non_null()
static bool delete_old_frozen(Group_c *g)
{
    if (g->numfrozen <= g->maxfrozen) {
        return false;
    }

    if (g->maxfrozen == 0) {
        free(g->frozen);
        g->frozen = nullptr;
        g->numfrozen = 0;
        return true;
    }

    qsort(g->frozen, g->numfrozen, sizeof(Group_Peer), cmp_frozen);

    Group_Peer *temp = (Group_Peer *)realloc(g->frozen, sizeof(Group_Peer) * g->maxfrozen);

    if (temp == nullptr) {
        return false;
    }

    g->frozen = temp;

    g->numfrozen = g->maxfrozen;

    return true;
}

non_null()
static bool try_send_rejoin(Group_Chats *g_c, Group_c *g, const uint8_t *real_pk);

non_null(1) nullable(4)
static bool freeze_peer(Group_Chats *g_c, uint32_t groupnumber, int peer_index, void *userdata)
{
    Group_c *g = get_group_c(g_c, groupnumber);

    if (g == nullptr) {
        return false;
    }

    Group_Peer *temp = (Group_Peer *)realloc(g->frozen, sizeof(Group_Peer) * (g->numfrozen + 1));

    if (temp == nullptr) {
        return false;
    }

    g->frozen = temp;
    g->frozen[g->numfrozen] = g->group[peer_index];
    g->frozen[g->numfrozen].object = nullptr;

    if (!delpeer(g_c, groupnumber, peer_index, userdata)) {
        return false;
    }

    try_send_rejoin(g_c, g, g->frozen[g->numfrozen].real_pk);

    ++g->numfrozen;

    delete_old_frozen(g);

    return true;
}


/** @brief Set the nick for a peer.
 *
 * do_gc_callback indicates whether we want to trigger callbacks set by the client
 * via the public API. This should be set to false if this function is called
 * from outside of the `tox_iterate()` loop.
 *
 * @retval true on success.
 */
non_null(1, 4) nullable(6)
static bool setnick(Group_Chats *g_c, uint32_t groupnumber, int peer_index, const uint8_t *nick, uint16_t nick_len,
                    void *userdata, bool do_gc_callback)
{
    if (nick_len > MAX_NAME_LENGTH) {
        return false;
    }

    Group_c *g = get_group_c(g_c, groupnumber);

    if (g == nullptr) {
        return false;
    }

    g->group[peer_index].nick_updated = true;

    if (g_peer_nick_eq(&g->group[peer_index], nick, nick_len)) {
        /* same name as already stored */
        return true;
    }

    if (nick_len > 0) {
        memcpy(g->group[peer_index].nick, nick, nick_len);
    }

    g->group[peer_index].nick_len = nick_len;

    if (do_gc_callback && g_c->peer_name_callback != nullptr) {
        g_c->peer_name_callback(g_c->m, groupnumber, peer_index, nick, nick_len, userdata);
    }

    return true;
}

/** @brief Set the title for a group.
 *
 * @retval true on success.
 */
non_null(1, 4) nullable(6)
static bool settitle(Group_Chats *g_c, uint32_t groupnumber, int peer_index, const uint8_t *title, uint8_t title_len,
                     void *userdata)
{
    if (title_len > MAX_NAME_LENGTH || title_len == 0) {
        return false;
    }

    Group_c *g = get_group_c(g_c, groupnumber);

    if (g == nullptr) {
        return false;
    }

    if (g_title_eq(g, title, title_len)) {
        /* same title as already set */
        return true;
    }

    memcpy(g->title, title, title_len);
    g->title_len = title_len;

    g->title_fresh = true;

    if (g_c->title_callback != nullptr) {
        g_c->title_callback(g_c->m, groupnumber, peer_index, title, title_len, userdata);
    }

    return true;
}

/** Check if the group has no online connection, and freeze all peers if so */
non_null(1) nullable(3)
static void check_disconnected(Group_Chats *g_c, uint32_t groupnumber, void *userdata)
{
    const Group_c *g = get_group_c(g_c, groupnumber);

    if (g == nullptr) {
        return;
    }

    for (uint32_t i = 0; i < MAX_GROUP_CONNECTIONS; ++i) {
        if (g->connections[i].type == GROUPCHAT_CONNECTION_ONLINE) {
            return;
        }
    }

    for (uint32_t i = 0; i < g->numpeers; ++i) {
        while (i < g->numpeers && !pk_equal(g->group[i].real_pk, g->real_pk)) {
            freeze_peer(g_c, groupnumber, i, userdata);
        }
    }
}

non_null(1) nullable(5)
static void set_conns_type_connections(Group_Chats *g_c, uint32_t groupnumber, int friendcon_id, uint8_t type,
                                       void *userdata)
{
    Group_c *g = get_group_c(g_c, groupnumber);

    if (g == nullptr) {
        return;
    }

    for (uint32_t i = 0; i < MAX_GROUP_CONNECTIONS; ++i) {
        if (g->connections[i].type == GROUPCHAT_CONNECTION_NONE) {
            continue;
        }

        if (g->connections[i].number != (unsigned int)friendcon_id) {
            continue;
        }

        if (type == GROUPCHAT_CONNECTION_ONLINE) {
            send_packet_online(g_c->fr_c, friendcon_id, groupnumber, g->type, g->id);
        } else {
            g->connections[i].type = type;
            check_disconnected(g_c, groupnumber, userdata);
        }
    }
}

/** Set the type for all connections with friendcon_id */
non_null(1) nullable(4)
static void set_conns_status_groups(Group_Chats *g_c, int friendcon_id, uint8_t type, void *userdata)
{
    for (uint16_t i = 0; i < g_c->num_chats; ++i) {
        set_conns_type_connections(g_c, i, friendcon_id, type, userdata);
    }
}

non_null()
static void rejoin_frozen_friend(Group_Chats *g_c, int friendcon_id)
{
    uint8_t real_pk[CRYPTO_PUBLIC_KEY_SIZE];
    get_friendcon_public_keys(real_pk, nullptr, g_c->fr_c, friendcon_id);

    for (uint16_t i = 0; i < g_c->num_chats; ++i) {
        Group_c *g = get_group_c(g_c, i);

        if (g == nullptr) {
            continue;
        }

        for (uint32_t j = 0; j < g->numfrozen; ++j) {
            if (pk_equal(g->frozen[j].real_pk, real_pk)) {
                try_send_rejoin(g_c, g, real_pk);
                break;
            }
        }
    }
}

non_null(1) nullable(4)
static int g_handle_any_status(void *object, int friendcon_id, bool status, void *userdata)
{
    Group_Chats *g_c = (Group_Chats *)object;

    if (status) {
        rejoin_frozen_friend(g_c, friendcon_id);
    }

    return 0;
}

non_null(1) nullable(4)
static int g_handle_status(void *object, int friendcon_id, bool status, void *userdata)
{
    Group_Chats *g_c = (Group_Chats *)object;

    if (status) { /* Went online */
        set_conns_status_groups(g_c, friendcon_id, GROUPCHAT_CONNECTION_ONLINE, userdata);
    } else { /* Went offline */
        set_conns_status_groups(g_c, friendcon_id, GROUPCHAT_CONNECTION_CONNECTING, userdata);
        // TODO(irungentoo): remove timedout connections?
    }

    return 0;
}

non_null(1, 3) nullable(5)
static int g_handle_packet(void *object, int friendcon_id, const uint8_t *data, uint16_t length, void *userdata);
non_null(1, 3) nullable(5)
static int handle_lossy(void *object, int friendcon_id, const uint8_t *data, uint16_t length, void *userdata);

/** @brief Add friend to group chat.
 *
 * @return connections index on success
 * @retval -1 on failure.
 */
static int add_conn_to_groupchat(Group_Chats *g_c, int friendcon_id, Group_c *g, uint8_t reason,
                                 bool lock)
{
    uint16_t empty = MAX_GROUP_CONNECTIONS;
    uint16_t ind = MAX_GROUP_CONNECTIONS;

    for (uint16_t i = 0; i < MAX_GROUP_CONNECTIONS; ++i) {
        if (g->connections[i].type == GROUPCHAT_CONNECTION_NONE) {
            empty = i;
            continue;
        }

        if (g->connections[i].number == (uint32_t)friendcon_id) {
            ind = i; /* Already in list. */
            break;
        }
    }

    if (ind == MAX_GROUP_CONNECTIONS) {
        if (empty == MAX_GROUP_CONNECTIONS) {
            return -1;
        }

        if (lock) {
            friend_connection_lock(g_c->fr_c, friendcon_id);
        }

        g->connections[empty].type = GROUPCHAT_CONNECTION_CONNECTING;
        g->connections[empty].number = friendcon_id;
        g->connections[empty].reasons = 0;
        // TODO(irungentoo):
        friend_connection_callbacks(g_c->m->fr_c, friendcon_id, GROUPCHAT_CALLBACK_INDEX, &g_handle_status, &g_handle_packet,
                                    &handle_lossy, g_c, friendcon_id);
        ind = empty;
    }

    if ((g->connections[ind].reasons & reason) == 0) {
        g->connections[ind].reasons |= reason;

        if (reason == GROUPCHAT_CONNECTION_REASON_INTRODUCER) {
            ++g->num_introducer_connections;
        }
    }

    return ind;
}

non_null()
static bool send_peer_introduced(const Group_Chats *g_c, int friendcon_id, uint16_t group_num);

/** @brief Removes reason for keeping connection.
 *
 * Kills connection if this was the last reason.
 */
static void remove_connection_reason(Group_Chats *g_c, Group_c *g, uint16_t i, uint8_t reason)
{
    if ((g->connections[i].reasons & reason) == 0) {
        return;
    }

    g->connections[i].reasons &= ~reason;

    if (reason == GROUPCHAT_CONNECTION_REASON_INTRODUCER) {
        --g->num_introducer_connections;

        if (g->connections[i].type == GROUPCHAT_CONNECTION_ONLINE) {
            send_peer_introduced(g_c, g->connections[i].number, g->connections[i].group_number);
        }
    }

    if (g->connections[i].reasons == 0) {
        kill_friend_connection(g_c->fr_c, g->connections[i].number);
        g->connections[i].type = GROUPCHAT_CONNECTION_NONE;
    }
}

/** @brief Creates a new groupchat and puts it in the chats array.
 *
 * @param rng Random number generator used for generating the group ID.
 * @param type is one of `GROUPCHAT_TYPE_*`
 *
 * @return group number on success.
 * @retval -1 on failure.
 */
int add_groupchat(Group_Chats *g_c, const Random *rng, uint8_t type)
{
    const int32_t groupnumber = create_group_chat(g_c);

    if (groupnumber == -1) {
        return -1;
    }

    Group_c *g = &g_c->chats[groupnumber];

    g->status = GROUPCHAT_STATUS_CONNECTED;
    g->type = type;
    new_symmetric_key(rng, g->id);
    g->peer_number = 0; /* Founder is peer 0. */
    memcpy(g->real_pk, nc_get_self_public_key(g_c->m->net_crypto), CRYPTO_PUBLIC_KEY_SIZE);
    const int peer_index = addpeer(g_c, groupnumber, g->real_pk, dht_get_self_public_key(g_c->m->dht), 0, nullptr, true,
                                   false);

    if (peer_index == -1) {
        return -1;
    }

    setnick(g_c, groupnumber, peer_index, g_c->m->name, g_c->m->name_length, nullptr, false);

    return groupnumber;
}

non_null()
static bool group_leave(const Group_Chats *g_c, uint32_t groupnumber, bool permanent);

/** @brief Delete a groupchat from the chats array, informing the group first as
 * appropriate.
 *
 * @retval true on success.
 * @retval false if groupnumber is invalid.
 */
bool del_groupchat(Group_Chats *g_c, uint32_t groupnumber, bool leave_permanently)
{
    Group_c *g = get_group_c(g_c, groupnumber);

    if (g == nullptr) {
        return false;
    }

    group_leave(g_c, groupnumber, leave_permanently);

    for (uint32_t i = 0; i < MAX_GROUP_CONNECTIONS; ++i) {
        if (g->connections[i].type == GROUPCHAT_CONNECTION_NONE) {
            continue;
        }

        g->connections[i].type = GROUPCHAT_CONNECTION_NONE;
        kill_friend_connection(g_c->fr_c, g->connections[i].number);
    }

    for (uint32_t i = 0; i < g->numpeers; ++i) {
        if (g->peer_on_leave != nullptr) {
            g->peer_on_leave(g->object, groupnumber, g->group[i].object);
        }
    }

    if (g->group_on_delete != nullptr) {
        g->group_on_delete(g->object, groupnumber);
    }

    return wipe_group_chat(g_c, groupnumber);
}

non_null()
static const Group_Peer *peer_in_list(const Group_c *g, uint32_t peernumber, bool frozen)
{
    const Group_Peer *list = frozen ? g->frozen : g->group;
    const uint32_t num = frozen ? g->numfrozen : g->numpeers;

    if (peernumber >= num) {
        return nullptr;
    }

    return &list[peernumber];
}


/**
 * @brief Copy the public key of (frozen, if frozen is true) peernumber who is in
 *   groupnumber to pk.
 *
 * @param pk must be CRYPTO_PUBLIC_KEY_SIZE long.
 *
 * @retval 0 on success
 * @retval -1 if groupnumber is invalid.
 * @retval -2 if peernumber is invalid.
 */
int group_peer_pubkey(const Group_Chats *g_c, uint32_t groupnumber, uint32_t peernumber, uint8_t *pk, bool frozen)
{
    const Group_c *g = get_group_c(g_c, groupnumber);

    if (g == nullptr) {
        return -1;
    }

    const Group_Peer *peer = peer_in_list(g, peernumber, frozen);

    if (peer == nullptr) {
        return -2;
    }

    memcpy(pk, peer->real_pk, CRYPTO_PUBLIC_KEY_SIZE);
    return 0;
}

/**
 * @brief Return the size of (frozen, if frozen is true) peernumber's name.
 *
 * @retval -1 if groupnumber is invalid.
 * @retval -2 if peernumber is invalid.
 */
int group_peername_size(const Group_Chats *g_c, uint32_t groupnumber, uint32_t peernumber, bool frozen)
{
    const Group_c *g = get_group_c(g_c, groupnumber);

    if (g == nullptr) {
        return -1;
    }

    const Group_Peer *peer = peer_in_list(g, peernumber, frozen);

    if (peer == nullptr) {
        return -2;
    }

    return peer->nick_len;
}

/**
 * @brief Copy the name of (frozen, if frozen is true) peernumber who is in
 *   groupnumber to name.
 *
 * @param  name must be at least MAX_NAME_LENGTH long.
 *
 * @return length of name if success
 * @retval -1 if groupnumber is invalid.
 * @retval -2 if peernumber is invalid.
 */
int group_peername(const Group_Chats *g_c, uint32_t groupnumber, uint32_t peernumber, uint8_t *name, bool frozen)
{
    const Group_c *g = get_group_c(g_c, groupnumber);

    if (g == nullptr) {
        return -1;
    }

    const Group_Peer *peer = peer_in_list(g, peernumber, frozen);

    if (peer == nullptr) {
        return -2;
    }

    if (peer->nick_len > 0) {
        memcpy(name, peer->nick, peer->nick_len);
    }

    return peer->nick_len;
}

/**
 * @brief Copy last active timestamp of frozen peernumber who is in groupnumber to
 *   last_active.
 *
 * @retval 0 on success.
 * @retval -1 if groupnumber is invalid.
 * @retval -2 if peernumber is invalid.
 */
int group_frozen_last_active(const Group_Chats *g_c, uint32_t groupnumber, uint32_t peernumber,
                             uint64_t *last_active)
{
    const Group_c *g = get_group_c(g_c, groupnumber);

    if (g == nullptr) {
        return -1;
    }

    if (peernumber >= g->numfrozen) {
        return -2;
    }

    *last_active = g->frozen[peernumber].last_active;
    return 0;
}

/** @brief Set maximum number of frozen peers.
 *
 * @retval 0 on success.
 * @retval -1 if groupnumber is invalid.
 */
int group_set_max_frozen(const Group_Chats *g_c, uint32_t groupnumber, uint32_t maxfrozen)
{
    Group_c *g = get_group_c(g_c, groupnumber);

    if (g == nullptr) {
        return -1;
    }

    g->maxfrozen = maxfrozen;
    delete_old_frozen(g);
    return 0;
}

/**
 * @return the number of (frozen, if frozen is true) peers in the group chat on success.
 * @retval -1 if groupnumber is invalid.
 */
int group_number_peers(const Group_Chats *g_c, uint32_t groupnumber, bool frozen)
{
    const Group_c *g = get_group_c(g_c, groupnumber);

    if (g == nullptr) {
        return -1;
    }

    return frozen ? g->numfrozen : g->numpeers;
}

/**
 * @retval 1 if the peernumber corresponds to ours.
 * @retval 0 if the peernumber is not ours.
 * @retval -1 if groupnumber is invalid.
 * @retval -2 if peernumber is invalid.
 * @retval -3 if we are not connected to the group chat.
 */
int group_peernumber_is_ours(const Group_Chats *g_c, uint32_t groupnumber, uint32_t peernumber)
{
    const Group_c *g = get_group_c(g_c, groupnumber);

    if (g == nullptr) {
        return -1;
    }

    if (peernumber >= g->numpeers) {
        return -2;
    }

    if (g->status != GROUPCHAT_STATUS_CONNECTED) {
        return -3;
    }

    return (g->peer_number == g->group[peernumber].peer_number) ? 1 : 0;
}

/** @brief return the type of groupchat (GROUPCHAT_TYPE_) that groupnumber is.
 *
 * @retval -1 on failure.
 * @return type on success.
 */
int group_get_type(const Group_Chats *g_c, uint32_t groupnumber)
{
    const Group_c *g = get_group_c(g_c, groupnumber);

    if (g == nullptr) {
        return -1;
    }

    return g->type;
}

/** @brief Copies the unique id of `group_chat[groupnumber]` into `id`.
 *
 * @retval false on failure.
 * @retval true on success.
 */
bool conference_get_id(const Group_Chats *g_c, uint32_t groupnumber, uint8_t *id)
{
    const Group_c *g = get_group_c(g_c, groupnumber);

    if (g == nullptr) {
        return false;
    }

    if (id != nullptr) {
        memcpy(id, g->id, sizeof(g->id));
    }

    return true;
}

/** @brief Send a group packet to friendcon_id.
 *
 * @retval true on success
 * @retval false on failure
 */
non_null()
static bool send_packet_group_peer(const Friend_Connections *fr_c, int friendcon_id, uint8_t packet_id,
                                   uint16_t group_num, const uint8_t *data, uint16_t length)
{
    if (1 + sizeof(uint16_t) + length > MAX_CRYPTO_DATA_SIZE) {
        return false;
    }

    group_num = net_htons(group_num);
    VLA(uint8_t, packet, 1 + sizeof(uint16_t) + length);
    packet[0] = packet_id;
    memcpy(packet + 1, &group_num, sizeof(uint16_t));
    memcpy(packet + 1 + sizeof(uint16_t), data, length);
    return write_cryptpacket(friendconn_net_crypto(fr_c), friend_connection_crypt_connection_id(fr_c, friendcon_id), packet,
                             SIZEOF_VLA(packet), false) != -1;
}

/** @brief Send a group lossy packet to friendcon_id.
 *
 * @retval true on success
 * @retval false on failure
 */
non_null()
static bool send_lossy_group_peer(const Friend_Connections *fr_c, int friendcon_id, uint8_t packet_id,
                                  uint16_t group_num, const uint8_t *data, uint16_t length)
{
    if (1 + sizeof(uint16_t) + length > MAX_CRYPTO_DATA_SIZE) {
        return false;
    }

    group_num = net_htons(group_num);
    VLA(uint8_t, packet, 1 + sizeof(uint16_t) + length);
    packet[0] = packet_id;
    memcpy(packet + 1, &group_num, sizeof(uint16_t));
    memcpy(packet + 1 + sizeof(uint16_t), data, length);
    return send_lossy_cryptpacket(friendconn_net_crypto(fr_c), friend_connection_crypt_connection_id(fr_c, friendcon_id),
                                  packet, SIZEOF_VLA(packet)) != -1;
}

/** @brief invite friendnumber to groupnumber.
 *
 * @retval 0 on success.
 * @retval -1 if groupnumber is invalid.
 * @retval -2 if invite packet failed to send.
 * @retval -3 if we are not connected to the group chat.
 */
int invite_friend(const Group_Chats *g_c, uint32_t friendnumber, uint32_t groupnumber)
{
    const Group_c *g = get_group_c(g_c, groupnumber);

    if (g == nullptr) {
        return -1;
    }

    if (g->status != GROUPCHAT_STATUS_CONNECTED) {
        return -3;
    }

    uint8_t invite[INVITE_PACKET_SIZE];
    invite[0] = INVITE_ID;
    const uint16_t groupchat_num = net_htons((uint16_t)groupnumber);
    memcpy(invite + 1, &groupchat_num, sizeof(groupchat_num));
    invite[1 + sizeof(groupchat_num)] = g->type;
    memcpy(invite + 1 + sizeof(groupchat_num) + 1, g->id, GROUP_ID_LENGTH);

    if (send_conference_invite_packet(g_c->m, friendnumber, invite, sizeof(invite))) {
        return 0;
    }

    return -2;
}

/** @brief Send a rejoin packet to a peer if we have a friend connection to the peer.
 * @retval true if a packet was sent.
 * @retval false otherwise.
 */
static bool try_send_rejoin(Group_Chats *g_c, Group_c *g, const uint8_t *real_pk)
{
    const int friendcon_id = getfriend_conn_id_pk(g_c->fr_c, real_pk);

    if (friendcon_id == -1) {
        return false;
    }

    uint8_t packet[1 + 1 + GROUP_ID_LENGTH];
    packet[0] = PACKET_ID_REJOIN_CONFERENCE;
    packet[1] = g->type;
    memcpy(packet + 2, g->id, GROUP_ID_LENGTH);

    if (write_cryptpacket(friendconn_net_crypto(g_c->fr_c), friend_connection_crypt_connection_id(g_c->fr_c, friendcon_id),
                          packet, sizeof(packet), false) == -1) {
        return false;
    }

    add_conn_to_groupchat(g_c, friendcon_id, g, GROUPCHAT_CONNECTION_REASON_INTRODUCER, true);

    return true;
}

non_null()
static bool send_peer_query(const Group_Chats *g_c, int friendcon_id, uint16_t group_num);

non_null()
static bool send_invite_response(Group_Chats *g_c, int groupnumber, uint32_t friendnumber, const uint8_t *data,
                                 uint16_t length);

/** @brief Join a group (we need to have been invited first).
 *
 * @param expected_type is the groupchat type we expect the chat we are joining
 *   to have.
 *
 * @return group number on success.
 * @retval -1 if data length is invalid.
 * @retval -2 if group is not the expected type.
 * @retval -3 if friendnumber is invalid.
 * @retval -4 if client is already in this group.
 * @retval -5 if group instance failed to initialize.
 * @retval -6 if join packet fails to send.
 */
int join_groupchat(Group_Chats *g_c, uint32_t friendnumber, uint8_t expected_type, const uint8_t *data, uint16_t length)
{
    if (length != sizeof(uint16_t) + 1 + GROUP_ID_LENGTH) {
        return -1;
    }

    if (data[sizeof(uint16_t)] != expected_type) {
        return -2;
    }

    const int friendcon_id = getfriendcon_id(g_c->m, friendnumber);

    if (friendcon_id == -1) {
        return -3;
    }

    if (get_group_num(g_c, data[sizeof(uint16_t)], data + sizeof(uint16_t) + 1) != -1) {
        return -4;
    }

    const int groupnumber = create_group_chat(g_c);

    if (groupnumber == -1) {
        return -5;
    }

    Group_c *g = &g_c->chats[groupnumber];

    g->status = GROUPCHAT_STATUS_VALID;
    memcpy(g->real_pk, nc_get_self_public_key(g_c->m->net_crypto), CRYPTO_PUBLIC_KEY_SIZE);

    if (!send_invite_response(g_c, groupnumber, friendnumber, data, length)) {
        g->status = GROUPCHAT_STATUS_NONE;
        return -6;
    }

    return groupnumber;
}

static bool send_invite_response(Group_Chats *g_c, int groupnumber, uint32_t friendnumber, const uint8_t *data,
                                 uint16_t length)
{
    Group_c *g = get_group_c(g_c, groupnumber);

    if (g == nullptr) {
        return false;
    }

    const bool member = g->status == GROUPCHAT_STATUS_CONNECTED;

    VLA(uint8_t, response, member ? INVITE_MEMBER_PACKET_SIZE : INVITE_ACCEPT_PACKET_SIZE);
    response[0] = member ? INVITE_MEMBER_ID : INVITE_ACCEPT_ID;
    net_pack_u16(response + 1, groupnumber);
    memcpy(response + 1 + sizeof(uint16_t), data, length);

    if (member) {
        net_pack_u16(response + 1 + sizeof(uint16_t) + length, g->peer_number);
    }

    if (!send_conference_invite_packet(g_c->m, friendnumber, response, SIZEOF_VLA(response))) {
        return false;
    }

    if (!member) {
        g->type = data[sizeof(uint16_t)];
        memcpy(g->id, data + sizeof(uint16_t) + 1, GROUP_ID_LENGTH);
    }

    uint16_t other_groupnum;
    net_unpack_u16(data, &other_groupnum);

    const int friendcon_id = getfriendcon_id(g_c->m, friendnumber);

    if (friendcon_id == -1) {
        return false;
    }

    const int connection_index = add_conn_to_groupchat(g_c, friendcon_id, g, GROUPCHAT_CONNECTION_REASON_INTRODUCER, true);

    if (member) {
        add_conn_to_groupchat(g_c, friendcon_id, g, GROUPCHAT_CONNECTION_REASON_INTRODUCING, false);
    }

    if (connection_index != -1) {
        g->connections[connection_index].group_number = other_groupnum;
        g->connections[connection_index].type = GROUPCHAT_CONNECTION_ONLINE;
    }

    send_peer_query(g_c, friendcon_id, other_groupnum);

    return true;
}

/** Set handlers for custom lossy packets. */
void group_lossy_packet_registerhandler(Group_Chats *g_c, uint8_t byte, lossy_packet_cb *function)
{
    g_c->lossy_packethandlers[byte] = function;
}

/** Set the callback for group invites. */
void g_callback_group_invite(Group_Chats *g_c, g_conference_invite_cb *function)
{
    g_c->invite_callback = function;
}

/** Set the callback for group connection. */
void g_callback_group_connected(Group_Chats *g_c, g_conference_connected_cb *function)
{
    g_c->connected_callback = function;
}

/** Set the callback for group messages. */
void g_callback_group_message(Group_Chats *g_c, g_conference_message_cb *function)
{
    g_c->message_callback = function;
}

/** @brief Set callback function for peer nickname changes.
 *
 * It gets called every time a peer changes their nickname.
 */
void g_callback_peer_name(Group_Chats *g_c, peer_name_cb *function)
{
    g_c->peer_name_callback = function;
}

/** @brief Set callback function for peer list changes.
 *
 * It gets called every time the name list changes(new peer, deleted peer)
 */
void g_callback_peer_list_changed(Group_Chats *g_c, peer_list_changed_cb *function)
{
    g_c->peer_list_changed_callback = function;
}

/** Set callback function for title changes. */
void g_callback_group_title(Group_Chats *g_c, title_cb *function)
{
    g_c->title_callback = function;
}

/** @brief Set a function to be called when a new peer joins a group chat.
 *
 * @retval 0 on success.
 * @retval -1 on failure.
 */
int callback_groupchat_peer_new(const Group_Chats *g_c, uint32_t groupnumber, peer_on_join_cb *function)
{
    Group_c *g = get_group_c(g_c, groupnumber);

    if (g == nullptr) {
        return -1;
    }

    g->peer_on_join = function;
    return 0;
}

/** @brief Set a function to be called when a peer leaves a group chat.
 *
 * @retval 0 on success.
 * @retval -1 on failure.
 */
int callback_groupchat_peer_delete(const Group_Chats *g_c, uint32_t groupnumber, peer_on_leave_cb *function)
{
    Group_c *g = get_group_c(g_c, groupnumber);

    if (g == nullptr) {
        return -1;
    }

    g->peer_on_leave = function;
    return 0;
}

/** @brief Set a function to be called when the group chat is deleted.
 *
 * @retval 0 on success.
 * @retval -1 on failure.
 */
int callback_groupchat_delete(const Group_Chats *g_c, uint32_t groupnumber, group_on_delete_cb *function)
{
    Group_c *g = get_group_c(g_c, groupnumber);

    if (g == nullptr) {
        return -1;
    }

    g->group_on_delete = function;
    return 0;
}

non_null(1) nullable(4)
static int send_message_group(const Group_Chats *g_c, uint32_t groupnumber, uint8_t message_id, const uint8_t *data,
                              uint16_t len);

/** @brief send a ping message
 * return true on success
 */
non_null()
static bool group_ping_send(const Group_Chats *g_c, uint32_t groupnumber)
{
    return send_message_group(g_c, groupnumber, GROUP_MESSAGE_PING_ID, nullptr, 0) > 0;
}

/** @brief send a new_peer message
 * return true on success
 */
non_null()
static bool group_new_peer_send(const Group_Chats *g_c, uint32_t groupnumber, uint16_t peer_num, const uint8_t *real_pk,
                                const uint8_t *temp_pk)
{
    uint8_t packet[GROUP_MESSAGE_NEW_PEER_LENGTH];

    peer_num = net_htons(peer_num);
    memcpy(packet, &peer_num, sizeof(uint16_t));
    memcpy(packet + sizeof(uint16_t), real_pk, CRYPTO_PUBLIC_KEY_SIZE);
    memcpy(packet + sizeof(uint16_t) + CRYPTO_PUBLIC_KEY_SIZE, temp_pk, CRYPTO_PUBLIC_KEY_SIZE);

    return send_message_group(g_c, groupnumber, GROUP_MESSAGE_NEW_PEER_ID, packet, sizeof(packet)) > 0;
}

/** @brief send a kill_peer message
 * return true on success
 */
non_null()
static bool group_kill_peer_send(const Group_Chats *g_c, uint32_t groupnumber, uint16_t peer_num)
{
    uint8_t packet[GROUP_MESSAGE_KILL_PEER_LENGTH];

    peer_num = net_htons(peer_num);
    memcpy(packet, &peer_num, sizeof(uint16_t));

    return send_message_group(g_c, groupnumber, GROUP_MESSAGE_KILL_PEER_ID, packet, sizeof(packet)) > 0;
}

/** @brief send a freeze_peer message
 * return true on success
 */
non_null()
static bool group_freeze_peer_send(const Group_Chats *g_c, uint32_t groupnumber, uint16_t peer_num)
{
    uint8_t packet[GROUP_MESSAGE_KILL_PEER_LENGTH];

    peer_num = net_htons(peer_num);
    memcpy(packet, &peer_num, sizeof(uint16_t));

    return send_message_group(g_c, groupnumber, GROUP_MESSAGE_FREEZE_PEER_ID, packet, sizeof(packet)) > 0;
}

/** @brief send a name message
 * return true on success
 */
non_null()
static bool group_name_send(const Group_Chats *g_c, uint32_t groupnumber, const uint8_t *nick, uint16_t nick_len)
{
    if (nick_len > MAX_NAME_LENGTH) {
        return false;
    }

    return send_message_group(g_c, groupnumber, GROUP_MESSAGE_NAME_ID, nick, nick_len) > 0;
}

/** @brief send message to announce leaving group
 * return true on success
 */
static bool group_leave(const Group_Chats *g_c, uint32_t groupnumber, bool permanent)
{
    const Group_c *g = get_group_c(g_c, groupnumber);

    if (g == nullptr) {
        return false;
    }

    if (permanent) {
        return group_kill_peer_send(g_c, groupnumber, g->peer_number);
    } else {
        return group_freeze_peer_send(g_c, groupnumber, g->peer_number);
    }
}


/** @brief set the group's title, limited to MAX_NAME_LENGTH.
 * @retval 0 on success
 * @retval -1 if groupnumber is invalid.
 * @retval -2 if title is too long or empty.
 * @retval -3 if packet fails to send.
 */
int group_title_send(const Group_Chats *g_c, uint32_t groupnumber, const uint8_t *title, uint8_t title_len)
{
    Group_c *g = get_group_c(g_c, groupnumber);

    if (g == nullptr) {
        return -1;
    }

    if (title_len > MAX_NAME_LENGTH || title_len == 0) {
        return -2;
    }

    /* same as already set? */
    if (g_title_eq(g, title, title_len)) {
        return 0;
    }

    memcpy(g->title, title, title_len);
    g->title_len = title_len;

    if (g->numpeers == 1) {
        return 0;
    }

    if (send_message_group(g_c, groupnumber, GROUP_MESSAGE_TITLE_ID, title, title_len) > 0) {
        return 0;
    }

    return -3;
}

/** @brief return the group's title size.
 * @retval -1 of groupnumber is invalid.
 * @retval -2 if title is too long or empty.
 */
int group_title_get_size(const Group_Chats *g_c, uint32_t groupnumber)
{
    const Group_c *g = get_group_c(g_c, groupnumber);

    if (g == nullptr) {
        return -1;
    }

    if (g->title_len > MAX_NAME_LENGTH || g->title_len == 0) {
        return -2;
    }

    return g->title_len;
}

/** @brief Get group title from groupnumber and put it in title.
 *
 * Title needs to be a valid memory location with a size of at least MAX_NAME_LENGTH (128) bytes.
 *
 * @return length of copied title if success.
 * @retval -1 if groupnumber is invalid.
 * @retval -2 if title is too long or empty.
 */
int group_title_get(const Group_Chats *g_c, uint32_t groupnumber, uint8_t *title)
{
    const Group_c *g = get_group_c(g_c, groupnumber);

    if (g == nullptr) {
        return -1;
    }

    if (g->title_len > MAX_NAME_LENGTH || g->title_len == 0) {
        return -2;
    }

    memcpy(title, g->title, g->title_len);
    return g->title_len;
}

non_null()
static bool get_peer_number(const Group_c *g, const uint8_t *real_pk, uint16_t *peer_number)
{
    const int peer_index = peer_in_group(g, real_pk);

    if (peer_index >= 0) {
        *peer_number = g->group[peer_index].peer_number;
        return true;
    }

    const int frozen_index = frozen_in_group(g, real_pk);

    if (frozen_index >= 0) {
        *peer_number = g->frozen[frozen_index].peer_number;
        return true;
    }

    return false;
}

non_null(1, 3) nullable(5)
static void handle_friend_invite_packet(Messenger *m, uint32_t friendnumber, const uint8_t *data, uint16_t length,
                                        void *userdata)
{
    Group_Chats *g_c = m->conferences_object;

    if (length <= 1) {
        return;
    }

    switch (data[0]) {
        case INVITE_ID: {
            if (length != INVITE_PACKET_SIZE) {
                return;
            }

            const int groupnumber = get_group_num(g_c, data[1 + sizeof(uint16_t)], data + 1 + sizeof(uint16_t) + 1);

            const uint8_t *invite_data = data + 1;
            const uint16_t invite_length = length - 1;

            if (groupnumber == -1) {
                if (g_c->invite_callback != nullptr) {
                    g_c->invite_callback(m, friendnumber, invite_data[sizeof(uint16_t)], invite_data, invite_length, userdata);
                }

                return;
            } else {
                const Group_c *g = get_group_c(g_c, groupnumber);

                if (g != nullptr && g->status == GROUPCHAT_STATUS_CONNECTED) {
                    send_invite_response(g_c, groupnumber, friendnumber, invite_data, invite_length);
                }
            }

            break;
        }

        case INVITE_ACCEPT_ID:
        case INVITE_MEMBER_ID: {
            const bool member = data[0] == INVITE_MEMBER_ID;

            if (length != (member ? INVITE_MEMBER_PACKET_SIZE : INVITE_ACCEPT_PACKET_SIZE)) {
                return;
            }

            uint16_t other_groupnum;
            uint16_t groupnum;
            net_unpack_u16(data + 1, &other_groupnum);
            net_unpack_u16(data + 1 + sizeof(uint16_t), &groupnum);

            Group_c *g = get_group_c(g_c, groupnum);

            if (g == nullptr) {
                return;
            }

            if (data[1 + sizeof(uint16_t) * 2] != g->type) {
                return;
            }

            if (!group_id_eq(data + 1 + sizeof(uint16_t) * 2 + 1, g->id)) {
                return;
            }

            uint16_t peer_number;

            if (member) {
                net_unpack_u16(data + 1 + sizeof(uint16_t) * 2 + 1 + GROUP_ID_LENGTH, &peer_number);
            } else {
                /* TODO(irungentoo): what if two people enter the group at the
                 * same time and are given the same peer_number by different
                 * nodes? */
                peer_number = random_u16(m->rng);

                unsigned int tries = 0;

                while (get_peer_index(g, peer_number) != -1 || get_frozen_index(g, peer_number) != -1) {
                    peer_number = random_u16(m->rng);
                    ++tries;

                    if (tries > 32) {
                        return;
                    }
                }
            }

            const int friendcon_id = getfriendcon_id(m, friendnumber);

            if (friendcon_id == -1) {
                // TODO(iphydf): Log something?
                return;
            }

            uint8_t real_pk[CRYPTO_PUBLIC_KEY_SIZE];
            uint8_t temp_pk[CRYPTO_PUBLIC_KEY_SIZE];
            get_friendcon_public_keys(real_pk, temp_pk, g_c->fr_c, friendcon_id);

            addpeer(g_c, groupnum, real_pk, temp_pk, peer_number, userdata, true, true);
            const int connection_index = add_conn_to_groupchat(g_c, friendcon_id, g,
                                         GROUPCHAT_CONNECTION_REASON_INTRODUCING, true);

            if (member) {
                add_conn_to_groupchat(g_c, friendcon_id, g, GROUPCHAT_CONNECTION_REASON_INTRODUCER, false);
                send_peer_query(g_c, friendcon_id, other_groupnum);
            }

            if (connection_index != -1) {
                g->connections[connection_index].group_number = other_groupnum;
                g->connections[connection_index].type = GROUPCHAT_CONNECTION_ONLINE;
            }

            group_new_peer_send(g_c, groupnum, peer_number, real_pk, temp_pk);

            break;
        }

        default: {
            return;
        }
    }
}

/** @brief Find index of friend in the connections list.
 *
 * return index on success
 * return -1 on failure.
 */
non_null()
static int friend_in_connections(const Group_c *g, int friendcon_id)
{
    for (unsigned int i = 0; i < MAX_GROUP_CONNECTIONS; ++i) {
        if (g->connections[i].type == GROUPCHAT_CONNECTION_NONE) {
            continue;
        }

        if (g->connections[i].number == (uint32_t)friendcon_id) {
            return i;
        }
    }

    return -1;
}

/** return number of connections. */
non_null()
static unsigned int count_connected(const Group_c *g)
{
    unsigned int count = 0;

    for (unsigned int i = 0; i < MAX_GROUP_CONNECTIONS; ++i) {
        if (g->connections[i].type == GROUPCHAT_CONNECTION_ONLINE) {
            ++count;
        }
    }

    return count;
}

static bool send_packet_online(const Friend_Connections *fr_c, int friendcon_id, uint16_t group_num,
                               uint8_t type, const uint8_t *id)
{
    uint8_t packet[1 + ONLINE_PACKET_DATA_SIZE];
    group_num = net_htons(group_num);
    packet[0] = PACKET_ID_ONLINE_PACKET;
    memcpy(packet + 1, &group_num, sizeof(uint16_t));
    packet[1 + sizeof(uint16_t)] = type;
    memcpy(packet + 1 + sizeof(uint16_t) + 1, id, GROUP_ID_LENGTH);
    return write_cryptpacket(friendconn_net_crypto(fr_c), friend_connection_crypt_connection_id(fr_c, friendcon_id), packet,
                             sizeof(packet), false) != -1;
}

non_null()
static bool ping_groupchat(const Group_Chats *g_c, uint32_t groupnumber);

non_null()
static int handle_packet_online(const Group_Chats *g_c, int friendcon_id, const uint8_t *data, uint16_t length)
{
    if (length != ONLINE_PACKET_DATA_SIZE) {
        return -1;
    }

    const int groupnumber = get_group_num(g_c, data[sizeof(uint16_t)], data + sizeof(uint16_t) + 1);

    if (groupnumber == -1) {
        return -1;
    }

    uint16_t other_groupnum;
    memcpy(&other_groupnum, data, sizeof(uint16_t));
    other_groupnum = net_ntohs(other_groupnum);

    Group_c *g = get_group_c(g_c, groupnumber);

    if (g == nullptr) {
        return -1;
    }

    const int index = friend_in_connections(g, friendcon_id);

    if (index == -1) {
        return -1;
    }

    if (g->connections[index].type == GROUPCHAT_CONNECTION_ONLINE) {
        return -1;
    }

    if (count_connected(g) == 0 || (g->connections[index].reasons & GROUPCHAT_CONNECTION_REASON_INTRODUCER) != 0) {
        send_peer_query(g_c, friendcon_id, other_groupnum);
    }

    g->connections[index].group_number = other_groupnum;
    g->connections[index].type = GROUPCHAT_CONNECTION_ONLINE;
    send_packet_online(g_c->fr_c, friendcon_id, groupnumber, g->type, g->id);

    if ((g->connections[index].reasons & GROUPCHAT_CONNECTION_REASON_INTRODUCING) != 0) {
        uint8_t real_pk[CRYPTO_PUBLIC_KEY_SIZE];
        uint8_t temp_pk[CRYPTO_PUBLIC_KEY_SIZE];
        get_friendcon_public_keys(real_pk, temp_pk, g_c->fr_c, friendcon_id);

        const int peer_index = peer_in_group(g, real_pk);

        if (peer_index != -1) {
            group_new_peer_send(g_c, groupnumber, g->group[peer_index].peer_number, real_pk, temp_pk);
        }

        g->need_send_name = true;
    }

    ping_groupchat(g_c, groupnumber);

    return 0;
}

non_null(1, 3) nullable(5)
static int handle_packet_rejoin(Group_Chats *g_c, int friendcon_id, const uint8_t *data, uint16_t length,
                                void *userdata)
{
    if (length < 1 + GROUP_ID_LENGTH) {
        return -1;
    }

    const int32_t groupnum = get_group_num(g_c, *data, data + 1);

    Group_c *g = get_group_c(g_c, groupnum);

    if (g == nullptr) {
        return -1;
    }

    uint8_t real_pk[CRYPTO_PUBLIC_KEY_SIZE];
    uint8_t temp_pk[CRYPTO_PUBLIC_KEY_SIZE];
    get_friendcon_public_keys(real_pk, temp_pk, g_c->fr_c, friendcon_id);

    uint16_t peer_number;

    if (!get_peer_number(g, real_pk, &peer_number)) {
        return -1;
    }

    addpeer(g_c, groupnum, real_pk, temp_pk, peer_number, userdata, true, true);
    const int connection_index = add_conn_to_groupchat(g_c, friendcon_id, g,
                                 GROUPCHAT_CONNECTION_REASON_INTRODUCING, true);

    if (connection_index != -1) {
        send_packet_online(g_c->fr_c, friendcon_id, groupnum, g->type, g->id);
    }

    return 0;
}


// we could send title with invite, but then if it changes between sending and accepting inv, joinee won't see it

/**
 * @retval true on success.
 * @retval false on failure
 */
static bool send_peer_introduced(const Group_Chats *g_c, int friendcon_id, uint16_t group_num)
{
    uint8_t packet[1];
    packet[0] = PEER_INTRODUCED_ID;
    return send_packet_group_peer(g_c->fr_c, friendcon_id, PACKET_ID_DIRECT_CONFERENCE, group_num, packet, sizeof(packet));
}


/**
 * @retval true on success.
 * @retval false on failure
 */
static bool send_peer_query(const Group_Chats *g_c, int friendcon_id, uint16_t group_num)
{
    uint8_t packet[1];
    packet[0] = PEER_QUERY_ID;
    return send_packet_group_peer(g_c->fr_c, friendcon_id, PACKET_ID_DIRECT_CONFERENCE, group_num, packet, sizeof(packet));
}

/**
 * @return number of peers sent on success.
 * @retval 0 on failure.
 */
non_null()
static unsigned int send_peers(const Group_Chats *g_c, const Group_c *g, int friendcon_id, uint16_t group_num)
{
    uint8_t response_packet[MAX_CRYPTO_DATA_SIZE - (1 + sizeof(uint16_t))];
    response_packet[0] = PEER_RESPONSE_ID;
    uint8_t *p = response_packet + 1;

    uint16_t sent = 0;

    for (uint32_t i = 0; i <= g->numpeers; ++i) {
        if (i == g->numpeers
                || (p - response_packet) + sizeof(uint16_t) + CRYPTO_PUBLIC_KEY_SIZE * 2 + 1 + g->group[i].nick_len >
                sizeof(response_packet)) {
            if (send_packet_group_peer(g_c->fr_c, friendcon_id, PACKET_ID_DIRECT_CONFERENCE, group_num, response_packet,
                                       p - response_packet)) {
                sent = i;
            } else {
                return sent;
            }

            if (i == g->numpeers) {
                break;
            }

            p = response_packet + 1;
        }

        const uint16_t peer_num = net_htons(g->group[i].peer_number);
        memcpy(p, &peer_num, sizeof(peer_num));
        p += sizeof(peer_num);
        memcpy(p, g->group[i].real_pk, CRYPTO_PUBLIC_KEY_SIZE);
        p += CRYPTO_PUBLIC_KEY_SIZE;
        memcpy(p, g->group[i].temp_pk, CRYPTO_PUBLIC_KEY_SIZE);
        p += CRYPTO_PUBLIC_KEY_SIZE;
        *p = g->group[i].nick_len;
        p += 1;
        memcpy(p, g->group[i].nick, g->group[i].nick_len);
        p += g->group[i].nick_len;
    }

    if (g->title_len > 0) {
        VLA(uint8_t, title_packet, 1 + g->title_len);
        title_packet[0] = PEER_TITLE_ID;
        memcpy(title_packet + 1, g->title, g->title_len);
        send_packet_group_peer(g_c->fr_c, friendcon_id, PACKET_ID_DIRECT_CONFERENCE, group_num, title_packet,
                               SIZEOF_VLA(title_packet));
    }

    return sent;
}

non_null(1, 3) nullable(5)
static int handle_send_peers(Group_Chats *g_c, uint32_t groupnumber, const uint8_t *data, uint16_t length,
                             void *userdata)
{
    if (length == 0) {
        return -1;
    }

    Group_c *g = get_group_c(g_c, groupnumber);

    if (g == nullptr) {
        return -1;
    }

    const uint8_t *d = data;

    while ((unsigned int)(length - (d - data)) >= sizeof(uint16_t) + CRYPTO_PUBLIC_KEY_SIZE * 2 + 1) {
        uint16_t peer_num;
        memcpy(&peer_num, d, sizeof(peer_num));
        peer_num = net_ntohs(peer_num);
        d += sizeof(uint16_t);

        if (g->status == GROUPCHAT_STATUS_VALID
                && pk_equal(d, nc_get_self_public_key(g_c->m->net_crypto))) {
            g->peer_number = peer_num;
            g->status = GROUPCHAT_STATUS_CONNECTED;

            if (g_c->connected_callback != nullptr) {
                g_c->connected_callback(g_c->m, groupnumber, userdata);
            }

            g->need_send_name = true;
        }

        const int peer_index = addpeer(g_c, groupnumber, d, d + CRYPTO_PUBLIC_KEY_SIZE, peer_num, userdata, false, true);

        if (peer_index == -1) {
            return -1;
        }

        d += CRYPTO_PUBLIC_KEY_SIZE * 2;
        const uint8_t name_length = *d;
        d += 1;

        if (name_length > (length - (d - data)) || name_length > MAX_NAME_LENGTH) {
            return -1;
        }

        if (!g->group[peer_index].nick_updated) {
            setnick(g_c, groupnumber, peer_index, d, name_length, userdata, true);
        }

        d += name_length;
    }

    return 0;
}

non_null(1, 3) nullable(6)
static void handle_direct_packet(Group_Chats *g_c, uint32_t groupnumber, const uint8_t *data, uint16_t length,
                                 int connection_index, void *userdata)
{
    if (length == 0) {
        return;
    }

    Group_c *g = get_group_c(g_c, groupnumber);

    if (g == nullptr) {
        return;
    }

    switch (data[0]) {
        case PEER_INTRODUCED_ID: {
            remove_connection_reason(g_c, g, connection_index, GROUPCHAT_CONNECTION_REASON_INTRODUCING);
            break;
        }

        case PEER_QUERY_ID: {
            if (g->connections[connection_index].type != GROUPCHAT_CONNECTION_ONLINE) {
                return;
            }

            send_peers(g_c, g, g->connections[connection_index].number, g->connections[connection_index].group_number);
            break;
        }


        case PEER_RESPONSE_ID: {
            handle_send_peers(g_c, groupnumber, data + 1, length - 1, userdata);
            break;
        }


        case PEER_TITLE_ID: {
            if (!g->title_fresh) {
                settitle(g_c, groupnumber, -1, data + 1, length - 1, userdata);
            }

            break;
        }
    }
}

/** @brief Send message to all connections except receiver (if receiver isn't -1)
 *
 * NOTE: this function appends the group chat number to the data passed to it.
 *
 * @return number of messages sent.
 */
non_null()
static unsigned int send_message_all_connections(const Group_Chats *g_c, const Group_c *g, const uint8_t *data,
        uint16_t length, int receiver)
{
    uint16_t sent = 0;

    for (uint16_t i = 0; i < MAX_GROUP_CONNECTIONS; ++i) {
        if (g->connections[i].type != GROUPCHAT_CONNECTION_ONLINE) {
            continue;
        }

        if ((int)i == receiver) {
            continue;
        }

        if (send_packet_group_peer(g_c->fr_c, g->connections[i].number, PACKET_ID_MESSAGE_CONFERENCE,
                                   g->connections[i].group_number, data, length)) {
            ++sent;
        }
    }

    return sent;
}

/** @brief Send lossy message to all connections except receiver (if receiver isn't -1)
 *
 * NOTE: this function appends the group chat number to the data passed to it.
 *
 * @return number of messages sent.
 */
non_null()
static unsigned int send_lossy_all_connections(const Group_Chats *g_c, const Group_c *g, const uint8_t *data,
        uint16_t length, int receiver)
{
    unsigned int sent = 0;
    unsigned int num_connected_closest = 0;
    unsigned int connected_closest[DESIRED_CLOSEST] = {0};

    for (unsigned int i = 0; i < MAX_GROUP_CONNECTIONS; ++i) {
        if (g->connections[i].type != GROUPCHAT_CONNECTION_ONLINE) {
            continue;
        }

        if ((int)i == receiver) {
            continue;
        }

        if ((g->connections[i].reasons & GROUPCHAT_CONNECTION_REASON_CLOSEST) != 0) {
            connected_closest[num_connected_closest] = i;
            ++num_connected_closest;
            continue;
        }

        if (send_lossy_group_peer(g_c->fr_c, g->connections[i].number, PACKET_ID_LOSSY_CONFERENCE,
                                  g->connections[i].group_number, data, length)) {
            ++sent;
        }
    }

    if (num_connected_closest == 0) {
        return sent;
    }

    unsigned int to_send[2] = {0, 0};
    uint64_t comp_val_old[2] = {(uint64_t) -1, (uint64_t) -1};

    for (unsigned int i = 0; i < num_connected_closest; ++i) {
        uint8_t real_pk[CRYPTO_PUBLIC_KEY_SIZE] = {0};
        get_friendcon_public_keys(real_pk, nullptr, g_c->fr_c, g->connections[connected_closest[i]].number);
        const uint64_t comp_val = calculate_comp_value(g->real_pk, real_pk);

        for (uint8_t j = 0; j < 2; ++j) {
            if (j > 0 ? (comp_val > comp_val_old[j]) : (comp_val < comp_val_old[j])) {
                to_send[j] = connected_closest[i];
                comp_val_old[j] = comp_val;
            }
        }
    }

    for (uint8_t j = 0; j < 2; ++j) {
        if (j > 0 && to_send[1] == to_send[0]) {
            break;
        }

        if (send_lossy_group_peer(g_c->fr_c, g->connections[to_send[j]].number, PACKET_ID_LOSSY_CONFERENCE,
                                  g->connections[to_send[j]].group_number, data, length)) {
            ++sent;
        }
    }

    return sent;
}

/** @brief Send data of len with message_id to groupnumber.
 *
 * @return number of peers it was sent to on success.
 * @retval -1 if groupnumber is invalid.
 * @retval -2 if message is too long.
 * @retval -3 if we are not connected to the group.
 * @retval -4 if message failed to send.
 */
static int send_message_group(const Group_Chats *g_c, uint32_t groupnumber, uint8_t message_id, const uint8_t *data,
                              uint16_t len)
{
    assert(len == 0 || data != nullptr);
    Group_c *g = get_group_c(g_c, groupnumber);

    if (g == nullptr) {
        return -1;
    }

    if (len > MAX_GROUP_MESSAGE_DATA_LEN) {
        return -2;
    }

    if (g->status != GROUPCHAT_STATUS_CONNECTED || count_connected(g) == 0) {
        return -3;
    }

    VLA(uint8_t, packet, sizeof(uint16_t) + sizeof(uint32_t) + 1 + len);
    const uint16_t peer_num = net_htons(g->peer_number);
    memcpy(packet, &peer_num, sizeof(peer_num));

    ++g->message_number;

    if (g->message_number == 0) {
        ++g->message_number;
    }

    const uint32_t message_num = net_htonl(g->message_number);
    memcpy(packet + sizeof(uint16_t), &message_num, sizeof(message_num));

    packet[sizeof(uint16_t) + sizeof(uint32_t)] = message_id;

    if (len != 0) {
        memcpy(packet + sizeof(uint16_t) + sizeof(uint32_t) + 1, data, len);
    }

    const unsigned int ret = send_message_all_connections(g_c, g, packet, SIZEOF_VLA(packet), -1);

    if (ret == 0) {
        return -4;
    }

    return ret;
}

/** @brief send a group message
 * @retval 0 on success
 * @see send_message_group for error codes.
 */
int group_message_send(const Group_Chats *g_c, uint32_t groupnumber, const uint8_t *message, uint16_t length)
{
    const int ret = send_message_group(g_c, groupnumber, PACKET_ID_MESSAGE, message, length);

    if (ret > 0) {
        return 0;
    }

    return ret;
}

/** @brief send a group action
 * @retval 0 on success
 * @see send_message_group for error codes.
 */
int group_action_send(const Group_Chats *g_c, uint32_t groupnumber, const uint8_t *action, uint16_t length)
{
    const int ret = send_message_group(g_c, groupnumber, PACKET_ID_ACTION, action, length);

    if (ret > 0) {
        return 0;
    }

    return ret;
}

/** @brief High level function to send custom lossy packets.
 *
 * @retval -1 on failure.
 * @retval 0 on success.
 */
int send_group_lossy_packet(const Group_Chats *g_c, uint32_t groupnumber, const uint8_t *data, uint16_t length)
{
    // TODO(irungentoo): length check here?
    Group_c *g = get_group_c(g_c, groupnumber);

    if (g == nullptr) {
        return -1;
    }

    VLA(uint8_t, packet, sizeof(uint16_t) * 2 + length);
    const uint16_t peer_number = net_htons(g->peer_number);
    memcpy(packet, &peer_number, sizeof(uint16_t));
    const uint16_t message_num = net_htons(g->lossy_message_number);
    memcpy(packet + sizeof(uint16_t), &message_num, sizeof(uint16_t));
    memcpy(packet + sizeof(uint16_t) * 2, data, length);

    if (send_lossy_all_connections(g_c, g, packet, SIZEOF_VLA(packet), -1) == 0) {
        return -1;
    }

    ++g->lossy_message_number;
    return 0;
}

non_null()
static Message_Info *find_message_slot_or_reject(uint32_t message_number, uint8_t message_id, Group_Peer *peer)
{
    const bool ignore_older = message_id == GROUP_MESSAGE_NAME_ID || message_id == GROUP_MESSAGE_TITLE_ID;

    Message_Info *i;

    for (i = peer->last_message_infos; i < peer->last_message_infos + peer->num_last_message_infos; ++i) {
        if (message_number - (i->message_number + 1) <= ((uint32_t)1 << 31)) {
            break;
        }

        if (message_number == i->message_number) {
            return nullptr;
        }

        if (ignore_older && message_id == i->message_id) {
            return nullptr;
        }
    }

    return i;
}

/** @brief Stores message info in `peer->last_message_infos`.
 *
 * @retval true if message should be processed.
 * @retval false otherwise.
 */
non_null()
static bool check_message_info(uint32_t message_number, uint8_t message_id, Group_Peer *peer)
{
    Message_Info *const i = find_message_slot_or_reject(message_number, message_id, peer);

    if (i == nullptr) {
        return false;
    }

    if (i == peer->last_message_infos + MAX_LAST_MESSAGE_INFOS) {
        return false;
    }

    if (peer->num_last_message_infos < MAX_LAST_MESSAGE_INFOS) {
        ++peer->num_last_message_infos;
    }

    memmove(i + 1, i, (&peer->last_message_infos[peer->num_last_message_infos - 1] - i) * sizeof(Message_Info));

    i->message_number = message_number;
    i->message_id = message_id;

    return true;
}

non_null(1, 3) nullable(6)
static void handle_message_packet_group(Group_Chats *g_c, uint32_t groupnumber, const uint8_t *data, uint16_t length,
                                        int connection_index, void *userdata)
{
    if (length < sizeof(uint16_t) + sizeof(uint32_t) + 1) {
        return;
    }

    Group_c *g = get_group_c(g_c, groupnumber);

    if (g == nullptr) {
        return;
    }

    uint16_t peer_number;
    memcpy(&peer_number, data, sizeof(uint16_t));
    peer_number = net_ntohs(peer_number);

    uint32_t message_number;
    memcpy(&message_number, data + sizeof(uint16_t), sizeof(message_number));

    // HINT: uint32_t message number in network byte order
    uint32_t message_number_network_byte_order = message_number;
    message_number = net_ntohl(message_number);

    const uint8_t message_id = data[sizeof(uint16_t) + sizeof(message_number)];
    const uint8_t *msg_data = data + sizeof(uint16_t) + sizeof(message_number) + 1;
    const uint16_t msg_data_len = length - (sizeof(uint16_t) + sizeof(message_number) + 1);

    const bool ignore_frozen = message_id == GROUP_MESSAGE_FREEZE_PEER_ID;

    const int index = ignore_frozen ? get_peer_index(g, peer_number)
                      : note_peer_active(g_c, groupnumber, peer_number, userdata);

    if (index == -1) {
        if (ignore_frozen) {
            return;
        }

        if (g->connections[connection_index].type != GROUPCHAT_CONNECTION_ONLINE) {
            return;
        }

        /* If we don't know the peer this packet came from, then we query the
         * list of peers from the relaying peer.
         * (They wouldn't have relayed it if they didn't know the peer.) */
        send_peer_query(g_c, g->connections[connection_index].number, g->connections[connection_index].group_number);
        return;
    }

    if (g->num_introducer_connections > 0 && count_connected(g) > DESIRED_CLOSEST) {
        for (uint32_t i = 0; i < MAX_GROUP_CONNECTIONS; ++i) {
            if (g->connections[i].type == GROUPCHAT_CONNECTION_NONE
                    || (g->connections[i].reasons & GROUPCHAT_CONNECTION_REASON_INTRODUCER) == 0
                    || i == connection_index) {
                continue;
            }

            uint8_t real_pk[CRYPTO_PUBLIC_KEY_SIZE];
            get_friendcon_public_keys(real_pk, nullptr, g_c->fr_c, g->connections[i].number);

            if (pk_equal(g->group[index].real_pk, real_pk)) {
                /* Received message from peer relayed via another peer, so
                 * the introduction was successful */
                remove_connection_reason(g_c, g, i, GROUPCHAT_CONNECTION_REASON_INTRODUCER);
            }
        }
    }

    if (!check_message_info(message_number, message_id, &g->group[index])) {
        return;
    }

    uint8_t real_pk[CRYPTO_PUBLIC_KEY_SIZE];
    get_friendcon_public_keys(real_pk, nullptr, g_c->fr_c, g->connections[connection_index].number);
    const bool direct_from_sender = pk_equal(g->group[index].real_pk, real_pk);

    switch (message_id) {
        case GROUP_MESSAGE_PING_ID: {
            break;
        }

        case GROUP_MESSAGE_NEW_PEER_ID: {
            if (msg_data_len != GROUP_MESSAGE_NEW_PEER_LENGTH) {
                return;
            }

            uint16_t new_peer_number;
            memcpy(&new_peer_number, msg_data, sizeof(uint16_t));
            new_peer_number = net_ntohs(new_peer_number);
            addpeer(g_c, groupnumber, msg_data + sizeof(uint16_t), msg_data + sizeof(uint16_t) + CRYPTO_PUBLIC_KEY_SIZE,
                    new_peer_number, userdata, true, true);
            break;
        }

        case GROUP_MESSAGE_KILL_PEER_ID:
        case GROUP_MESSAGE_FREEZE_PEER_ID: {
            if (msg_data_len != GROUP_MESSAGE_KILL_PEER_LENGTH) {
                return;
            }

            uint16_t kill_peer_number;
            memcpy(&kill_peer_number, msg_data, sizeof(uint16_t));
            kill_peer_number = net_ntohs(kill_peer_number);

            if (peer_number == kill_peer_number) {
                if (message_id == GROUP_MESSAGE_KILL_PEER_ID) {
                    delpeer(g_c, groupnumber, index, userdata);
                } else {
                    freeze_peer(g_c, groupnumber, index, userdata);
                }
            } else {
                return;
                // TODO(irungentoo):
            }

            break;
        }

        case GROUP_MESSAGE_NAME_ID: {
            if (!setnick(g_c, groupnumber, index, msg_data, msg_data_len, userdata, true)) {
                return;
            }

            break;
        }

        case GROUP_MESSAGE_TITLE_ID: {
            if (!settitle(g_c, groupnumber, index, msg_data, msg_data_len, userdata)) {
                return;
            }

            break;
        }

        case PACKET_ID_MESSAGE: {
            if (msg_data_len == 0) {
                return;
            }

            // ATTENTION: !!add uint32_t message_number (as lowercase HEX) + ":" in front of the text message bytes!!
#define HEX_MSG_NUM_LEN_COLON 9
            VLA(uint8_t, newmsg, msg_data_len + 1 + HEX_MSG_NUM_LEN_COLON);
            memset(newmsg, 0, msg_data_len + 1 + HEX_MSG_NUM_LEN_COLON);
            uint8_t *t1 = (uint8_t *)(&(message_number_network_byte_order));
            uint8_t *t2 = t1 + 1;
            uint8_t *t3 = t1 + 2;
            uint8_t *t4 = t1 + 3;
            sprintf((char *)newmsg, "%02x%02x%02x%02x:", *t1, *t2, *t3, *t4); // BEWARE: this adds a NULL byte at the end
            memcpy(newmsg + HEX_MSG_NUM_LEN_COLON, msg_data, msg_data_len);
            newmsg[msg_data_len + HEX_MSG_NUM_LEN_COLON] = 0;

            // TODO(irungentoo):
            if (g_c->message_callback != nullptr) {
                g_c->message_callback(g_c->m, groupnumber, index, 0, newmsg, (msg_data_len + HEX_MSG_NUM_LEN_COLON), userdata);
            }

            break;
        }

        case PACKET_ID_ACTION: {
            if (msg_data_len == 0) {
                return;
            }

            VLA(uint8_t, newmsg, msg_data_len + 1);
            memcpy(newmsg, msg_data, msg_data_len);
            newmsg[msg_data_len] = 0;

            // TODO(irungentoo):
            if (g_c->message_callback != nullptr) {
                g_c->message_callback(g_c->m, groupnumber, index, 1, newmsg, msg_data_len, userdata);
            }

            break;
        }

        default: {
            return;
        }
    }

    /* If the packet was received from the peer who sent the message, relay it
     * back. When the sender only has one group connection (e.g. because there
     * are only two peers in the group), this is the only way for them to
     * receive their own message. */
    send_message_all_connections(g_c, g, data, length, direct_from_sender ? -1 : connection_index);
}

static int g_handle_packet(void *object, int friendcon_id, const uint8_t *data, uint16_t length, void *userdata)
{
    Group_Chats *g_c = (Group_Chats *)object;

    if (length < 1 + sizeof(uint16_t) + 1) {
        return -1;
    }

    if (data[0] == PACKET_ID_ONLINE_PACKET) {
        return handle_packet_online(g_c, friendcon_id, data + 1, length - 1);
    }

    if (data[0] == PACKET_ID_REJOIN_CONFERENCE) {
        return handle_packet_rejoin(g_c, friendcon_id, data + 1, length - 1, userdata);
    }

    uint16_t groupnumber;
    memcpy(&groupnumber, data + 1, sizeof(uint16_t));
    groupnumber = net_ntohs(groupnumber);
    const Group_c *g = get_group_c(g_c, groupnumber);

    if (g == nullptr) {
        return -1;
    }

    const int index = friend_in_connections(g, friendcon_id);

    if (index == -1) {
        return -1;
    }

    if (data[0] == PACKET_ID_DIRECT_CONFERENCE) {
        handle_direct_packet(g_c, groupnumber, data + 1 + sizeof(uint16_t),
                             length - (1 + sizeof(uint16_t)), index, userdata);
        return 0;
    }

    if (data[0] == PACKET_ID_MESSAGE_CONFERENCE) {
        handle_message_packet_group(g_c, groupnumber, data + 1 + sizeof(uint16_t),
                                    length - (1 + sizeof(uint16_t)), index, userdata);
        return 0;
    }

    return -1;
}

/** @brief Did we already receive the lossy packet or not.
 *
 * @retval -1 on failure.
 * @retval 0 if packet was not received.
 * @retval 1 if packet was received.
 *
 * TODO(irungentoo): test this
 */
non_null()
static int lossy_packet_not_received(const Group_c *g, int peer_index, uint16_t message_number)
{
    if (peer_index == -1) {
        return -1;
    }

    if (g->group[peer_index].bottom_lossy_number == g->group[peer_index].top_lossy_number) {
        g->group[peer_index].top_lossy_number = message_number;
        g->group[peer_index].bottom_lossy_number = (message_number - MAX_LOSSY_COUNT) + 1;
        g->group[peer_index].recv_lossy[message_number % MAX_LOSSY_COUNT] = 1;
        return 0;
    }

    if ((uint16_t)(message_number - g->group[peer_index].bottom_lossy_number) < MAX_LOSSY_COUNT) {
        if (g->group[peer_index].recv_lossy[message_number % MAX_LOSSY_COUNT] != 0) {
            return 1;
        }

        g->group[peer_index].recv_lossy[message_number % MAX_LOSSY_COUNT] = 1;
        return 0;
    }

    if ((uint16_t)(message_number - g->group[peer_index].bottom_lossy_number) > (1 << 15)) {
        return -1;
    }

    const uint16_t top_distance = message_number - g->group[peer_index].top_lossy_number;

    if (top_distance >= MAX_LOSSY_COUNT) {
        crypto_memzero(g->group[peer_index].recv_lossy, sizeof(g->group[peer_index].recv_lossy));
    } else {  // top_distance < MAX_LOSSY_COUNT
        for (unsigned int i = g->group[peer_index].bottom_lossy_number;
                i != g->group[peer_index].bottom_lossy_number + top_distance;
                ++i) {
            g->group[peer_index].recv_lossy[i % MAX_LOSSY_COUNT] = 0;
        }
    }

    g->group[peer_index].top_lossy_number = message_number;
    g->group[peer_index].bottom_lossy_number = (message_number - MAX_LOSSY_COUNT) + 1;
    g->group[peer_index].recv_lossy[message_number % MAX_LOSSY_COUNT] = 1;

    return 0;

}

/** Does this group type make use of lossy packets? */
static bool type_uses_lossy(uint8_t type)
{
    return type == GROUPCHAT_TYPE_AV;
}

static int handle_lossy(void *object, int friendcon_id, const uint8_t *data, uint16_t length, void *userdata)
{
    const Group_Chats *g_c = (const Group_Chats *)object;

    if (data[0] != PACKET_ID_LOSSY_CONFERENCE) {
        return -1;
    }

    if (length < 1 + sizeof(uint16_t) * 3 + 1) {
        return -1;
    }

    uint16_t groupnumber;
    uint16_t peer_number;
    uint16_t message_number;
    memcpy(&groupnumber, data + 1, sizeof(uint16_t));
    memcpy(&peer_number, data + 1 + sizeof(uint16_t), sizeof(uint16_t));
    memcpy(&message_number, data + 1 + sizeof(uint16_t) * 2, sizeof(uint16_t));
    groupnumber = net_ntohs(groupnumber);
    peer_number = net_ntohs(peer_number);
    message_number = net_ntohs(message_number);

    const Group_c *g = get_group_c(g_c, groupnumber);

    if (g == nullptr) {
        return -1;
    }

    if (!type_uses_lossy(g->type)) {
        return -1;
    }

    const int index = friend_in_connections(g, friendcon_id);

    if (index == -1) {
        return -1;
    }

    if (peer_number == g->peer_number) {
        return -1;
    }

    const int peer_index = get_peer_index(g, peer_number);

    if (peer_index == -1) {
        return -1;
    }

    if (lossy_packet_not_received(g, peer_index, message_number) != 0) {
        return -1;
    }

    const uint8_t *lossy_data = data + 1 + sizeof(uint16_t) * 3;
    uint16_t lossy_length = length - (1 + sizeof(uint16_t) * 3);
    const uint8_t message_id = lossy_data[0];
    ++lossy_data;
    --lossy_length;

    send_lossy_all_connections(g_c, g, data + 1 + sizeof(uint16_t), length - (1 + sizeof(uint16_t)), index);

    if (g_c->lossy_packethandlers[message_id] == nullptr) {
        return -1;
    }

    if (g_c->lossy_packethandlers[message_id](g->object, groupnumber, peer_index, g->group[peer_index].object,
            lossy_data, lossy_length) == -1) {
        return -1;
    }

    return 0;
}

/** @brief Set the object that is tied to the group chat.
 *
 * @retval 0 on success.
 * @retval -1 on failure
 */
int group_set_object(const Group_Chats *g_c, uint32_t groupnumber, void *object)
{
    Group_c *g = get_group_c(g_c, groupnumber);

    if (g == nullptr) {
        return -1;
    }

    g->object = object;
    return 0;
}

/** @brief Set the object that is tied to the group peer.
 *
 * @retval 0 on success.
 * @retval -1 on failure
 */
int group_peer_set_object(const Group_Chats *g_c, uint32_t groupnumber, uint32_t peernumber, void *object)
{
    const Group_c *g = get_group_c(g_c, groupnumber);

    if (g == nullptr) {
        return -1;
    }

    if (peernumber >= g->numpeers) {
        return -1;
    }

    g->group[peernumber].object = object;
    return 0;
}

/** @brief Return the object tied to the group chat previously set by group_set_object.
 *
 * @retval NULL on failure.
 * @return object on success.
 */
void *group_get_object(const Group_Chats *g_c, uint32_t groupnumber)
{
    const Group_c *g = get_group_c(g_c, groupnumber);

    if (g == nullptr) {
        return nullptr;
    }

    return g->object;
}

/** @brief Return the object tied to the group chat peer previously set by group_peer_set_object.
 *
 * @retval NULL on failure.
 * @return object on success.
 */
void *group_peer_get_object(const Group_Chats *g_c, uint32_t groupnumber, uint32_t peernumber)
{
    const Group_c *g = get_group_c(g_c, groupnumber);

    if (g == nullptr) {
        return nullptr;
    }

    if (peernumber >= g->numpeers) {
        return nullptr;
    }

    return g->group[peernumber].object;
}

/** Interval in seconds to send ping messages */
#define GROUP_PING_INTERVAL 20

static bool ping_groupchat(const Group_Chats *g_c, uint32_t groupnumber)
{
    Group_c *g = get_group_c(g_c, groupnumber);

    if (g == nullptr) {
        return false;
    }

    if (mono_time_is_timeout(g_c->mono_time, g->last_sent_ping, GROUP_PING_INTERVAL)) {
        if (group_ping_send(g_c, groupnumber)) {
            g->last_sent_ping = mono_time_get(g_c->mono_time);
        }
    }

    return true;
}

/** Seconds of inactivity after which to freeze a peer */
#define FREEZE_TIMEOUT (GROUP_PING_INTERVAL * 3)

non_null(1) nullable(3)
static bool groupchat_freeze_timedout(Group_Chats *g_c, uint32_t groupnumber, void *userdata)
{
    Group_c *g = get_group_c(g_c, groupnumber);

    if (g == nullptr) {
        return false;
    }

    for (uint32_t i = 0; i < g->numpeers; ++i) {
        if (g->group[i].peer_number == g->peer_number) {
            continue;
        }

        if (mono_time_is_timeout(g_c->mono_time, g->group[i].last_active, FREEZE_TIMEOUT)) {
            freeze_peer(g_c, groupnumber, i, userdata);
        }
    }

    if (g->numpeers <= 1) {
        g->title_fresh = false;
    }

    return true;
}

/** Push non-empty slots to start. */
non_null()
static void squash_connections(Group_c *g)
{
    uint16_t num_connected = 0;

    for (uint16_t i = 0; i < MAX_GROUP_CONNECTIONS; ++i) {
        if (g->connections[i].type != GROUPCHAT_CONNECTION_NONE) {
            g->connections[num_connected] = g->connections[i];
            ++num_connected;
        }
    }

    for (uint16_t i = num_connected; i < MAX_GROUP_CONNECTIONS; ++i) {
        g->connections[i].type = GROUPCHAT_CONNECTION_NONE;
    }
}

#define MIN_EMPTY_CONNECTIONS (1 + MAX_GROUP_CONNECTIONS / 10)

non_null()
static uint16_t empty_connection_count(const Group_c *g)
{
    uint16_t to_clear = MIN_EMPTY_CONNECTIONS;

    for (uint16_t i = 0; i < MAX_GROUP_CONNECTIONS; ++i) {
        if (g->connections[i].type == GROUPCHAT_CONNECTION_NONE) {
            --to_clear;

            if (to_clear == 0) {
                break;
            }
        }
    }

    return to_clear;
}

/**
 * @brief Remove old connections as necessary to ensure we have space for new
 *   connections.
 *
 * This invalidates connections array indices (which is
 * why we do this periodically rather than on adding a connection).
 */
non_null()
static void clean_connections(Group_Chats *g_c, Group_c *g)
{
    for (uint16_t to_clear = empty_connection_count(g); to_clear > 0; --to_clear) {
        // Remove a connection. Prefer non-closest connections, and given
        // that prefer non-online connections, and given that prefer earlier
        // slots.
        uint16_t i = 0;

        while (i < MAX_GROUP_CONNECTIONS
                && (g->connections[i].type != GROUPCHAT_CONNECTION_CONNECTING
                    || (g->connections[i].reasons & GROUPCHAT_CONNECTION_REASON_CLOSEST) != 0)) {
            ++i;
        }

        if (i == MAX_GROUP_CONNECTIONS) {
            i = 0;

            while (i < MAX_GROUP_CONNECTIONS - to_clear
                    && (g->connections[i].type != GROUPCHAT_CONNECTION_ONLINE
                        || (g->connections[i].reasons & GROUPCHAT_CONNECTION_REASON_CLOSEST) != 0)) {
                ++i;
            }
        }

        if (g->connections[i].type != GROUPCHAT_CONNECTION_NONE) {
            remove_connection(g_c, g, i);
        }
    }

    squash_connections(g);
}

/** Send current name (set in messenger) to all online groups. */
void send_name_all_groups(const Group_Chats *g_c)
{
    for (uint16_t i = 0; i < g_c->num_chats; ++i) {
        Group_c *g = get_group_c(g_c, i);

        if (g == nullptr) {
            continue;
        }

        if (g->status == GROUPCHAT_STATUS_CONNECTED) {
            group_name_send(g_c, i, g_c->m->name, g_c->m->name_length);
            g->need_send_name = false;
        }
    }
}

#define SAVED_PEER_SIZE_CONSTANT (2 * CRYPTO_PUBLIC_KEY_SIZE + sizeof(uint16_t) + sizeof(uint64_t) + 1)

non_null()
static uint32_t saved_peer_size(const Group_Peer *peer)
{
    return SAVED_PEER_SIZE_CONSTANT + peer->nick_len;
}

non_null()
static uint8_t *save_peer(const Group_Peer *peer, uint8_t *data)
{
    memcpy(data, peer->real_pk, CRYPTO_PUBLIC_KEY_SIZE);
    data += CRYPTO_PUBLIC_KEY_SIZE;

    memcpy(data, peer->temp_pk, CRYPTO_PUBLIC_KEY_SIZE);
    data += CRYPTO_PUBLIC_KEY_SIZE;

    host_to_lendian_bytes16(data, peer->peer_number);
    data += sizeof(uint16_t);

    host_to_lendian_bytes64(data, peer->last_active);
    data += sizeof(uint64_t);

    // TODO(iphydf): This looks broken: nick_len can be > 255.
    *data = peer->nick_len;
    ++data;

    memcpy(data, peer->nick, peer->nick_len);
    data += peer->nick_len;

    return data;
}

#define SAVED_CONF_SIZE_CONSTANT (1 + GROUP_ID_LENGTH + sizeof(uint32_t) \
      + sizeof(uint16_t) + sizeof(uint16_t) + sizeof(uint32_t) + 1)

non_null()
static uint32_t saved_conf_size(const Group_c *g)
{
    uint32_t len = SAVED_CONF_SIZE_CONSTANT + g->title_len;

    for (uint32_t j = 0; j < g->numpeers + g->numfrozen; ++j) {
        const Group_Peer *peer = (j < g->numpeers) ? &g->group[j] : &g->frozen[j - g->numpeers];

        if (pk_equal(peer->real_pk, g->real_pk)) {
            continue;
        }

        len += saved_peer_size(peer);
    }

    return len;
}

/**
 * Save a future message number. The save will remain valid until we have sent
 * this many more messages.
 */
#define SAVE_OFFSET_MESSAGE_NUMBER (1 << 16)
#define SAVE_OFFSET_LOSSY_MESSAGE_NUMBER (1 << 13)

non_null()
static uint8_t *save_conf(const Group_c *g, uint8_t *data)
{
    *data = g->type;
    ++data;

    memcpy(data, g->id, GROUP_ID_LENGTH);
    data += GROUP_ID_LENGTH;

    host_to_lendian_bytes32(data, g->message_number + SAVE_OFFSET_MESSAGE_NUMBER);
    data += sizeof(uint32_t);

    host_to_lendian_bytes16(data, g->lossy_message_number + SAVE_OFFSET_LOSSY_MESSAGE_NUMBER);
    data += sizeof(uint16_t);

    host_to_lendian_bytes16(data, g->peer_number);
    data += sizeof(uint16_t);

    uint8_t *const numsaved_location = data;
    data += sizeof(uint32_t);

    *data = g->title_len;
    ++data;

    memcpy(data, g->title, g->title_len);
    data += g->title_len;

    uint32_t numsaved = 0;

    for (uint32_t j = 0; j < g->numpeers + g->numfrozen; ++j) {
        const Group_Peer *peer = (j < g->numpeers) ? &g->group[j] : &g->frozen[j - g->numpeers];

        if (pk_equal(peer->real_pk, g->real_pk)) {
            continue;
        }

        data = save_peer(peer, data);
        ++numsaved;
    }

    host_to_lendian_bytes32(numsaved_location, numsaved);

    return data;
}

non_null()
static uint32_t conferences_section_size(const Group_Chats *g_c)
{
    uint32_t len = 0;

    for (uint16_t i = 0; i < g_c->num_chats; ++i) {
        const Group_c *g = get_group_c(g_c, i);

        if (g == nullptr || g->status != GROUPCHAT_STATUS_CONNECTED) {
            continue;
        }

        len += saved_conf_size(g);
    }

    return len;
}

uint32_t conferences_size(const Group_Chats *g_c)
{
    return 2 * sizeof(uint32_t) + conferences_section_size(g_c);
}

uint8_t *conferences_save(const Group_Chats *g_c, uint8_t *data)
{
    const uint32_t len = conferences_section_size(g_c);
    data = state_write_section_header(data, STATE_COOKIE_TYPE, len, STATE_TYPE_CONFERENCES);

    for (uint16_t i = 0; i < g_c->num_chats; ++i) {
        const Group_c *g = get_group_c(g_c, i);

        if (g == nullptr || g->status != GROUPCHAT_STATUS_CONNECTED) {
            continue;
        }

        data = save_conf(g, data);
    }

    return data;
}

/**
 * @brief load_group Load a Group section from a save file
 * @param g Group to load
 * @param g_c Reference to all groupchats, need for utility functions
 * @param data Start of the data to deserialze
 * @param length Length of data
 * @return 0 on error, number of consumed bytes otherwise
 */
non_null()
static uint32_t load_group(Group_c *g, const Group_Chats *g_c, const uint8_t *data, uint32_t length)
{
    const uint8_t *init_data = data;

    // Initialize to default values so we can unconditionally free in case of an error
    setup_conference(g);

    g->type = *data;
    ++data;

    memcpy(g->id, data, GROUP_ID_LENGTH);
    data += GROUP_ID_LENGTH;

    lendian_bytes_to_host32(&g->message_number, data);
    data += sizeof(uint32_t);

    lendian_bytes_to_host16(&g->lossy_message_number, data);
    data += sizeof(uint16_t);

    lendian_bytes_to_host16(&g->peer_number, data);
    data += sizeof(uint16_t);

    lendian_bytes_to_host32(&g->numfrozen, data);
    data += sizeof(uint32_t);

    g->title_len = *data;

    if (g->title_len > MAX_NAME_LENGTH) {
        return 0;
    }

    ++data;

    assert((data - init_data) < UINT32_MAX);

    if (length < (uint32_t)(data - init_data) + g->title_len) {
        return 0;
    }

    memcpy(g->title, data, g->title_len);
    data += g->title_len;

    for (uint32_t j = 0; j < g->numfrozen; ++j) {

        assert((data - init_data) < UINT32_MAX);

        if (length < (uint32_t)(data - init_data) + SAVED_PEER_SIZE_CONSTANT) {
            return 0;
        }

        // This is inefficient, but allows us to check data consistency before allocating memory
        Group_Peer *tmp_frozen = (Group_Peer *)realloc(g->frozen, (j + 1) * sizeof(Group_Peer));

        if (tmp_frozen == nullptr) {
            // Memory allocation failure
            return 0;
        }

        g->frozen = tmp_frozen;

        Group_Peer *peer = &g->frozen[j];
        *peer = empty_group_peer;

        pk_copy(peer->real_pk, data);
        data += CRYPTO_PUBLIC_KEY_SIZE;
        pk_copy(peer->temp_pk, data);
        data += CRYPTO_PUBLIC_KEY_SIZE;

        lendian_bytes_to_host16(&peer->peer_number, data);
        data += sizeof(uint16_t);

        lendian_bytes_to_host64(&peer->last_active, data);
        data += sizeof(uint64_t);

        peer->nick_len = *data;

        if (peer->nick_len > MAX_NAME_LENGTH) {
            return 0;
        }

        ++data;
        assert((data - init_data) < UINT32_MAX);

        if (length < (uint32_t)(data - init_data) + peer->nick_len) {
            return 0;
        }

        memcpy(peer->nick, data, peer->nick_len);
        data += peer->nick_len;

        // NOTE: this relies on friends being loaded before conferences.
        peer->is_friend = getfriend_id(g_c->m, peer->real_pk) != -1;
    }

    if (g->numfrozen > g->maxfrozen) {
        g->maxfrozen = g->numfrozen;
    }

    g->status = GROUPCHAT_STATUS_CONNECTED;

    pk_copy(g->real_pk, nc_get_self_public_key(g_c->m->net_crypto));

    assert((data - init_data) < UINT32_MAX);

    return (uint32_t)(data - init_data);
}

non_null()
static State_Load_Status load_conferences_helper(Group_Chats *g_c, const uint8_t *data, uint32_t length)
{
    const uint8_t *init_data = data;

    while (length >= (uint32_t)(data - init_data) + SAVED_CONF_SIZE_CONSTANT) {
        const int groupnumber = create_group_chat(g_c);

        // Helpful for testing
        assert(groupnumber != -1);

        if (groupnumber == -1) {
            // If this fails there's a serious problem, don't bother with cleanup
            LOGGER_ERROR(g_c->m->log, "conference creation failed");
            return STATE_LOAD_STATUS_ERROR;
        }

        Group_c *g = &g_c->chats[groupnumber];

        const uint32_t consumed = load_group(g, g_c, data, length - (uint32_t)(data - init_data));

        if (consumed == 0) {
            // remove partially loaded stuff, wipe_group_chat must be able to wipe a partially loaded group
            const bool ret = wipe_group_chat(g_c, groupnumber);

            // HACK: suppress unused variable warning
            if (!ret) {
                // wipe_group_chat(...) must be able to wipe partially allocated groups
                assert(ret);
            }

            return STATE_LOAD_STATUS_ERROR;
        }

        data += consumed;

        const int peer_index = addpeer(g_c, groupnumber, g->real_pk, dht_get_self_public_key(g_c->m->dht), g->peer_number,
                                       nullptr, true, false);

        if (peer_index == -1) {
            LOGGER_ERROR(g_c->m->log, "adding peer %d failed", g->peer_number);
            return STATE_LOAD_STATUS_ERROR;
        }

        setnick(g_c, groupnumber, peer_index, g_c->m->name, g_c->m->name_length, nullptr, false);
    }

    return STATE_LOAD_STATUS_CONTINUE;
}

non_null()
static State_Load_Status load_conferences(Group_Chats *g_c, const uint8_t *data, uint32_t length)
{
    const State_Load_Status res = load_conferences_helper(g_c, data, length);

    if (res == STATE_LOAD_STATUS_CONTINUE) {
        return res;
    }

    // Loading failed, cleanup all Group_c

    // save locally, because wipe_group_chat(...) modifies it
    const uint16_t num_groups = g_c->num_chats;

    for (uint16_t i = 0; i < num_groups; ++i) {
        wipe_group_chat(g_c, i);
    }

    return res;
}

bool conferences_load_state_section(Group_Chats *g_c, const uint8_t *data, uint32_t length, uint16_t type,
                                    State_Load_Status *status)
{
    if (type != STATE_TYPE_CONFERENCES) {
        return false;
    }

    *status = load_conferences(g_c, data, length);
    return true;
}


/** Create new groupchat instance. */
Group_Chats *new_groupchats(const Mono_Time *mono_time, Messenger *m)
{
    if (m == nullptr) {
        return nullptr;
    }

    Group_Chats *temp = (Group_Chats *)calloc(1, sizeof(Group_Chats));

    if (temp == nullptr) {
        return nullptr;
    }

    temp->mono_time = mono_time;
    temp->m = m;
    temp->fr_c = m->fr_c;
    m->conferences_object = temp;
    m_callback_conference_invite(m, &handle_friend_invite_packet);

    set_global_status_callback(m->fr_c, &g_handle_any_status, temp);

    return temp;
}

/** main groupchats loop. */
void do_groupchats(Group_Chats *g_c, void *userdata)
{
    for (uint16_t i = 0; i < g_c->num_chats; ++i) {
        Group_c *g = get_group_c(g_c, i);

        if (g == nullptr) {
            continue;
        }

        if (g->status == GROUPCHAT_STATUS_CONNECTED) {
            connect_to_closest(g_c, i, userdata);
            ping_groupchat(g_c, i);
            groupchat_freeze_timedout(g_c, i, userdata);
            clean_connections(g_c, g);

            if (g->need_send_name) {
                group_name_send(g_c, i, g_c->m->name, g_c->m->name_length);
                g->need_send_name = false;
            }
        }
    }

    // TODO(irungentoo):
}

/** Free everything related with group chats. */
void kill_groupchats(Group_Chats *g_c)
{
    if (g_c == nullptr) {
        return;
    }

    for (uint16_t i = 0; i < g_c->num_chats; ++i) {
        del_groupchat(g_c, i, false);
    }

    m_callback_conference_invite(g_c->m, nullptr);
    set_global_status_callback(g_c->m->fr_c, nullptr, nullptr);
    g_c->m->conferences_object = nullptr;
    free(g_c);
}

/**
 * @brief Return the number of chats in the instance m.
 *
 * You should use this to determine how much memory to allocate
 * for copy_chatlist.
 */
uint32_t count_chatlist(const Group_Chats *g_c)
{
    uint32_t ret = 0;

    for (uint16_t i = 0; i < g_c->num_chats; ++i) {
        if (g_c->chats[i].status != GROUPCHAT_STATUS_NONE) {
            ++ret;
        }
    }

    return ret;
}

/** @brief Copy a list of valid chat IDs into the array out_list.
 *
 * If out_list is NULL, returns 0.
 * Otherwise, returns the number of elements copied.
 * If the array was too small, the contents
 * of out_list will be truncated to list_size.
 */
uint32_t copy_chatlist(const Group_Chats *g_c, uint32_t *out_list, uint32_t list_size)
{
    if (out_list == nullptr) {
        return 0;
    }

    if (g_c->num_chats == 0) {
        return 0;
    }

    uint32_t ret = 0;

    for (uint16_t i = 0; i < g_c->num_chats; ++i) {
        if (ret >= list_size) {
            break;  /* Abandon ship */
        }

        if (g_c->chats[i].status > GROUPCHAT_STATUS_NONE) {
            out_list[ret] = i;
            ++ret;
        }
    }

    return ret;
}
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2020 The TokTok team.
 * Copyright © 2015 Tox project.
 */

/**
 * An implementation of massive text only group chats.
 */


#include <assert.h>

#ifndef VANILLA_NACL
#include <sodium.h>
#endif

#include <string.h>


#ifndef VANILLA_NACL

/* The minimum size of a plaintext group handshake packet */
#define GC_MIN_HS_PACKET_PAYLOAD_SIZE (1 + ENC_PUBLIC_KEY_SIZE + SIG_PUBLIC_KEY_SIZE + 1 + 1)

/* The minimum size of an encrypted group handshake packet. */
#define GC_MIN_ENCRYPTED_HS_PAYLOAD_SIZE (1 + ENC_PUBLIC_KEY_SIZE + ENC_PUBLIC_KEY_SIZE +\
                                          GC_MIN_HS_PACKET_PAYLOAD_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_MAC_SIZE)

/* Size of a group's shared state in packed format */
#define GC_PACKED_SHARED_STATE_SIZE (EXT_PUBLIC_KEY_SIZE + sizeof(uint16_t) + MAX_GC_GROUP_NAME_SIZE +\
                                     sizeof(uint16_t) + 1 + sizeof(uint16_t) + MAX_GC_PASSWORD_SIZE +\
                                     MOD_MODERATION_HASH_SIZE + sizeof(uint32_t) + sizeof(uint32_t) + 1)

/* Minimum size of a topic packet; includes topic length, public signature key, topic version and checksum */
#define GC_MIN_PACKED_TOPIC_INFO_SIZE (sizeof(uint16_t) + SIG_PUBLIC_KEY_SIZE + sizeof(uint32_t) + sizeof(uint16_t))

#define GC_SHARED_STATE_ENC_PACKET_SIZE (SIGNATURE_SIZE + GC_PACKED_SHARED_STATE_SIZE)

/* Header information attached to all broadcast messages: broadcast_type */
#define GC_BROADCAST_ENC_HEADER_SIZE 1

/* Size of a group packet message ID */
#define GC_MESSAGE_ID_BYTES sizeof(uint64_t)

/* Size of a lossless ack packet */
#define GC_LOSSLESS_ACK_PACKET_SIZE (GC_MESSAGE_ID_BYTES + 1)

/* Smallest possible size of an encrypted lossless payload.
 *
 * Data includes the message_id, group packet type, and the nonce and MAC for decryption.
 */
#define GC_MIN_LOSSLESS_PAYLOAD_SIZE (GC_MESSAGE_ID_BYTES + CRYPTO_NONCE_SIZE + 1 + CRYPTO_MAC_SIZE)

/* Smallest possible size of a lossy group packet */
#define GC_MIN_LOSSY_PAYLOAD_SIZE (GC_MIN_LOSSLESS_PAYLOAD_SIZE - GC_MESSAGE_ID_BYTES)

/* Maximum number of bytes to pad packets with.
 *
 * Packets are padded with a random number of zero bytes between zero and this value in order to hide
 * the true length of the message, which reduces the amount of metadata leaked through packet analysis.
 *
 * Note: This behaviour was copied from the toxcore encryption implementation in net_crypto.c.
 */
#define GC_MAX_PACKET_PADDING 8

/* Minimum size of a ping packet, which contains the peer count, peer list checksum, shared state version,
 * sanctions list version, sanctions list checksum, topic version, and topic checksum
 */
#define GC_PING_PACKET_MIN_DATA_SIZE ((sizeof(uint16_t) * 4) + (sizeof(uint32_t) * 3))

/* How often in seconds we can send a group sync request packet */
#define GC_SYNC_REQUEST_LIMIT (GC_PING_TIMEOUT + 1)

/* How often in seconds we can send the peer list to any peer in the group in a sync response */
#define GC_SYNC_RESPONSE_PEER_LIST_LIMIT 3

/* How often in seconds we try to handshake with an unconfirmed peer */
#define GC_SEND_HANDSHAKE_INTERVAL 3

/* How often in seconds we rotate session encryption keys with a peer */
#define GC_KEY_ROTATION_TIMEOUT (5 * 60)

/* How often in seconds we try to reconnect to peers that recently timed out */
#define GC_TIMED_OUT_RECONN_TIMEOUT (GC_UNCONFIRMED_PEER_TIMEOUT * 3)

/* How long in seconds before we stop trying to reconnect with a timed out peer */
#define GC_TIMED_OUT_STALE_TIMEOUT (60 * 15)

/* The value the topic lock is set to when the topic lock is enabled. */
#define GC_TOPIC_LOCK_ENABLED 0

static_assert(GCC_BUFFER_SIZE <= UINT16_MAX,
              "GCC_BUFFER_SIZE must be <= UINT16_MAX)");

static_assert(MAX_GC_PACKET_CHUNK_SIZE < MAX_GC_PACKET_SIZE,
              "MAX_GC_PACKET_CHUNK_SIZE must be < MAX_GC_PACKET_SIZE");

// size of a lossless handshake packet - lossless packets can't/shouldn't be split up
static_assert(MAX_GC_PACKET_CHUNK_SIZE >= 171,
              "MAX_GC_PACKET_CHUNK_SIZE must be >= 171");

// group_moderation constants assume this is the max packet size.
static_assert(MAX_GC_PACKET_SIZE >= 50000,
              "MAX_GC_PACKET_SIZE doesn't match constants in group_moderation.h");

static_assert(MAX_GC_PACKET_SIZE <= UINT16_MAX - MAX_GC_PACKET_CHUNK_SIZE,
              "MAX_GC_PACKET_SIZE must be <= UINT16_MAX - MAX_GC_PACKET_CHUNK_SIZE");

/** Types of broadcast messages. */
typedef enum Group_Message_Type {
    GC_MESSAGE_TYPE_NORMAL = 0x00,
    GC_MESSAGE_TYPE_ACTION = 0x01,
} Group_Message_Type;

/** Types of handshake request packets. */
typedef enum Group_Handshake_Packet_Type {
    GH_REQUEST  = 0x00,  // Requests a handshake
    GH_RESPONSE = 0x01,  // Responds to a handshake request
} Group_Handshake_Packet_Type;

/** Types of handshake requests (within a handshake request packet). */
typedef enum Group_Handshake_Request_Type {
    HS_INVITE_REQUEST     = 0x00,   // Requests an invite to the group
    HS_PEER_INFO_EXCHANGE = 0x01,   // Requests a peer info exchange
} Group_Handshake_Request_Type;

/** These bitmasks determine what group state info a peer is requesting in a sync request */
typedef enum Group_Sync_Flags {
    GF_PEERS      = (1 << 0), // 1
    GF_TOPIC      = (1 << 1), // 2
    GF_STATE      = (1 << 2), // 4
} Group_Sync_Flags;

non_null() static bool self_gc_is_founder(const GC_Chat *chat);
non_null() static bool group_number_valid(const GC_Session *c, int group_number);
non_null() static int peer_update(const GC_Chat *chat, const GC_Peer *peer, uint32_t peer_number);
non_null() static void group_delete(GC_Session *c, GC_Chat *chat);
non_null() static void group_cleanup(GC_Session *c, GC_Chat *chat);
non_null() static bool group_exists(const GC_Session *c, const uint8_t *chat_id);
non_null() static void add_tcp_relays_to_chat(const GC_Session *c, GC_Chat *chat);
non_null(1, 2) nullable(4)
static bool peer_delete(const GC_Session *c, GC_Chat *chat, uint32_t peer_number, void *userdata);
non_null() static void create_gc_session_keypair(const Logger *log, const Random *rng, uint8_t *public_key,
        uint8_t *secret_key);
non_null() static size_t load_gc_peers(GC_Chat *chat, const GC_SavedPeerInfo *addrs, uint16_t num_addrs);
non_null() static bool saved_peer_is_valid(const GC_SavedPeerInfo *saved_peer);

static const GC_Chat empty_gc_chat = {nullptr};

non_null()
static void kill_group_friend_connection(const GC_Session *c, const GC_Chat *chat)
{
    if (chat->friend_connection_id != -1) {
        m_kill_group_connection(c->messenger, chat);
    }
}

uint16_t gc_get_wrapped_packet_size(uint16_t length, Net_Packet_Type packet_type)
{
    assert(length <= MAX_GC_PACKET_CHUNK_SIZE);

    const uint16_t min_header_size = packet_type == NET_PACKET_GC_LOSSY
                                     ? GC_MIN_LOSSY_PAYLOAD_SIZE
                                     : GC_MIN_LOSSLESS_PAYLOAD_SIZE;
    const uint16_t header_size = ENC_PUBLIC_KEY_SIZE + GC_MAX_PACKET_PADDING + min_header_size;

    assert(length <= UINT16_MAX - header_size);

    return length + header_size;
}

/** Return true if `peer_number` is our own. */
static bool peer_number_is_self(int peer_number)
{
    return peer_number == 0;
}

bool gc_peer_number_is_valid(const GC_Chat *chat, int peer_number)
{
    return peer_number >= 0 && peer_number < (int)chat->numpeers;
}

non_null()
static GC_Peer *get_gc_peer(const GC_Chat *chat, int peer_number)
{
    if (!gc_peer_number_is_valid(chat, peer_number)) {
        return nullptr;
    }

    return &chat->group[peer_number];
}

GC_Connection *get_gc_connection(const GC_Chat *chat, int peer_number)
{
    GC_Peer *peer = get_gc_peer(chat, peer_number);

    if (peer == nullptr) {
        return nullptr;
    }

    return &peer->gconn;
}

/** Returns the amount of empty padding a packet of designated length should have. */
static uint16_t group_packet_padding_length(uint16_t length)
{
    return (MAX_GC_PACKET_CHUNK_SIZE - length) % GC_MAX_PACKET_PADDING;
}

void gc_get_self_nick(const GC_Chat *chat, uint8_t *nick)
{
    if (nick != nullptr) {
        const GC_Peer *peer = get_gc_peer(chat, 0);
        assert(peer != nullptr);
        assert(peer->nick_length > 0);

        memcpy(nick, peer->nick, peer->nick_length);
    }
}

uint16_t gc_get_self_nick_size(const GC_Chat *chat)
{
    const GC_Peer *peer = get_gc_peer(chat, 0);
    assert(peer != nullptr);

    return peer->nick_length;
}

/** @brief Sets self nick to `nick`.
 *
 * Returns false if `nick` is null or `length` is greater than MAX_GC_NICK_SIZE.
 */
non_null()
static bool self_gc_set_nick(const GC_Chat *chat, const uint8_t *nick, uint16_t length)
{
    if (nick == nullptr || length > MAX_GC_NICK_SIZE) {
        return false;
    }

    GC_Peer *peer = get_gc_peer(chat, 0);
    assert(peer != nullptr);

    memcpy(peer->nick, nick, length);
    peer->nick_length = length;

    return true;
}

Group_Role gc_get_self_role(const GC_Chat *chat)
{

    const GC_Peer *peer = get_gc_peer(chat, 0);
    assert(peer != nullptr);

    return peer->role;
}

/** Sets self role. If role is invalid this function has no effect. */
non_null()
static void self_gc_set_role(const GC_Chat *chat, Group_Role role)
{
    if (role <= GR_OBSERVER) {
        GC_Peer *peer = get_gc_peer(chat, 0);
        assert(peer != nullptr);

        peer->role = role;
    }
}

uint8_t gc_get_self_status(const GC_Chat *chat)
{
    const GC_Peer *peer = get_gc_peer(chat, 0);
    assert(peer != nullptr);

    return peer->status;
}

/** Sets self status. If status is invalid this function has no effect. */
non_null()
static void self_gc_set_status(const GC_Chat *chat, Group_Peer_Status status)
{
    if (status == GS_NONE || status == GS_AWAY || status == GS_BUSY) {
        GC_Peer *peer = get_gc_peer(chat, 0);
        assert(peer != nullptr);
        peer->status = status;
        return;
    }

    LOGGER_WARNING(chat->log, "Attempting to set user status with invalid status: %u", (uint8_t)status);
}

uint32_t gc_get_self_peer_id(const GC_Chat *chat)
{
    const GC_Peer *peer = get_gc_peer(chat, 0);
    assert(peer != nullptr);

    return peer->peer_id;
}

/** Sets self confirmed status. */
non_null()
static void self_gc_set_confirmed(const GC_Chat *chat, bool confirmed)
{
    GC_Connection *gconn = get_gc_connection(chat, 0);
    assert(gconn != nullptr);

    gconn->confirmed = confirmed;
}

/** Returns true if self has the founder role */
non_null()
static bool self_gc_is_founder(const GC_Chat *chat)
{
    return gc_get_self_role(chat) == GR_FOUNDER;
}

void gc_get_self_public_key(const GC_Chat *chat, uint8_t *public_key)
{
    if (public_key != nullptr) {
        memcpy(public_key, chat->self_public_key, ENC_PUBLIC_KEY_SIZE);
    }
}

/** @brief Sets self extended public key to `ext_public_key`.
 *
 * If `ext_public_key` is null this function has no effect.
 */
non_null()
static void self_gc_set_ext_public_key(const GC_Chat *chat, const uint8_t *ext_public_key)
{
    if (ext_public_key != nullptr) {
        GC_Connection *gconn = get_gc_connection(chat, 0);
        assert(gconn != nullptr);
        memcpy(gconn->addr.public_key, ext_public_key, EXT_PUBLIC_KEY_SIZE);
    }
}

/**
 * Return true if `peer` has permission to speak according to the `voice_state`.
 */
non_null()
static bool peer_has_voice(const GC_Peer *peer, Group_Voice_State voice_state)
{
    const Group_Role role = peer->role;

    switch (voice_state) {
        case GV_ALL:
            return role <= GR_USER;

        case GV_MODS:
            return role <= GR_MODERATOR;

        case GV_FOUNDER:
            return role == GR_FOUNDER;

        default:
            return false;
    }
}

int pack_gc_saved_peers(const GC_Chat *chat, uint8_t *data, uint16_t length, uint16_t *processed)
{
    uint16_t packed_len = 0;
    uint16_t count = 0;

    for (uint32_t i = 0; i < GC_MAX_SAVED_PEERS; ++i) {
        const GC_SavedPeerInfo *saved_peer = &chat->saved_peers[i];

        if (!saved_peer_is_valid(saved_peer)) {
            continue;
        }

        int packed_ipp_len = 0;
        int packed_tcp_len = 0;

        if (ipport_isset(&saved_peer->ip_port)) {
            if (packed_len > length) {
                return -1;
            }

            packed_ipp_len = pack_ip_port(chat->log, data + packed_len, length - packed_len, &saved_peer->ip_port);

            if (packed_ipp_len > 0) {
                packed_len += packed_ipp_len;
            }
        }

        if (ipport_isset(&saved_peer->tcp_relay.ip_port)) {
            if (packed_len > length) {
                return -1;
            }

            packed_tcp_len = pack_nodes(chat->log, data + packed_len, length - packed_len, &saved_peer->tcp_relay, 1);

            if (packed_tcp_len > 0) {
                packed_len += packed_tcp_len;
            }
        }

        if (packed_len + ENC_PUBLIC_KEY_SIZE > length) {
            return -1;
        }

        if (packed_tcp_len > 0 || packed_ipp_len > 0) {
            memcpy(data + packed_len, chat->saved_peers[i].public_key, ENC_PUBLIC_KEY_SIZE);
            packed_len += ENC_PUBLIC_KEY_SIZE;
            ++count;
        } else {
            LOGGER_WARNING(chat->log, "Failed to pack saved peer");
        }
    }

    if (processed != nullptr) {
        *processed = packed_len;
    }

    return count;
}

int unpack_gc_saved_peers(GC_Chat *chat, const uint8_t *data, uint16_t length)
{
    uint16_t count = 0;
    uint16_t unpacked_len = 0;

    for (size_t i = 0; unpacked_len < length; ++i) {
        GC_SavedPeerInfo *saved_peer = &chat->saved_peers[i];

        const int ipp_len = unpack_ip_port(&saved_peer->ip_port, data + unpacked_len, length - unpacked_len, false);

        if (ipp_len > 0) {
            unpacked_len += ipp_len;
        }

        if (unpacked_len > length) {
            return -1;
        }

        uint16_t tcp_len_processed = 0;
        const int tcp_len = unpack_nodes(&saved_peer->tcp_relay, 1, &tcp_len_processed, data + unpacked_len,
                                         length - unpacked_len, true);

        if (tcp_len == 1 && tcp_len_processed > 0) {
            unpacked_len += tcp_len_processed;
        } else if (ipp_len <= 0) {
            LOGGER_WARNING(chat->log, "Failed to unpack saved peer: Invalid connection info.");
            return -1;
        }

        if (unpacked_len + ENC_PUBLIC_KEY_SIZE > length) {
            return -1;
        }

        if (tcp_len > 0 || ipp_len > 0) {
            memcpy(saved_peer->public_key, data + unpacked_len, ENC_PUBLIC_KEY_SIZE);
            unpacked_len += ENC_PUBLIC_KEY_SIZE;
            ++count;
        } else {
            LOGGER_ERROR(chat->log, "Unpacked peer with bad connection info");
            return -1;
        }
    }

    return count;
}

/** Returns true if chat privacy state is set to public. */
non_null()
static bool is_public_chat(const GC_Chat *chat)
{
    return chat->shared_state.privacy_state == GI_PUBLIC;
}

/** Returns true if group is password protected */
non_null()
static bool chat_is_password_protected(const GC_Chat *chat)
{
    return chat->shared_state.password_length > 0;
}

/** Returns true if `password` matches the current group password. */
non_null()
static bool validate_password(const GC_Chat *chat, const uint8_t *password, uint16_t length)
{
    if (length > MAX_GC_PASSWORD_SIZE) {
        return false;
    }

    if (length != chat->shared_state.password_length) {
        return false;
    }

    return memcmp(chat->shared_state.password, password, length) == 0;
}

/** @brief Returns the chat object that contains a peer with a public key equal to `id`.
 *
 * `id` must be at least ENC_PUBLIC_KEY_SIZE bytes in length.
 */
non_null()
static GC_Chat *get_chat_by_id(const GC_Session *c, const uint8_t *id)
{
    if (c == nullptr) {
        return nullptr;
    }

    for (uint32_t i = 0; i < c->chats_index; ++i) {
        GC_Chat *chat = &c->chats[i];

        if (chat->connection_state == CS_NONE) {
            continue;
        }

        if (memcmp(id, chat->self_public_key, ENC_PUBLIC_KEY_SIZE) == 0) {
            return chat;
        }

        if (get_peer_number_of_enc_pk(chat, id, false) != -1) {
            return chat;
        }
    }

    return nullptr;
}

/** @brief Returns the jenkins hash of a 32 byte public encryption key. */
uint32_t gc_get_pk_jenkins_hash(const uint8_t *public_key)
{
    return jenkins_one_at_a_time_hash(public_key, ENC_PUBLIC_KEY_SIZE);
}

/** @brief Sets the sum of the public_key_hash of all confirmed peers.
 *
 * Must be called every time a peer is confirmed or deleted.
 */
non_null()
static void set_gc_peerlist_checksum(GC_Chat *chat)
{
    uint16_t sum = 0;

    for (uint32_t i = 0; i < chat->numpeers; ++i) {
        const GC_Connection *gconn = get_gc_connection(chat, i);

        assert(gconn != nullptr);

        if (gconn->confirmed) {
            sum += gconn->public_key_hash;
        }
    }

    chat->peers_checksum = sum;
}

/** Returns a checksum of the topic currently set in `topic_info`. */
non_null()
static uint16_t get_gc_topic_checksum(const GC_TopicInfo *topic_info)
{
    return data_checksum(topic_info->topic, topic_info->length);
}

int get_peer_number_of_enc_pk(const GC_Chat *chat, const uint8_t *public_enc_key, bool confirmed)
{
    for (uint32_t i = 0; i < chat->numpeers; ++i) {
        const GC_Connection *gconn = get_gc_connection(chat, i);

        assert(gconn != nullptr);

        if (gconn->pending_delete) {
            continue;
        }

        if (confirmed && !gconn->confirmed) {
            continue;
        }

        if (memcmp(gconn->addr.public_key, public_enc_key, ENC_PUBLIC_KEY_SIZE) == 0) {
            return i;
        }
    }

    return -1;
}

/** @brief Check if peer associated with `public_sig_key` is in peer list.
 *
 * Returns the peer number if peer is in the peer list.
 * Returns -1 if peer is not in the peer list.
 */
non_null()
static int get_peer_number_of_sig_pk(const GC_Chat *chat, const uint8_t *public_sig_key)
{
    for (uint32_t i = 0; i < chat->numpeers; ++i) {
        const GC_Connection *gconn = get_gc_connection(chat, i);

        assert(gconn != nullptr);

        if (memcmp(get_sig_pk(gconn->addr.public_key), public_sig_key, SIG_PUBLIC_KEY_SIZE) == 0) {
            return i;
        }
    }

    return -1;
}

non_null()
static bool gc_get_enc_pk_from_sig_pk(const GC_Chat *chat, uint8_t *public_key, const uint8_t *public_sig_key)
{
    for (uint32_t i = 0; i < chat->numpeers; ++i) {
        const GC_Connection *gconn = get_gc_connection(chat, i);

        assert(gconn != nullptr);

        const uint8_t *full_pk = gconn->addr.public_key;

        if (memcmp(public_sig_key, get_sig_pk(full_pk), SIG_PUBLIC_KEY_SIZE) == 0) {
            memcpy(public_key, get_enc_key(full_pk), ENC_PUBLIC_KEY_SIZE);
            return true;
        }
    }

    return false;
}

non_null()
static GC_Connection *random_gc_connection(const GC_Chat *chat)
{
    if (chat->numpeers <= 1) {
        return nullptr;
    }

    const uint32_t base = random_range_u32(chat->rng, chat->numpeers - 1);

    for (uint32_t i = 0; i < chat->numpeers - 1; ++i) {
        const uint32_t index = 1 + (base + i) % (chat->numpeers - 1);
        GC_Connection *rand_gconn = get_gc_connection(chat, index);

        if (rand_gconn == nullptr) {
            return nullptr;
        }

        if (!rand_gconn->pending_delete && rand_gconn->confirmed) {
            return rand_gconn;
        }
    }

    return nullptr;
}

/** @brief Returns the peer number associated with peer_id.
 * Returns -1 if peer_id is invalid.
 */
non_null()
static int get_peer_number_of_peer_id(const GC_Chat *chat, uint32_t peer_id)
{
    for (uint32_t i = 0; i < chat->numpeers; ++i) {
        if (chat->group[i].peer_id == peer_id) {
            return i;
        }
    }

    return -1;
}

/** @brief Returns a unique peer ID.
 * Returns UINT32_MAX if all possible peer ID's are taken.
 *
 * These ID's are permanently assigned to a peer when they join the group and should be
 * considered arbitrary values.
 */
non_null()
static uint32_t get_new_peer_id(const GC_Chat *chat)
{
    for (uint32_t i = 0; i < UINT32_MAX - 1; ++i) {
        if (get_peer_number_of_peer_id(chat, i) == -1) {
            return i;
        }
    }

    return UINT32_MAX;
}

/** @brief Sets the password for the group (locally only).
 *
 * Return true on success.
 */
non_null(1) nullable(2)
static bool set_gc_password_local(GC_Chat *chat, const uint8_t *passwd, uint16_t length)
{
    if (length > MAX_GC_PASSWORD_SIZE) {
        return false;
    }

    if (passwd == nullptr || length == 0) {
        chat->shared_state.password_length = 0;
        memset(chat->shared_state.password, 0, MAX_GC_PASSWORD_SIZE);
    } else {
        chat->shared_state.password_length = length;
        crypto_memlock(chat->shared_state.password, sizeof(chat->shared_state.password));
        memcpy(chat->shared_state.password, passwd, length);
    }

    return true;
}

/** @brief Sets the local shared state to `version`.
 *
 * This should always be called instead of setting the variables manually.
 */
non_null()
static void set_gc_shared_state_version(GC_Chat *chat, uint32_t version)
{
    chat->shared_state.version = version;
    chat->moderation.shared_state_version = version;
}

/** @brief Expands the chat_id into the extended chat public key (encryption key + signature key).
 *
 * @param dest must have room for EXT_PUBLIC_KEY_SIZE bytes.
 *
 * Return true on success.
 */
non_null()
static bool expand_chat_id(uint8_t *dest, const uint8_t *chat_id)
{
    assert(dest != nullptr);

    const int ret = crypto_sign_ed25519_pk_to_curve25519(dest, chat_id);
    memcpy(dest + ENC_PUBLIC_KEY_SIZE, chat_id, SIG_PUBLIC_KEY_SIZE);

    return ret != -1;
}

/** Copies peer connect info from `gconn` to `addr`. */
non_null()
static void copy_gc_saved_peer(const Random *rng, const GC_Connection *gconn, GC_SavedPeerInfo *addr)
{
    if (!gcc_copy_tcp_relay(rng, &addr->tcp_relay, gconn)) {
        addr->tcp_relay = (Node_format) {
            0
        };
    }

    addr->ip_port = gconn->addr.ip_port;
    memcpy(addr->public_key, gconn->addr.public_key, ENC_PUBLIC_KEY_SIZE);
}

/** Return true if `saved_peer` has either a valid IP_Port or a valid TCP relay. */
non_null()
static bool saved_peer_is_valid(const GC_SavedPeerInfo *saved_peer)
{
    return ipport_isset(&saved_peer->ip_port) || ipport_isset(&saved_peer->tcp_relay.ip_port);
}

/** @brief Returns the index of the saved peers entry for `public_key`.
 * Returns -1 if key is not found.
 */
non_null()
static int saved_peer_index(const GC_Chat *chat, const uint8_t *public_key)
{
    for (uint16_t i = 0; i < GC_MAX_SAVED_PEERS; ++i) {
        const GC_SavedPeerInfo *saved_peer = &chat->saved_peers[i];

        if (memcmp(saved_peer->public_key, public_key, ENC_PUBLIC_KEY_SIZE) == 0) {
            return i;
        }
    }

    return -1;
}

/** @brief Returns the index of the first vacant entry in saved peers list.
 *
 * If `public_key` is non-null and already exists in the list, its index will be returned.
 *
 * A vacant entry is an entry that does not have either an IP_port or tcp relay set (invalid),
 * or an entry containing info on a peer that is not presently online (offline).
 *
 * Invalid entries are given priority over offline entries.
 *
 * Returns -1 if there are no vacant indices.
 */
non_null(1) nullable(2)
static int saved_peers_get_new_index(const GC_Chat *chat, const uint8_t *public_key)
{
    if (public_key != nullptr) {
        const int idx = saved_peer_index(chat, public_key);

        if (idx != -1) {
            return idx;
        }
    }

    // first check for invalid spots
    for (uint16_t i = 0; i < GC_MAX_SAVED_PEERS; ++i) {
        const GC_SavedPeerInfo *saved_peer = &chat->saved_peers[i];

        if (!saved_peer_is_valid(saved_peer)) {
            return i;
        }
    }

    // now look for entries with offline peers
    for (uint16_t i = 0; i < GC_MAX_SAVED_PEERS; ++i) {
        const GC_SavedPeerInfo *saved_peer = &chat->saved_peers[i];

        const int peernumber = get_peer_number_of_enc_pk(chat, saved_peer->public_key, true);

        if (peernumber < 0) {
            return i;
        }
    }

    return -1;
}

/** @brief Attempts to add `gconn` to the saved peer list.
 *
 * If an entry already exists it will be updated.
 *
 * Older peers will only be overwritten if the peer is no longer
 * present in the chat. This gives priority to more stable connections.
 *
 * This function should be called every time a new peer joins the group.
 */
non_null()
static void add_gc_saved_peers(GC_Chat *chat, const GC_Connection *gconn)
{
    const int idx = saved_peers_get_new_index(chat, gconn->addr.public_key);

    if (idx == -1) {
        return;
    }

    GC_SavedPeerInfo *saved_peer = &chat->saved_peers[idx];
    copy_gc_saved_peer(chat->rng, gconn, saved_peer);
}

/** @brief Finds the first vacant spot in the saved peers list and fills it with a present
 * peer who isn't already in the list.
 *
 * This function should be called after a confirmed peer exits the group.
 */
non_null()
static void refresh_gc_saved_peers(GC_Chat *chat)
{
    const int idx = saved_peers_get_new_index(chat, nullptr);

    if (idx == -1) {
        return;
    }

    for (uint32_t i = 1; i < chat->numpeers; ++i) {
        const GC_Connection *gconn = get_gc_connection(chat, i);

        if (gconn == nullptr) {
            continue;
        }

        if (!gconn->confirmed) {
            continue;
        }

        if (saved_peer_index(chat, gconn->addr.public_key) == -1) {
            GC_SavedPeerInfo *saved_peer = &chat->saved_peers[idx];
            copy_gc_saved_peer(chat->rng, gconn, saved_peer);
            return;
        }
    }
}

/** Returns the number of confirmed peers in peerlist. */
non_null()
static uint16_t get_gc_confirmed_numpeers(const GC_Chat *chat)
{
    uint16_t count = 0;

    for (uint32_t i = 0; i < chat->numpeers; ++i) {
        const GC_Connection *gconn = get_gc_connection(chat, i);

        assert(gconn != nullptr);

        if (gconn->confirmed) {
            ++count;
        }
    }

    return count;
}

non_null() static bool sign_gc_shared_state(GC_Chat *chat);
non_null() static bool broadcast_gc_mod_list(const GC_Chat *chat);
non_null() static bool broadcast_gc_shared_state(const GC_Chat *chat);
non_null() static bool update_gc_sanctions_list(GC_Chat *chat, const uint8_t *public_sig_key);
non_null() static bool update_gc_topic(GC_Chat *chat, const uint8_t *public_sig_key);
non_null() static bool send_gc_set_observer(const GC_Chat *chat, const uint8_t *target_ext_pk,
        const uint8_t *sanction_data, uint16_t length, bool add_obs);

/** Returns true if peer designated by `peer_number` is in the sanctions list as an observer. */
non_null()
static bool peer_is_observer(const GC_Chat *chat, uint32_t peer_number)
{
    const GC_Connection *gconn = get_gc_connection(chat, peer_number);

    if (gconn == nullptr) {
        return false;
    }

    return sanctions_list_is_observer(&chat->moderation, get_enc_key(gconn->addr.public_key));
}

/** Returns true if peer designated by `peer_number` is the group founder. */
non_null()
static bool peer_is_founder(const GC_Chat *chat, uint32_t peer_number)
{

    const GC_Connection *gconn = get_gc_connection(chat, peer_number);

    if (gconn == nullptr) {
        return false;
    }

    return memcmp(chat->shared_state.founder_public_key, gconn->addr.public_key, ENC_PUBLIC_KEY_SIZE) == 0;
}

/** Returns true if peer designated by `peer_number` is in the moderator list or is the founder. */
non_null()
static bool peer_is_moderator(const GC_Chat *chat, uint32_t peer_number)
{
    const GC_Connection *gconn = get_gc_connection(chat, peer_number);

    if (gconn == nullptr) {
        return false;
    }

    if (peer_is_founder(chat, peer_number)) {
        return false;
    }

    return mod_list_verify_sig_pk(&chat->moderation, get_sig_pk(gconn->addr.public_key));
}

/** @brief Iterates through the peerlist and updates group roles according to the
 * current group state.
 *
 * Also updates the roles checksum. If any role conflicts exist the shared state
 * version is set to zero in order to force a sync update.
 *
 * This should be called every time the moderator list or sanctions list changes,
 * and after a new peer is marked as confirmed.
 */
non_null()
static void update_gc_peer_roles(GC_Chat *chat)
{
    chat->roles_checksum = 0;
    bool conflicts = false;

    for (uint32_t i = 0; i < chat->numpeers; ++i) {
        const GC_Connection *gconn = get_gc_connection(chat, i);

        if (gconn == nullptr) {
            continue;
        }

        if (!gconn->confirmed) {
            continue;
        }

        const uint8_t first_byte = gconn->addr.public_key[0];
        const bool is_founder = peer_is_founder(chat, i);

        if (is_founder) {
            chat->group[i].role = GR_FOUNDER;
            chat->roles_checksum += GR_FOUNDER + first_byte;
            continue;
        }

        const bool is_observer  = peer_is_observer(chat, i);
        const bool is_moderator = peer_is_moderator(chat, i);
        const bool is_user = !(is_founder || is_moderator || is_observer);

        if (is_observer && is_moderator) {
            conflicts = true;
        }

        if (is_user) {
            chat->group[i].role = GR_USER;
            chat->roles_checksum += GR_USER + first_byte;
            continue;
        }

        if (is_moderator) {
            chat->group[i].role = GR_MODERATOR;
            chat->roles_checksum += GR_MODERATOR + first_byte;
            continue;
        }

        if (is_observer) {
            chat->group[i].role = GR_OBSERVER;
            chat->roles_checksum += GR_OBSERVER + first_byte;
            continue;
        }
    }

    if (conflicts && !self_gc_is_founder(chat)) {
        set_gc_shared_state_version(chat, 0);  // need a new shared state
    }
}

/** @brief Removes the first found offline mod from the mod list.
 *
 * Broadcasts the shared state and moderator list on success, as well as the updated
 * sanctions list if necessary.
 *
 * TODO(Jfreegman): Make this smarter in who to remove (e.g. the mod who hasn't been seen online in the longest time)
 *
 * Returns false on failure.
 */
non_null()
static bool prune_gc_mod_list(GC_Chat *chat)
{
    if (chat->moderation.num_mods == 0) {
        return true;
    }

    uint8_t public_sig_key[SIG_PUBLIC_KEY_SIZE];
    bool pruned_mod = false;

    for (uint16_t i = 0; i < chat->moderation.num_mods; ++i) {
        if (get_peer_number_of_sig_pk(chat, chat->moderation.mod_list[i]) == -1) {
            memcpy(public_sig_key, chat->moderation.mod_list[i], SIG_PUBLIC_KEY_SIZE);

            if (!mod_list_remove_index(&chat->moderation, i)) {
                continue;
            }

            pruned_mod = true;
            break;
        }
    }

    return pruned_mod
           && mod_list_make_hash(&chat->moderation, chat->shared_state.mod_list_hash)
           && sign_gc_shared_state(chat)
           && broadcast_gc_shared_state(chat)
           && broadcast_gc_mod_list(chat)
           && update_gc_sanctions_list(chat, public_sig_key)
           && update_gc_topic(chat, public_sig_key);
}

/** @brief Removes the first found offline sanctioned peer from the sanctions list and sends the
 * event to the rest of the group.
 *
 * @retval false on failure or if no presently sanctioned peer is offline.
 */
non_null()
static bool prune_gc_sanctions_list(GC_Chat *chat)
{
    if (chat->moderation.num_sanctions == 0) {
        return true;
    }

    const Mod_Sanction *sanction = nullptr;
    uint8_t target_ext_pk[ENC_PUBLIC_KEY_SIZE + SIG_PUBLIC_KEY_SIZE];

    for (uint16_t i = 0; i < chat->moderation.num_sanctions; ++i) {
        const int peer_number = get_peer_number_of_enc_pk(chat, chat->moderation.sanctions[i].target_public_enc_key, true);

        if (peer_number == -1) {
            sanction = &chat->moderation.sanctions[i];
            memcpy(target_ext_pk, sanction->target_public_enc_key, ENC_PUBLIC_KEY_SIZE);
            memcpy(target_ext_pk + ENC_PUBLIC_KEY_SIZE, sanction->setter_public_sig_key, SIG_PUBLIC_KEY_SIZE);
            break;
        }
    }

    if (sanction == nullptr) {
        return false;
    }

    if (!sanctions_list_remove_observer(&chat->moderation, sanction->target_public_enc_key, nullptr)) {
        LOGGER_WARNING(chat->log, "Failed to remove entry from observer list");
        return false;
    }

    sanction = nullptr;

    uint8_t data[MOD_SANCTIONS_CREDS_SIZE];
    const uint16_t length = sanctions_creds_pack(&chat->moderation.sanctions_creds, data);

    if (length != MOD_SANCTIONS_CREDS_SIZE) {
        LOGGER_ERROR(chat->log, "Failed to pack credentials (invalid length: %u)", length);
        return false;
    }

    if (!send_gc_set_observer(chat, target_ext_pk, data, length, false)) {
        LOGGER_WARNING(chat->log, "Failed to broadcast set observer");
        return false;
    }

    return true;
}

/** @brief Size of peer data that we pack for transfer (nick length must be accounted for separately).
 * packed data consists of: nick length, nick, and status.
 */
#define PACKED_GC_PEER_SIZE (sizeof(uint16_t) + MAX_GC_NICK_SIZE + sizeof(uint8_t))

/** @brief Packs peer info into data of maxlength length.
 *
 * Return length of packed peer on success.
 * Return -1 on failure.
 */
non_null()
static int pack_gc_peer(uint8_t *data, uint16_t length, const GC_Peer *peer)
{
    if (PACKED_GC_PEER_SIZE > length) {
        return -1;
    }

    uint32_t packed_len = 0;

    net_pack_u16(data + packed_len, peer->nick_length);
    packed_len += sizeof(uint16_t);
    memcpy(data + packed_len, peer->nick, MAX_GC_NICK_SIZE);
    packed_len += MAX_GC_NICK_SIZE;
    memcpy(data + packed_len, &peer->status, sizeof(uint8_t));
    packed_len += sizeof(uint8_t);

    return packed_len;
}

/** @brief Unpacks peer info of size length into peer.
 *
 * Returns the length of processed data on success.
 * Returns -1 on failure.
 */
non_null()
static int unpack_gc_peer(GC_Peer *peer, const uint8_t *data, uint16_t length)
{
    if (PACKED_GC_PEER_SIZE > length) {
        return -1;
    }

    uint16_t len_processed = 0;

    net_unpack_u16(data + len_processed, &peer->nick_length);
    len_processed += sizeof(uint16_t);
    peer->nick_length = min_u16(MAX_GC_NICK_SIZE, peer->nick_length);
    memcpy(peer->nick, data + len_processed, MAX_GC_NICK_SIZE);
    len_processed += MAX_GC_NICK_SIZE;
    memcpy(&peer->status, data + len_processed, sizeof(uint8_t));
    len_processed += sizeof(uint8_t);

    return len_processed;
}

/** @brief Packs shared_state into data.
 *
 * @param data must have room for at least GC_PACKED_SHARED_STATE_SIZE bytes.
 *
 * Returns packed data length.
 */
non_null()
static uint16_t pack_gc_shared_state(uint8_t *data, uint16_t length, const GC_SharedState *shared_state)
{
    if (length < GC_PACKED_SHARED_STATE_SIZE) {
        return 0;
    }

    const uint8_t privacy_state = shared_state->privacy_state;
    const uint8_t voice_state = shared_state->voice_state;

    uint16_t packed_len = 0;

    // version is always first
    net_pack_u32(data + packed_len, shared_state->version);
    packed_len += sizeof(uint32_t);

    memcpy(data + packed_len, shared_state->founder_public_key, EXT_PUBLIC_KEY_SIZE);
    packed_len += EXT_PUBLIC_KEY_SIZE;
    net_pack_u16(data + packed_len, shared_state->maxpeers);
    packed_len += sizeof(uint16_t);
    net_pack_u16(data + packed_len, shared_state->group_name_len);
    packed_len += sizeof(uint16_t);
    memcpy(data + packed_len, shared_state->group_name, MAX_GC_GROUP_NAME_SIZE);
    packed_len += MAX_GC_GROUP_NAME_SIZE;
    memcpy(data + packed_len, &privacy_state, sizeof(uint8_t));
    packed_len += sizeof(uint8_t);
    net_pack_u16(data + packed_len, shared_state->password_length);
    packed_len += sizeof(uint16_t);
    memcpy(data + packed_len, shared_state->password, MAX_GC_PASSWORD_SIZE);
    packed_len += MAX_GC_PASSWORD_SIZE;
    memcpy(data + packed_len, shared_state->mod_list_hash, MOD_MODERATION_HASH_SIZE);
    packed_len += MOD_MODERATION_HASH_SIZE;
    net_pack_u32(data + packed_len, shared_state->topic_lock);
    packed_len += sizeof(uint32_t);
    memcpy(data + packed_len, &voice_state, sizeof(uint8_t));
    packed_len += sizeof(uint8_t);

    return packed_len;
}

/** @brief Unpacks shared state data into shared_state.
 *
 * @param data must contain at least GC_PACKED_SHARED_STATE_SIZE bytes.
 *
 * Returns the length of processed data.
 */
non_null()
static uint16_t unpack_gc_shared_state(GC_SharedState *shared_state, const uint8_t *data, uint16_t length)
{
    if (length < GC_PACKED_SHARED_STATE_SIZE) {
        return 0;
    }

    uint16_t len_processed = 0;

    // version is always first
    net_unpack_u32(data + len_processed, &shared_state->version);
    len_processed += sizeof(uint32_t);

    memcpy(shared_state->founder_public_key, data + len_processed, EXT_PUBLIC_KEY_SIZE);
    len_processed += EXT_PUBLIC_KEY_SIZE;
    net_unpack_u16(data + len_processed, &shared_state->maxpeers);
    len_processed += sizeof(uint16_t);
    net_unpack_u16(data + len_processed, &shared_state->group_name_len);
    shared_state->group_name_len = min_u16(shared_state->group_name_len, MAX_GC_GROUP_NAME_SIZE);
    len_processed += sizeof(uint16_t);
    memcpy(shared_state->group_name, data + len_processed, MAX_GC_GROUP_NAME_SIZE);
    len_processed += MAX_GC_GROUP_NAME_SIZE;

    uint8_t privacy_state;
    memcpy(&privacy_state, data + len_processed, sizeof(uint8_t));
    len_processed += sizeof(uint8_t);

    net_unpack_u16(data + len_processed, &shared_state->password_length);
    len_processed += sizeof(uint16_t);
    memcpy(shared_state->password, data + len_processed, MAX_GC_PASSWORD_SIZE);
    len_processed += MAX_GC_PASSWORD_SIZE;
    memcpy(shared_state->mod_list_hash, data + len_processed, MOD_MODERATION_HASH_SIZE);
    len_processed += MOD_MODERATION_HASH_SIZE;
    net_unpack_u32(data + len_processed, &shared_state->topic_lock);
    len_processed += sizeof(uint32_t);

    uint8_t voice_state;
    memcpy(&voice_state, data + len_processed, sizeof(uint8_t));
    len_processed += sizeof(uint8_t);

    shared_state->voice_state = (Group_Voice_State)voice_state;
    shared_state->privacy_state = (Group_Privacy_State)privacy_state;

    return len_processed;
}

/** @brief Packs topic info into data.
 *
 * @param data must have room for at least topic length + GC_MIN_PACKED_TOPIC_INFO_SIZE bytes.
 *
 * Returns packed data length.
 */
non_null()
static uint16_t pack_gc_topic_info(uint8_t *data, uint16_t length, const GC_TopicInfo *topic_info)
{
    if (length < topic_info->length + GC_MIN_PACKED_TOPIC_INFO_SIZE) {
        return 0;
    }

    uint16_t packed_len = 0;

    net_pack_u32(data + packed_len, topic_info->version);
    packed_len += sizeof(uint32_t);
    net_pack_u16(data + packed_len, topic_info->checksum);
    packed_len += sizeof(uint16_t);
    net_pack_u16(data + packed_len, topic_info->length);
    packed_len += sizeof(uint16_t);
    memcpy(data + packed_len, topic_info->topic, topic_info->length);
    packed_len += topic_info->length;
    memcpy(data + packed_len, topic_info->public_sig_key, SIG_PUBLIC_KEY_SIZE);
    packed_len += SIG_PUBLIC_KEY_SIZE;

    return packed_len;
}

/** @brief Unpacks topic info into `topic_info`.
 *
 * Returns -1 on failure.
 * Returns the length of the processed data on success.
 */
non_null()
static int unpack_gc_topic_info(GC_TopicInfo *topic_info, const uint8_t *data, uint16_t length)
{
    if (length < sizeof(uint16_t) + sizeof(uint16_t) + sizeof(uint32_t)) {
        return -1;
    }

    uint16_t len_processed = 0;

    net_unpack_u32(data + len_processed, &topic_info->version);
    len_processed += sizeof(uint32_t);
    net_unpack_u16(data + len_processed, &topic_info->checksum);
    len_processed += sizeof(uint16_t);
    net_unpack_u16(data + len_processed, &topic_info->length);
    len_processed += sizeof(uint16_t);

    if (topic_info->length > MAX_GC_TOPIC_SIZE) {
        topic_info->length = MAX_GC_TOPIC_SIZE;
    }

    if (length - len_processed < topic_info->length + SIG_PUBLIC_KEY_SIZE) {
        return -1;
    }

    if (topic_info->length > 0) {
        memcpy(topic_info->topic, data + len_processed, topic_info->length);
        len_processed += topic_info->length;
    }

    memcpy(topic_info->public_sig_key, data + len_processed, SIG_PUBLIC_KEY_SIZE);
    len_processed += SIG_PUBLIC_KEY_SIZE;

    return len_processed;
}

/** @brief Creates a shared state packet and puts it in data.
 * Packet includes self pk hash, shared state signature, and packed shared state info.
 * data must have room for at least GC_SHARED_STATE_ENC_PACKET_SIZE bytes.
 *
 * Returns packet length on success.
 * Returns -1 on failure.
 */
non_null()
static int make_gc_shared_state_packet(const GC_Chat *chat, uint8_t *data, uint16_t length)
{
    if (length < GC_SHARED_STATE_ENC_PACKET_SIZE) {
        return -1;
    }

    memcpy(data, chat->shared_state_sig, SIGNATURE_SIZE);
    const uint16_t header_len = SIGNATURE_SIZE;

    const uint16_t packed_len = pack_gc_shared_state(data + header_len, length - header_len, &chat->shared_state);

    if (packed_len != GC_PACKED_SHARED_STATE_SIZE) {
        return -1;
    }

    return (int)(header_len + packed_len);
}

/** @brief Creates a signature for the group's shared state in packed form.
 *
 * This function only works for the Founder.
 *
 * Returns true on success and increments the shared state version.
 */
non_null()
static bool sign_gc_shared_state(GC_Chat *chat)
{
    if (!self_gc_is_founder(chat)) {
        LOGGER_ERROR(chat->log, "Failed to sign shared state (invalid permission)");
        return false;
    }

    if (chat->shared_state.version != UINT32_MAX) {
        /* improbable, but an overflow would break everything */
        set_gc_shared_state_version(chat, chat->shared_state.version + 1);
    } else {
        LOGGER_WARNING(chat->log, "Shared state version wraparound");
    }

    uint8_t shared_state[GC_PACKED_SHARED_STATE_SIZE];
    const uint16_t packed_len = pack_gc_shared_state(shared_state, sizeof(shared_state), &chat->shared_state);

    if (packed_len != GC_PACKED_SHARED_STATE_SIZE) {
        set_gc_shared_state_version(chat, chat->shared_state.version - 1);
        LOGGER_ERROR(chat->log, "Failed to pack shared state");
        return false;
    }

    const int ret = crypto_sign_detached(chat->shared_state_sig, nullptr, shared_state, packed_len,
                                         get_sig_sk(chat->chat_secret_key));

    if (ret != 0) {
        set_gc_shared_state_version(chat, chat->shared_state.version - 1);
        LOGGER_ERROR(chat->log, "Failed to sign shared state (%d)", ret);
        return false;
    }

    return true;
}

/** @brief Decrypts data using the shared key associated with `gconn`.
 *
 * The packet payload should begin with a nonce.
 *
 * @param message_id should be set to NULL for lossy packets.
 *
 * Returns length of the plaintext data on success.
 * Return -1 if encrypted payload length is invalid.
 * Return -2 on decryption failure.
 * Return -3 if plaintext payload length is invalid.
 */
non_null(1, 2, 3, 5, 6) nullable(4)
static int group_packet_unwrap(const Logger *log, const GC_Connection *gconn, uint8_t *data, uint64_t *message_id,
                               uint8_t *packet_type, const uint8_t *packet, uint16_t length)
{
    if (length <= CRYPTO_NONCE_SIZE) {
        LOGGER_FATAL(log, "Invalid packet length: %u", length);
        return -1;
    }

    uint8_t *plain = (uint8_t *)malloc(length);

    if (plain == nullptr) {
        LOGGER_ERROR(log, "Failed to allocate memory for plain data buffer");
        return -1;
    }

    int plain_len = decrypt_data_symmetric(gconn->session_shared_key, packet, packet + CRYPTO_NONCE_SIZE,
                                           length - CRYPTO_NONCE_SIZE, plain);

    if (plain_len <= 0) {
        free(plain);
        return plain_len == 0 ? -3 : -2;
    }

    const int min_plain_len = message_id != nullptr ? 1 + GC_MESSAGE_ID_BYTES : 1;

    /* remove padding */
    const uint8_t *real_plain = plain;

    while (real_plain[0] == 0) {
        ++real_plain;
        --plain_len;

        if (plain_len < min_plain_len) {
            free(plain);
            return -3;
        }
    }

    uint32_t header_len = sizeof(uint8_t);
    *packet_type = real_plain[0];
    plain_len -= sizeof(uint8_t);

    if (message_id != nullptr) {
        net_unpack_u64(real_plain + sizeof(uint8_t), message_id);
        plain_len -= GC_MESSAGE_ID_BYTES;
        header_len += GC_MESSAGE_ID_BYTES;
    }

    memcpy(data, real_plain + header_len, plain_len);

    free(plain);

    return plain_len;
}

int group_packet_wrap(
    const Logger *log, const Random *rng, const uint8_t *self_pk, const uint8_t *shared_key, uint8_t *packet,
    uint16_t packet_size, const uint8_t *data, uint16_t length, uint64_t message_id,
    uint8_t gp_packet_type, uint8_t net_packet_type)
{
    const uint16_t padding_len = group_packet_padding_length(length);
    const uint16_t min_packet_size = net_packet_type == NET_PACKET_GC_LOSSLESS
                                     ? length + padding_len + CRYPTO_MAC_SIZE + 1 + ENC_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + GC_MESSAGE_ID_BYTES + 1
                                     : length + padding_len + CRYPTO_MAC_SIZE + 1 + ENC_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + 1;

    if (min_packet_size > packet_size) {
        LOGGER_ERROR(log, "Invalid packet buffer size: %u", packet_size);
        return -1;
    }

    if (length > MAX_GC_PACKET_CHUNK_SIZE) {
        LOGGER_ERROR(log, "Packet payload size (%u) exceeds maximum (%u)", length, MAX_GC_PACKET_CHUNK_SIZE);
        return -1;
    }

    uint8_t *plain = (uint8_t *)malloc(packet_size);

    if (plain == nullptr) {
        return -1;
    }

    assert(padding_len < packet_size);

    memset(plain, 0, padding_len);

    uint16_t enc_header_len = sizeof(uint8_t);
    plain[padding_len] = gp_packet_type;

    if (net_packet_type == NET_PACKET_GC_LOSSLESS) {
        net_pack_u64(plain + padding_len + sizeof(uint8_t), message_id);
        enc_header_len += GC_MESSAGE_ID_BYTES;
    }

    if (length > 0 && data != nullptr) {
        memcpy(plain + padding_len + enc_header_len, data, length);
    }

    uint8_t nonce[CRYPTO_NONCE_SIZE];
    random_nonce(rng, nonce);

    const uint16_t plain_len = padding_len + enc_header_len + length;
    const uint16_t encrypt_buf_size = plain_len + CRYPTO_MAC_SIZE;

    uint8_t *encrypt = (uint8_t *)malloc(encrypt_buf_size);

    if (encrypt == nullptr) {
        free(plain);
        return -2;
    }

    const int enc_len = encrypt_data_symmetric(shared_key, nonce, plain, plain_len, encrypt);

    free(plain);

    if (enc_len != encrypt_buf_size) {
        LOGGER_ERROR(log, "encryption failed. packet type: 0x%02x, enc_len: %d", gp_packet_type, enc_len);
        free(encrypt);
        return -3;
    }

    packet[0] = net_packet_type;
    memcpy(packet + 1, self_pk, ENC_PUBLIC_KEY_SIZE);
    memcpy(packet + 1 + ENC_PUBLIC_KEY_SIZE, nonce, CRYPTO_NONCE_SIZE);
    memcpy(packet + 1 + ENC_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE, encrypt, enc_len);

    free(encrypt);

    return 1 + ENC_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + enc_len;
}

/** @brief Sends a lossy packet to peer_number in chat instance.
 *
 * Returns true on success.
 */
non_null()
static bool send_lossy_group_packet(const GC_Chat *chat, const GC_Connection *gconn, const uint8_t *data,
                                    uint16_t length, uint8_t packet_type)
{
    assert(length <= MAX_GC_PACKET_CHUNK_SIZE);

    if (!gconn->handshaked || gconn->pending_delete) {
        return false;
    }

    if (data == nullptr || length == 0) {
        return false;
    }

    const uint16_t packet_size = gc_get_wrapped_packet_size(length, NET_PACKET_GC_LOSSY);
    uint8_t *packet = (uint8_t *)malloc(packet_size);

    if (packet == nullptr) {
        return false;
    }

    const int len = group_packet_wrap(
                        chat->log, chat->rng, chat->self_public_key, gconn->session_shared_key, packet,
                        packet_size, data, length, 0, packet_type, NET_PACKET_GC_LOSSY);

    if (len < 0) {
        LOGGER_ERROR(chat->log, "Failed to encrypt packet (type: 0x%02x, error: %d)", packet_type, len);
        free(packet);
        return false;
    }

    const bool ret = gcc_send_packet(chat, gconn, packet, (uint16_t)len);

    free(packet);

    return ret;
}

/** @brief Sends a lossless packet to peer_number in chat instance.
 *
 * Returns true on success.
 */
non_null(1, 2) nullable(3)
static bool send_lossless_group_packet(const GC_Chat *chat, GC_Connection *gconn, const uint8_t *data, uint16_t length,
                                       uint8_t packet_type)
{
    assert(length <= MAX_GC_PACKET_SIZE);

    if (!gconn->handshaked || gconn->pending_delete) {
        return false;
    }

    if (length > MAX_GC_PACKET_CHUNK_SIZE) {
        return gcc_send_lossless_packet_fragments(chat, gconn, data, length, packet_type);
    }

    return gcc_send_lossless_packet(chat, gconn, data, length, packet_type) == 0;
}

/** @brief Sends a group sync request to peer.
 *
 * Returns true on success or if sync request timeout has not expired.
 */
non_null()
static bool send_gc_sync_request(GC_Chat *chat, GC_Connection *gconn, uint16_t sync_flags)
{
    if (!mono_time_is_timeout(chat->mono_time, chat->last_sync_request, GC_SYNC_REQUEST_LIMIT)) {
        return true;
    }

    chat->last_sync_request = mono_time_get(chat->mono_time);

    uint8_t data[(sizeof(uint16_t) * 2) + MAX_GC_PASSWORD_SIZE];
    uint16_t length = sizeof(uint16_t);

    net_pack_u16(data, sync_flags);

    if (chat_is_password_protected(chat)) {
        net_pack_u16(data + length, chat->shared_state.password_length);
        length += sizeof(uint16_t);

        memcpy(data + length, chat->shared_state.password, MAX_GC_PASSWORD_SIZE);
        length += MAX_GC_PASSWORD_SIZE;
    }

    return send_lossless_group_packet(chat, gconn, data, length, GP_SYNC_REQUEST);
}

/** @brief Sends a sync response packet to peer designated by `gconn`.
 *
 * Return true on success.
 */
non_null(1, 2) nullable(3)
static bool send_gc_sync_response(const GC_Chat *chat, GC_Connection *gconn, const uint8_t *data, uint16_t length)
{
    return send_lossless_group_packet(chat, gconn, data, length, GP_SYNC_RESPONSE);
}

non_null() static bool send_gc_peer_exchange(const GC_Chat *chat, GC_Connection *gconn);
non_null() static bool send_gc_handshake_packet(const GC_Chat *chat, GC_Connection *gconn, uint8_t handshake_type,
        uint8_t request_type, uint8_t join_type);
non_null() static bool send_gc_oob_handshake_request(const GC_Chat *chat, const GC_Connection *gconn);

/** @brief Unpacks a sync announce.
 *
 * If the announced peer is not already in our peer list, we attempt to
 * initiate a peer info exchange with them.
 *
 * Return true on success (whether or not the peer was added).
 */
non_null()
static bool unpack_gc_sync_announce(GC_Chat *chat, const uint8_t *data, const uint16_t length)
{
    GC_Announce announce = {0};

    const int unpacked_announces = gca_unpack_announces_list(chat->log, data, length, &announce, 1);

    if (unpacked_announces <= 0) {
        LOGGER_WARNING(chat->log, "Failed to unpack announces: %d", unpacked_announces);
        return false;
    }

    if (memcmp(announce.peer_public_key, chat->self_public_key, ENC_PUBLIC_KEY_SIZE) == 0) {
        LOGGER_WARNING(chat->log, "Attempted to unpack our own announce");
        return true;
    }

    if (!gca_is_valid_announce(&announce)) {
        LOGGER_WARNING(chat->log, "got invalid announce");
        return false;
    }

    const IP_Port *ip_port = announce.ip_port_is_set ? &announce.ip_port : nullptr;
    const int new_peer_number = peer_add(chat, ip_port, announce.peer_public_key);

    if (new_peer_number == -1) {
        LOGGER_ERROR(chat->log, "peer_add() failed");
        return false;
    }

    if (new_peer_number == -2) {  // peer already added
        return true;
    }

    if (new_peer_number > 0) {
        GC_Connection *new_gconn = get_gc_connection(chat, new_peer_number);

        if (new_gconn == nullptr) {
            return false;
        }

        uint32_t added_tcp_relays = 0;

        for (uint8_t i = 0; i < announce.tcp_relays_count; ++i) {
            const int add_tcp_result = add_tcp_relay_connection(chat->tcp_conn, new_gconn->tcp_connection_num,
                                       &announce.tcp_relays[i].ip_port,
                                       announce.tcp_relays[i].public_key);

            if (add_tcp_result == -1) {
                continue;
            }

            if (gcc_save_tcp_relay(chat->rng, new_gconn, &announce.tcp_relays[i]) == 0) {
                ++added_tcp_relays;
            }
        }

        if (!announce.ip_port_is_set && added_tcp_relays == 0) {
            gcc_mark_for_deletion(new_gconn, chat->tcp_conn, GC_EXIT_TYPE_DISCONNECTED, nullptr, 0);
            LOGGER_ERROR(chat->log, "Sync error: Invalid peer connection info");
            return false;
        }

        new_gconn->pending_handshake_type = HS_PEER_INFO_EXCHANGE;

        return true;
    }

    LOGGER_FATAL(chat->log, "got impossible return value %d", new_peer_number);

    return false;
}

/** @brief Handles a sync response packet.
 *
 * Note: This function may change peer numbers.
 *
 * Return 0 on success.
 * Return -1 if the group is full or the peer failed to unpack.
 * Return -2 if `peer_number` does not designate a valid peer.
 */
non_null(1, 2, 4) nullable(6)
static int handle_gc_sync_response(const GC_Session *c, GC_Chat *chat, uint32_t peer_number, const uint8_t *data,
                                   uint16_t length, void *userdata)
{
    if (chat->connection_state == CS_CONNECTED && get_gc_confirmed_numpeers(chat) >= chat->shared_state.maxpeers
            && !peer_is_founder(chat, peer_number)) {
        return -1;
    }

    if (length > 0) {
        if (!unpack_gc_sync_announce(chat, data, length)) {
            return -1;
        }
    }

    chat->connection_state = CS_CONNECTED;

    GC_Connection *gconn = get_gc_connection(chat, peer_number);

    if (gconn == nullptr) {
        return -2;
    }

    if (!send_gc_peer_exchange(chat, gconn)) {
        LOGGER_WARNING(chat->log, "Failed to send peer exchange on sync response");
    }

    if (c->self_join != nullptr && chat->time_connected == 0) {
        c->self_join(c->messenger, chat->group_number, userdata);
        chat->time_connected = mono_time_get(chat->mono_time);
    }

    return 0;
}

non_null() static int get_gc_peer_public_key(const GC_Chat *chat, uint32_t peer_number, uint8_t *public_key);
non_null() static bool send_peer_shared_state(const GC_Chat *chat, GC_Connection *gconn);
non_null() static bool send_peer_mod_list(const GC_Chat *chat, GC_Connection *gconn);
non_null() static bool send_peer_sanctions_list(const GC_Chat *chat, GC_Connection *gconn);
non_null() static bool send_peer_topic(const GC_Chat *chat, GC_Connection *gconn);


/** @brief Creates a sync announce for peer designated by `gconn` and puts it in `announce`, which
 * must be zeroed by the caller.
 *
 * Returns true if announce was successfully created.
 */
non_null()
static bool create_sync_announce(const GC_Chat *chat, const GC_Connection *gconn, uint32_t peer_number,
                                 GC_Announce *announce)
{
    if (chat == nullptr || gconn == nullptr) {
        return false;
    }

    if (gconn->tcp_relays_count > 0) {
        if (gcc_copy_tcp_relay(chat->rng, &announce->tcp_relays[0], gconn)) {
            announce->tcp_relays_count = 1;
        }
    }

    get_gc_peer_public_key(chat, peer_number, announce->peer_public_key);

    if (gcc_ip_port_is_set(gconn)) {
        announce->ip_port = gconn->addr.ip_port;
        announce->ip_port_is_set = true;
    }

    return true;
}

non_null()
static bool sync_response_send_peers(GC_Chat *chat, GC_Connection *gconn, uint32_t peer_number, bool first_sync)
{
    // Always respond to a peer's first sync request
    if (!first_sync && !mono_time_is_timeout(chat->mono_time,
            chat->last_sync_response_peer_list,
            GC_SYNC_RESPONSE_PEER_LIST_LIMIT)) {
        return true;
    }

    uint8_t *response = (uint8_t *)malloc(MAX_GC_PACKET_CHUNK_SIZE);

    if (response == nullptr) {
        return false;
    }

    size_t num_announces = 0;

    for (uint32_t i = 1; i < chat->numpeers; ++i) {
        const GC_Connection *peer_gconn = get_gc_connection(chat, i);

        if (peer_gconn == nullptr || !peer_gconn->confirmed) {
            continue;
        }

        if (peer_gconn->public_key_hash == gconn->public_key_hash || i == peer_number) {
            continue;
        }

        GC_Announce announce = {0};

        if (!create_sync_announce(chat, peer_gconn, i, &announce)) {
            continue;
        }

        const int packed_length = gca_pack_announce(chat->log, response, MAX_GC_PACKET_CHUNK_SIZE, &announce);

        if (packed_length <= 0) {
            LOGGER_WARNING(chat->log, "Failed to pack announce: %d", packed_length);
            continue;
        }

        if (!send_gc_sync_response(chat, gconn, response, packed_length)) {
            LOGGER_WARNING(chat->log, "Failed to send peer announce info");
            continue;
        }

        ++num_announces;
    }

    free(response);

    if (num_announces == 0) {
        // we send an empty sync response even if we didn't send any peers as an acknowledgement
        if (!send_gc_sync_response(chat, gconn, nullptr, 0)) {
            LOGGER_WARNING(chat->log, "Failed to send peer announce info");
            return false;
        }
    } else {
        chat->last_sync_response_peer_list = mono_time_get(chat->mono_time);
    }

    return true;
}

/** @brief Sends group state specified by `sync_flags` peer designated by `peer_number`.
 *
 * Return true on success.
 */
non_null()
static bool sync_response_send_state(GC_Chat *chat, GC_Connection *gconn, uint32_t peer_number,
                                     uint16_t sync_flags)
{
    const bool first_sync = gconn->last_sync_response == 0;

    // Do not change the order of these four send calls. See: https://toktok.ltd/spec.html#sync_request-0xf8
    if ((sync_flags & GF_STATE) > 0 && chat->shared_state.version > 0) {
        if (!send_peer_shared_state(chat, gconn)) {
            LOGGER_WARNING(chat->log, "Failed to send shared state");
            return false;
        }

        if (!send_peer_mod_list(chat, gconn)) {
            LOGGER_WARNING(chat->log, "Failed to send mod list");
            return false;
        }

        if (!send_peer_sanctions_list(chat, gconn)) {
            LOGGER_WARNING(chat->log, "Failed to send sanctions list");
            return false;
        }

        gconn->last_sync_response = mono_time_get(chat->mono_time);
    }

    if ((sync_flags & GF_TOPIC) > 0 && chat->time_connected > 0 && chat->topic_info.version > 0) {
        if (!send_peer_topic(chat, gconn)) {
            LOGGER_WARNING(chat->log, "Failed to send topic");
            return false;
        }

        gconn->last_sync_response = mono_time_get(chat->mono_time);
    }

    if ((sync_flags & GF_PEERS) > 0) {
        if (!sync_response_send_peers(chat, gconn, peer_number, first_sync)) {
            return false;
        }

        gconn->last_sync_response = mono_time_get(chat->mono_time);
    }

    return true;
}

/** @brief Handles a sync request packet and sends a response containing the peer list.
 *
 * May send additional group info in separate packets, including the topic, shared state, mod list,
 * and sanctions list, if respective sync flags are set.
 *
 * If the group is password protected the password in the request data must first be verified.
 *
 * Return 0 if packet is handled correctly.
 * Return -1 if packet has invalid size.
 * Return -2 if password is invalid.
 * Return -3 if we fail to send a response packet.
 * Return -4 if `peer_number` does not designate a valid peer.
 */
non_null()
static int handle_gc_sync_request(GC_Chat *chat, uint32_t peer_number, const uint8_t *data, uint16_t length)
{
    GC_Connection *gconn = get_gc_connection(chat, peer_number);

    if (gconn == nullptr) {
        return -4;
    }

    if (length < sizeof(uint16_t)) {
        return -1;
    }

    if (chat->numpeers <= 1) {
        return 0;
    }

    if (chat->shared_state.version == 0) {
        LOGGER_DEBUG(chat->log, "Got sync request with uninitialized state");
        return 0;
    }

    if (!mono_time_is_timeout(chat->mono_time, gconn->last_sync_response, GC_PING_TIMEOUT)) {
        LOGGER_DEBUG(chat->log, "sync request rate limit for peer %d", peer_number);
        return 0;
    }

    uint16_t sync_flags;
    net_unpack_u16(data, &sync_flags);

    if (chat_is_password_protected(chat)) {
        if (length < (sizeof(uint16_t) * 2) + MAX_GC_PASSWORD_SIZE) {
            return -2;
        }

        uint16_t password_length;
        net_unpack_u16(data + sizeof(uint16_t), &password_length);

        const uint8_t *password = data + (sizeof(uint16_t) * 2);

        if (!validate_password(chat, password, password_length)) {
            LOGGER_DEBUG(chat->log, "Invalid password");
            return -2;
        }
    }

    if (!sync_response_send_state(chat, gconn, peer_number, sync_flags)) {
        return -3;
    }

    return 0;
}

non_null() static void copy_self(const GC_Chat *chat, GC_Peer *peer);
non_null() static bool send_gc_peer_info_request(const GC_Chat *chat, GC_Connection *gconn);


/** @brief Shares our TCP relays with peer and adds shared relays to our connection with them.
 *
 * Returns true on success or if we're not connected to any TCP relays.
 */
non_null()
static bool send_gc_tcp_relays(const GC_Chat *chat, GC_Connection *gconn)
{

    Node_format tcp_relays[GCC_MAX_TCP_SHARED_RELAYS];
    uint8_t data[GCC_MAX_TCP_SHARED_RELAYS * PACKED_NODE_SIZE_IP6];

    const uint32_t n = tcp_copy_connected_relays_index(chat->tcp_conn, tcp_relays, GCC_MAX_TCP_SHARED_RELAYS,
                       gconn->tcp_relay_share_index);

    if (n == 0) {
        return true;
    }

    gconn->tcp_relay_share_index += GCC_MAX_TCP_SHARED_RELAYS;

    for (uint32_t i = 0; i < n; ++i) {
        add_tcp_relay_connection(chat->tcp_conn, gconn->tcp_connection_num, &tcp_relays[i].ip_port,
                                 tcp_relays[i].public_key);
    }

    const int nodes_len = pack_nodes(chat->log, data, sizeof(data), tcp_relays, n);

    if (nodes_len <= 0 || (uint32_t)nodes_len > sizeof(data)) {
        LOGGER_ERROR(chat->log, "Failed to pack tcp relays (nodes_len: %d)", nodes_len);
        return false;
    }

    if (!send_lossless_group_packet(chat, gconn, data, (uint16_t)nodes_len, GP_TCP_RELAYS)) {
        LOGGER_ERROR(chat->log, "Failed to send tcp relays");
        return false;
    }

    return true;
}

/** @brief Adds a peer's shared TCP relays to our connection with them.
 *
 * Return 0 if packet is handled correctly.
 * Return -1 if packet has invalid size.
 * Return -2 if packet contains invalid data.
 */
non_null()
static int handle_gc_tcp_relays(GC_Chat *chat, GC_Connection *gconn, const uint8_t *data, uint16_t length)
{
    if (length == 0) {
        return -1;
    }

    Node_format tcp_relays[GCC_MAX_TCP_SHARED_RELAYS];
    const int num_nodes = unpack_nodes(tcp_relays, GCC_MAX_TCP_SHARED_RELAYS, nullptr, data, length, true);

    if (num_nodes <= 0) {
        return -2;
    }

    for (int i = 0; i < num_nodes; ++i) {
        const Node_format *tcp_node = &tcp_relays[i];

        if (add_tcp_relay_connection(chat->tcp_conn, gconn->tcp_connection_num, &tcp_node->ip_port,
                                     tcp_node->public_key) == 0) {
            gcc_save_tcp_relay(chat->rng, gconn, tcp_node);

            if (gconn->tcp_relays_count == 1) {
                add_gc_saved_peers(chat, gconn);  // make sure we save at least one tcp relay
            }
        }
    }

    return 0;
}

/** @brief Send invite request to peer_number.
 *
 * If the group requires a password, the packet will
 * contain the password supplied by the invite requestor.
 *
 * Return true on success.
 */
non_null()
static bool send_gc_invite_request(const GC_Chat *chat, GC_Connection *gconn)
{
    uint16_t length = 0;
    uint8_t data[sizeof(uint16_t) + MAX_GC_PASSWORD_SIZE];

    if (chat_is_password_protected(chat)) {
        net_pack_u16(data, chat->shared_state.password_length);
        length += sizeof(uint16_t);

        memcpy(data + length, chat->shared_state.password, MAX_GC_PASSWORD_SIZE);
        length += MAX_GC_PASSWORD_SIZE;
    }

    return send_lossless_group_packet(chat, gconn, data, length, GP_INVITE_REQUEST);
}

non_null()
static bool send_gc_invite_response(const GC_Chat *chat, GC_Connection *gconn)
{
    return send_lossless_group_packet(chat, gconn, nullptr, 0, GP_INVITE_RESPONSE);
}

/** @brief Handles an invite response packet.
 *
 * Return 0 if packet is correctly handled.
 * Return -1 if we fail to send a sync request.
 */
non_null()
static int handle_gc_invite_response(GC_Chat *chat, GC_Connection *gconn)
{
    const uint16_t flags = GF_PEERS | GF_TOPIC | GF_STATE;

    if (!send_gc_sync_request(chat, gconn, flags)) {
        return -1;
    }

    return 0;
}

/**
 * @brief Handles an invite response reject packet.
 *
 * Return 0 if packet is handled correctly.
 * Return -1 if packet has invalid size.
 */
non_null(1, 2, 3) nullable(5)
static int handle_gc_invite_response_reject(const GC_Session *c, GC_Chat *chat, const uint8_t *data, uint16_t length,
        void *userdata)
{
    if (length < sizeof(uint8_t)) {
        return -1;
    }

    if (chat->connection_state == CS_CONNECTED) {
        return 0;
    }

    if (gc_get_self_role(chat) == GR_FOUNDER) {
        return 0;
    }

    uint8_t type = data[0];

    if (type >= GJ_INVALID) {
        type = GJ_INVITE_FAILED;
    }

    chat->connection_state = CS_DISCONNECTED;

    if (c->rejected != nullptr) {
        c->rejected(c->messenger, chat->group_number, type, userdata);
    }

    return 0;
}

/** @brief Sends an invite response rejection packet to peer designated by `gconn`.
 *
 * Return true on success.
 */
non_null()
static bool send_gc_invite_response_reject(const GC_Chat *chat, const GC_Connection *gconn, uint8_t type)
{
    if (type >= GJ_INVALID) {
        type = GJ_INVITE_FAILED;
    }

    uint8_t data[1];
    data[0] = type;
    const uint16_t length = 1;

    return send_lossy_group_packet(chat, gconn, data, length, GP_INVITE_RESPONSE_REJECT);
}

/** @brief Handles an invite request and verifies that the correct password has been supplied
 * if the group is password protected.
 *
 * Return 0 if invite request is successfully handled.
 * Return -1 if the group is full.
 * Return -2 if the supplied password is invalid.
 * Return -3 if we fail to send an invite response.
 * Return -4 if peer_number does not designate a valid peer.
 */
non_null()
static int handle_gc_invite_request(GC_Chat *chat, uint32_t peer_number, const uint8_t *data, uint16_t length)
{
    if (chat->shared_state.version == 0) {  // we aren't synced yet; ignore request
        return 0;
    }

    GC_Connection *gconn = get_gc_connection(chat, peer_number);

    if (gconn == nullptr) {
        return -4;
    }

    int ret = -1;

    uint8_t invite_error;

    if (get_gc_confirmed_numpeers(chat) >= chat->shared_state.maxpeers && !peer_is_founder(chat, peer_number)) {
        invite_error = GJ_GROUP_FULL;
        goto FAILED_INVITE;
    }

    if (chat_is_password_protected(chat)) {
        invite_error = GJ_INVALID_PASSWORD;
        ret = -2;

        if (length < sizeof(uint16_t) + MAX_GC_PASSWORD_SIZE) {
            goto FAILED_INVITE;
        }

        uint16_t password_length;
        net_unpack_u16(data, &password_length);

        const uint8_t *password = data + sizeof(uint16_t);

        if (!validate_password(chat, password, password_length)) {
            goto FAILED_INVITE;
        }
    }

    if (!send_gc_invite_response(chat, gconn)) {
        return -3;
    }

    return 0;

FAILED_INVITE:
    send_gc_invite_response_reject(chat, gconn, invite_error);
    gcc_mark_for_deletion(gconn, chat->tcp_conn, GC_EXIT_TYPE_DISCONNECTED, nullptr, 0);

    return ret;
}

/** @brief Sends a lossless packet of type and length to all confirmed peers. */
non_null()
static void send_gc_lossless_packet_all_peers(const GC_Chat *chat, const uint8_t *data, uint16_t length, uint8_t type)
{
    for (uint32_t i = 1; i < chat->numpeers; ++i) {
        GC_Connection *gconn = get_gc_connection(chat, i);

        assert(gconn != nullptr);

        if (gconn->confirmed) {
            send_lossless_group_packet(chat, gconn, data, length, type);
        }
    }
}

/** @brief Sends a lossy packet of type and length to all confirmed peers. */
non_null()
static void send_gc_lossy_packet_all_peers(const GC_Chat *chat, const uint8_t *data, uint16_t length, uint8_t type)
{
    for (uint32_t i = 1; i < chat->numpeers; ++i) {
        const GC_Connection *gconn = get_gc_connection(chat, i);

        assert(gconn != nullptr);

        if (gconn->confirmed) {
            send_lossy_group_packet(chat, gconn, data, length, type);
        }
    }
}

/** @brief Creates packet with broadcast header info followed by data of length.
 *
 * Returns length of packet including header.
 */
non_null(3) nullable(1)
static uint16_t make_gc_broadcast_header(const uint8_t *data, uint16_t length, uint8_t *packet, uint8_t bc_type)
{
    packet[0] = bc_type;
    const uint16_t header_len = sizeof(uint8_t);

    if (data != nullptr && length > 0) {
        memcpy(packet + header_len, data, length);
    }

    return length + header_len;
}

/** @brief sends a group broadcast packet to all confirmed peers.
 *
 * Returns true on success.
 */
non_null(1) nullable(2)
static bool send_gc_broadcast_message(const GC_Chat *chat, const uint8_t *data, uint16_t length, uint8_t bc_type)
{
    if (length + GC_BROADCAST_ENC_HEADER_SIZE > MAX_GC_PACKET_SIZE) {
        LOGGER_ERROR(chat->log, "Failed to broadcast message: invalid length %u", length);
        return false;
    }

    uint8_t *packet = (uint8_t *)malloc(length + GC_BROADCAST_ENC_HEADER_SIZE);

    if (packet == nullptr) {
        return false;
    }

    const uint16_t packet_len = make_gc_broadcast_header(data, length, packet, bc_type);

    send_gc_lossless_packet_all_peers(chat, packet, packet_len, GP_BROADCAST);

    free(packet);

    return true;
}

non_null()
static bool group_topic_lock_enabled(const GC_Chat *chat);

/** @brief Compares the supplied values with our own state and returns the appropriate
 * sync flags for a sync request.
 */
non_null()
static uint16_t get_sync_flags(const GC_Chat *chat, uint16_t peers_checksum, uint16_t peer_count,
                               uint32_t sstate_version, uint32_t screds_version, uint16_t roles_checksum,
                               uint32_t topic_version, uint16_t topic_checksum)
{
    uint16_t sync_flags = 0;

    if (peers_checksum != chat->peers_checksum && peer_count >= get_gc_confirmed_numpeers(chat)) {
        sync_flags |= GF_PEERS;
    }

    if (sstate_version > 0) {
        const uint16_t self_roles_checksum = chat->moderation.sanctions_creds.checksum + chat->roles_checksum;

        if ((sstate_version > chat->shared_state.version || screds_version > chat->moderation.sanctions_creds.version)
                || (screds_version == chat->moderation.sanctions_creds.version
                    && roles_checksum != self_roles_checksum)) {
            sync_flags |= GF_STATE;
        }
    }

    if (group_topic_lock_enabled(chat)) {
        if (topic_version > chat->topic_info.version ||
                (topic_version == chat->topic_info.version && topic_checksum > chat->topic_info.checksum)) {
            sync_flags |= GF_TOPIC;
        }
    } else if (topic_checksum > chat->topic_info.checksum) {
        sync_flags |= GF_TOPIC;
    }

    return sync_flags;
}

/** @brief Compares a peer's group sync info that we received in a ping packet to our own.
 *
 * If their info appears to be more recent than ours we send them a sync request.
 *
 * This function should only be called from `handle_gc_ping()`.
 *
 * Returns true if a sync request packet is successfully sent.
 */
non_null()
static bool do_gc_peer_state_sync(GC_Chat *chat, GC_Connection *gconn, const uint8_t *sync_data,
                                  const uint16_t length)
{
    if (length < GC_PING_PACKET_MIN_DATA_SIZE) {
        return false;
    }

    uint16_t peers_checksum;
    uint16_t peer_count;
    uint32_t sstate_version;
    uint32_t screds_version;
    uint16_t roles_checksum;
    uint32_t topic_version;
    uint16_t topic_checksum;

    size_t unpacked_len = 0;

    net_unpack_u16(sync_data, &peers_checksum);
    unpacked_len += sizeof(uint16_t);

    net_unpack_u16(sync_data + unpacked_len, &peer_count);
    unpacked_len += sizeof(uint16_t);

    net_unpack_u32(sync_data + unpacked_len, &sstate_version);
    unpacked_len += sizeof(uint32_t);

    net_unpack_u32(sync_data + unpacked_len, &screds_version);
    unpacked_len += sizeof(uint32_t);

    net_unpack_u16(sync_data + unpacked_len, &roles_checksum);
    unpacked_len += sizeof(uint16_t);

    net_unpack_u32(sync_data + unpacked_len, &topic_version);
    unpacked_len += sizeof(uint32_t);

    net_unpack_u16(sync_data + unpacked_len, &topic_checksum);
    unpacked_len += sizeof(uint16_t);

    if (unpacked_len != GC_PING_PACKET_MIN_DATA_SIZE) {
        LOGGER_FATAL(chat->log, "Unpacked length is impossible (%zu)", unpacked_len);
        return false;
    }

    const uint16_t sync_flags = get_sync_flags(chat, peers_checksum, peer_count, sstate_version, screds_version,
                                roles_checksum, topic_version, topic_checksum);

    if (sync_flags > 0) {
        return send_gc_sync_request(chat, gconn, sync_flags);
    }

    return false;
}

/** @brief Handles a ping packet.
 *
 * The packet contains sync information including peer's peer list checksum,
 * shared state version, topic version, and sanction credentials version.
 *
 * Return 0 if packet is handled correctly.
 * Return -1 if packet has invalid size or peer is not confirmed.
 */
non_null()
static int handle_gc_ping(GC_Chat *chat, GC_Connection *gconn, const uint8_t *data, uint16_t length)
{
    if (length < GC_PING_PACKET_MIN_DATA_SIZE) {
        return -1;
    }

    if (!gconn->confirmed) {
        return -1;
    }

    do_gc_peer_state_sync(chat, gconn, data, length);

    if (length > GC_PING_PACKET_MIN_DATA_SIZE) {
        IP_Port ip_port;
        memset(&ip_port, 0, sizeof(IP_Port));

        if (unpack_ip_port(&ip_port, data + GC_PING_PACKET_MIN_DATA_SIZE,
                           length - GC_PING_PACKET_MIN_DATA_SIZE, false) > 0) {
            gcc_set_ip_port(gconn, &ip_port);
            add_gc_saved_peers(chat, gconn);
        }
    }

    return 0;
}

int gc_set_self_status(const Messenger *m, int group_number, Group_Peer_Status status)
{
    const GC_Session *c = m->group_handler;
    const GC_Chat *chat = gc_get_group(c, group_number);

    if (chat == nullptr) {
        return -1;
    }

    self_gc_set_status(chat, status);

    uint8_t data[1];
    data[0] = gc_get_self_status(chat);

    if (!send_gc_broadcast_message(chat, data, 1, GM_STATUS)) {
        return -2;
    }

    return 0;
}

/** @brief Handles a status broadcast from `peer`.
 *
 * Return 0 if packet is handled correctly.
 * Return -1 if packet has invalid length.
 */
non_null(1, 2, 3, 4) nullable(6)
static int handle_gc_status(const GC_Session *c, const GC_Chat *chat, GC_Peer *peer, const uint8_t *data,
                            uint16_t length, void *userdata)
{
    if (length < sizeof(uint8_t)) {
        return -1;
    }

    const Group_Peer_Status status = (Group_Peer_Status)data[0];

    if (status > GS_BUSY) {
        LOGGER_WARNING(chat->log, "Received invalid status %u", status);
        return 0;
    }

    peer->status = status;

    if (c->status_change != nullptr) {
        c->status_change(c->messenger, chat->group_number, peer->peer_id, status, userdata);
    }

    return 0;
}

uint8_t gc_get_status(const GC_Chat *chat, uint32_t peer_id)
{
    const int peer_number = get_peer_number_of_peer_id(chat, peer_id);

    const GC_Peer *peer = get_gc_peer(chat, peer_number);

    if (peer == nullptr) {
        return UINT8_MAX;
    }

    return peer->status;
}

uint8_t gc_get_role(const GC_Chat *chat, uint32_t peer_id)
{
    const int peer_number = get_peer_number_of_peer_id(chat, peer_id);

    const GC_Peer *peer = get_gc_peer(chat, peer_number);

    if (peer == nullptr) {
        return UINT8_MAX;
    }

    return peer->role;
}

void gc_get_chat_id(const GC_Chat *chat, uint8_t *dest)
{
    if (dest != nullptr) {
        memcpy(dest, get_chat_id(chat->chat_public_key), CHAT_ID_SIZE);
    }
}

/** @brief Sends self peer info to `gconn`.
 *
 * If the group is password protected the request will contain the group
 * password, which the recipient will validate in the respective
 * group message handler.
 *
 * Returns true on success.
 */
non_null()
static bool send_self_to_peer(const GC_Chat *chat, GC_Connection *gconn)
{
    GC_Peer *self = (GC_Peer *)calloc(1, sizeof(GC_Peer));

    if (self == nullptr) {
        return false;
    }

    copy_self(chat, self);

    const uint16_t data_size = PACKED_GC_PEER_SIZE + sizeof(uint16_t) + MAX_GC_PASSWORD_SIZE;
    uint8_t *data = (uint8_t *)malloc(data_size);

    if (data == nullptr) {
        free(self);
        return false;
    }

    uint16_t length = 0;

    if (chat_is_password_protected(chat)) {
        net_pack_u16(data, chat->shared_state.password_length);
        length += sizeof(uint16_t);

        memcpy(data + sizeof(uint16_t), chat->shared_state.password, MAX_GC_PASSWORD_SIZE);
        length += MAX_GC_PASSWORD_SIZE;
    }

    const int packed_len = pack_gc_peer(data + length, data_size - length, self);
    length += packed_len;

    free(self);

    if (packed_len <= 0) {
        LOGGER_DEBUG(chat->log, "pack_gc_peer failed in handle_gc_peer_info_request_request %d", packed_len);
        free(data);
        return false;
    }

    const bool ret = send_lossless_group_packet(chat, gconn, data, length, GP_PEER_INFO_RESPONSE);

    free(data);

    return ret;
}

/** @brief Handles a peer info request packet.
 *
 * Return 0 on success.
 * Return -1 if unconfirmed peer is trying to join a full group.
 * Return -2 if response fails.
 * Return -3 if `peer_number` does not designate a valid peer.
 */
non_null()
static int handle_gc_peer_info_request(const GC_Chat *chat, uint32_t peer_number)
{
    GC_Connection *gconn = get_gc_connection(chat, peer_number);

    if (gconn == nullptr) {
        return -3;
    }

    if (!gconn->confirmed && get_gc_confirmed_numpeers(chat) >= chat->shared_state.maxpeers
            && !peer_is_founder(chat, peer_number)) {
        return -1;
    }

    if (!send_self_to_peer(chat, gconn)) {
        return -2;
    }

    return 0;
}

/** @brief Sends a peer info request to peer designated by `gconn`.
 *
 * Return true on success.
 */
non_null()
static bool send_gc_peer_info_request(const GC_Chat *chat, GC_Connection *gconn)
{
    return send_lossless_group_packet(chat, gconn, nullptr, 0, GP_PEER_INFO_REQUEST);
}

/** @brief Do peer info exchange with peer designated by `gconn`.
 *
 * This function sends two packets to a peer. The first packet is a peer info response containing our own info,
 * and the second packet is a peer info request.
 *
 * Return false if either packet fails to send.
 */
static bool send_gc_peer_exchange(const GC_Chat *chat, GC_Connection *gconn)
{
    return send_self_to_peer(chat, gconn) && send_gc_peer_info_request(chat, gconn);
}

/** @brief Updates peer's info, validates their group role, and sets them as a confirmed peer.
 * If the group is password protected the password must first be validated.
 *
 * Return 0 if packet is handled correctly.
 * Return -1 if packet has invalid size.
 * Return -2 if group number is invalid.
 * Return -3 if peer number is invalid.
 * Return -4 if unconfirmed peer is trying to join a full group.
 * Return -5 if supplied group password is invalid.
 * Return -6 if we fail to add the peer to the peer list.
 * Return -7 if peer's role cannot be validated.
 * Return -8 if malloc fails.
 */
non_null(1, 2, 4) nullable(6)
static int handle_gc_peer_info_response(const GC_Session *c, GC_Chat *chat, uint32_t peer_number,
                                        const uint8_t *data, uint16_t length, void *userdata)
{
    if (length < PACKED_GC_PEER_SIZE) {
        return -1;
    }

    GC_Peer *peer = get_gc_peer(chat, peer_number);

    if (peer == nullptr) {
        return -3;
    }

    GC_Connection *gconn = &peer->gconn;

    if (!gconn->confirmed && get_gc_confirmed_numpeers(chat) >= chat->shared_state.maxpeers
            && !peer_is_founder(chat, peer_number)) {
        return -4;
    }

    uint16_t unpacked_len = 0;

    if (chat_is_password_protected(chat)) {
        if (length < sizeof(uint16_t) + MAX_GC_PASSWORD_SIZE) {
            return -5;
        }

        uint16_t password_length;
        net_unpack_u16(data, &password_length);
        unpacked_len += sizeof(uint16_t);

        if (!validate_password(chat, data + unpacked_len, password_length)) {
            return -5;
        }

        unpacked_len += MAX_GC_PASSWORD_SIZE;
    }

    if (length <= unpacked_len) {
        return -1;
    }

    GC_Peer *peer_info = (GC_Peer *)calloc(1, sizeof(GC_Peer));

    if (peer_info == nullptr) {
        return -8;
    }

    if (unpack_gc_peer(peer_info, data + unpacked_len, length - unpacked_len) == -1) {
        LOGGER_ERROR(chat->log, "unpack_gc_peer() failed");
        free(peer_info);
        return -6;
    }

    if (peer_update(chat, peer_info, peer_number) == -1) {
        LOGGER_WARNING(chat->log, "peer_update() failed");
        free(peer_info);
        return -6;
    }

    free(peer_info);

    const bool was_confirmed = gconn->confirmed;
    gconn->confirmed = true;

    update_gc_peer_roles(chat);

    add_gc_saved_peers(chat, gconn);

    set_gc_peerlist_checksum(chat);

    if (c->peer_join != nullptr && !was_confirmed) {
        c->peer_join(c->messenger, chat->group_number, peer->peer_id, userdata);
    }

    return 0;
}

/** @brief Sends the group shared state and its signature to peer_number.
 *
 * Returns true on success.
 */
non_null()
static bool send_peer_shared_state(const GC_Chat *chat, GC_Connection *gconn)
{
    if (chat->shared_state.version == 0) {
        return false;
    }

    uint8_t packet[GC_SHARED_STATE_ENC_PACKET_SIZE];
    const int length = make_gc_shared_state_packet(chat, packet, sizeof(packet));

    if (length != GC_SHARED_STATE_ENC_PACKET_SIZE) {
        return false;
    }

    return send_lossless_group_packet(chat, gconn, packet, (uint16_t)length, GP_SHARED_STATE);
}

/** @brief Sends the group shared state and signature to all confirmed peers.
 *
 * Returns true on success.
 */
non_null()
static bool broadcast_gc_shared_state(const GC_Chat *chat)
{
    uint8_t packet[GC_SHARED_STATE_ENC_PACKET_SIZE];
    const int packet_len = make_gc_shared_state_packet(chat, packet, sizeof(packet));

    if (packet_len != GC_SHARED_STATE_ENC_PACKET_SIZE) {
        return false;
    }

    send_gc_lossless_packet_all_peers(chat, packet, (uint16_t)packet_len, GP_SHARED_STATE);

    return true;
}

/** @brief Helper function for `do_gc_shared_state_changes()`.
 *
 * If the privacy state has been set to private, we kill our group's connection to the DHT.
 * Otherwise, we create a new connection with the DHT and flag an announcement.
 */
non_null(1, 2) nullable(3)
static void do_privacy_state_change(const GC_Session *c, GC_Chat *chat, void *userdata)
{
    if (is_public_chat(chat)) {
        if (!m_create_group_connection(c->messenger, chat)) {
            LOGGER_ERROR(chat->log, "Failed to initialize group friend connection");
        } else {
            chat->update_self_announces = true;
            chat->join_type = HJ_PUBLIC;
        }
    } else {
        kill_group_friend_connection(c, chat);
        cleanup_gca(c->announces_list, get_chat_id(chat->chat_public_key));
        chat->join_type = HJ_PRIVATE;
    }

    if (c->privacy_state != nullptr) {
        c->privacy_state(c->messenger, chat->group_number, chat->shared_state.privacy_state, userdata);
    }
}

/**
 * Compares old_shared_state with the chat instance's current shared state and triggers the
 * appropriate callbacks depending on what pieces of state information changed. Also
 * handles DHT announcement/removal if the privacy state changed.
 *
 * The initial retrieval of the shared state on group join will be ignored by this function.
 */
non_null(1, 2, 3) nullable(4)
static void do_gc_shared_state_changes(const GC_Session *c, GC_Chat *chat, const GC_SharedState *old_shared_state,
                                       void *userdata)
{
    /* Max peers changed */
    if (chat->shared_state.maxpeers != old_shared_state->maxpeers && c->peer_limit != nullptr) {
        c->peer_limit(c->messenger, chat->group_number, chat->shared_state.maxpeers, userdata);
    }

    /* privacy state changed */
    if (chat->shared_state.privacy_state != old_shared_state->privacy_state) {
        do_privacy_state_change(c, chat, userdata);
    }

    /* password changed */
    if (chat->shared_state.password_length != old_shared_state->password_length
            || memcmp(chat->shared_state.password, old_shared_state->password, old_shared_state->password_length) != 0) {

        if (c->password != nullptr) {
            c->password(c->messenger, chat->group_number, chat->shared_state.password,
                        chat->shared_state.password_length, userdata);
        }
    }

    /* topic lock state changed */
    if (chat->shared_state.topic_lock != old_shared_state->topic_lock && c->topic_lock != nullptr) {
        const Group_Topic_Lock lock_state = group_topic_lock_enabled(chat) ? TL_ENABLED : TL_DISABLED;
        c->topic_lock(c->messenger, chat->group_number, lock_state, userdata);
    }

    /* voice state changed */
    if (chat->shared_state.voice_state != old_shared_state->voice_state && c->voice_state != nullptr) {
        c->voice_state(c->messenger, chat->group_number, chat->shared_state.voice_state, userdata);
    }
}

/** @brief Sends a sync request to a random peer in the group with the specificed sync flags.
 *
 * Return true on success.
 */
non_null()
static bool send_gc_random_sync_request(GC_Chat *chat, uint16_t sync_flags)
{
    GC_Connection *rand_gconn = random_gc_connection(chat);

    if (rand_gconn == nullptr) {
        return false;
    }

    return send_gc_sync_request(chat, rand_gconn, sync_flags);
}

/** @brief Returns true if all shared state values are legal. */
non_null()
static bool validate_gc_shared_state(const GC_SharedState *state)
{
    return state->maxpeers > 0
           && state->password_length <= MAX_GC_PASSWORD_SIZE
           && state->group_name_len > 0
           && state->group_name_len <= MAX_GC_GROUP_NAME_SIZE
           && state->privacy_state <= GI_PRIVATE
           && state->voice_state <= GV_FOUNDER;
}

/** @brief Handles a shared state error and attempts to send a sync request to a random peer.
 *
 * Return 0 if error is currectly handled.
 * Return -1 on failure.
 */
non_null()
static int handle_gc_shared_state_error(GC_Chat *chat, GC_Connection *gconn)
{
    gcc_mark_for_deletion(gconn, chat->tcp_conn, GC_EXIT_TYPE_SYNC_ERR, nullptr, 0);

    if (chat->shared_state.version == 0) {
        chat->connection_state = CS_CONNECTING;
        return 0;
    }

    if (chat->numpeers <= 1) {
        return 0;
    }

    if (!send_gc_random_sync_request(chat, GF_STATE)) {
        return -1;
    }

    return 0;
}

/** @brief Handles a shared state packet and validates the new shared state.
 *
 * Return 0 if packet is successfully handled.
 * Return -1 if packet is invalid and this is not successfully handled.
 */
non_null(1, 2, 3, 4) nullable(6)
static int handle_gc_shared_state(const GC_Session *c, GC_Chat *chat, GC_Connection *gconn, const uint8_t *data,
                                  uint16_t length, void *userdata)
{
    if (length < GC_SHARED_STATE_ENC_PACKET_SIZE) {
        return handle_gc_shared_state_error(chat, gconn);
    }

    const uint8_t *signature = data;
    const uint8_t *ss_data = data + SIGNATURE_SIZE;
    const uint16_t ss_length = length - SIGNATURE_SIZE;

    if (crypto_sign_verify_detached(signature, ss_data, GC_PACKED_SHARED_STATE_SIZE,
                                    get_sig_pk(chat->chat_public_key)) == -1) {
        LOGGER_DEBUG(chat->log, "Failed to validate shared state signature");
        return handle_gc_shared_state_error(chat, gconn);
    }

    uint32_t version;
    net_unpack_u32(ss_data, &version);  // version is the first 4 bytes of shared state data payload

    if (version == 0 || version < chat->shared_state.version) {
        LOGGER_DEBUG(chat->log, "Invalid shared state version (got %u, expected >= %u)",
                     version, chat->shared_state.version);
        return 0;
    }

    GC_SharedState old_shared_state = chat->shared_state;
    GC_SharedState new_shared_state;

    if (unpack_gc_shared_state(&new_shared_state, ss_data, ss_length) == 0) {
        LOGGER_WARNING(chat->log, "Failed to unpack shared state");
        return 0;
    }

    if (!validate_gc_shared_state(&new_shared_state)) {
        LOGGER_WARNING(chat->log, "Failed to validate shared state");
        return 0;
    }

    if (chat->shared_state.version == 0) {  // init founder public sig key in moderation object
        memcpy(chat->moderation.founder_public_sig_key,
               get_sig_pk(new_shared_state.founder_public_key), SIG_PUBLIC_KEY_SIZE);
    }

    chat->shared_state = new_shared_state;

    memcpy(chat->shared_state_sig, signature, sizeof(chat->shared_state_sig));

    set_gc_shared_state_version(chat, chat->shared_state.version);

    do_gc_shared_state_changes(c, chat, &old_shared_state, userdata);

    return 0;
}

/** @brief Validates `data` containing a moderation list and unpacks it into the
 * shared state of `chat`.
 *
 * Return 1 if data is valid but mod list doesn't match shared state.
 * Return 0 if data is valid.
 * Return -1 if data is invalid.
 */
non_null()
static int validate_unpack_mod_list(GC_Chat *chat, const uint8_t *data, uint16_t length, uint16_t num_mods)
{
    if (num_mods > MOD_MAX_NUM_MODERATORS) {
        return -1;
    }

    uint8_t mod_list_hash[MOD_MODERATION_HASH_SIZE] = {0};

    if (length > 0) {
        mod_list_get_data_hash(mod_list_hash, data, length);
    }

    // we make sure that this mod list's hash matches the one we got in our last shared state update
    if (chat->shared_state.version > 0
            && memcmp(mod_list_hash, chat->shared_state.mod_list_hash, MOD_MODERATION_HASH_SIZE) != 0) {
        LOGGER_WARNING(chat->log, "failed to validate mod list hash");
        return 1;
    }

    if (mod_list_unpack(&chat->moderation, data, length, num_mods) == -1) {
        LOGGER_WARNING(chat->log, "failed to unpack mod list");
        return -1;
    }

    return 0;
}

/** @brief Handles new mod_list and compares its hash against the mod_list_hash in the shared state.
 *
 * If the new list fails validation, we attempt to send a sync request to a random peer.
 *
 * Return 0 if packet is handled correctly.
 * Return -1 if packet has invalid size.
 * Return -2 if packet contained invalid data or validation failed.
 */
non_null(1, 2, 3) nullable(5)
static int handle_gc_mod_list(const GC_Session *c, GC_Chat *chat, const uint8_t *data, uint16_t length, void *userdata)
{
    if (length < sizeof(uint16_t)) {
        return -1;
    }

    // only the founder can modify the list; the founder can never be out of sync
    if (self_gc_is_founder(chat)) {
        return 0;
    }

    uint16_t num_mods;
    net_unpack_u16(data, &num_mods);

    const int unpack_ret = validate_unpack_mod_list(chat, data + sizeof(uint16_t), length - sizeof(uint16_t), num_mods);

    if (unpack_ret == 0) {
        update_gc_peer_roles(chat);

        if (chat->connection_state == CS_CONNECTED && c->moderation != nullptr) {
            c->moderation(c->messenger, chat->group_number, (uint32_t) -1, (uint32_t) -1, MV_MOD, userdata);
        }

        return 0;
    }

    if (unpack_ret == 1) {
        return 0;
    }

    // unpack/validation failed: handle error

    if (chat->shared_state.version == 0) {
        chat->connection_state = CS_CONNECTING;
        return -2;
    }

    if (chat->numpeers <= 1) {
        return 0;
    }

    send_gc_random_sync_request(chat, GF_STATE);

    return 0;
}

/** @brief Handles a sanctions list validation error and attempts to send a sync request to a random peer.
 *
 * Return 0 on success.
 * Return -1 on failure.
 */
non_null()
static int handle_gc_sanctions_list_error(GC_Chat *chat)
{
    if (chat->moderation.sanctions_creds.version > 0) {
        return 0;
    }

    if (chat->shared_state.version == 0) {
        chat->connection_state = CS_CONNECTING;
        return 0;
    }

    if (chat->numpeers <= 1) {
        return 0;
    }

    if (!send_gc_random_sync_request(chat, GF_STATE)) {
        return -1;
    }

    return 0;
}

/** @brief Handles a sanctions list packet.
 *
 * Return 0 if packet is handled correctly.
 * Return -1 if we failed to gracefully handle a sanctions list error.
 * Return -2 if packet has invalid size.
 */
non_null(1, 2, 3) nullable(5)
static int handle_gc_sanctions_list(const GC_Session *c, GC_Chat *chat, const uint8_t *data, uint16_t length,
                                    void *userdata)
{
    if (length < sizeof(uint16_t)) {
        return -2;
    }

    uint16_t num_sanctions;
    net_unpack_u16(data, &num_sanctions);

    if (num_sanctions > MOD_MAX_NUM_SANCTIONS) {
        LOGGER_DEBUG(chat->log, "num_sanctions: %u exceeds maximum", num_sanctions);
        return handle_gc_sanctions_list_error(chat);
    }

    Mod_Sanction_Creds creds;

    Mod_Sanction *sanctions = (Mod_Sanction *)calloc(num_sanctions, sizeof(Mod_Sanction));

    if (sanctions == nullptr) {
        return -1;
    }

    const int unpacked_num = sanctions_list_unpack(sanctions, &creds, num_sanctions, data + sizeof(uint16_t),
                             length - sizeof(uint16_t), nullptr);

    if (unpacked_num != num_sanctions) {
        LOGGER_WARNING(chat->log, "Failed to unpack sanctions list: %d", unpacked_num);
        free(sanctions);
        return handle_gc_sanctions_list_error(chat);
    }

    if (!sanctions_list_check_integrity(&chat->moderation, &creds, sanctions, num_sanctions)) {
        LOGGER_WARNING(chat->log, "Sanctions list failed integrity check");
        free(sanctions);
        return handle_gc_sanctions_list_error(chat);
    }

    if (creds.version < chat->moderation.sanctions_creds.version) {
        free(sanctions);
        return 0;
    }

    // this may occur if two mods change the sanctions list at the exact same time
    if (creds.version == chat->moderation.sanctions_creds.version
            && creds.checksum <= chat->moderation.sanctions_creds.checksum) {
        free(sanctions);
        return 0;
    }

    sanctions_list_cleanup(&chat->moderation);

    chat->moderation.sanctions_creds = creds;
    chat->moderation.sanctions = sanctions;
    chat->moderation.num_sanctions = num_sanctions;

    update_gc_peer_roles(chat);

    if (chat->connection_state == CS_CONNECTED) {
        if (c->moderation != nullptr) {
            c->moderation(c->messenger, chat->group_number, (uint32_t) -1, (uint32_t) -1, MV_OBSERVER, userdata);
        }
    }

    return 0;
}

/** @brief Makes a mod_list packet.
 *
 * Returns length of packet data on success.
 * Returns -1 on failure.
 */
non_null()
static int make_gc_mod_list_packet(const GC_Chat *chat, uint8_t *data, uint32_t maxlen, uint16_t mod_list_size)
{
    if (maxlen < sizeof(uint16_t) + mod_list_size) {
        return -1;
    }

    net_pack_u16(data, chat->moderation.num_mods);
    const uint16_t length = sizeof(uint16_t) + mod_list_size;

    if (mod_list_size > 0) {
        uint8_t *packed_mod_list = (uint8_t *)malloc(mod_list_size);

        if (packed_mod_list == nullptr) {
            return -1;
        }

        mod_list_pack(&chat->moderation, packed_mod_list);
        memcpy(data + sizeof(uint16_t), packed_mod_list, mod_list_size);

        free(packed_mod_list);
    }

    return length;
}

/** @brief Sends the moderator list to peer.
 *
 * Return true on success.
 */
non_null()
static bool send_peer_mod_list(const GC_Chat *chat, GC_Connection *gconn)
{
    const uint16_t mod_list_size = chat->moderation.num_mods * MOD_LIST_ENTRY_SIZE;
    const uint16_t length = sizeof(uint16_t) + mod_list_size;
    uint8_t *packet = (uint8_t *)malloc(length);

    if (packet == nullptr) {
        return false;
    }

    const int packet_len = make_gc_mod_list_packet(chat, packet, length, mod_list_size);

    if (packet_len != length) {
        free(packet);
        return false;
    }

    const bool ret = send_lossless_group_packet(chat, gconn, packet, length, GP_MOD_LIST);

    free(packet);

    return ret;
}

/** @brief Makes a sanctions list packet.
 *
 * Returns packet length on success.
 * Returns -1 on failure.
 */
non_null()
static int make_gc_sanctions_list_packet(const GC_Chat *chat, uint8_t *data, uint16_t maxlen)
{
    if (maxlen < sizeof(uint16_t)) {
        return -1;
    }

    net_pack_u16(data, chat->moderation.num_sanctions);
    const uint16_t length = sizeof(uint16_t);

    const int packed_len = sanctions_list_pack(data + length, maxlen - length, chat->moderation.sanctions,
                           chat->moderation.num_sanctions, &chat->moderation.sanctions_creds);

    if (packed_len < 0) {
        return -1;
    }

    return (int)(length + packed_len);
}

/** @brief Sends the sanctions list to peer.
 *
 * Returns true on success.
 */
non_null()
static bool send_peer_sanctions_list(const GC_Chat *chat, GC_Connection *gconn)
{
    if (chat->moderation.sanctions_creds.version == 0) {
        return true;
    }

    const uint16_t packet_size = MOD_SANCTION_PACKED_SIZE * chat->moderation.num_sanctions +
                                 sizeof(uint16_t) + MOD_SANCTIONS_CREDS_SIZE;

    uint8_t *packet = (uint8_t *)malloc(packet_size);

    if (packet == nullptr) {
        return false;
    }

    const int packet_len = make_gc_sanctions_list_packet(chat, packet, packet_size);

    if (packet_len == -1) {
        free(packet);
        return false;
    }

    const bool ret = send_lossless_group_packet(chat, gconn, packet, (uint16_t)packet_len, GP_SANCTIONS_LIST);

    free(packet);

    return ret;
}

/** @brief Sends the sanctions list to all peers in group.
 *
 * Returns true on success.
 */
non_null()
static bool broadcast_gc_sanctions_list(const GC_Chat *chat)
{
    const uint16_t packet_size = MOD_SANCTION_PACKED_SIZE * chat->moderation.num_sanctions +
                                 sizeof(uint16_t) + MOD_SANCTIONS_CREDS_SIZE;

    uint8_t *packet = (uint8_t *)malloc(packet_size);

    if (packet == nullptr) {
        return false;
    }

    const int packet_len = make_gc_sanctions_list_packet(chat, packet, packet_size);

    if (packet_len == -1) {
        free(packet);
        return false;
    }

    send_gc_lossless_packet_all_peers(chat, packet, (uint16_t)packet_len, GP_SANCTIONS_LIST);

    free(packet);

    return true;
}

/** @brief Re-signs all sanctions list entries signed by public_sig_key and broadcasts
 * the updated sanctions list to all group peers.
 *
 * Returns true on success.
 */
non_null()
static bool update_gc_sanctions_list(GC_Chat *chat, const uint8_t *public_sig_key)
{
    const uint16_t num_replaced = sanctions_list_replace_sig(&chat->moderation, public_sig_key);

    if (num_replaced == 0) {
        return true;
    }

    return broadcast_gc_sanctions_list(chat);
}

/** @brief Sends mod_list to all peers in group.
 *
 * Returns true on success.
 */
non_null()
static bool broadcast_gc_mod_list(const GC_Chat *chat)
{
    const uint16_t mod_list_size = chat->moderation.num_mods * MOD_LIST_ENTRY_SIZE;
    const uint16_t length = sizeof(uint16_t) + mod_list_size;
    uint8_t *packet = (uint8_t *)malloc(length);

    if (packet == nullptr) {
        return false;
    }

    const int packet_len = make_gc_mod_list_packet(chat, packet, length, mod_list_size);

    if (packet_len != length) {
        free(packet);
        return false;
    }

    send_gc_lossless_packet_all_peers(chat, packet, length, GP_MOD_LIST);

    free(packet);

    return true;
}

/** @brief Sends a parting signal to the group.
 *
 * Returns 0 on success.
 * Returns -1 if the message is too long.
 * Returns -2 if the packet failed to send.
 */
non_null(1) nullable(2)
static int send_gc_self_exit(const GC_Chat *chat, const uint8_t *partmessage, uint16_t length)
{
    if (length > MAX_GC_PART_MESSAGE_SIZE) {
        return -1;
    }

    if (!send_gc_broadcast_message(chat, partmessage, length, GM_PEER_EXIT)) {
        return -2;
    }

    return 0;
}

/** @brief Handles a peer exit broadcast. */
non_null(1, 2) nullable(3)
static void handle_gc_peer_exit(const GC_Chat *chat, GC_Connection *gconn, const uint8_t *data, uint16_t length)
{
    if (length > MAX_GC_PART_MESSAGE_SIZE) {
        length = MAX_GC_PART_MESSAGE_SIZE;
    }

    gcc_mark_for_deletion(gconn, chat->tcp_conn, GC_EXIT_TYPE_QUIT, data, length);
}

void gc_get_group_peer_connection_ip(const Messenger *m, int group_number, uint32_t peer_id, uint8_t *ip_str)
{
    if (ip_str == nullptr) {
        return;
    }
    char *p = (char *)ip_str;

    const GC_Session *c = m->group_handler;
    const GC_Chat *chat = gc_get_group(c, group_number);
    if (chat == nullptr) {
        return;
    }
    if (chat->connection_state != CS_CONNECTED) {
        return;
    }

    const int peer_number = get_peer_number_of_peer_id(chat, peer_id);
    const GC_Connection *gconn = get_gc_connection(chat, peer_number);
    if (gconn == nullptr) {
        return;
    }

    if (gcc_direct_conn_is_possible(chat, gconn)) {
        if (gcc_conn_is_direct(chat->mono_time, gconn)) {
            if (!net_family_is_unspec(gconn->addr.ip_port.ip.family)) {
                if (net_family_is_ipv4(gconn->addr.ip_port.ip.family)) {
                    char ipv4[20];
                    memset(ipv4, 0, 20);
                    snprintf(ipv4, 16, "%d.%d.%d.%d",
                        gconn->addr.ip_port.ip.ip.v4.uint8[0],
                        gconn->addr.ip_port.ip.ip.v4.uint8[1],
                        gconn->addr.ip_port.ip.ip.v4.uint8[2],
                        gconn->addr.ip_port.ip.ip.v4.uint8[3]
                    );
                    p += snprintf(p, 60, "%s %5d\n", ipv4, net_ntohs(gconn->addr.ip_port.port));
                } else if (net_family_is_ipv6(gconn->addr.ip_port.ip.family)) {
                    char ipv6[401];
                    memset(ipv6, 0, 401);
                    bool res = ip_parse_addr(&gconn->addr.ip_port.ip, ipv6, 400);
                    if (!res) {
                        snprintf(ipv6, 16, "<error in ipv6>");
                    }
                    p += snprintf(p, 60, "%s %5d\n", ipv6, net_ntohs(gconn->addr.ip_port.port));
                }
            }
            return;
        }
    }

    if (gconn->tcp_relays_count > 0) {
        // get tcp connections
        const TCP_Connection_to *con_to = get_connection(chat->tcp_conn, gconn->tcp_connection_num);

        if (con_to == nullptr) {
            return;
        }
        for (uint32_t i = 0; i < MAX_FRIEND_TCP_CONNECTIONS; ++i) {
            uint32_t tcp_con_num = con_to->connections[i].tcp_connection;
            const uint8_t status = con_to->connections[i].status;

            if (tcp_con_num > 0 && status == TCP_CONNECTIONS_STATUS_ONLINE) {
                tcp_con_num -= 1;
                TCP_con *tcp_con = get_tcp_connection(chat->tcp_conn, tcp_con_num);

                if (tcp_con == nullptr) {
                    continue;
                }

                if (tcp_con->connection == nullptr) {
                    continue;
                }

                const IP_Port conn_ip_port = tcp_con_ip_port(tcp_con->connection);

                if (!net_family_is_unspec(conn_ip_port.ip.family)) {
                    if (net_family_is_ipv4(conn_ip_port.ip.family)) {
                        char ipv4[20];
                        memset(ipv4, 0, 20);
                        snprintf(ipv4, 16, "%d.%d.%d.%d",
                            conn_ip_port.ip.ip.v4.uint8[0],
                            conn_ip_port.ip.ip.v4.uint8[1],
                            conn_ip_port.ip.ip.v4.uint8[2],
                            conn_ip_port.ip.ip.v4.uint8[3]
                        );
                        p += snprintf(p, 60, "%s %5d\n", ipv4, net_ntohs(conn_ip_port.port));
                    } else if (net_family_is_ipv6(conn_ip_port.ip.family)) {
                        char ipv6[401];
                        memset(ipv6, 0, 401);
                        bool res = ip_parse_addr(&conn_ip_port.ip, ipv6, 400);
                        if (!res) {
                            snprintf(ipv6, 16, "<error in ipv6>");
                        }
                        p += snprintf(p, 60, "%s %5d\n", ipv6, net_ntohs(conn_ip_port.port));
                    }
                }
            }
        }
    }
}

int gc_set_self_nick(const Messenger *m, int group_number, const uint8_t *nick, uint16_t length)
{
    const GC_Session *c = m->group_handler;
    const GC_Chat *chat = gc_get_group(c, group_number);

    if (chat == nullptr) {
        return -1;
    }

    if (length > MAX_GC_NICK_SIZE) {
        return -2;
    }

    if (length == 0 || nick == nullptr) {
        return -3;
    }

    if (!self_gc_set_nick(chat, nick, length)) {
        return -2;
    }

    if (!send_gc_broadcast_message(chat, nick, length, GM_NICK)) {
        return -4;
    }

    return 0;
}

bool gc_get_peer_nick(const GC_Chat *chat, uint32_t peer_id, uint8_t *name)
{
    const int peer_number = get_peer_number_of_peer_id(chat, peer_id);

    const GC_Peer *peer = get_gc_peer(chat, peer_number);

    if (peer == nullptr) {
        return false;
    }

    if (name != nullptr) {
        memcpy(name, peer->nick, peer->nick_length);
    }

    return true;
}

int gc_get_peer_nick_size(const GC_Chat *chat, uint32_t peer_id)
{
    const int peer_number = get_peer_number_of_peer_id(chat, peer_id);

    const GC_Peer *peer = get_gc_peer(chat, peer_number);

    if (peer == nullptr) {
        return -1;
    }

    return peer->nick_length;
}

/** @brief Handles a nick change broadcast.
 *
 * Return 0 if packet is handled correctly.
 * Return -1 on failure.
 */
non_null(1, 2, 3, 4) nullable(6)
static int handle_gc_nick(const GC_Session *c, GC_Chat *chat, GC_Peer *peer, const uint8_t *nick,
                          uint16_t length,  void *userdata)
{
    /* If this happens malicious behaviour is highly suspect */
    if (length == 0 || length > MAX_GC_NICK_SIZE) {
        GC_Connection *gconn = &peer->gconn;
        gcc_mark_for_deletion(gconn, chat->tcp_conn, GC_EXIT_TYPE_SYNC_ERR, nullptr, 0);
        LOGGER_WARNING(chat->log, "Invalid nick length for nick: %s (%u)", nick, length);
        return -1;
    }

    memcpy(peer->nick, nick, length);
    peer->nick_length = length;

    if (c->nick_change != nullptr) {
        c->nick_change(c->messenger, chat->group_number, peer->peer_id, nick, length, userdata);
    }

    return 0;
}

/** @brief Copies peer_number's public key to `public_key`.
 *
 * Returns 0 on success.
 * Returns -1 if peer_number is invalid.
 * Returns -2 if `public_key` is null.
 */
non_null()
static int get_gc_peer_public_key(const GC_Chat *chat, uint32_t peer_number, uint8_t *public_key)
{
    const GC_Connection *gconn = get_gc_connection(chat, peer_number);

    if (gconn == nullptr) {
        return -1;
    }

    if (public_key == nullptr) {
        return -2;
    }

    memcpy(public_key, gconn->addr.public_key, ENC_PUBLIC_KEY_SIZE);

    return 0;
}

non_null()
int64_t get_gc_peer_id_by_public_key(const GC_Chat *chat, const uint8_t *public_key)
{
    if (chat == nullptr) {
        return -1;
    }

    if (public_key == nullptr) {
        return -1;
    }

    if (chat->numpeers == 0) {
        return -1;
    }

    const int target_peer_number = get_peer_number_of_enc_pk(chat, public_key, false);

    if (target_peer_number == -1)
    {
        return -1;
    }

    return (chat->group[target_peer_number].peer_id);
}

int gc_get_savedpeer_public_key_by_slot_number(const GC_Chat *chat, uint32_t slot_number, uint8_t *public_key)
{
    if (((int)slot_number < 0) || (slot_number > GC_MAX_SAVED_PEERS))
    {
        return -1;
    }

    if (public_key == nullptr) {
        return -1;
    }

    const GC_SavedPeerInfo *saved_peer = &chat->saved_peers[slot_number];
    if (saved_peer_is_valid(saved_peer)) {
        const int peernumber = get_peer_number_of_enc_pk(chat, saved_peer->public_key, true);
        if (peernumber < 0) {
            memcpy(public_key, saved_peer->public_key, ENC_PUBLIC_KEY_SIZE);
            return 0;
        }
    }
    return -1;
}

int gc_get_peer_public_key_by_peer_id(const GC_Chat *chat, uint32_t peer_id, uint8_t *public_key)
{
    const int peer_number = get_peer_number_of_peer_id(chat, peer_id);

    const GC_Connection *gconn = get_gc_connection(chat, peer_number);

    if (gconn == nullptr) {
        return -1;
    }

    if (public_key == nullptr) {
        return -2;
    }

    memcpy(public_key, gconn->addr.public_key, ENC_PUBLIC_KEY_SIZE);

    return 0;
}

unsigned int gc_get_peer_connection_status(const GC_Chat *chat, uint32_t peer_id)
{
    const int peer_number = get_peer_number_of_peer_id(chat, peer_id);

    if (peer_number_is_self(peer_number)) {
        return chat->self_udp_status ==  SELF_UDP_STATUS_NONE ? 1 : 2;
    }

    const GC_Connection *gconn = get_gc_connection(chat, peer_number);

    if (gconn == nullptr) {
        return 0;
    }

    if (gcc_conn_is_direct(chat->mono_time, gconn)) {
        return 2;
    }

    return 1;
}

/** @brief Creates a topic packet and puts it in data.
 *
 * Packet includes the topic, topic length, public signature key of the
 * setter, topic version, and the signature.
 *
 * Returns packet length on success.
 * Returns -1 on failure.
 */
non_null()
static int make_gc_topic_packet(const GC_Chat *chat, uint8_t *data, uint16_t length)
{
    if (length < SIGNATURE_SIZE + chat->topic_info.length + GC_MIN_PACKED_TOPIC_INFO_SIZE) {
        return -1;
    }

    memcpy(data, chat->topic_sig, SIGNATURE_SIZE);
    uint16_t data_length = SIGNATURE_SIZE;

    const uint16_t packed_len = pack_gc_topic_info(data + data_length, length - data_length, &chat->topic_info);
    data_length += packed_len;

    if (packed_len != chat->topic_info.length + GC_MIN_PACKED_TOPIC_INFO_SIZE) {
        return -1;
    }

    return data_length;
}

/** @brief Sends the group topic to peer.
 *
 * Returns true on success.
 */
non_null()
static bool send_peer_topic(const GC_Chat *chat, GC_Connection *gconn)
{
    const uint16_t packet_buf_size = SIGNATURE_SIZE + chat->topic_info.length + GC_MIN_PACKED_TOPIC_INFO_SIZE;
    uint8_t *packet = (uint8_t *)malloc(packet_buf_size);

    if (packet == nullptr) {
        return false;
    }

    const int packet_len = make_gc_topic_packet(chat, packet, packet_buf_size);

    if (packet_len != packet_buf_size) {
        free(packet);
        return false;
    }

    if (!send_lossless_group_packet(chat, gconn, packet, packet_buf_size, GP_TOPIC)) {
        free(packet);
        return false;
    }

    free(packet);

    return true;
}

/**
 * @brief Initiates a session key rotation with peer designated by `gconn`.
 *
 * Return true on success.
 */
non_null()
static bool send_peer_key_rotation_request(const GC_Chat *chat, GC_Connection *gconn)
{
    // Only the peer closest to the chat_id sends requests. This is to prevent both peers from sending
    // requests at the same time and ending up with a different resulting shared key
    if (!gconn->self_is_closer) {
        // if this peer hasn't sent us a rotation request in a reasonable timeframe we drop their connection
        if (mono_time_is_timeout(chat->mono_time, gconn->last_key_rotation, GC_KEY_ROTATION_TIMEOUT + GC_PING_TIMEOUT)) {
            gcc_mark_for_deletion(gconn, chat->tcp_conn, GC_EXIT_TYPE_TIMEOUT, nullptr, 0);
        }

        return true;
    }

    uint8_t packet[1 + ENC_PUBLIC_KEY_SIZE];

    net_pack_bool(&packet[0], false); // request type

    create_gc_session_keypair(chat->log, chat->rng, gconn->session_public_key, gconn->session_secret_key);

    // copy new session public key to packet
    memcpy(packet + 1, gconn->session_public_key, ENC_PUBLIC_KEY_SIZE);

    if (!send_lossless_group_packet(chat, gconn, packet, sizeof(packet), GP_KEY_ROTATION)) {
        return false;
    }

    gconn->pending_key_rotation_request = true;

    return true;
}

/** @brief Sends the group topic to all group members.
 *
 * Returns true on success.
 */
non_null()
static bool broadcast_gc_topic(const GC_Chat *chat)
{
    const uint16_t packet_buf_size = SIGNATURE_SIZE + chat->topic_info.length + GC_MIN_PACKED_TOPIC_INFO_SIZE;
    uint8_t *packet = (uint8_t *)malloc(packet_buf_size);

    if (packet == nullptr) {
        return false;
    }

    const int packet_len = make_gc_topic_packet(chat, packet, packet_buf_size);

    if (packet_len != packet_buf_size) {
        free(packet);
        return false;
    }

    send_gc_lossless_packet_all_peers(chat, packet, packet_buf_size, GP_TOPIC);

    free(packet);

    return true;
}

int gc_set_topic(GC_Chat *chat, const uint8_t *topic, uint16_t length)
{
    if (length > MAX_GC_TOPIC_SIZE) {
        return -1;
    }

    const bool topic_lock_enabled = group_topic_lock_enabled(chat);

    if (topic_lock_enabled && gc_get_self_role(chat) > GR_MODERATOR) {
        return -2;
    }

    if (gc_get_self_role(chat) > GR_USER) {
        return -2;
    }

    const GC_TopicInfo old_topic_info = chat->topic_info;

    uint8_t old_topic_sig[SIGNATURE_SIZE];
    memcpy(old_topic_sig, chat->topic_sig, SIGNATURE_SIZE);

    // TODO(jfreegman): improbable, but an overflow would break topic setting
    if (chat->topic_info.version == UINT32_MAX) {
        return -3;
    }

    // only increment topic version when lock is enabled
    if (topic_lock_enabled) {
        ++chat->topic_info.version;
    }

    chat->topic_info.length = length;

    if (length > 0) {
        assert(topic != nullptr);
        memcpy(chat->topic_info.topic, topic, length);
    } else {
        memset(chat->topic_info.topic, 0, sizeof(chat->topic_info.topic));
    }

    memcpy(chat->topic_info.public_sig_key, get_sig_pk(chat->self_public_key), SIG_PUBLIC_KEY_SIZE);

    chat->topic_info.checksum = get_gc_topic_checksum(&chat->topic_info);

    const uint16_t packet_buf_size = length + GC_MIN_PACKED_TOPIC_INFO_SIZE;
    uint8_t *packed_topic = (uint8_t *)malloc(packet_buf_size);

    if (packed_topic == nullptr) {
        return -3;
    }

    int err = -3;

    const uint16_t packed_len = pack_gc_topic_info(packed_topic, packet_buf_size, &chat->topic_info);

    if (packed_len != packet_buf_size) {
        goto ON_ERROR;
    }

    if (crypto_sign_detached(chat->topic_sig, nullptr, packed_topic, packet_buf_size,
                             get_sig_sk(chat->self_secret_key)) == -1) {
        goto ON_ERROR;
    }

    if (!broadcast_gc_topic(chat)) {
        err = -4;
        goto ON_ERROR;
    }

    chat->topic_prev_checksum = old_topic_info.checksum;
    chat->topic_time_set = mono_time_get(chat->mono_time);

    free(packed_topic);
    return 0;

ON_ERROR:
    chat->topic_info = old_topic_info;
    memcpy(chat->topic_sig, old_topic_sig, SIGNATURE_SIZE);
    free(packed_topic);
    return err;
}

void gc_get_topic(const GC_Chat *chat, uint8_t *topic)
{
    if (topic != nullptr) {
        memcpy(topic, chat->topic_info.topic, chat->topic_info.length);
    }
}

uint16_t gc_get_topic_size(const GC_Chat *chat)
{
    return chat->topic_info.length;
}

/**
 * If public_sig_key is equal to the key of the topic setter, replaces topic credentials
 * and re-broadcasts the updated topic info to the group.
 *
 * Returns true on success
 */
non_null()
static bool update_gc_topic(GC_Chat *chat, const uint8_t *public_sig_key)
{
    if (memcmp(public_sig_key, chat->topic_info.public_sig_key, SIG_PUBLIC_KEY_SIZE) != 0) {
        return true;
    }

    return gc_set_topic(chat, chat->topic_info.topic, chat->topic_info.length) == 0;
}

/** @brief Validates `topic_info`.
 *
 * Return true if topic info is valid.
 */
non_null()
static bool handle_gc_topic_validate(const GC_Chat *chat, const GC_Peer *peer, const GC_TopicInfo *topic_info,
                                     bool topic_lock_enabled)
{
    if (topic_info->checksum != get_gc_topic_checksum(topic_info)) {
        LOGGER_WARNING(chat->log, "received invalid topic checksum");
        return false;
    }

    if (topic_lock_enabled) {
        if (!mod_list_verify_sig_pk(&chat->moderation, topic_info->public_sig_key)) {
            LOGGER_DEBUG(chat->log, "Invalid topic signature (bad credentials)");
            return false;
        }

        if (topic_info->version < chat->topic_info.version) {
            return false;
        }
    } else {
        uint8_t public_enc_key[ENC_PUBLIC_KEY_SIZE];

        if (gc_get_enc_pk_from_sig_pk(chat, public_enc_key, topic_info->public_sig_key)) {
            if (sanctions_list_is_observer(&chat->moderation, public_enc_key)) {
                LOGGER_DEBUG(chat->log, "Invalid topic signature (sanctioned peer attempted to change topic)");
                return false;
            }
        }

        if (topic_info->version == chat->shared_state.topic_lock) {
            // always accept topic on initial connection
            if (!mono_time_is_timeout(chat->mono_time, chat->time_connected, GC_PING_TIMEOUT)) {
                return true;
            }

            if (chat->topic_prev_checksum == topic_info->checksum &&
                    !mono_time_is_timeout(chat->mono_time, chat->topic_time_set, GC_CONFIRMED_PEER_TIMEOUT)) {
                LOGGER_DEBUG(chat->log, "Topic reversion (probable sync error)");
                return false;
            }

            return true;
        }

        // the topic version should never change when the topic lock is disabled except when
        // the founder changes the topic prior to enabling the lock
        if (!(peer->role == GR_FOUNDER && topic_info->version == chat->shared_state.topic_lock + 1)) {
            LOGGER_ERROR(chat->log, "topic version %u differs from topic lock %u", topic_info->version,
                         chat->shared_state.topic_lock);
            return false;
        }
    }

    return true;
}

/** @brief Handles a topic packet.
 *
 * Return 0 if packet is correctly handled.
 * Return -1 if packet has invalid size.
 */
non_null(1, 2, 3, 4) nullable(6)
static int handle_gc_topic(const GC_Session *c, GC_Chat *chat, const GC_Peer *peer, const uint8_t *data,
                           uint16_t length, void *userdata)
{
    if (length < SIGNATURE_SIZE + GC_MIN_PACKED_TOPIC_INFO_SIZE) {
        return -1;
    }

    const uint16_t old_checksum = chat->topic_info.checksum;

    GC_TopicInfo topic_info;

    if (unpack_gc_topic_info(&topic_info, data + SIGNATURE_SIZE, length - SIGNATURE_SIZE) == -1) {
        LOGGER_WARNING(chat->log, "failed to unpack topic");
        return 0;
    }

    const uint8_t *signature = data;

    if (crypto_sign_verify_detached(signature, data + SIGNATURE_SIZE, length - SIGNATURE_SIZE,
                                    topic_info.public_sig_key) == -1) {
        LOGGER_WARNING(chat->log, "failed to verify topic signature");
        return 0;
    }

    const bool topic_lock_enabled = group_topic_lock_enabled(chat);

    if (!handle_gc_topic_validate(chat, peer, &topic_info, topic_lock_enabled)) {
        return 0;
    }

    // prevents sync issues from triggering the callback needlessly
    const bool skip_callback = chat->topic_info.length == topic_info.length
                               && memcmp(chat->topic_info.topic, topic_info.topic, topic_info.length) == 0;

    chat->topic_prev_checksum = old_checksum;
    chat->topic_time_set = mono_time_get(chat->mono_time);
    chat->topic_info = topic_info;
    memcpy(chat->topic_sig, signature, SIGNATURE_SIZE);

    if (!skip_callback && chat->connection_state == CS_CONNECTED && c->topic_change != nullptr) {
        const int setter_peer_number = get_peer_number_of_sig_pk(chat, topic_info.public_sig_key);
        const uint32_t peer_id = setter_peer_number >= 0 ? chat->group[setter_peer_number].peer_id : 0;

        c->topic_change(c->messenger, chat->group_number, peer_id, topic_info.topic, topic_info.length, userdata);
    }

    return 0;
}

/** @brief Handles a key exchange packet.
 *
 * Return 0 if packet is handled correctly.
 * Return -1 if length is invalid.
 * Return -2 if we fail to create a new session keypair.
 * Return -3 if response packet fails to send.
 */
non_null()
static int handle_gc_key_exchange(const GC_Chat *chat, GC_Connection *gconn, const uint8_t *data, uint16_t length)
{
    if (length < 1 + ENC_PUBLIC_KEY_SIZE) {
        return -1;
    }

    bool is_response;
    net_unpack_bool(&data[0], &is_response);

    const uint8_t *sender_public_session_key = data + 1;

    if (is_response) {
        if (!gconn->pending_key_rotation_request) {
            LOGGER_WARNING(chat->log, "got unsolicited key rotation response from peer %u", gconn->public_key_hash);
            return 0;
        }

        // now that we have response we can compute our new shared key and begin using it
        gcc_make_session_shared_key(gconn, sender_public_session_key);

        gconn->pending_key_rotation_request = false;

        return 0;
    }

    // key generation is pretty cpu intensive so we make sure a peer can't DOS us by spamming requests
    if (!mono_time_is_timeout(chat->mono_time, gconn->last_key_rotation, GC_KEY_ROTATION_TIMEOUT / 2)) {
        return 0;
    }

    uint8_t response[1 + ENC_PUBLIC_KEY_SIZE];
    uint8_t new_session_pk[ENC_PUBLIC_KEY_SIZE];
    uint8_t new_session_sk[ENC_SECRET_KEY_SIZE];

    net_pack_bool(&response[0], true);

    crypto_memlock(new_session_sk, sizeof(new_session_sk));

    create_gc_session_keypair(chat->log, chat->rng, new_session_pk, new_session_sk);

    memcpy(response + 1, new_session_pk, ENC_PUBLIC_KEY_SIZE);

    if (!send_lossless_group_packet(chat, gconn, response, sizeof(response), GP_KEY_ROTATION)) {
        // Don't really care about zeroing the secret key here, because we failed, but
        // we're doing it anyway for symmetry with the memzero+munlock below, where we
        // really do care about it.
        crypto_memzero(new_session_sk, sizeof(new_session_sk));
        crypto_memunlock(new_session_sk, sizeof(new_session_sk));
        return -3;
    }

    // save new keys and compute new shared key AFTER sending response packet with old key
    memcpy(gconn->session_public_key, new_session_pk, sizeof(gconn->session_public_key));
    memcpy(gconn->session_secret_key, new_session_sk, sizeof(gconn->session_secret_key));

    gcc_make_session_shared_key(gconn, sender_public_session_key);

    crypto_memzero(new_session_sk, sizeof(new_session_sk));
    crypto_memunlock(new_session_sk, sizeof(new_session_sk));

    gconn->last_key_rotation = mono_time_get(chat->mono_time);

    return 0;
}

void gc_get_group_name(const GC_Chat *chat, uint8_t *group_name)
{
    if (group_name != nullptr) {
        memcpy(group_name, chat->shared_state.group_name, chat->shared_state.group_name_len);
    }
}

uint16_t gc_get_group_name_size(const GC_Chat *chat)
{
    return chat->shared_state.group_name_len;
}

void gc_get_password(const GC_Chat *chat, uint8_t *password)
{
    if (password != nullptr) {
        memcpy(password, chat->shared_state.password, chat->shared_state.password_length);
    }
}

uint16_t gc_get_password_size(const GC_Chat *chat)
{
    return chat->shared_state.password_length;
}

int gc_founder_set_password(GC_Chat *chat, const uint8_t *password, uint16_t password_length)
{
    if (!self_gc_is_founder(chat)) {
        return -1;
    }

    uint8_t *oldpasswd = nullptr;
    const uint16_t oldlen = chat->shared_state.password_length;

    if (oldlen > 0) {
        oldpasswd = (uint8_t *)malloc(oldlen);

        if (oldpasswd == nullptr) {
            return -4;
        }

        memcpy(oldpasswd, chat->shared_state.password, oldlen);
    }

    if (!set_gc_password_local(chat, password, password_length)) {
        free(oldpasswd);
        return -2;
    }

    if (!sign_gc_shared_state(chat)) {
        set_gc_password_local(chat, oldpasswd, oldlen);
        free(oldpasswd);
        return -2;
    }

    free(oldpasswd);

    if (!broadcast_gc_shared_state(chat)) {
        return -3;
    }

    return 0;
}

/** @brief Validates change to moderator list and either adds or removes peer from our moderator list.
 *
 * Return target's peer number on success.
 * Return -1 on packet handle failure.
 * Return -2 if target peer is not online.
 * Return -3 if target peer is not a valid role (probably indicates sync issues).
 * Return -4 on validation failure.
 */
non_null()
static int validate_unpack_gc_set_mod(GC_Chat *chat, uint32_t peer_number, const uint8_t *data, uint16_t length,
                                      bool add_mod)
{
    int target_peer_number;
    uint8_t mod_data[MOD_LIST_ENTRY_SIZE];

    if (add_mod) {
        if (length < 1 + MOD_LIST_ENTRY_SIZE) {
            return -1;
        }

        memcpy(mod_data, data + 1, MOD_MODERATION_HASH_SIZE);
        target_peer_number = get_peer_number_of_sig_pk(chat, mod_data);

        if (!gc_peer_number_is_valid(chat, target_peer_number)) {
            return -2;
        }

        const Group_Role target_role = chat->group[target_peer_number].role;

        if (target_role != GR_USER) {
            return -3;
        }

        if (!mod_list_add_entry(&chat->moderation, mod_data)) {
            return -4;
        }
    } else {
        memcpy(mod_data, data + 1, SIG_PUBLIC_KEY_SIZE);
        target_peer_number = get_peer_number_of_sig_pk(chat, mod_data);

        if (!gc_peer_number_is_valid(chat, target_peer_number)) {
            return -2;
        }

        const Group_Role target_role = chat->group[target_peer_number].role;

        if (target_role != GR_MODERATOR) {
            return -3;
        }

        if (!mod_list_remove_entry(&chat->moderation, mod_data)) {
            return -4;
        }
    }

    update_gc_peer_roles(chat);

    return target_peer_number;
}

/** @brief Handles a moderator set broadcast.
 *
 * Return 0 if packet is handled correctly.
 * Return -1 if packet has invalid size.
 * Return -2 if the packet contains invalid data.
 * Return -3 if `peer_number` does not designate a valid peer.
 */
non_null(1, 2, 4) nullable(6)
static int handle_gc_set_mod(const GC_Session *c, GC_Chat *chat, uint32_t peer_number, const uint8_t *data,
                             uint16_t length, void *userdata)
{
    if (length < 1 + SIG_PUBLIC_KEY_SIZE) {
        return -1;
    }

    const GC_Peer *setter_peer = get_gc_peer(chat, peer_number);

    if (setter_peer == nullptr) {
        return -3;
    }

    if (setter_peer->role != GR_FOUNDER) {
        return 0;
    }

    bool add_mod;
    net_unpack_bool(&data[0], &add_mod);

    const int target_peer_number = validate_unpack_gc_set_mod(chat, peer_number, data, length, add_mod);

    if (target_peer_number == -1) {
        return -2;
    }

    const GC_Peer *target_peer = get_gc_peer(chat, target_peer_number);

    if (target_peer == nullptr) {
        return 0;
    }

    if (c->moderation != nullptr) {
        c->moderation(c->messenger, chat->group_number, setter_peer->peer_id, target_peer->peer_id,
                      add_mod ? MV_MOD : MV_USER, userdata);
    }

    return 0;
}

/** @brief Sends a set mod broadcast to the group.
 *
 * Return true on success.
 */
non_null()
static bool send_gc_set_mod(const GC_Chat *chat, const GC_Connection *gconn, bool add_mod)
{
    const uint16_t length = 1 + SIG_PUBLIC_KEY_SIZE;
    uint8_t *data = (uint8_t *)malloc(length);

    if (data == nullptr) {
        return false;
    }

    net_pack_bool(&data[0], add_mod);

    memcpy(data + 1, get_sig_pk(gconn->addr.public_key), SIG_PUBLIC_KEY_SIZE);

    if (!send_gc_broadcast_message(chat, data, length, GM_SET_MOD)) {
        free(data);
        return false;
    }

    free(data);

    return true;
}

/**
 * Adds or removes the peer designated by gconn from moderator list if `add_mod` is true or false respectively.
 * Re-signs and re-distributes an updated mod_list hash.
 *
 * Returns true on success.
 */
non_null()
static bool founder_gc_set_moderator(GC_Chat *chat, const GC_Connection *gconn, bool add_mod)
{
    if (!self_gc_is_founder(chat)) {
        return false;
    }

    if (add_mod) {
        if (chat->moderation.num_mods >= MOD_MAX_NUM_MODERATORS) {
            if (!prune_gc_mod_list(chat)) {
                return false;
            }
        }

        if (!mod_list_add_entry(&chat->moderation, get_sig_pk(gconn->addr.public_key))) {
            return false;
        }
    } else {
        if (!mod_list_remove_entry(&chat->moderation, get_sig_pk(gconn->addr.public_key))) {
            return false;
        }

        if (!update_gc_sanctions_list(chat,  get_sig_pk(gconn->addr.public_key))
                || !update_gc_topic(chat, get_sig_pk(gconn->addr.public_key))) {
            return false;
        }
    }

    uint8_t old_hash[MOD_MODERATION_HASH_SIZE];
    memcpy(old_hash, chat->shared_state.mod_list_hash, MOD_MODERATION_HASH_SIZE);

    if (!mod_list_make_hash(&chat->moderation, chat->shared_state.mod_list_hash)) {
        return false;
    }

    if (!sign_gc_shared_state(chat) || !broadcast_gc_shared_state(chat)) {
        memcpy(chat->shared_state.mod_list_hash, old_hash, MOD_MODERATION_HASH_SIZE);
        return false;
    }

    return send_gc_set_mod(chat, gconn, add_mod);
}

/** @brief Validates `data` containing a change for the sanction list and unpacks it
 * into the sanctions list for `chat`.
 *
 * if `add_obs` is true we're adding an observer to the list.
 *
 * Return 1 if sanctions list is not modified.
 * Return 0 if data is valid and sanctions list is successfully modified.
 * Return -1 if data is invalid format.
 */
non_null()
static int validate_unpack_observer_entry(GC_Chat *chat, const uint8_t *data, uint16_t length,
        const uint8_t *public_key, bool add_obs)
{
    Mod_Sanction_Creds creds;

    if (add_obs) {
        Mod_Sanction sanction;

        if (sanctions_list_unpack(&sanction, &creds, 1, data, length, nullptr) != 1) {
            return -1;
        }

        // this may occur if two mods change the sanctions list at the exact same time
        if (creds.version == chat->moderation.sanctions_creds.version
                && creds.checksum <= chat->moderation.sanctions_creds.checksum) {
            return 1;
        }

        if (sanctions_list_entry_exists(&chat->moderation, &sanction)
                || !sanctions_list_add_entry(&chat->moderation, &sanction, &creds)) {
            return -1;
        }
    } else {
        if (length < MOD_SANCTIONS_CREDS_SIZE) {
            return -1;
        }

        if (sanctions_creds_unpack(&creds, data) != MOD_SANCTIONS_CREDS_SIZE) {
            return -1;
        }

        if (creds.version == chat->moderation.sanctions_creds.version
                && creds.checksum <= chat->moderation.sanctions_creds.checksum) {
            return 1;
        }

        if (!sanctions_list_is_observer(&chat->moderation, public_key)
                || !sanctions_list_remove_observer(&chat->moderation, public_key, &creds)) {
            return 1;
        }
    }

    return 0;
}

/** @brief Handles a set observer broadcast.
 *
 * Return 0 if packet is handled correctly.
 * Return -1 if packet has invalid size.
 * Return -2 if the packet contains invalid data.
 * Return -3 if `peer_number` does not designate a valid peer.
 */
non_null(1, 2, 4) nullable(6)
static int handle_gc_set_observer(const GC_Session *c, GC_Chat *chat, uint32_t peer_number, const uint8_t *data,
                                  uint16_t length, void *userdata)
{
    if (length <= 1 + EXT_PUBLIC_KEY_SIZE) {
        return -1;
    }

    const GC_Peer *setter_peer = get_gc_peer(chat, peer_number);

    if (setter_peer == nullptr) {
        return -3;
    }

    if (setter_peer->role > GR_MODERATOR) {
        LOGGER_DEBUG(chat->log, "peer with insufficient permissions tried to modify sanctions list");
        return 0;
    }

    bool add_obs;
    net_unpack_bool(&data[0], &add_obs);

    const uint8_t *public_key = data + 1;

    const int target_peer_number = get_peer_number_of_enc_pk(chat, public_key, false);

    if (target_peer_number >= 0 && (uint32_t)target_peer_number == peer_number) {
        return -2;
    }

    const GC_Peer *target_peer = get_gc_peer(chat, target_peer_number);

    if (target_peer != nullptr) {
        if ((add_obs && target_peer->role != GR_USER) || (!add_obs && target_peer->role != GR_OBSERVER)) {
            return 0;
        }
    }

    const int ret = validate_unpack_observer_entry(chat,
                    data + 1 + EXT_PUBLIC_KEY_SIZE,
                    length - 1 - EXT_PUBLIC_KEY_SIZE,
                    public_key, add_obs);

    if (ret == -1) {
        return -2;
    }


    if (ret == 1) {
        return 0;
    }

    update_gc_peer_roles(chat);

    if (target_peer != nullptr) {
        if (c->moderation != nullptr) {
            c->moderation(c->messenger, chat->group_number, setter_peer->peer_id, target_peer->peer_id,
                          add_obs ? MV_OBSERVER : MV_USER, userdata);
        }
    }

    return 0;
}

/** @brief Broadcasts observer role data to the group.
 *
 * Returns true on success.
 */
non_null()
static bool send_gc_set_observer(const GC_Chat *chat, const uint8_t *target_ext_pk, const uint8_t *sanction_data,
                                 uint16_t length, bool add_obs)
{
    const uint16_t packet_len = 1 + EXT_PUBLIC_KEY_SIZE + length;
    uint8_t *packet = (uint8_t *)malloc(packet_len);

    if (packet == nullptr) {
        return false;
    }

    net_pack_bool(&packet[0], add_obs);

    memcpy(packet + 1, target_ext_pk, EXT_PUBLIC_KEY_SIZE);
    memcpy(packet + 1 + EXT_PUBLIC_KEY_SIZE, sanction_data, length);

    if (!send_gc_broadcast_message(chat, packet, packet_len, GM_SET_OBSERVER)) {
        free(packet);
        return false;
    }

    free(packet);

    return true;
}

/** @brief Adds or removes peer_number from the observer list if add_obs is true or false respectively.
 * Broadcasts this change to the entire group.
 *
 * Returns true on success.
 */
non_null()
static bool mod_gc_set_observer(GC_Chat *chat, uint32_t peer_number, bool add_obs)
{
    const GC_Connection *gconn = get_gc_connection(chat, peer_number);

    if (gconn == nullptr) {
        return false;
    }

    if (gc_get_self_role(chat) >= GR_USER) {
        return false;
    }

    uint8_t sanction_data[MOD_SANCTION_PACKED_SIZE + MOD_SANCTIONS_CREDS_SIZE];
    uint16_t length = 0;

    if (add_obs) {
        if (chat->moderation.num_sanctions >= MOD_MAX_NUM_SANCTIONS) {
            if (!prune_gc_sanctions_list(chat)) {
                return false;
            }
        }

        // if sanctioned peer set the topic we need to overwrite his signature and redistribute
        // topic info
        const int setter_peer_number = get_peer_number_of_sig_pk(chat, chat->topic_info.public_sig_key);

        if (setter_peer_number >= 0 && (uint32_t)setter_peer_number == peer_number) {
            if (gc_set_topic(chat, chat->topic_info.topic, chat->topic_info.length) != 0) {
                return false;
            }
        }

        Mod_Sanction sanction;

        if (!sanctions_list_make_entry(&chat->moderation, gconn->addr.public_key, &sanction, SA_OBSERVER)) {
            LOGGER_WARNING(chat->log, "sanctions_list_make_entry failed in mod_gc_set_observer");
            return false;
        }

        const int packed_len = sanctions_list_pack(sanction_data, sizeof(sanction_data), &sanction, 1,
                               &chat->moderation.sanctions_creds);

        if (packed_len == -1) {
            return false;
        }

        length += packed_len;
    } else {
        if (!sanctions_list_remove_observer(&chat->moderation, gconn->addr.public_key, nullptr)) {
            LOGGER_WARNING(chat->log, "failed to remove sanction");
            return false;
        }

        const uint16_t packed_len = sanctions_creds_pack(&chat->moderation.sanctions_creds, sanction_data);

        if (packed_len != MOD_SANCTIONS_CREDS_SIZE) {
            return false;
        }

        length += packed_len;
    }

    if (length > sizeof(sanction_data)) {
        LOGGER_FATAL(chat->log, "Invalid sanction data length: %u", length);
        return false;
    }

    update_gc_peer_roles(chat);

    return send_gc_set_observer(chat, gconn->addr.public_key, sanction_data, length, add_obs);
}

/** @brief Sets the role of `peer_number` to `new_role`. If necessary this function will first
 * remove the peer's current role before applying the new one.
 *
 * Return true on success.
 */
non_null()
static bool apply_new_gc_role(GC_Chat *chat, uint32_t peer_number, Group_Role current_role, Group_Role new_role)
{
    const GC_Connection *gconn = get_gc_connection(chat, peer_number);

    if (gconn == nullptr) {
        return false;
    }

    switch (current_role) {
        case GR_MODERATOR: {
            if (!founder_gc_set_moderator(chat, gconn, false)) {
                return false;
            }

            update_gc_peer_roles(chat);

            if (new_role == GR_OBSERVER) {
                return mod_gc_set_observer(chat, peer_number, true);
            }

            break;
        }

        case GR_OBSERVER: {
            if (!mod_gc_set_observer(chat, peer_number, false)) {
                return false;
            }

            update_gc_peer_roles(chat);

            if (new_role == GR_MODERATOR) {
                return founder_gc_set_moderator(chat, gconn, true);
            }

            break;
        }

        case GR_USER: {
            if (new_role == GR_MODERATOR) {
                return founder_gc_set_moderator(chat, gconn, true);
            } else if (new_role == GR_OBSERVER) {
                return mod_gc_set_observer(chat, peer_number, true);
            }

            break;
        }

        case GR_FOUNDER:

        // Intentional fallthrough
        default: {
            return false;
        }
    }

    return true;
}

int gc_set_peer_role(const Messenger *m, int group_number, uint32_t peer_id, Group_Role new_role)
{
    const GC_Session *c = m->group_handler;
    GC_Chat *chat = gc_get_group(c, group_number);

    if (chat == nullptr) {
        return -1;
    }

    const int peer_number = get_peer_number_of_peer_id(chat, peer_id);

    const GC_Peer *peer = get_gc_peer(chat, peer_number);

    if (peer == nullptr) {
        return -2;
    }

    const GC_Connection *gconn = &peer->gconn;

    if (!gconn->confirmed) {
        return -2;
    }

    const Group_Role current_role = peer->role;

    if (new_role == GR_FOUNDER || peer->role == new_role) {
        return -4;
    }

    if (peer_number_is_self(peer_number)) {
        return -6;
    }

    if (current_role == GR_FOUNDER || gc_get_self_role(chat) >= GR_USER) {
        return -3;
    }

    // moderators can't demote moderators or promote peers to moderator
    if (!self_gc_is_founder(chat) && (new_role == GR_MODERATOR || current_role == GR_MODERATOR)) {
        return -3;
    }

    if (!apply_new_gc_role(chat, peer_number, current_role, new_role)) {
        return -5;
    }

    update_gc_peer_roles(chat);

    return 0;
}

/** @brief Return true if topic lock is enabled */
non_null()
static bool group_topic_lock_enabled(const GC_Chat *chat)
{
    return chat->shared_state.topic_lock == GC_TOPIC_LOCK_ENABLED;
}

Group_Privacy_State gc_get_privacy_state(const GC_Chat *chat)
{
    return chat->shared_state.privacy_state;
}

Group_Topic_Lock gc_get_topic_lock_state(const GC_Chat *chat)
{
    return group_topic_lock_enabled(chat) ? TL_ENABLED : TL_DISABLED;
}

Group_Voice_State gc_get_voice_state(const GC_Chat *chat)
{
    return chat->shared_state.voice_state;
}

int gc_founder_set_topic_lock(const Messenger *m, int group_number, Group_Topic_Lock new_lock_state)
{
    const GC_Session *c = m->group_handler;
    GC_Chat *chat = gc_get_group(c, group_number);

    if (chat == nullptr) {
        return -1;
    }

    if (new_lock_state > TL_DISABLED) {
        return -2;
    }

    if (!self_gc_is_founder(chat)) {
        return -3;
    }

    if (chat->connection_state <= CS_DISCONNECTED) {
        return -4;
    }

    const Group_Topic_Lock old_lock_state = gc_get_topic_lock_state(chat);

    if (new_lock_state == old_lock_state) {
        return 0;
    }

    const uint32_t old_topic_lock = chat->shared_state.topic_lock;

    // If we're enabling the lock the founder needs to sign the current topic and re-broadcast
    // it with a new version. This needs to happen before we re-broadcast the shared state because
    // if it fails we don't want to enable the topic lock with an invalid topic signature or version.
    if (new_lock_state == TL_ENABLED) {
        chat->shared_state.topic_lock = GC_TOPIC_LOCK_ENABLED;

        if (gc_set_topic(chat, chat->topic_info.topic, chat->topic_info.length) != 0) {
            chat->shared_state.topic_lock = old_topic_lock;
            return -6;
        }
    } else {
        chat->shared_state.topic_lock = chat->topic_info.version;
    }

    if (!sign_gc_shared_state(chat)) {
        chat->shared_state.topic_lock = old_topic_lock;
        return -5;
    }

    if (!broadcast_gc_shared_state(chat)) {
        return -6;
    }

    return 0;
}

int gc_founder_set_voice_state(const Messenger *m, int group_number, Group_Voice_State new_voice_state)
{
    const GC_Session *c = m->group_handler;
    GC_Chat *chat = gc_get_group(c, group_number);

    if (chat == nullptr) {
        return -1;
    }

    if (!self_gc_is_founder(chat)) {
        return -2;
    }

    if (chat->connection_state == CS_DISCONNECTED || chat->connection_state == CS_NONE) {
        return -3;
    }

    const Group_Voice_State old_voice_state = chat->shared_state.voice_state;

    if (new_voice_state == old_voice_state) {
        return 0;
    }

    chat->shared_state.voice_state = new_voice_state;

    if (!sign_gc_shared_state(chat)) {
        chat->shared_state.voice_state = old_voice_state;
        return -4;
    }

    if (!broadcast_gc_shared_state(chat)) {
        return -5;
    }

    return 0;
}

int gc_founder_set_privacy_state(const Messenger *m, int group_number, Group_Privacy_State new_privacy_state)
{
    const GC_Session *c = m->group_handler;
    GC_Chat *chat = gc_get_group(c, group_number);

    if (chat == nullptr) {
        return -1;
    }

    if (!self_gc_is_founder(chat)) {
        return -2;
    }

    if (chat->connection_state == CS_DISCONNECTED || chat->connection_state == CS_NONE) {
        return -3;
    }

    const Group_Privacy_State old_privacy_state = chat->shared_state.privacy_state;

    if (new_privacy_state == old_privacy_state) {
        return 0;
    }

    chat->shared_state.privacy_state = new_privacy_state;

    if (!sign_gc_shared_state(chat)) {
        chat->shared_state.privacy_state = old_privacy_state;
        return -4;
    }

    if (new_privacy_state == GI_PRIVATE) {
        cleanup_gca(c->announces_list, get_chat_id(chat->chat_public_key));
        kill_group_friend_connection(c, chat);
        chat->join_type = HJ_PRIVATE;
    } else {
        if (!m_create_group_connection(c->messenger, chat)) {
            LOGGER_ERROR(chat->log, "Failed to initialize group friend connection");
        } else {
            chat->update_self_announces = true;
            chat->join_type = HJ_PUBLIC;
        }
    }

    if (!broadcast_gc_shared_state(chat)) {
        return -5;
    }

    return 0;
}

uint16_t gc_get_max_peers(const GC_Chat *chat)
{
    return chat->shared_state.maxpeers;
}

int gc_founder_set_max_peers(GC_Chat *chat, uint16_t max_peers)
{
    if (!self_gc_is_founder(chat)) {
        return -1;
    }

    const uint16_t old_maxpeers = chat->shared_state.maxpeers;

    if (max_peers == chat->shared_state.maxpeers) {
        return 0;
    }

    chat->shared_state.maxpeers = max_peers;

    if (!sign_gc_shared_state(chat)) {
        chat->shared_state.maxpeers = old_maxpeers;
        return -2;
    }

    if (!broadcast_gc_shared_state(chat)) {
        return -3;
    }

    return 0;
}

int gc_send_message(const GC_Chat *chat, const uint8_t *message, uint16_t length, uint8_t type, uint32_t *message_id)
{
    if (length > MAX_GC_MESSAGE_SIZE) {
        return -1;
    }

    if (message == nullptr || length == 0) {
        return -2;
    }

    if (type != GC_MESSAGE_TYPE_NORMAL && type != GC_MESSAGE_TYPE_ACTION) {
        return -3;
    }

    const GC_Peer *self = get_gc_peer(chat, 0);
    assert(self != nullptr);

    if (gc_get_self_role(chat) >= GR_OBSERVER || !peer_has_voice(self, chat->shared_state.voice_state)) {
        return -4;
    }

    const uint8_t packet_type = type == GC_MESSAGE_TYPE_NORMAL ? GM_PLAIN_MESSAGE : GM_ACTION_MESSAGE;

    const uint16_t length_raw = length + GC_MESSAGE_PSEUDO_ID_SIZE;
    uint8_t *message_raw = (uint8_t *)malloc(length_raw);

    if (message_raw == nullptr) {
        return -5;
    }

    const uint32_t pseudo_msg_id = random_u32(chat->rng);

    net_pack_u32(message_raw, pseudo_msg_id);
    memcpy(message_raw + GC_MESSAGE_PSEUDO_ID_SIZE, message, length);

    if (!send_gc_broadcast_message(chat, message_raw, length_raw, packet_type)) {
        free(message_raw);
        return -5;
    }

    if (message_id != nullptr) {
        *message_id = pseudo_msg_id;
    }

    free(message_raw);
    return 0;
}

/** @brief Handles a message broadcast.
 *
 * Return 0 if packet is handled correctly.
 * Return -1 if packet has invalid size.
 */
non_null(1, 2, 3, 4) nullable(7)
static int handle_gc_message(const GC_Session *c, const GC_Chat *chat, const GC_Peer *peer, const uint8_t *data,
                             uint16_t length, uint8_t type, void *userdata)
{
    if (data == nullptr || length > MAX_GC_MESSAGE_RAW_SIZE || length <= GC_MESSAGE_PSEUDO_ID_SIZE) {
        return -1;
    }

    if (peer->ignore || peer->role >= GR_OBSERVER || !peer_has_voice(peer, chat->shared_state.voice_state)) {
        return 0;
    }

    if (type != GM_PLAIN_MESSAGE && type != GM_ACTION_MESSAGE) {
        LOGGER_WARNING(chat->log, "received invalid message type: %u", type);
        return 0;
    }

    const uint8_t cb_type = (type == GM_PLAIN_MESSAGE) ? MESSAGE_NORMAL : MESSAGE_ACTION;

    uint32_t pseudo_msg_id;
    net_unpack_u32(data, &pseudo_msg_id);

    if (c->message != nullptr) {
        c->message(c->messenger, chat->group_number, peer->peer_id, cb_type, data + GC_MESSAGE_PSEUDO_ID_SIZE,
                   length - GC_MESSAGE_PSEUDO_ID_SIZE, pseudo_msg_id, userdata);
    }

    return 0;
}

int gc_send_private_message(const GC_Chat *chat, uint32_t peer_id, uint8_t type, const uint8_t *message,
                            uint16_t length)
{
    if (length > MAX_GC_MESSAGE_SIZE) {
        return -1;
    }

    if (message == nullptr || length == 0) {
        return -2;
    }

    const int peer_number = get_peer_number_of_peer_id(chat, peer_id);

    GC_Connection *gconn = get_gc_connection(chat, peer_number);

    if (gconn == nullptr) {
        return -3;
    }

    if (type > MESSAGE_ACTION) {
        return -4;
    }

    if (gc_get_self_role(chat) >= GR_OBSERVER) {
        return -5;
    }

    uint8_t *message_with_type = (uint8_t *)malloc(length + 1);

    if (message_with_type == nullptr) {
        return -6;
    }

    message_with_type[0] = type;
    memcpy(message_with_type + 1, message, length);

    uint8_t *packet = (uint8_t *)malloc(length + 1 + GC_BROADCAST_ENC_HEADER_SIZE);

    if (packet == nullptr) {
        free(message_with_type);
        return -6;
    }

    const uint16_t packet_len = make_gc_broadcast_header(message_with_type, length + 1, packet, GM_PRIVATE_MESSAGE);

    free(message_with_type);

    if (!send_lossless_group_packet(chat, gconn, packet, packet_len, GP_BROADCAST)) {
        free(packet);
        return -6;
    }

    free(packet);

    return 0;
}

/** @brief Handles a private message.
 *
 * Return 0 if packet is handled correctly.
 * Return -1 if packet has invalid size.
 */
non_null(1, 2, 3, 4) nullable(6)
static int handle_gc_private_message(const GC_Session *c, const GC_Chat *chat, const GC_Peer *peer, const uint8_t *data,
                                     uint16_t length, void *userdata)
{
    if (data == nullptr || length > MAX_GC_MESSAGE_SIZE || length <= 1) {
        return -1;
    }

    if (peer->ignore || peer->role >= GR_OBSERVER) {
        return 0;
    }

    const uint8_t message_type = data[0];

    if (message_type > MESSAGE_ACTION) {
        LOGGER_WARNING(chat->log, "Received invalid private message type: %u", message_type);
        return 0;
    }

    if (c->private_message != nullptr) {
        c->private_message(c->messenger, chat->group_number, peer->peer_id, message_type, data + 1, length - 1, userdata);
    }

    return 0;
}

int gc_send_custom_private_packet(const GC_Chat *chat, bool lossless, uint32_t peer_id, const uint8_t *message,
                                  uint16_t length)
{
    if (length > MAX_GC_CUSTOM_PACKET_SIZE) {
        return -1;
    }

    if ((!lossless) && (length > MAX_GC_PACKET_CHUNK_SIZE)) {
        return -1;
    }

    if (message == nullptr || length == 0) {
        return -2;
    }

    const int peer_number = get_peer_number_of_peer_id(chat, peer_id);

    GC_Connection *gconn = get_gc_connection(chat, peer_number);

    if (gconn == nullptr) {
        return -3;
    }

    if (gc_get_self_role(chat) >= GR_OBSERVER) {
        return -4;
    }

    bool ret;

    if (lossless) {
        ret = send_lossless_group_packet(chat, gconn, message, length, GP_CUSTOM_PRIVATE_PACKET);
    } else {
        ret = send_lossy_group_packet(chat, gconn, message, length, GP_CUSTOM_PRIVATE_PACKET);
    }

    return ret ? 0 : -5;
}
/** @brief Handles a custom private packet.
 *
 * @retval 0 if packet is handled correctly.
 * @retval -1 if packet has invalid size.
 */
non_null(1, 2, 3, 4) nullable(6)
static int handle_gc_custom_private_packet(const GC_Session *c, const GC_Chat *chat, const GC_Peer *peer,
        const uint8_t *data, uint16_t length, void *userdata)
{
    if (data == nullptr || length == 0 || length > MAX_GC_CUSTOM_PACKET_SIZE) {
        return -1;
    }

    if (peer->ignore || peer->role >= GR_OBSERVER) {
        return 0;
    }

    if (c->custom_private_packet != nullptr) {
        c->custom_private_packet(c->messenger, chat->group_number, peer->peer_id, data, length, userdata);
    }

    return 0;
}

int gc_send_custom_packet(const GC_Chat *chat, bool lossless, const uint8_t *data, uint16_t length)
{
    if (length > MAX_GC_CUSTOM_PACKET_SIZE) {
        return -1;
    }

    if ((!lossless) && (length > MAX_GC_PACKET_CHUNK_SIZE)) {
        return -1;
    }

    if (data == nullptr || length == 0) {
        return -2;
    }

    if (gc_get_self_role(chat) >= GR_OBSERVER) {
        return -3;
    }

    if (lossless) {
        send_gc_lossless_packet_all_peers(chat, data, length, GP_CUSTOM_PACKET);
    } else {
        send_gc_lossy_packet_all_peers(chat, data, length, GP_CUSTOM_PACKET);
    }

    return 0;
}

/** @brief Handles a custom packet.
 *
 * Return 0 if packet is handled correctly.
 * Return -1 if packet has invalid size.
 */
non_null(1, 2, 3, 4) nullable(6)
static int handle_gc_custom_packet(const GC_Session *c, const GC_Chat *chat, const GC_Peer *peer, const uint8_t *data,
                                   uint16_t length, void *userdata)
{
    if (data == nullptr || length == 0 || length > MAX_GC_CUSTOM_PACKET_SIZE) {
        return -1;
    }

    if (peer->ignore || peer->role >= GR_OBSERVER) {
        return 0;
    }

    if (c->custom_packet != nullptr) {
        c->custom_packet(c->messenger, chat->group_number, peer->peer_id, data, length, userdata);
    }

    return 0;
}

/** @brief Handles a peer kick broadcast.
 *
 * Return 0 if packet is handled correctly.
 * Return -1 if packet has invalid size.
 */
non_null(1, 2, 3, 4) nullable(6)
static int handle_gc_kick_peer(const GC_Session *c, GC_Chat *chat, const GC_Peer *setter_peer, const uint8_t *data,
                               uint16_t length, void *userdata)
{
    if (length < ENC_PUBLIC_KEY_SIZE) {
        return -1;
    }

    if (setter_peer->role >= GR_USER) {
        return 0;
    }

    const uint8_t *target_pk = data;

    const int target_peer_number = get_peer_number_of_enc_pk(chat, target_pk, false);
    GC_Peer *target_peer = get_gc_peer(chat, target_peer_number);

    if (target_peer != nullptr) {
        if (target_peer->role != GR_USER) {
            return 0;
        }
    }

    if (peer_number_is_self(target_peer_number)) {
        assert(target_peer != nullptr);

        for (uint32_t i = 1; i < chat->numpeers; ++i) {
            GC_Connection *gconn = get_gc_connection(chat, i);
            assert(gconn != nullptr);

            gcc_mark_for_deletion(gconn, chat->tcp_conn, GC_EXIT_TYPE_SELF_DISCONNECTED, nullptr, 0);
        }

        chat->connection_state = CS_DISCONNECTED;

        if (c->moderation != nullptr) {
            c->moderation(c->messenger, chat->group_number, setter_peer->peer_id, target_peer->peer_id,
                          MV_KICK, userdata);
        }

        return 0;
    }

    if (target_peer == nullptr) {   /** we don't need to/can't kick a peer that isn't in our peerlist */
        return 0;
    }

    gcc_mark_for_deletion(&target_peer->gconn, chat->tcp_conn, GC_EXIT_TYPE_KICKED, nullptr, 0);

    if (c->moderation != nullptr) {
        c->moderation(c->messenger, chat->group_number, setter_peer->peer_id, target_peer->peer_id, MV_KICK, userdata);
    }

    return 0;
}

/** @brief Sends a packet to instruct all peers to remove gconn from their peerlist.
 *
 * Returns true on success.
 */
non_null()
static bool send_gc_kick_peer(const GC_Chat *chat, const GC_Connection *gconn)
{
    uint8_t packet[ENC_PUBLIC_KEY_SIZE];
    memcpy(packet, gconn->addr.public_key, ENC_PUBLIC_KEY_SIZE);

    return send_gc_broadcast_message(chat, packet, ENC_PUBLIC_KEY_SIZE, GM_KICK_PEER);
}

int gc_kick_peer(const Messenger *m, int group_number, uint32_t peer_id)
{
    const GC_Session *c = m->group_handler;
    GC_Chat *chat = gc_get_group(c, group_number);

    if (chat == nullptr) {
        return -1;
    }

    const int peer_number = get_peer_number_of_peer_id(chat, peer_id);

    if (peer_number_is_self(peer_number)) {
        return -6;
    }

    GC_Peer *peer = get_gc_peer(chat, peer_number);

    if (peer == nullptr) {
        return -2;
    }

    if (gc_get_self_role(chat) >= GR_USER || peer->role == GR_FOUNDER) {
        return -3;
    }

    if (!self_gc_is_founder(chat) && peer->role == GR_MODERATOR) {
        return -3;
    }

    if (peer->role == GR_MODERATOR || peer->role == GR_OBSERVER) {
        // this first removes peer from any lists they're on and broadcasts new lists to group
        if (gc_set_peer_role(c->messenger, chat->group_number, peer_id, GR_USER) < 0) {
            return -4;
        }
    }

    if (!send_gc_kick_peer(chat, &peer->gconn)) {
        return -5;
    }

    gcc_mark_for_deletion(&peer->gconn, chat->tcp_conn, GC_EXIT_TYPE_NO_CALLBACK, nullptr, 0);

    return 0;
}

bool gc_send_message_ack(const GC_Chat *chat, GC_Connection *gconn, uint64_t message_id, Group_Message_Ack_Type type)
{
    if (gconn->pending_delete) {
        return true;
    }

    if (type == GR_ACK_REQ) {
        const uint64_t tm = mono_time_get(chat->mono_time);

        if (gconn->last_requested_packet_time == tm) {
            return true;
        }

        gconn->last_requested_packet_time = tm;
    } else if (type != GR_ACK_RECV) {
        return false;
    }

    uint8_t data[GC_LOSSLESS_ACK_PACKET_SIZE];
    data[0] = (uint8_t) type;
    net_pack_u64(data + 1, message_id);

    return send_lossy_group_packet(chat, gconn, data, GC_LOSSLESS_ACK_PACKET_SIZE, GP_MESSAGE_ACK);
}

/** @brief Handles a lossless message acknowledgement.
 *
 * If the type is GR_ACK_RECV we remove the packet from our
 * send array. If the type is GR_ACK_REQ we re-send the packet
 * associated with the requested message_id.
 *
 * Returns 0 if packet is handled correctly.
 * Return -1 if packet has invalid size.
 * Return -2 if we failed to handle the ack (may be caused by connection issues).
 * Return -3 if we failed to re-send a requested packet.
 */
non_null()
static int handle_gc_message_ack(const GC_Chat *chat, GC_Connection *gconn, const uint8_t *data, uint16_t length)
{
    if (length < GC_LOSSLESS_ACK_PACKET_SIZE) {
        return -1;
    }

    uint64_t message_id;
    net_unpack_u64(data + 1, &message_id);

    const Group_Message_Ack_Type type = (Group_Message_Ack_Type) data[0];

    if (type == GR_ACK_RECV) {
        if (!gcc_handle_ack(chat->log, gconn, message_id)) {
            return -2;
        }

        return 0;
    }

    if (type != GR_ACK_REQ) {
        return 0;
    }

    const uint64_t tm = mono_time_get(chat->mono_time);
    const uint16_t idx = gcc_get_array_index(message_id);

    /* re-send requested packet */
    if (gconn->send_array[idx].message_id == message_id) {
        if (gcc_encrypt_and_send_lossless_packet(chat, gconn, gconn->send_array[idx].data,
                gconn->send_array[idx].data_length,
                gconn->send_array[idx].message_id,
                gconn->send_array[idx].packet_type)) {
            gconn->send_array[idx].last_send_try = tm;
            LOGGER_DEBUG(chat->log, "Re-sent requested packet %llu", (unsigned long long)message_id);
        } else {
            return -3;
        }
    }

    return 0;
}

/** @brief Sends a handshake response ack to peer.
 *
 * Return true on success.
 */
non_null()
static bool send_gc_hs_response_ack(const GC_Chat *chat, GC_Connection *gconn)
{
    return send_lossless_group_packet(chat, gconn, nullptr, 0, GP_HS_RESPONSE_ACK);
}

/** @brief Handles a handshake response ack.
 *
 * Return 0 if packet is handled correctly.
 * Return -1 if we failed to respond with an invite request.
 */
non_null()
static int handle_gc_hs_response_ack(const GC_Chat *chat, GC_Connection *gconn)
{
    gconn->handshaked = true;  // has to be true before we can send a lossless packet

    if (!send_gc_invite_request(chat, gconn)) {
        gconn->handshaked = false;
        return -1;
    }

    return 0;
}

int gc_set_ignore(const GC_Chat *chat, uint32_t peer_id, bool ignore)
{
    const int peer_number = get_peer_number_of_peer_id(chat, peer_id);

    GC_Peer *peer = get_gc_peer(chat, peer_number);

    if (peer == nullptr) {
        return -1;
    }

    if (peer_number_is_self(peer_number)) {
        return -2;
    }

    peer->ignore = ignore;

    return 0;
}

/** @brief Handles a broadcast packet.
 *
 * Returns 0 if packet is handled correctly.
 * Returns -1 on failure.
 */
non_null(1, 2, 4) nullable(6)
static int handle_gc_broadcast(const GC_Session *c, GC_Chat *chat, uint32_t peer_number, const uint8_t *data,
                               uint16_t length, void *userdata)
{
    if (length < GC_BROADCAST_ENC_HEADER_SIZE) {
        return -1;
    }

    GC_Peer *peer = get_gc_peer(chat, peer_number);

    if (peer == nullptr) {
        return -1;
    }

    GC_Connection *gconn = &peer->gconn;

    if (!gconn->confirmed) {
        return -1;
    }

    const uint8_t broadcast_type = data[0];

    const uint16_t m_len = length - 1;
    const uint8_t *message = data + 1;

    int ret = 0;

    switch (broadcast_type) {
        case GM_STATUS: {
            ret = handle_gc_status(c, chat, peer, message, m_len, userdata);
            break;
        }

        case GM_NICK: {
            ret = handle_gc_nick(c, chat, peer, message, m_len, userdata);
            break;
        }

        case GM_ACTION_MESSAGE:

        // intentional fallthrough
        case GM_PLAIN_MESSAGE: {
            ret = handle_gc_message(c, chat, peer, message, m_len, broadcast_type, userdata);
            break;
        }

        case GM_PRIVATE_MESSAGE: {
            ret = handle_gc_private_message(c, chat, peer, message, m_len, userdata);
            break;
        }

        case GM_PEER_EXIT: {
            handle_gc_peer_exit(chat, gconn, message, m_len);
            ret = 0;
            break;
        }

        case GM_KICK_PEER: {
            ret = handle_gc_kick_peer(c, chat, peer, message, m_len, userdata);
            break;
        }

        case GM_SET_MOD: {
            ret = handle_gc_set_mod(c, chat, peer_number, message, m_len, userdata);
            break;
        }

        case GM_SET_OBSERVER: {
            ret = handle_gc_set_observer(c, chat, peer_number, message, m_len, userdata);
            break;
        }

        default: {
            LOGGER_DEBUG(chat->log, "Received an invalid broadcast type 0x%02x", broadcast_type);
            break;
        }
    }

    if (ret < 0) {
        LOGGER_DEBUG(chat->log, "Broadcast handle error %d: type: 0x%02x, peernumber: %u",
                     ret, broadcast_type, peer_number);
        return -1;
    }

    return 0;
}

/** @brief Decrypts data of size `length` using self secret key and sender's public key.
 *
 * The packet payload should begin with a nonce.
 *
 * Returns length of plaintext data on success.
 * Return -1 if length is invalid.
 * Return -2 if decryption fails.
 */
non_null()
static int unwrap_group_handshake_packet(const Logger *log, const uint8_t *self_sk, const uint8_t *sender_pk,
        uint8_t *plain, size_t plain_size, const uint8_t *packet, uint16_t length)
{
    if (length <= CRYPTO_NONCE_SIZE) {
        LOGGER_FATAL(log, "Invalid handshake packet length %u", length);
        return -1;
    }

    const int plain_len = decrypt_data(sender_pk, self_sk, packet, packet + CRYPTO_NONCE_SIZE,
                                       length - CRYPTO_NONCE_SIZE, plain);

    if (plain_len < 0 || (uint32_t)plain_len != plain_size) {
        LOGGER_DEBUG(log, "decrypt handshake request failed: len: %d, size: %zu", plain_len, plain_size);
        return -2;
    }

    return plain_len;
}

/** @brief Encrypts data of length using the peer's shared key a new nonce.
 *
 * Adds plaintext header consisting of: packet identifier, target public encryption key,
 * self public encryption key, nonce.
 *
 * Return length of encrypted packet on success.
 * Return -1 if packet size is invalid.
 * Return -2 on malloc failure.
 * Return -3 if encryption fails.
 */
non_null()
static int wrap_group_handshake_packet(
    const Logger *log, const Random *rng, const uint8_t *self_pk, const uint8_t *self_sk,
    const uint8_t *target_pk, uint8_t *packet, uint32_t packet_size,
    const uint8_t *data, uint16_t length)
{
    if (packet_size != GC_MIN_ENCRYPTED_HS_PAYLOAD_SIZE + sizeof(Node_format)) {
        LOGGER_FATAL(log, "Invalid packet size: %u", packet_size);
        return -1;
    }

    uint8_t nonce[CRYPTO_NONCE_SIZE];
    random_nonce(rng, nonce);

    const size_t encrypt_buf_size = length + CRYPTO_MAC_SIZE;
    uint8_t *encrypt = (uint8_t *)malloc(encrypt_buf_size);

    if (encrypt == nullptr) {
        return -2;
    }

    const int enc_len = encrypt_data(target_pk, self_sk, nonce, data, length, encrypt);

    if (enc_len < 0 || (size_t)enc_len != encrypt_buf_size) {
        LOGGER_ERROR(log, "Failed to encrypt group handshake packet (len: %d)", enc_len);
        free(encrypt);
        return -3;
    }

    packet[0] = NET_PACKET_GC_HANDSHAKE;
    memcpy(packet + 1, self_pk, ENC_PUBLIC_KEY_SIZE);
    memcpy(packet + 1 + ENC_PUBLIC_KEY_SIZE, target_pk, ENC_PUBLIC_KEY_SIZE);
    memcpy(packet + 1 + ENC_PUBLIC_KEY_SIZE + ENC_PUBLIC_KEY_SIZE, nonce, CRYPTO_NONCE_SIZE);
    memcpy(packet + 1 + ENC_PUBLIC_KEY_SIZE + ENC_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE, encrypt, enc_len);

    free(encrypt);

    return 1 + ENC_PUBLIC_KEY_SIZE + ENC_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + enc_len;
}

/** @brief Makes, wraps and encrypts a group handshake packet (both request and response are the same format).
 *
 * Packet contains the packet header, handshake type, self public encryption key, self public signature key,
 * request type, and a single TCP relay node.
 *
 * Returns length of encrypted packet on success.
 * Returns -1 on failure.
 */
non_null()
static int make_gc_handshake_packet(const GC_Chat *chat, const GC_Connection *gconn, uint8_t handshake_type,
                                    uint8_t request_type, uint8_t join_type, uint8_t *packet, size_t packet_size,
                                    const Node_format *node)
{
    if (packet_size != GC_MIN_ENCRYPTED_HS_PAYLOAD_SIZE + sizeof(Node_format)) {
        LOGGER_FATAL(chat->log, "invalid packet size: %zu", packet_size);
        return -1;
    }

    if (chat == nullptr || gconn == nullptr || node == nullptr) {
        return -1;
    }

    uint8_t data[GC_MIN_HS_PACKET_PAYLOAD_SIZE + sizeof(Node_format)];

    uint16_t length = sizeof(uint8_t);

    data[0] = handshake_type;
    memcpy(data + length, gconn->session_public_key, ENC_PUBLIC_KEY_SIZE);
    length += ENC_PUBLIC_KEY_SIZE;
    memcpy(data + length, get_sig_pk(chat->self_public_key), SIG_PUBLIC_KEY_SIZE);
    length += SIG_PUBLIC_KEY_SIZE;
    memcpy(data + length, &request_type, sizeof(uint8_t));
    length += sizeof(uint8_t);
    memcpy(data + length, &join_type, sizeof(uint8_t));
    length += sizeof(uint8_t);

    int nodes_size = pack_nodes(chat->log, data + length, sizeof(Node_format), node, MAX_SENT_GC_NODES);

    if (nodes_size > 0) {
        length += nodes_size;
    } else {
        nodes_size = 0;
    }

    const int enc_len = wrap_group_handshake_packet(
                            chat->log, chat->rng, chat->self_public_key, chat->self_secret_key,
                            gconn->addr.public_key, packet, (uint16_t)packet_size, data, length);

    if (enc_len != GC_MIN_ENCRYPTED_HS_PAYLOAD_SIZE + nodes_size) {
        LOGGER_WARNING(chat->log, "Failed to wrap handshake packet: %d", enc_len);
        return -1;
    }

    return enc_len;
}

/** @brief Sends a handshake packet to `gconn`.
 *
 * Handshake_type should be GH_REQUEST or GH_RESPONSE.
 *
 * Returns true on success.
 */
non_null()
static bool send_gc_handshake_packet(const GC_Chat *chat, GC_Connection *gconn, uint8_t handshake_type,
                                     uint8_t request_type, uint8_t join_type)
{
    if (gconn == nullptr) {
        return false;
    }

    Node_format node;
    memset(&node, 0, sizeof(node));

    if (!gcc_copy_tcp_relay(chat->rng, &node, gconn)) {
        LOGGER_TRACE(chat->log, "Failed to copy TCP relay during handshake (%u TCP relays)", gconn->tcp_relays_count);
    }

    uint8_t packet[GC_MIN_ENCRYPTED_HS_PAYLOAD_SIZE + sizeof(Node_format)];
    const int length = make_gc_handshake_packet(chat, gconn, handshake_type, request_type, join_type, packet,
                       sizeof(packet), &node);

    if (length < 0) {
        return false;
    }

    const bool try_tcp_fallback = gconn->handshake_attempts % 2 == 1 && gconn->tcp_relays_count > 0;
    ++gconn->handshake_attempts;

    int ret = -1;

    if (!try_tcp_fallback && gcc_direct_conn_is_possible(chat, gconn)) {
        ret = sendpacket(chat->net, &gconn->addr.ip_port, packet, (uint16_t)length);
    }

    if (ret != length && gconn->tcp_relays_count == 0) {
        LOGGER_WARNING(chat->log, "UDP handshake failed and no TCP relays to fall back on");
        return false;
    }

    // Send a TCP handshake if UDP fails, or if UDP succeeded last time but we never got a response
    if (gconn->tcp_relays_count > 0 && (ret != length || try_tcp_fallback)) {
        if (send_packet_tcp_connection(chat->tcp_conn, gconn->tcp_connection_num, packet, (uint16_t)length) == -1) {
            LOGGER_DEBUG(chat->log, "Send handshake packet failed. Type 0x%02x", request_type);
            return false;
        }
    }

    if (gconn->is_pending_handshake_response) {
        gcc_set_send_message_id(gconn, 3);  // handshake response is always second packet
    }  else {
        gcc_set_send_message_id(gconn, 2);  // handshake request is always first packet
    }

    return true;
}

/** @brief Sends an out-of-band TCP handshake request packet to `gconn`.
 *
 * Return true on success.
 */
static bool send_gc_oob_handshake_request(const GC_Chat *chat, const GC_Connection *gconn)
{
    if (gconn == nullptr) {
        return false;
    }

    Node_format node;
    memset(&node, 0, sizeof(node));

    if (!gcc_copy_tcp_relay(chat->rng, &node, gconn)) {
        LOGGER_WARNING(chat->log, "Failed to copy TCP relay");
        return false;
    }

    uint8_t packet[GC_MIN_ENCRYPTED_HS_PAYLOAD_SIZE + sizeof(Node_format)];
    const int length = make_gc_handshake_packet(chat, gconn, GH_REQUEST, gconn->pending_handshake_type, chat->join_type,
                       packet, sizeof(packet), &node);

    if (length < 0) {
        LOGGER_WARNING(chat->log, "Failed to make handshake packet");
        return false;
    }

    return tcp_send_oob_packet_using_relay(chat->tcp_conn, gconn->oob_relay_pk, gconn->addr.public_key,
                                           packet, (uint16_t)length) == 0;
}

/** @brief Handles a handshake response packet and takes appropriate action depending on the value of request_type.
 *
 * This function assumes the length has already been validated.
 *
 * Returns peer_number of new connected peer on success.
 * Returns -1 on failure.
 */
non_null()
static int handle_gc_handshake_response(const GC_Chat *chat, const uint8_t *sender_pk, const uint8_t *data,
                                        uint16_t length)
{
    // this should be checked at lower level; this is a redundant defense check. Ideally we should
    // guarantee that this can never happen in the future.
    if (length < ENC_PUBLIC_KEY_SIZE + SIG_PUBLIC_KEY_SIZE + 1) {
        LOGGER_FATAL(chat->log, "Invalid handshake response size (%u)", length);
        return -1;
    }

    const int peer_number = get_peer_number_of_enc_pk(chat, sender_pk, false);

    if (peer_number == -1) {
        return -1;
    }

    GC_Connection *gconn = get_gc_connection(chat, peer_number);

    if (gconn == nullptr) {
        return -1;
    }

    const uint8_t *sender_session_pk = data;

    gcc_make_session_shared_key(gconn, sender_session_pk);

    set_sig_pk(gconn->addr.public_key, data + ENC_PUBLIC_KEY_SIZE);

    gcc_set_recv_message_id(gconn, 2);  // handshake response is always second packet

    gconn->handshaked = true;

    send_gc_hs_response_ack(chat, gconn);

    const uint8_t request_type = data[ENC_PUBLIC_KEY_SIZE + SIG_PUBLIC_KEY_SIZE];

    switch (request_type) {
        case HS_INVITE_REQUEST: {
            if (!send_gc_invite_request(chat, gconn)) {
                return -1;
            }

            break;
        }

        case HS_PEER_INFO_EXCHANGE: {
            if (!send_gc_peer_exchange(chat, gconn)) {
                return -1;
            }

            break;
        }

        default: {
            return -1;
        }
    }

    return peer_number;
}

/** @brief Sends a handshake response packet of type `request_type` to `gconn`.
 *
 * Return true on success.
 */
non_null()
static bool send_gc_handshake_response(const GC_Chat *chat, GC_Connection *gconn)
{
    return send_gc_handshake_packet(chat, gconn, GH_RESPONSE, gconn->pending_handshake_type, 0);
}

/** @brief Handles handshake request packets.
 *
 * Peer is added to peerlist and a lossless connection is established.
 *
 * This function assumes the length has already been validated.
 *
 * Return new peer's peer_number on success.
 * Return -1 on failure.
 */
#define GC_NEW_PEER_CONNECTION_LIMIT 10
non_null(1, 3, 4) nullable(2)
static int handle_gc_handshake_request(GC_Chat *chat, const IP_Port *ipp, const uint8_t *sender_pk,
                                       const uint8_t *data, uint16_t length)
{
    // this should be checked at lower level; this is a redundant defense check. Ideally we should
    // guarantee that this can never happen in the future.
    if (length < ENC_PUBLIC_KEY_SIZE + SIG_PUBLIC_KEY_SIZE + 1 + 1) {
        LOGGER_FATAL(chat->log, "Invalid length (%u)", length);
        return -1;
    }

    if (chat->connection_state <= CS_DISCONNECTED) {
        LOGGER_DEBUG(chat->log, "Handshake request ignored; state is disconnected");
        return -1;
    }

    if (chat->connection_O_metre >= GC_NEW_PEER_CONNECTION_LIMIT) {
        chat->block_handshakes = true;
        LOGGER_DEBUG(chat->log, "Handshake overflow. Blocking handshakes.");
        return -1;
    }

    ++chat->connection_O_metre;

    const uint8_t *public_sig_key = data + ENC_PUBLIC_KEY_SIZE;

    const uint8_t request_type = data[ENC_PUBLIC_KEY_SIZE + SIG_PUBLIC_KEY_SIZE];
    const uint8_t join_type = data[ENC_PUBLIC_KEY_SIZE + SIG_PUBLIC_KEY_SIZE + 1];

    int peer_number = get_peer_number_of_enc_pk(chat, sender_pk, false);
    const bool is_new_peer = peer_number < 0;

    if (is_new_peer) {
        peer_number = peer_add(chat, ipp, sender_pk);

        if (peer_number < 0) {
            LOGGER_WARNING(chat->log, "Failed to add peer during handshake request");
            return -1;
        }
    } else  {
        GC_Connection *gconn = get_gc_connection(chat, peer_number);

        if (gconn == nullptr) {
            LOGGER_WARNING(chat->log, "Invalid peer number");
            return -1;
        }

        if (gconn->handshaked) {
            gconn->handshaked = false;
            LOGGER_DEBUG(chat->log, "Handshaked peer sent a handshake request");
            return -1;
        }

        // peers sent handshake request at same time so the closer peer becomes the requestor
        // and ignores the request packet while further peer continues on with the response
        if (gconn->self_is_closer) {
            LOGGER_DEBUG(chat->log, "Simultaneous handshake requests; other peer is closer");
            return 0;
        }
    }

    GC_Connection *gconn = get_gc_connection(chat, peer_number);

    if (gconn == nullptr) {
        LOGGER_DEBUG(chat->log, "Peer connection invalid");
        return -1;
    }

    gcc_set_ip_port(gconn, ipp);

    Node_format node[GCA_MAX_ANNOUNCED_TCP_RELAYS];
    const int processed = ENC_PUBLIC_KEY_SIZE + SIG_PUBLIC_KEY_SIZE + 1 + 1;

    const int nodes_count = unpack_nodes(node, GCA_MAX_ANNOUNCED_TCP_RELAYS, nullptr,
                                         data + processed, length - processed, true);

    if (nodes_count <= 0 && ipp == nullptr) {
        if (is_new_peer) {
            LOGGER_WARNING(chat->log, "Broken tcp relay for new peer");
            gcc_mark_for_deletion(gconn, chat->tcp_conn, GC_EXIT_TYPE_DISCONNECTED, nullptr, 0);
        }

        return -1;
    }

    if (nodes_count > 0) {
        const int add_tcp_result = add_tcp_relay_connection(chat->tcp_conn, gconn->tcp_connection_num,
                                   &node->ip_port, node->public_key);

        if (add_tcp_result < 0 && is_new_peer && ipp == nullptr) {
            LOGGER_WARNING(chat->log, "Broken tcp relay for new peer");
            gcc_mark_for_deletion(gconn, chat->tcp_conn, GC_EXIT_TYPE_DISCONNECTED, nullptr, 0);
            return -1;
        }

        if (add_tcp_result == 0) {
            gcc_save_tcp_relay(chat->rng, gconn, node);
        }
    }

    const uint8_t *sender_session_pk = data;

    gcc_make_session_shared_key(gconn, sender_session_pk);

    set_sig_pk(gconn->addr.public_key, public_sig_key);

    if (join_type == HJ_PUBLIC && !is_public_chat(chat)) {
        gcc_mark_for_deletion(gconn, chat->tcp_conn, GC_EXIT_TYPE_DISCONNECTED, nullptr, 0);
        LOGGER_DEBUG(chat->log, "Ignoring invalid invite request");
        return -1;
    }

    gcc_set_recv_message_id(gconn, 1);  // handshake request is always first packet

    gconn->is_pending_handshake_response = true;
    gconn->pending_handshake_type = request_type;

    return peer_number;
}

/** @brief Handles handshake request and handshake response packets.
 *
 * Returns the peer_number of the connecting peer on success.
 * Returns -1 on failure.
 */
non_null(1, 2, 4) nullable(3, 7)
static int handle_gc_handshake_packet(GC_Chat *chat, const uint8_t *sender_pk, const IP_Port *ipp,
                                      const uint8_t *packet, uint16_t length, bool direct_conn, void *userdata)
{
    if (length < GC_MIN_HS_PACKET_PAYLOAD_SIZE + CRYPTO_MAC_SIZE + CRYPTO_NONCE_SIZE) {
        return -1;
    }

    const size_t data_buf_size = length - CRYPTO_NONCE_SIZE - CRYPTO_MAC_SIZE;
    uint8_t *data = (uint8_t *)malloc(data_buf_size);

    if (data == nullptr) {
        return -1;
    }

    const int plain_len = unwrap_group_handshake_packet(chat->log, chat->self_secret_key, sender_pk, data,
                          data_buf_size, packet, length);

    if (plain_len < GC_MIN_HS_PACKET_PAYLOAD_SIZE)  {
        LOGGER_DEBUG(chat->log, "Failed to unwrap handshake packet (probably a stale request using an old key)");
        free(data);
        return -1;
    }

    const uint8_t handshake_type = data[0];

    const uint8_t *real_data = data + 1;
    const uint16_t real_len = (uint16_t)plain_len - 1;

    int peer_number;

    if (handshake_type == GH_REQUEST) {
        peer_number = handle_gc_handshake_request(chat, ipp, sender_pk, real_data, real_len);
    } else if (handshake_type == GH_RESPONSE) {
        peer_number = handle_gc_handshake_response(chat, sender_pk, real_data, real_len);
    } else {
        free(data);
        return -1;
    }

    free(data);

    GC_Connection *gconn = get_gc_connection(chat, peer_number);

    if (gconn == nullptr) {
        return -1;
    }

    if (direct_conn) {
        gconn->last_received_direct_time = mono_time_get(chat->mono_time);
    }

    return peer_number;
}

bool handle_gc_lossless_helper(const GC_Session *c, GC_Chat *chat, uint32_t peer_number, const uint8_t *data,
                               uint16_t length, uint8_t packet_type, void *userdata)
{
    GC_Peer *peer = get_gc_peer(chat, peer_number);

    if (peer == nullptr) {
        return false;
    }

    GC_Connection *gconn = &peer->gconn;

    int ret;

    switch (packet_type) {
        case GP_BROADCAST: {
            ret = handle_gc_broadcast(c, chat, peer_number, data, length, userdata);
            break;
        }

        case GP_PEER_INFO_REQUEST: {
            ret = handle_gc_peer_info_request(chat, peer_number);
            break;
        }

        case GP_PEER_INFO_RESPONSE: {
            ret = handle_gc_peer_info_response(c, chat, peer_number, data, length, userdata);
            break;
        }

        case GP_SYNC_REQUEST: {
            ret = handle_gc_sync_request(chat, peer_number, data, length);
            break;
        }

        case GP_SYNC_RESPONSE: {
            ret = handle_gc_sync_response(c, chat, peer_number, data, length, userdata);
            break;
        }

        case GP_INVITE_REQUEST: {
            ret = handle_gc_invite_request(chat, peer_number, data, length);
            break;
        }

        case GP_INVITE_RESPONSE: {
            ret = handle_gc_invite_response(chat, gconn);
            break;
        }

        case GP_TOPIC: {
            ret = handle_gc_topic(c, chat, peer, data, length, userdata);
            break;
        }

        case GP_SHARED_STATE: {
            ret = handle_gc_shared_state(c, chat, gconn, data, length, userdata);
            break;
        }

        case GP_MOD_LIST: {
            ret = handle_gc_mod_list(c, chat, data, length, userdata);
            break;
        }

        case GP_SANCTIONS_LIST: {
            ret = handle_gc_sanctions_list(c, chat, data, length, userdata);
            break;
        }

        case GP_HS_RESPONSE_ACK: {
            ret = handle_gc_hs_response_ack(chat, gconn);
            break;
        }

        case GP_TCP_RELAYS: {
            ret = handle_gc_tcp_relays(chat, gconn, data, length);
            break;
        }

        case GP_KEY_ROTATION: {
            ret = handle_gc_key_exchange(chat, gconn, data, length);
            break;
        }

        case GP_CUSTOM_PACKET: {
            ret = handle_gc_custom_packet(c, chat, peer, data, length, userdata);
            break;
        }

        case GP_CUSTOM_PRIVATE_PACKET: {
            ret = handle_gc_custom_private_packet(c, chat, peer, data, length, userdata);
            break;
        }

        default: {
            LOGGER_DEBUG(chat->log, "Handling invalid lossless group packet type 0x%02x", packet_type);
            return false;
        }
    }

    if (ret < 0) {
        LOGGER_DEBUG(chat->log, "Lossless packet handle error %d: type: 0x%02x, peernumber: %d",
                     ret, packet_type, peer_number);
        return false;
    }

    peer = get_gc_peer(chat, peer_number);

    if (peer != nullptr) {
        peer->gconn.last_requested_packet_time = mono_time_get(chat->mono_time);
    }

    return true;
}

/** @brief Handles a packet fragment.
 *
 * If the fragment is the last one in a sequence we send an ack. Otherwise we
 * store the fragment in the receive array and wait for the next segment.
 *
 * Segments must be processed in correct sequence, and we cannot handle
 * non-fragment packets while a sequence is incomplete.
 *
 * Return true if packet is handled successfully.
 */
non_null(1, 2, 4) nullable(5, 9)
static bool handle_gc_packet_fragment(const GC_Session *c, GC_Chat *chat, uint32_t peer_number, GC_Connection *gconn,
                                      const uint8_t *data, uint16_t length, uint8_t packet_type, uint64_t message_id,
                                      void *userdata)
{
    if (gconn->last_chunk_id != 0 && message_id != gconn->last_chunk_id + 1) {
        return gc_send_message_ack(chat, gconn, gconn->last_chunk_id + 1, GR_ACK_REQ);
    }

    if (gconn->last_chunk_id == 0 && message_id != gconn->received_message_id + 1) {
        return gc_send_message_ack(chat, gconn, gconn->received_message_id + 1, GR_ACK_REQ);
    }

    const int frag_ret = gcc_handle_packet_fragment(c, chat, peer_number, gconn, data, length, packet_type,
                         message_id, userdata);

    if (frag_ret == -1) {
        return false;
    }

    if (frag_ret == 0) {
        gc_send_message_ack(chat, gconn, message_id, GR_ACK_RECV);
    }

    gconn->last_received_packet_time = mono_time_get(chat->mono_time);

    return true;
}

/** @brief Handles lossless groupchat packets.
 *
 * This function assumes the length has already been validated.
 *
 * Returns true if packet is successfully handled.
 */
non_null(1, 2, 3, 4) nullable(7)
static bool handle_gc_lossless_packet(const GC_Session *c, GC_Chat *chat, const uint8_t *sender_pk,
                                      const uint8_t *packet, uint16_t length, bool direct_conn, void *userdata)
{
    if (length < GC_MIN_LOSSLESS_PAYLOAD_SIZE) {
        return false;
    }

    int peer_number = get_peer_number_of_enc_pk(chat, sender_pk, false);

    GC_Connection *gconn = get_gc_connection(chat, peer_number);

    if (gconn == nullptr) {
        return false;
    }

    if (gconn->pending_delete) {
        return true;
    }

    uint8_t *data = (uint8_t *)malloc(length);

    if (data == nullptr) {
        LOGGER_DEBUG(chat->log, "Failed to allocate memory for packet data buffer");
        return false;
    }

    uint8_t packet_type;
    uint64_t message_id;

    const int len = group_packet_unwrap(chat->log, gconn, data, &message_id, &packet_type, packet, length);

    if (len < 0) {
        Ip_Ntoa ip_str;
        LOGGER_DEBUG(chat->log, "Failed to unwrap lossless packet from %s:%d: %d",
                     net_ip_ntoa(&gconn->addr.ip_port.ip, &ip_str), net_ntohs(gconn->addr.ip_port.port), len);
        free(data);
        return false;
    }

    if (!gconn->handshaked && (packet_type != GP_HS_RESPONSE_ACK && packet_type != GP_INVITE_REQUEST)) {
        LOGGER_DEBUG(chat->log, "Got lossless packet type 0x%02x from unconfirmed peer", packet_type);
        free(data);
        return false;
    }

    const bool is_invite_packet = packet_type == GP_INVITE_REQUEST || packet_type == GP_INVITE_RESPONSE
                                  || packet_type == GP_INVITE_RESPONSE_REJECT;

    if (message_id == 3 && is_invite_packet && gconn->received_message_id <= 1) {
        // we missed initial handshake request. Drop this packet and wait for another handshake request.
        LOGGER_DEBUG(chat->log, "Missed handshake packet, type: 0x%02x", packet_type);
        free(data);
        return false;
    }

    const int lossless_ret = gcc_handle_received_message(chat->log, chat->mono_time, gconn, data, (uint16_t) len,
                             packet_type, message_id, direct_conn);

    if (packet_type == GP_INVITE_REQUEST && !gconn->handshaked) {  // Both peers sent request at same time
        free(data);
        return true;
    }

    if (lossless_ret < 0) {
        LOGGER_DEBUG(chat->log, "failed to handle packet %llu (type: 0x%02x, id: %llu)",
                     (unsigned long long)message_id, packet_type, (unsigned long long)message_id);
        free(data);
        return false;
    }

    /* Duplicate packet */
    if (lossless_ret == 0) {
        free(data);
        return gc_send_message_ack(chat, gconn, message_id, GR_ACK_RECV);
    }

    /* request missing packet */
    if (lossless_ret == 1) {
        LOGGER_TRACE(chat->log, "received out of order packet from peer %u. expected %llu, got %llu", peer_number,
                     (unsigned long long)gconn->received_message_id + 1, (unsigned long long)message_id);
        free(data);
        return gc_send_message_ack(chat, gconn, gconn->received_message_id + 1, GR_ACK_REQ);
    }

    /* handle packet fragment */
    if (lossless_ret == 3) {
        const bool frag_ret = handle_gc_packet_fragment(c, chat, peer_number, gconn, data, (uint16_t)len, packet_type,
                              message_id, userdata);
        free(data);
        return frag_ret;
    }

    const bool ret = handle_gc_lossless_helper(c, chat, peer_number, data, (uint16_t)len, packet_type, userdata);

    free(data);

    if (!ret) {
        return false;
    }

    /* peer number can change from peer add operations in packet handlers */
    peer_number = get_peer_number_of_enc_pk(chat, sender_pk, false);
    gconn = get_gc_connection(chat, peer_number);

    if (gconn != nullptr && lossless_ret == 2) {
        gc_send_message_ack(chat, gconn, message_id, GR_ACK_RECV);
    }

    return true;
}

/** @brief Handles lossy groupchat message packets.
 *
 * This function assumes the length has already been validated.
 *
 * Return true if packet is handled successfully.
 */
non_null(1, 2, 3, 4) nullable(7)
static bool handle_gc_lossy_packet(const GC_Session *c, GC_Chat *chat, const uint8_t *sender_pk,
                                   const uint8_t *packet, uint16_t length, bool direct_conn, void *userdata)
{
    if (length < GC_MIN_LOSSY_PAYLOAD_SIZE) {
        return false;
    }

    const int peer_number = get_peer_number_of_enc_pk(chat, sender_pk, false);

    GC_Peer *peer = get_gc_peer(chat, peer_number);

    if (peer == nullptr) {
        return false;
    }

    GC_Connection *gconn = &peer->gconn;

    if (!gconn->handshaked || gconn->pending_delete) {
        LOGGER_DEBUG(chat->log, "Got lossy packet from invalid peer");
        return false;
    }

    uint8_t *data = (uint8_t *)malloc(length);

    if (data == nullptr) {
        LOGGER_ERROR(chat->log, "Failed to allocate memory for packet buffer");
        return false;
    }

    uint8_t packet_type;

    const int len = group_packet_unwrap(chat->log, gconn, data, nullptr, &packet_type, packet, length);

    if (len <= 0) {
        Ip_Ntoa ip_str;
        LOGGER_DEBUG(chat->log, "Failed to unwrap lossy packet from %s:%d: %d",
                     net_ip_ntoa(&gconn->addr.ip_port.ip, &ip_str), net_ntohs(gconn->addr.ip_port.port), len);
        free(data);
        return false;
    }

    int ret = -1;
    const uint16_t payload_len = (uint16_t)len;

    switch (packet_type) {
        case GP_MESSAGE_ACK: {
            ret = handle_gc_message_ack(chat, gconn, data, payload_len);
            break;
        }

        case GP_PING: {
            ret = handle_gc_ping(chat, gconn, data, payload_len);
            break;
        }

        case GP_INVITE_RESPONSE_REJECT: {
            ret = handle_gc_invite_response_reject(c, chat, data, payload_len, userdata);
            break;
        }

        case GP_CUSTOM_PACKET: {
            ret = handle_gc_custom_packet(c, chat, peer, data, payload_len, userdata);
            break;
        }

        case GP_CUSTOM_PRIVATE_PACKET: {
            ret = handle_gc_custom_private_packet(c, chat, peer, data, payload_len, userdata);
            break;
        }

        default: {
            LOGGER_WARNING(chat->log, "Warning: handling invalid lossy group packet type 0x%02x", packet_type);
            free(data);
            return false;
        }
    }

    free(data);

    if (ret < 0) {
        LOGGER_DEBUG(chat->log, "Lossy packet handle error %d: type: 0x%02x, peernumber %d", ret, packet_type,
                     peer_number);
        return false;
    }

    const uint64_t tm = mono_time_get(chat->mono_time);

    if (direct_conn) {
        gconn->last_received_direct_time = tm;
    }

    gconn->last_received_packet_time = tm;

    return true;
}

/** @brief Return true if group is either connected or attempting to connect. */
non_null()
static bool group_can_handle_packets(const GC_Chat *chat)
{
    const GC_Conn_State state = chat->connection_state;
    return state == CS_CONNECTING || state == CS_CONNECTED;
}

/** @brief Sends a group packet to appropriate handler function.
 *
 * Returns non-negative value on success.
 * Returns -1 on failure.
 */
#define MIN_TCP_PACKET_SIZE (1 + ENC_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_MAC_SIZE)
non_null(1, 3) nullable(5)
static int handle_gc_tcp_packet(void *object, int id, const uint8_t *packet, uint16_t length, void *userdata)
{
    const Messenger *m = (Messenger *)object;

    if (m == nullptr) {
        return -1;
    }

    if (length <= MIN_TCP_PACKET_SIZE) {
        LOGGER_WARNING(m->log, "Got tcp packet with invalid length: %u (expected %u to %u)", length,
                       MIN_TCP_PACKET_SIZE, MAX_GC_PACKET_CHUNK_SIZE + MIN_TCP_PACKET_SIZE + ENC_PUBLIC_KEY_SIZE);
        return -1;
    }

    if (length > MAX_GC_PACKET_CHUNK_SIZE + MIN_TCP_PACKET_SIZE + ENC_PUBLIC_KEY_SIZE) {
        LOGGER_WARNING(m->log, "Got tcp packet with invalid length: %u (expected %u to %u)", length,
                       MIN_TCP_PACKET_SIZE, MAX_GC_PACKET_CHUNK_SIZE + MIN_TCP_PACKET_SIZE + ENC_PUBLIC_KEY_SIZE);
        return -1;
    }

    const uint8_t packet_type = packet[0];

    const uint8_t *sender_pk = packet + 1;

    const GC_Session *c = m->group_handler;
    GC_Chat *chat = nullptr;

    if (packet_type == NET_PACKET_GC_HANDSHAKE) {
        chat = get_chat_by_id(c, packet + 1 + ENC_PUBLIC_KEY_SIZE);
    } else {
        chat = get_chat_by_id(c, sender_pk);
    }

    if (chat == nullptr) {
        return -1;
    }

    if (!group_can_handle_packets(chat)) {
        return -1;
    }

    const uint8_t *payload = packet + 1 + ENC_PUBLIC_KEY_SIZE;
    uint16_t payload_len = length - 1 - ENC_PUBLIC_KEY_SIZE;

    switch (packet_type) {
        case NET_PACKET_GC_LOSSLESS: {
            if (!handle_gc_lossless_packet(c, chat, sender_pk, payload, payload_len, false, userdata)) {
                return -1;
            }

            return 0;
        }

        case NET_PACKET_GC_LOSSY: {
            if (!handle_gc_lossy_packet(c, chat, sender_pk, payload, payload_len, false, userdata)) {
                return -1;
            }

            return 0;
        }

        case NET_PACKET_GC_HANDSHAKE: {
            // handshake packets have an extra public key in plaintext header
            if (length <= 1 + ENC_PUBLIC_KEY_SIZE + ENC_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_MAC_SIZE) {
                return -1;
            }

            payload_len = payload_len - ENC_PUBLIC_KEY_SIZE;
            payload = payload + ENC_PUBLIC_KEY_SIZE;

            return handle_gc_handshake_packet(chat, sender_pk, nullptr, payload, payload_len, false, userdata);
        }

        default: {
            return -1;
        }
    }
}

non_null(1, 2, 4) nullable(6)
static int handle_gc_tcp_oob_packet(void *object, const uint8_t *public_key, unsigned int tcp_connections_number,
                                    const uint8_t *packet, uint16_t length, void *userdata)
{
    const Messenger *m = (Messenger *)object;

    if (m == nullptr) {
        return -1;
    }

    if (length <= GC_MIN_HS_PACKET_PAYLOAD_SIZE) {
        LOGGER_WARNING(m->log, "Got tcp oob packet with invalid length: %u (expected %u to %u)", length,
                       GC_MIN_HS_PACKET_PAYLOAD_SIZE, MAX_GC_PACKET_CHUNK_SIZE + CRYPTO_MAC_SIZE + CRYPTO_NONCE_SIZE);
        return -1;
    }

    if (length > MAX_GC_PACKET_CHUNK_SIZE + CRYPTO_MAC_SIZE + CRYPTO_NONCE_SIZE) {
        LOGGER_WARNING(m->log, "Got tcp oob packet with invalid length: %u (expected %u to %u)", length,
                       GC_MIN_HS_PACKET_PAYLOAD_SIZE, MAX_GC_PACKET_CHUNK_SIZE + CRYPTO_MAC_SIZE + CRYPTO_NONCE_SIZE);
        return -1;
    }

    const GC_Session *c = m->group_handler;
    GC_Chat *chat = get_chat_by_id(c, packet + 1 + ENC_PUBLIC_KEY_SIZE);

    if (chat == nullptr) {
        return -1;
    }

    if (!group_can_handle_packets(chat)) {
        return -1;
    }

    const uint8_t packet_type = packet[0];

    if (packet_type != NET_PACKET_GC_HANDSHAKE) {
        return -1;
    }

    const uint8_t *sender_pk = packet + 1;

    const uint8_t *payload = packet + 1 + ENC_PUBLIC_KEY_SIZE + ENC_PUBLIC_KEY_SIZE;
    const uint16_t payload_len = length - 1 - ENC_PUBLIC_KEY_SIZE - ENC_PUBLIC_KEY_SIZE;

    if (payload_len < GC_MIN_HS_PACKET_PAYLOAD_SIZE + CRYPTO_MAC_SIZE + CRYPTO_NONCE_SIZE) {
        return -1;
    }

    if (handle_gc_handshake_packet(chat, sender_pk, nullptr, payload, payload_len, false, userdata) == -1) {
        return -1;
    }

    return 0;
}

#define MIN_UDP_PACKET_SIZE (1 + ENC_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_MAC_SIZE)
non_null(1, 2, 3) nullable(5)
static int handle_gc_udp_packet(void *object, const IP_Port *ipp, const uint8_t *packet, uint16_t length,
                                void *userdata)
{
    const Messenger *m = (Messenger *)object;

    if (m == nullptr) {
        return -1;
    }

    if (length <= MIN_UDP_PACKET_SIZE) {
        LOGGER_WARNING(m->log, "Got UDP packet with invalid length: %u (expected %u to %u)", length,
                       MIN_UDP_PACKET_SIZE, MAX_GC_PACKET_CHUNK_SIZE + MIN_UDP_PACKET_SIZE + ENC_PUBLIC_KEY_SIZE);
        return -1;
    }

    if (length > MAX_GC_PACKET_CHUNK_SIZE + MIN_UDP_PACKET_SIZE + ENC_PUBLIC_KEY_SIZE) {
        LOGGER_WARNING(m->log, "Got UDP packet with invalid length: %u (expected %u to %u)", length,
                       MIN_UDP_PACKET_SIZE, MAX_GC_PACKET_CHUNK_SIZE + MIN_UDP_PACKET_SIZE + ENC_PUBLIC_KEY_SIZE);
        return -1;
    }

    const uint8_t packet_type = packet[0];
    const uint8_t *sender_pk = packet + 1;

    const GC_Session *c = m->group_handler;
    GC_Chat *chat = nullptr;

    if (packet_type == NET_PACKET_GC_HANDSHAKE) {
        chat = get_chat_by_id(c, packet + 1 + ENC_PUBLIC_KEY_SIZE);
    } else {
        chat = get_chat_by_id(c, sender_pk);
    }

    if (chat == nullptr) {
        return -1;
    }

    if (!group_can_handle_packets(chat)) {
        return -1;
    }

    const uint8_t *payload = packet + 1 + ENC_PUBLIC_KEY_SIZE;
    uint16_t payload_len = length - 1 - ENC_PUBLIC_KEY_SIZE;
    bool ret = false;

    switch (packet_type) {
        case NET_PACKET_GC_LOSSLESS: {
            ret = handle_gc_lossless_packet(c, chat, sender_pk, payload, payload_len, true, userdata);
            break;
        }

        case NET_PACKET_GC_LOSSY: {
            ret = handle_gc_lossy_packet(c, chat, sender_pk, payload, payload_len, true, userdata);
            break;
        }

        case NET_PACKET_GC_HANDSHAKE: {
            // handshake packets have an extra public key in plaintext header
            if (length <= 1 + ENC_PUBLIC_KEY_SIZE + ENC_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_MAC_SIZE) {
                return -1;
            }

            payload_len = payload_len - ENC_PUBLIC_KEY_SIZE;
            payload = payload + ENC_PUBLIC_KEY_SIZE;

            ret = handle_gc_handshake_packet(chat, sender_pk, ipp, payload, payload_len, true, userdata) != -1;
            break;
        }

        default: {
            return -1;
        }
    }

    return ret ? 0 : -1;
}

void gc_callback_message(const Messenger *m, gc_message_cb *function)
{
    GC_Session *c = m->group_handler;
    c->message = function;
}

void gc_callback_private_message(const Messenger *m, gc_private_message_cb *function)
{
    GC_Session *c = m->group_handler;
    c->private_message = function;
}

void gc_callback_custom_packet(const Messenger *m, gc_custom_packet_cb *function)
{
    GC_Session *c = m->group_handler;
    c->custom_packet = function;
}

void gc_callback_custom_private_packet(const Messenger *m, gc_custom_private_packet_cb *function)
{
    GC_Session *c = m->group_handler;
    c->custom_private_packet = function;
}

void gc_callback_moderation(const Messenger *m, gc_moderation_cb *function)
{
    GC_Session *c = m->group_handler;
    c->moderation = function;
}

void gc_callback_nick_change(const Messenger *m, gc_nick_change_cb *function)
{
    GC_Session *c = m->group_handler;
    c->nick_change = function;
}

void gc_callback_status_change(const Messenger *m, gc_status_change_cb *function)
{
    GC_Session *c = m->group_handler;
    c->status_change = function;
}

void gc_callback_connection_status_change(const Messenger *m, gc_connection_status_change_cb *function)
{
    GC_Session *c = m->group_handler;
    c->connection_status_change = function;
}

void gc_callback_topic_change(const Messenger *m, gc_topic_change_cb *function)
{
    GC_Session *c = m->group_handler;
    c->topic_change = function;
}

void gc_callback_topic_lock(const Messenger *m, gc_topic_lock_cb *function)
{
    GC_Session *c = m->group_handler;
    c->topic_lock = function;
}

void gc_callback_voice_state(const Messenger *m, gc_voice_state_cb *function)
{
    GC_Session *c = m->group_handler;
    c->voice_state = function;
}

void gc_callback_peer_limit(const Messenger *m, gc_peer_limit_cb *function)
{
    GC_Session *c = m->group_handler;
    c->peer_limit = function;
}

void gc_callback_privacy_state(const Messenger *m, gc_privacy_state_cb *function)
{
    GC_Session *c = m->group_handler;
    c->privacy_state = function;
}

void gc_callback_password(const Messenger *m, gc_password_cb *function)
{
    GC_Session *c = m->group_handler;
    c->password = function;
}

void gc_callback_peer_join(const Messenger *m, gc_peer_join_cb *function)
{
    GC_Session *c = m->group_handler;
    c->peer_join = function;
}

void gc_callback_peer_exit(const Messenger *m, gc_peer_exit_cb *function)
{
    GC_Session *c = m->group_handler;
    c->peer_exit = function;
}

void gc_callback_self_join(const Messenger *m, gc_self_join_cb *function)
{
    GC_Session *c = m->group_handler;
    c->self_join = function;
}

void gc_callback_rejected(const Messenger *m, gc_rejected_cb *function)
{
    GC_Session *c = m->group_handler;
    c->rejected = function;
}

/** @brief Deletes peer_number from group.
 *
 * `no_callback` should be set to true if the `peer_exit` callback
 * should not be triggered.
 *
 * Return true on success.
 */
static bool peer_delete(const GC_Session *c, GC_Chat *chat, uint32_t peer_number, void *userdata)
{
    GC_Peer *peer = get_gc_peer(chat, peer_number);

    if (peer == nullptr) {
        return false;
    }

    // We need to save some peer info for the callback before deleting it
    const bool peer_confirmed = peer->gconn.confirmed;
    const uint32_t peer_id = peer->peer_id;
    uint8_t nick[MAX_GC_NICK_SIZE];
    const uint16_t nick_length = peer->nick_length;
    const GC_Exit_Info exit_info = peer->gconn.exit_info;

    assert(nick_length <= MAX_GC_NICK_SIZE);
    memcpy(nick, peer->nick, nick_length);

    gcc_peer_cleanup(&peer->gconn);

    --chat->numpeers;

    if (chat->numpeers != peer_number) {
        chat->group[peer_number] = chat->group[chat->numpeers];
    }

    chat->group[chat->numpeers] = (GC_Peer) {
        0
    };

    GC_Peer *tmp_group = (GC_Peer *)realloc(chat->group, chat->numpeers * sizeof(GC_Peer));

    if (tmp_group == nullptr) {
        return false;
    }

    chat->group = tmp_group;

    set_gc_peerlist_checksum(chat);

    if (peer_confirmed) {
        refresh_gc_saved_peers(chat);
    }

    if (exit_info.exit_type != GC_EXIT_TYPE_NO_CALLBACK && c->peer_exit != nullptr && peer_confirmed) {
        c->peer_exit(c->messenger, chat->group_number, peer_id, exit_info.exit_type, nick,
                     nick_length, exit_info.part_message, exit_info.length, userdata);
    }

    return true;
}

/** @brief Updates peer_number with info from `peer` and validates peer data.
 *
 * Returns peer_number on success.
 * Returns -1 on failure.
 */
static int peer_update(const GC_Chat *chat, const GC_Peer *peer, uint32_t peer_number)
{
    if (peer->nick_length == 0) {
        return -1;
    }

    if (peer->status > GS_BUSY) {
        return -1;
    }

    if (peer->role > GR_OBSERVER) {
        return -1;
    }

    GC_Peer *curr_peer = get_gc_peer(chat, peer_number);
    assert(curr_peer != nullptr);

    curr_peer->status = peer->status;
    curr_peer->nick_length = peer->nick_length;

    memcpy(curr_peer->nick, peer->nick, peer->nick_length);

    return peer_number;
}

int peer_add(GC_Chat *chat, const IP_Port *ipp, const uint8_t *public_key)
{
    if (get_peer_number_of_enc_pk(chat, public_key, false) != -1) {
        return -2;
    }

    const uint32_t peer_id = get_new_peer_id(chat);

    if (peer_id == UINT32_MAX) {
        LOGGER_WARNING(chat->log, "Failed to add peer: all peer ID's are taken?");
        return -1;
    }

    const int peer_number = chat->numpeers;
    int tcp_connection_num = -1;

    if (peer_number > 0) {  // we don't need a connection to ourself
        tcp_connection_num = new_tcp_connection_to(chat->tcp_conn, public_key, 0);

        if (tcp_connection_num == -1) {
            LOGGER_WARNING(chat->log, "Failed to init tcp connection for peer %d", peer_number);
        }
    }

    GC_Message_Array_Entry *send = (GC_Message_Array_Entry *)calloc(GCC_BUFFER_SIZE, sizeof(GC_Message_Array_Entry));
    GC_Message_Array_Entry *recv = (GC_Message_Array_Entry *)calloc(GCC_BUFFER_SIZE, sizeof(GC_Message_Array_Entry));

    if (send == nullptr || recv == nullptr) {
        LOGGER_ERROR(chat->log, "Failed to allocate memory for gconn buffers");

        if (tcp_connection_num != -1) {
            kill_tcp_connection_to(chat->tcp_conn, tcp_connection_num);
        }

        free(send);
        free(recv);
        return -1;
    }

    GC_Peer *tmp_group = (GC_Peer *)realloc(chat->group, (chat->numpeers + 1) * sizeof(GC_Peer));

    if (tmp_group == nullptr) {
        LOGGER_ERROR(chat->log, "Failed to allocate memory for group realloc");

        if (tcp_connection_num != -1) {
            kill_tcp_connection_to(chat->tcp_conn, tcp_connection_num);
        }

        free(send);
        free(recv);
        return -1;
    }

    ++chat->numpeers;
    chat->group = tmp_group;

    chat->group[peer_number] = (GC_Peer) {
        0
    };

    GC_Connection *gconn = &chat->group[peer_number].gconn;

    gconn->send_array = send;
    gconn->recv_array = recv;

    gcc_set_ip_port(gconn, ipp);
    chat->group[peer_number].role = GR_USER;
    chat->group[peer_number].peer_id = peer_id;
    chat->group[peer_number].ignore = false;

    crypto_memlock(gconn->session_secret_key, sizeof(gconn->session_secret_key));

    create_gc_session_keypair(chat->log, chat->rng, gconn->session_public_key, gconn->session_secret_key);

    if (peer_number > 0) {
        memcpy(gconn->addr.public_key, public_key, ENC_PUBLIC_KEY_SIZE);  // we get the sig key in the handshake
    } else {
        memcpy(gconn->addr.public_key, chat->self_public_key, EXT_PUBLIC_KEY_SIZE);
    }

    const uint64_t tm = mono_time_get(chat->mono_time);

    gcc_set_send_message_id(gconn, 1);
    gconn->public_key_hash = gc_get_pk_jenkins_hash(public_key);
    gconn->last_received_packet_time = tm;
    gconn->last_key_rotation = tm;
    gconn->tcp_connection_num = tcp_connection_num;
    gconn->last_sent_ip_time = tm;
    gconn->last_sent_ping_time = tm - (GC_PING_TIMEOUT / 2) + (peer_number % (GC_PING_TIMEOUT / 2));
    gconn->self_is_closer = id_closest(get_chat_id(chat->chat_public_key),
                                       get_enc_key(chat->self_public_key),
                                       get_enc_key(gconn->addr.public_key)) == 1;
    return peer_number;
}

/** @brief Copies own peer data to `peer`. */
non_null()
static void copy_self(const GC_Chat *chat, GC_Peer *peer)
{
    *peer = (GC_Peer) {
        0
    };

    peer->status = gc_get_self_status(chat);
    gc_get_self_nick(chat, peer->nick);
    peer->nick_length = gc_get_self_nick_size(chat);
    peer->role = gc_get_self_role(chat);
}

/** @brief Returns true if we haven't received a ping from this peer after n seconds.
 * n depends on whether or not the peer has been confirmed.
 */
non_null()
static bool peer_timed_out(const Mono_Time *mono_time, const GC_Connection *gconn)
{
    return mono_time_is_timeout(mono_time, gconn->last_received_packet_time, gconn->confirmed
                                ? GC_CONFIRMED_PEER_TIMEOUT
                                : GC_UNCONFIRMED_PEER_TIMEOUT);
}

/** @brief Attempts to send pending handshake packets to peer designated by `gconn`.
 *
 * One request of each type can be sent per `GC_SEND_HANDSHAKE_INTERVAL` seconds.
 *
 * Return true on success.
 */
non_null()
static bool send_pending_handshake(const GC_Chat *chat, GC_Connection *gconn)
{
    if (chat == nullptr || gconn == nullptr) {
        return false;
    }

    if (gconn->is_pending_handshake_response) {
        if (!mono_time_is_timeout(chat->mono_time, gconn->last_handshake_response, GC_SEND_HANDSHAKE_INTERVAL)) {
            return true;
        }

        gconn->last_handshake_response = mono_time_get(chat->mono_time);

        return send_gc_handshake_response(chat, gconn);
    }

    if (!mono_time_is_timeout(chat->mono_time, gconn->last_handshake_request, GC_SEND_HANDSHAKE_INTERVAL)) {
        return true;
    }

    gconn->last_handshake_request = mono_time_get(chat->mono_time);

    if (gconn->is_oob_handshake) {
        return send_gc_oob_handshake_request(chat, gconn);
    }

    return send_gc_handshake_packet(chat, gconn, GH_REQUEST, gconn->pending_handshake_type, chat->join_type);
}

#define GC_TCP_RELAY_SEND_INTERVAL (60 * 3)
non_null(1, 2) nullable(3)
static void do_peer_connections(const GC_Session *c, GC_Chat *chat, void *userdata)
{
    for (uint32_t i = 1; i < chat->numpeers; ++i) {
        GC_Connection *gconn = get_gc_connection(chat, i);
        assert(gconn != nullptr);

        if (gconn->pending_delete) {
            continue;
        }

        if (peer_timed_out(chat->mono_time, gconn)) {
            gcc_mark_for_deletion(gconn, chat->tcp_conn, GC_EXIT_TYPE_TIMEOUT, nullptr, 0);
            continue;
        }

        gcc_resend_packets(chat, gconn);

        if (gconn->tcp_relays_count > 0 &&
                mono_time_is_timeout(chat->mono_time, gconn->last_sent_tcp_relays_time, GC_TCP_RELAY_SEND_INTERVAL)) {
            if (gconn->confirmed) {
                send_gc_tcp_relays(chat, gconn);
                gconn->last_sent_tcp_relays_time = mono_time_get(chat->mono_time);
            }
        }

        gcc_check_recv_array(c, chat, gconn, i, userdata);   // may change peer numbers
    }
}

/** @brief Executes pending handshakes for peers.
 *
 * If our peerlist is empty we periodically try to
 * load peers from our saved peers list and initiate handshake requests with them.
 */
#define LOAD_PEERS_TIMEOUT (GC_UNCONFIRMED_PEER_TIMEOUT + 10)
non_null()
static void do_handshakes(GC_Chat *chat)
{
    for (uint32_t i = 1; i < chat->numpeers; ++i) {
        GC_Connection *gconn = get_gc_connection(chat, i);
        assert(gconn != nullptr);

        if (gconn->handshaked || gconn->pending_delete) {
            continue;
        }

        send_pending_handshake(chat, gconn);
    }

    if (chat->numpeers <= 1) {
        const uint64_t tm = mono_time_get(chat->mono_time);

        if (mono_time_is_timeout(chat->mono_time, chat->last_time_peers_loaded, LOAD_PEERS_TIMEOUT)) {
            load_gc_peers(chat, chat->saved_peers, GC_MAX_SAVED_PEERS);
            chat->last_time_peers_loaded = tm;
        }
    }
}

/** @brief Adds `gconn` to the group timeout list. */
non_null()
static void add_gc_peer_timeout_list(GC_Chat *chat, const GC_Connection *gconn)
{
    const size_t idx = chat->timeout_list_index;
    const uint64_t tm = mono_time_get(chat->mono_time);

    copy_gc_saved_peer(chat->rng, gconn, &chat->timeout_list[idx].addr);

    chat->timeout_list[idx].last_seen = tm;
    chat->timeout_list[idx].last_reconn_try = 0;
    chat->timeout_list_index = (idx + 1) % MAX_GC_SAVED_TIMEOUTS;
}

non_null(1, 2) nullable(3)
static void do_peer_delete(const GC_Session *c, GC_Chat *chat, void *userdata)
{
    for (uint32_t i = 1; i < chat->numpeers; ++i) {
        const GC_Connection *gconn = get_gc_connection(chat, i);
        assert(gconn != nullptr);

        if (gconn->pending_delete) {
            const GC_Exit_Info *exit_info = &gconn->exit_info;

            if (exit_info->exit_type == GC_EXIT_TYPE_TIMEOUT && gconn->confirmed) {
                add_gc_peer_timeout_list(chat, gconn);
            }

            if (!peer_delete(c, chat, i, userdata)) {
                LOGGER_ERROR(chat->log, "Failed to delete peer %u", i);
            }

            if (i >= chat->numpeers) {
                break;
            }
        }
    }
}

/** @brief Constructs and sends a ping packet to `gconn` containing info needed for group syncing
 * and connection maintenance.
 *
 * Return true on success.
 */
non_null()
static bool ping_peer(const GC_Chat *chat, const GC_Connection *gconn)
{
    const uint16_t buf_size = GC_PING_PACKET_MIN_DATA_SIZE + sizeof(IP_Port);
    uint8_t *data = (uint8_t *)malloc(buf_size);

    if (data == nullptr) {
        return false;
    }

    const uint16_t roles_checksum = chat->moderation.sanctions_creds.checksum + chat->roles_checksum;
    uint16_t packed_len = 0;

    net_pack_u16(data, chat->peers_checksum);
    packed_len += sizeof(uint16_t);

    net_pack_u16(data + packed_len, get_gc_confirmed_numpeers(chat));
    packed_len += sizeof(uint16_t);

    net_pack_u32(data + packed_len, chat->shared_state.version);
    packed_len += sizeof(uint32_t);

    net_pack_u32(data + packed_len, chat->moderation.sanctions_creds.version);
    packed_len += sizeof(uint32_t);

    net_pack_u16(data + packed_len, roles_checksum);
    packed_len += sizeof(uint16_t);

    net_pack_u32(data + packed_len, chat->topic_info.version);
    packed_len += sizeof(uint32_t);

    net_pack_u16(data + packed_len, chat->topic_info.checksum);
    packed_len += sizeof(uint16_t);

    if (packed_len != GC_PING_PACKET_MIN_DATA_SIZE) {
        LOGGER_FATAL(chat->log, "Packed length is impossible");
    }

    if (chat->self_udp_status == SELF_UDP_STATUS_WAN && !gcc_conn_is_direct(chat->mono_time, gconn)
            && mono_time_is_timeout(chat->mono_time, gconn->last_sent_ip_time, GC_SEND_IP_PORT_INTERVAL)) {

        const int packed_ipp_len = pack_ip_port(chat->log, data + buf_size - sizeof(IP_Port), sizeof(IP_Port),
                                                &chat->self_ip_port);

        if (packed_ipp_len > 0) {
            packed_len += packed_ipp_len;
        }
    }

    if (!send_lossy_group_packet(chat, gconn, data, packed_len, GP_PING)) {
        free(data);
        return false;
    }

    free(data);

    return true;
}

/**
 * Sends a ping packet to peers that haven't been pinged in at least GC_PING_TIMEOUT seconds, and
 * a key rotation request to peers with whom we haven't refreshed keys in at least GC_KEY_ROTATION_TIMEOUT
 * seconds.
 *
 * Ping packet always includes your confirmed peer count, a peer list checksum, your shared state and sanctions
 * list version for syncing purposes. We also occasionally try to send our own IP info to peers that we
 * do not have a direct connection with.
 */
#define GC_DO_PINGS_INTERVAL 2
non_null()
static void do_gc_ping_and_key_rotation(GC_Chat *chat)
{
    if (!mono_time_is_timeout(chat->mono_time, chat->last_ping_interval, GC_DO_PINGS_INTERVAL)) {
        return;
    }

    const uint64_t tm = mono_time_get(chat->mono_time);

    for (uint32_t i = 1; i < chat->numpeers; ++i) {
        GC_Connection *gconn = get_gc_connection(chat, i);
        assert(gconn != nullptr);

        if (!gconn->confirmed) {
            continue;
        }

        if (mono_time_is_timeout(chat->mono_time, gconn->last_sent_ping_time, GC_PING_TIMEOUT)) {
            if (ping_peer(chat, gconn)) {
                gconn->last_sent_ping_time = tm;
            }
        }

        if (mono_time_is_timeout(chat->mono_time, gconn->last_key_rotation, GC_KEY_ROTATION_TIMEOUT)) {
            if (send_peer_key_rotation_request(chat, gconn)) {
                gconn->last_key_rotation = tm;
            }
        }
    }

    chat->last_ping_interval = tm;
}

non_null()
static void do_new_connection_cooldown(GC_Chat *chat)
{
    if (chat->connection_O_metre == 0) {
        return;
    }

    const uint64_t tm = mono_time_get(chat->mono_time);

    if (chat->connection_cooldown_timer < tm) {
        chat->connection_cooldown_timer = tm;
        --chat->connection_O_metre;

        if (chat->connection_O_metre == 0 && chat->block_handshakes) {
            chat->block_handshakes = false;
            LOGGER_DEBUG(chat->log, "Unblocking handshakes");
        }
    }
}

#define TCP_RELAYS_CHECK_INTERVAL 10
non_null(1, 2) nullable(3)
static void do_gc_tcp(const GC_Session *c, GC_Chat *chat, void *userdata)
{
    if (chat->tcp_conn == nullptr || !group_can_handle_packets(chat)) {
        return;
    }

    do_tcp_connections(chat->log, chat->tcp_conn, userdata);

    for (uint32_t i = 1; i < chat->numpeers; ++i) {
        const GC_Connection *gconn = get_gc_connection(chat, i);
        assert(gconn != nullptr);

        const bool tcp_set = !gcc_conn_is_direct(chat->mono_time, gconn);
        set_tcp_connection_to_status(chat->tcp_conn, gconn->tcp_connection_num, tcp_set);
    }

    if (mono_time_is_timeout(chat->mono_time, chat->last_checked_tcp_relays, TCP_RELAYS_CHECK_INTERVAL)
            && tcp_connected_relays_count(chat->tcp_conn) != chat->connected_tcp_relays) {
        add_tcp_relays_to_chat(c, chat);
        chat->connected_tcp_relays = tcp_connected_relays_count(chat->tcp_conn);
        chat->last_checked_tcp_relays = mono_time_get(chat->mono_time);
    }
}

/**
 * Updates our TCP and UDP connection status and flags a new announcement if our connection has
 * changed and we have either a UDP or TCP connection.
 */
#define GC_SELF_CONNECTION_CHECK_INTERVAL 5  // how often in seconds we should run this function
#define GC_SELF_REFRESH_ANNOUNCE_INTERVAL (60 * 20)  // how often in seconds we force refresh our group announcement
non_null()
static void do_self_connection(const GC_Session *c, GC_Chat *chat)
{
    if (!mono_time_is_timeout(chat->mono_time, chat->last_self_announce_check, GC_SELF_CONNECTION_CHECK_INTERVAL)) {
        return;
    }

    const unsigned int self_udp_status = ipport_self_copy(c->messenger->dht, &chat->self_ip_port);
    const bool udp_change = (chat->self_udp_status != self_udp_status) && (self_udp_status != SELF_UDP_STATUS_NONE);

    // We flag a group announce if our UDP status has changed since last run, or if our last announced TCP
    // relay is no longer valid. Additionally, we will always flag an announce in the specified interval
    // regardless of the prior conditions. Private groups are never announced.
    if (is_public_chat(chat) &&
            ((udp_change || !tcp_relay_is_valid(chat->tcp_conn, chat->announced_tcp_relay_pk))
             || mono_time_is_timeout(chat->mono_time, chat->last_time_self_announce, GC_SELF_REFRESH_ANNOUNCE_INTERVAL))) {
        chat->update_self_announces = true;
    }

    chat->self_udp_status = (Self_UDP_Status) self_udp_status;
    chat->last_self_announce_check = mono_time_get(chat->mono_time);
}

/** @brief Attempts to initiate a new connection with peers in the timeout list.
 *
 * This function is not used for public groups as the DHT and group sync mechanism
 * should automatically do this for us.
 */
#define TIMED_OUT_RECONN_INTERVAL 2
non_null()
static void do_timed_out_reconn(GC_Chat *chat)
{
    if (is_public_chat(chat)) {
        return;
    }

    if (!mono_time_is_timeout(chat->mono_time, chat->last_timed_out_reconn_try, TIMED_OUT_RECONN_INTERVAL)) {
        return;
    }

    const uint64_t curr_time = mono_time_get(chat->mono_time);

    for (size_t i = 0; i < MAX_GC_SAVED_TIMEOUTS; ++i) {
        GC_TimedOutPeer *timeout = &chat->timeout_list[i];

        if (timeout->last_seen == 0 || timeout->last_seen == curr_time) {
            continue;
        }

        if (mono_time_is_timeout(chat->mono_time, timeout->last_seen, GC_TIMED_OUT_STALE_TIMEOUT)
                || get_peer_number_of_enc_pk(chat, timeout->addr.public_key, true) != -1) {
            *timeout = (GC_TimedOutPeer) {
                {{
                        0
                    }
                }
            };
            continue;
        }

        if (mono_time_is_timeout(chat->mono_time, timeout->last_reconn_try, GC_TIMED_OUT_RECONN_TIMEOUT)) {
            if (load_gc_peers(chat, &timeout->addr, 1) != 1) {
                LOGGER_WARNING(chat->log, "Failed to load timed out peer");
            }

            timeout->last_reconn_try = curr_time;
        }
    }

    chat->last_timed_out_reconn_try = curr_time;
}

void do_gc(GC_Session *c, void *userdata)
{
    if (c == nullptr) {
        return;
    }

    for (uint32_t i = 0; i < c->chats_index; ++i) {
        GC_Chat *chat = &c->chats[i];

        const GC_Conn_State state = chat->connection_state;

        if (state == CS_NONE) {
            continue;
        }

        if (state != CS_DISCONNECTED) {
            do_peer_connections(c, chat, userdata);
            do_gc_tcp(c, chat, userdata);
            do_handshakes(chat);
            do_self_connection(c, chat);
        }

        if (chat->connection_state == CS_CONNECTED) {
            do_gc_ping_and_key_rotation(chat);
            do_timed_out_reconn(chat);
        }

        do_new_connection_cooldown(chat);
        do_peer_delete(c, chat, userdata);

        if (chat->connection_state != state) {
            if (c->connection_status_change != nullptr) {
                c->connection_status_change(c->messenger, chat->group_number, chat->connection_state, userdata);
            }
        }

        if (chat->flag_exit) {  // should always come last as it modifies the chats array
            group_delete(c, chat);
        }
    }
}

/** @brief Set the size of the groupchat list to n.
 *
 * Return true on success.
 */
non_null()
static bool realloc_groupchats(GC_Session *c, uint32_t n)
{
    if (n == 0) {
        free(c->chats);
        c->chats = nullptr;
        return true;
    }

    GC_Chat *temp = (GC_Chat *)realloc(c->chats, n * sizeof(GC_Chat));

    if (temp == nullptr) {
        return false;
    }

    c->chats = temp;
    return true;
}

non_null()
static int get_new_group_index(GC_Session *c)
{
    if (c == nullptr) {
        return -1;
    }

    for (uint32_t i = 0; i < c->chats_index; ++i) {
        if (c->chats[i].connection_state == CS_NONE) {
            return i;
        }
    }

    if (!realloc_groupchats(c, c->chats_index + 1)) {
        return -1;
    }

    const int new_index = c->chats_index;

    c->chats[new_index] = empty_gc_chat;

    memset(&c->chats[new_index].saved_invites, -1, sizeof(c->chats[new_index].saved_invites));

    ++c->chats_index;

    return new_index;
}

/** Attempts to associate new TCP relays with our group connection. */
static void add_tcp_relays_to_chat(const GC_Session *c, GC_Chat *chat)
{
    const Messenger *m = c->messenger;

    const uint32_t num_relays = tcp_connections_count(nc_get_tcp_c(m->net_crypto));

    if (num_relays == 0) {
        return;
    }

    Node_format *tcp_relays = (Node_format *)calloc(num_relays, sizeof(Node_format));

    if (tcp_relays == nullptr) {
        return;
    }

    const uint32_t num_copied = tcp_copy_connected_relays(nc_get_tcp_c(m->net_crypto), tcp_relays, (uint16_t)num_relays);

    for (uint32_t i = 0; i < num_copied; ++i) {
        add_tcp_relay_global(chat->tcp_conn, &tcp_relays[i].ip_port, tcp_relays[i].public_key);
    }

    free(tcp_relays);
}

non_null()
static bool init_gc_tcp_connection(const GC_Session *c, GC_Chat *chat)
{
    const Messenger *m = c->messenger;

    chat->tcp_conn = new_tcp_connections(chat->log, chat->rng, m->ns, chat->mono_time, chat->self_secret_key,
                                         &m->options.proxy_info);

    if (chat->tcp_conn == nullptr) {
        return false;
    }

    add_tcp_relays_to_chat(c, chat);

    set_packet_tcp_connection_callback(chat->tcp_conn, &handle_gc_tcp_packet, c->messenger);
    set_oob_packet_tcp_connection_callback(chat->tcp_conn, &handle_gc_tcp_oob_packet, c->messenger);

    return true;
}

/** Initializes default shared state values. */
non_null()
static void init_gc_shared_state(GC_Chat *chat, const Group_Privacy_State privacy_state)
{
    chat->shared_state.maxpeers = MAX_GC_PEERS_DEFAULT;
    chat->shared_state.privacy_state = privacy_state;
    chat->shared_state.topic_lock = GC_TOPIC_LOCK_ENABLED;
    chat->shared_state.voice_state = GV_ALL;
}

/** @brief Initializes the group shared state for the founder.
 *
 * Return true on success.
 */
non_null()
static bool init_gc_shared_state_founder(GC_Chat *chat, Group_Privacy_State privacy_state, const uint8_t *group_name,
        uint16_t name_length)
{
    memcpy(chat->shared_state.founder_public_key, chat->self_public_key, EXT_PUBLIC_KEY_SIZE);
    memcpy(chat->shared_state.group_name, group_name, name_length);
    chat->shared_state.group_name_len = name_length;
    chat->shared_state.privacy_state = privacy_state;

    return sign_gc_shared_state(chat);
}

/** @brief Initializes shared state for moderation object.
 *
 * This must be called before any moderation
 * or sanctions related operations.
 */
non_null()
static void init_gc_moderation(GC_Chat *chat)
{
    memcpy(chat->moderation.founder_public_sig_key,
           get_sig_pk(chat->shared_state.founder_public_key), SIG_PUBLIC_KEY_SIZE);
    memcpy(chat->moderation.self_public_sig_key, get_sig_pk(chat->self_public_key), SIG_PUBLIC_KEY_SIZE);
    memcpy(chat->moderation.self_secret_sig_key, get_sig_pk(chat->self_secret_key), SIG_SECRET_KEY_SIZE);
    chat->moderation.shared_state_version = chat->shared_state.version;
    chat->moderation.log = chat->log;
}

non_null()
static bool create_new_chat_ext_keypair(GC_Chat *chat);

non_null()
static int create_new_group(GC_Session *c, const uint8_t *nick, size_t nick_length, bool founder,
                            const Group_Privacy_State privacy_state)
{
    if (nick == nullptr || nick_length == 0) {
        return -1;
    }

    if (nick_length > MAX_GC_NICK_SIZE) {
        return -1;
    }

    const int group_number = get_new_group_index(c);

    if (group_number == -1) {
        return -1;
    }

    Messenger *m = c->messenger;
    GC_Chat *chat = &c->chats[group_number];

    chat->log = m->log;
    chat->rng = m->rng;

    const uint64_t tm = mono_time_get(m->mono_time);

    chat->group_number = group_number;
    chat->numpeers = 0;
    chat->connection_state = CS_CONNECTING;
    chat->net = m->net;
    chat->mono_time = m->mono_time;
    chat->last_ping_interval = tm;
    chat->friend_connection_id = -1;

    if (!create_new_chat_ext_keypair(chat)) {
        LOGGER_ERROR(chat->log, "Failed to create extended keypair");
        group_delete(c, chat);
        return -1;
    }

    if (!init_gc_tcp_connection(c, chat)) {
        group_delete(c, chat);
        return -1;
    }

    if (peer_add(chat, nullptr, chat->self_public_key) != 0) {    /* you are always peer_number/index 0 */
        group_delete(c, chat);
        return -1;
    }

    if (!self_gc_set_nick(chat, nick, (uint16_t)nick_length)) {
        group_delete(c, chat);
        return -1;
    }

    self_gc_set_status(chat, GS_NONE);
    self_gc_set_role(chat, founder ? GR_FOUNDER : GR_USER);
    self_gc_set_confirmed(chat, true);
    self_gc_set_ext_public_key(chat, chat->self_public_key);

    init_gc_shared_state(chat, privacy_state);
    init_gc_moderation(chat);

    return group_number;
}

/** @brief Inits the sanctions list credentials.
 *
 * This should be called by the group founder on creation.
 *
 * This function must be called after `init_gc_moderation()`.
 *
 * Return true on success.
 */
non_null()
static bool init_gc_sanctions_creds(GC_Chat *chat)
{
    return sanctions_list_make_creds(&chat->moderation);
}

/** @brief Attempts to add `num_addrs` peers from `addrs` to our peerlist and initiate invite requests
 * for all of them.
 *
 * Returns the number of peers successfully loaded.
 */
static size_t load_gc_peers(GC_Chat *chat, const GC_SavedPeerInfo *addrs, uint16_t num_addrs)
{
    size_t count = 0;

    for (size_t i = 0; i < num_addrs; ++i) {
        if (!saved_peer_is_valid(&addrs[i])) {
            continue;
        }

        const bool ip_port_is_set = ipport_isset(&addrs[i].ip_port);
        const IP_Port *ip_port = ip_port_is_set ? &addrs[i].ip_port : nullptr;

        const int peer_number = peer_add(chat, ip_port, addrs[i].public_key);

        GC_Connection *gconn = get_gc_connection(chat, peer_number);

        if (gconn == nullptr) {
            continue;
        }

        add_tcp_relay_global(chat->tcp_conn, &addrs[i].tcp_relay.ip_port, addrs[i].tcp_relay.public_key);

        const int add_tcp_result = add_tcp_relay_connection(chat->tcp_conn, gconn->tcp_connection_num,
                                   &addrs[i].tcp_relay.ip_port,
                                   addrs[i].tcp_relay.public_key);

        if (add_tcp_result == -1 && !ip_port_is_set) {
            gcc_mark_for_deletion(gconn, chat->tcp_conn, GC_EXIT_TYPE_DISCONNECTED, nullptr, 0);
            continue;
        }

        if (add_tcp_result == 0) {
            const int save_tcp_result = gcc_save_tcp_relay(chat->rng, gconn, &addrs[i].tcp_relay);

            if (save_tcp_result == -1) {
                gcc_mark_for_deletion(gconn, chat->tcp_conn, GC_EXIT_TYPE_DISCONNECTED, nullptr, 0);
                continue;
            }

            memcpy(gconn->oob_relay_pk, addrs[i].tcp_relay.public_key, CRYPTO_PUBLIC_KEY_SIZE);
        }

        const uint64_t tm = mono_time_get(chat->mono_time);

        gconn->is_oob_handshake = !gcc_direct_conn_is_possible(chat, gconn);
        gconn->is_pending_handshake_response = false;
        gconn->pending_handshake_type = HS_INVITE_REQUEST;
        gconn->last_received_packet_time = tm;
        gconn->last_key_rotation = tm;

        ++count;
    }

    update_gc_peer_roles(chat);

    return count;
}

void gc_group_save(const GC_Chat *chat, Bin_Pack *bp)
{
    gc_save_pack_group(chat, bp);
}

int gc_group_load(GC_Session *c, Bin_Unpack *bu)
{
    const int group_number = get_new_group_index(c);

    if (group_number < 0) {
        return -1;
    }

    const uint64_t tm = mono_time_get(c->messenger->mono_time);

    Messenger *m = c->messenger;
    GC_Chat *chat = &c->chats[group_number];

    chat->group_number = group_number;
    chat->numpeers = 0;
    chat->net = m->net;
    chat->mono_time = m->mono_time;
    chat->log = m->log;
    chat->rng = m->rng;
    chat->last_ping_interval = tm;
    chat->friend_connection_id = -1;

    // Initialise these first, because we may need to log/dealloc things on cleanup.
    chat->moderation.log = m->log;

    if (!gc_load_unpack_group(chat, bu)) {
        LOGGER_ERROR(chat->log, "Failed to unpack group");
        return -1;
    }

    init_gc_moderation(chat);

    if (!init_gc_tcp_connection(c, chat)) {
        LOGGER_ERROR(chat->log, "Failed to init tcp connection");
        return -1;
    }

    if (chat->connection_state == CS_DISCONNECTED) {
        return group_number;
    }

    if (is_public_chat(chat)) {
        if (!m_create_group_connection(m, chat)) {
            LOGGER_ERROR(chat->log, "Failed to initialize group friend connection");
        }
    }

    return group_number;
}

int gc_group_add(GC_Session *c, Group_Privacy_State privacy_state, const uint8_t *group_name,
                 uint16_t group_name_length,
                 const uint8_t *nick, size_t nick_length)
{
    if (group_name_length > MAX_GC_GROUP_NAME_SIZE) {
        return -1;
    }

    if (nick_length > MAX_GC_NICK_SIZE) {
        return -1;
    }

    if (group_name_length == 0 || group_name == nullptr) {
        return -2;
    }

    if (nick_length == 0 || nick == nullptr) {
        return -2;
    }

    const int group_number = create_new_group(c, nick, nick_length, true, privacy_state);

    if (group_number == -1) {
        return -3;
    }

    GC_Chat *chat = gc_get_group(c, group_number);

    if (chat == nullptr) {
        return -3;
    }

    crypto_memlock(chat->chat_secret_key, sizeof(chat->chat_secret_key));

    create_extended_keypair(chat->chat_public_key, chat->chat_secret_key);

    if (!init_gc_shared_state_founder(chat, privacy_state, group_name, group_name_length)) {
        group_delete(c, chat);
        return -4;
    }

    init_gc_moderation(chat);

    if (!init_gc_sanctions_creds(chat)) {
        group_delete(c, chat);
        return -4;
    }

    if (gc_set_topic(chat, nullptr, 0) != 0) {
        group_delete(c, chat);
        return -4;
    }

    chat->join_type = HJ_PRIVATE;
    chat->connection_state = CS_CONNECTED;
    chat->time_connected = mono_time_get(c->messenger->mono_time);

    if (is_public_chat(chat)) {
        if (!m_create_group_connection(c->messenger, chat)) {
            LOGGER_ERROR(chat->log, "Failed to initialize group friend connection");
            group_delete(c, chat);
            return -5;
        }

        chat->join_type = HJ_PUBLIC;
    }

    update_gc_peer_roles(chat);

    return group_number;
}

int gc_group_join(GC_Session *c, const uint8_t *chat_id, const uint8_t *nick, size_t nick_length, const uint8_t *passwd,
                  uint16_t passwd_len)
{
    if (chat_id == nullptr || group_exists(c, chat_id) || getfriend_id(c->messenger, chat_id) != -1) {
        return -2;
    }

    if (nick_length > MAX_GC_NICK_SIZE) {
        return -3;
    }

    if (nick == nullptr || nick_length == 0) {
        return -4;
    }

    const int group_number = create_new_group(c, nick, nick_length, false, GI_PUBLIC);

    if (group_number == -1) {
        return -1;
    }

    GC_Chat *chat = gc_get_group(c, group_number);

    if (chat == nullptr) {
        return -1;
    }

    if (!expand_chat_id(chat->chat_public_key, chat_id)) {
        group_delete(c, chat);
        return -1;
    }

    chat->connection_state = CS_CONNECTING;

    if (passwd != nullptr && passwd_len > 0) {
        if (!set_gc_password_local(chat, passwd, passwd_len)) {
            group_delete(c, chat);
            return -5;
        }
    }

    if (!m_create_group_connection(c->messenger, chat)) {
        group_delete(c, chat);
        return -6;
    }

    update_gc_peer_roles(chat);

    return group_number;
}

bool gc_disconnect_from_group(const GC_Session *c, GC_Chat *chat)
{
    if (c == nullptr || chat == nullptr) {
        return false;
    }

    chat->connection_state = CS_DISCONNECTED;

    send_gc_broadcast_message(chat, nullptr, 0, GM_PEER_EXIT);

    for (uint32_t i = 1; i < chat->numpeers; ++i) {
        GC_Connection *gconn = get_gc_connection(chat, i);
        assert(gconn != nullptr);

        gcc_mark_for_deletion(gconn, chat->tcp_conn, GC_EXIT_TYPE_SELF_DISCONNECTED, nullptr, 0);
    }

    return true;
}

int gc_rejoin_group(GC_Session *c, GC_Chat *chat)
{
    if (c == nullptr || chat == nullptr) {
        return -1;
    }

    chat->time_connected = 0;

    if (group_can_handle_packets(chat)) {
        send_gc_self_exit(chat, nullptr, 0);
    }

    for (uint32_t i = 1; i < chat->numpeers; ++i) {
        GC_Connection *gconn = get_gc_connection(chat, i);
        assert(gconn != nullptr);

        gcc_mark_for_deletion(gconn, chat->tcp_conn, GC_EXIT_TYPE_SELF_DISCONNECTED, nullptr, 0);
    }

    if (is_public_chat(chat)) {
        kill_group_friend_connection(c, chat);

        if (!m_create_group_connection(c->messenger, chat)) {
            LOGGER_WARNING(chat->log, "Failed to create new messenger connection for group");
            return -2;
        }

        chat->update_self_announces = true;
    }

    chat->connection_state = CS_CONNECTING;

    return 0;
}

bool group_not_added(const GC_Session *c, const uint8_t *chat_id, uint32_t length)
{
    if (length < CHAT_ID_SIZE) {
        return false;
    }

    return !group_exists(c, chat_id);
}

int gc_invite_friend(const GC_Session *c, GC_Chat *chat, int32_t friend_number,
                     gc_send_group_invite_packet_cb *callback)
{
    if (!friend_is_valid(c->messenger, friend_number)) {
        return -1;
    }

    const uint16_t group_name_length = chat->shared_state.group_name_len;

    assert(group_name_length <= MAX_GC_GROUP_NAME_SIZE);

    uint8_t *packet = (uint8_t *)malloc(2 + CHAT_ID_SIZE + ENC_PUBLIC_KEY_SIZE + group_name_length);

    if (packet == nullptr) {
        return -1;
    }

    packet[0] = GP_FRIEND_INVITE;
    packet[1] = GROUP_INVITE;

    memcpy(packet + 2, get_chat_id(chat->chat_public_key), CHAT_ID_SIZE);
    uint16_t length = 2 + CHAT_ID_SIZE;

    memcpy(packet + length, chat->self_public_key, ENC_PUBLIC_KEY_SIZE);
    length += ENC_PUBLIC_KEY_SIZE;


    memcpy(packet + length, chat->shared_state.group_name, group_name_length);
    length += group_name_length;

    assert(length <= MAX_GC_PACKET_SIZE);

    if (!callback(c->messenger, friend_number, packet, length)) {
        free(packet);
        return -2;
    }

    free(packet);

    chat->saved_invites[chat->saved_invites_index] = friend_number;
    chat->saved_invites_index = (chat->saved_invites_index + 1) % MAX_GC_SAVED_INVITES;

    return 0;
}

/** @brief Sends an invite accepted packet to `friend_number`.
 *
 * Return 0 on success.
 * Return -1 if `friend_number` does not designate a valid friend.
 * Return -2 if `chat `is null.
 * Return -3 if packet failed to send.
 */
non_null()
static int send_gc_invite_accepted_packet(const Messenger *m, const GC_Chat *chat, uint32_t friend_number)
{
    if (!friend_is_valid(m, friend_number)) {
        return -1;
    }

    if (chat == nullptr) {
        return -2;
    }

    uint8_t packet[1 + 1 + CHAT_ID_SIZE + ENC_PUBLIC_KEY_SIZE];
    packet[0] = GP_FRIEND_INVITE;
    packet[1] = GROUP_INVITE_ACCEPTED;

    memcpy(packet + 2, get_chat_id(chat->chat_public_key), CHAT_ID_SIZE);
    uint16_t length = 2 + CHAT_ID_SIZE;

    memcpy(packet + length, chat->self_public_key, ENC_PUBLIC_KEY_SIZE);
    length += ENC_PUBLIC_KEY_SIZE;

    if (!send_group_invite_packet(m, friend_number, packet, length)) {
        LOGGER_ERROR(chat->log, "Failed to send group invite packet.");
        return -3;
    }

    return 0;
}

/** @brief Sends an invite confirmed packet to friend designated by `friend_number`.
 *
 * `data` must contain the group's Chat ID, the sender's public encryption key,
 * and either the sender's packed IP_Port, or at least one packed TCP node that
 * the sender can be connected to through (or both).
 *
 * Return true on success.
 */
non_null()
static bool send_gc_invite_confirmed_packet(const Messenger *m, const GC_Chat *chat, uint32_t friend_number,
        const uint8_t *data, uint16_t length)
{
    if (!friend_is_valid(m, friend_number)) {
        return false;
    }

    if (chat == nullptr) {
        return false;
    }

    if (length > MAX_GC_PACKET_SIZE) {
        return false;
    }

    const uint16_t packet_length = 2 + length;
    uint8_t *packet = (uint8_t *)malloc(packet_length);

    if (packet == nullptr) {
        return false;
    }

    packet[0] = GP_FRIEND_INVITE;
    packet[1] = GROUP_INVITE_CONFIRMATION;

    memcpy(packet + 2, data, length);

    if (!send_group_invite_packet(m, friend_number, packet, packet_length)) {
        free(packet);
        return false;
    }

    free(packet);

    return true;
}

/** @brief Adds `num_nodes` tcp relays from `tcp_relays` to tcp relays list associated with `gconn`
 *
 * Returns the number of relays successfully added.
 */
non_null()
static uint32_t add_gc_tcp_relays(const GC_Chat *chat, GC_Connection *gconn, const Node_format *tcp_relays,
                                  size_t num_nodes)
{
    uint32_t relays_added = 0;

    for (size_t i = 0; i < num_nodes; ++i) {
        const int add_tcp_result = add_tcp_relay_connection(chat->tcp_conn,
                                   gconn->tcp_connection_num, &tcp_relays[i].ip_port,
                                   tcp_relays[i].public_key);

        if (add_tcp_result == 0) {
            if (gcc_save_tcp_relay(chat->rng, gconn, &tcp_relays[i]) == 0) {
                ++relays_added;
            }
        }
    }

    return relays_added;
}

non_null()
static bool copy_friend_ip_port_to_gconn(const Messenger *m, int friend_number, GC_Connection *gconn)
{
    if (!friend_is_valid(m, friend_number)) {
        return false;
    }

    const Friend *f = &m->friendlist[friend_number];
    const int friend_connection_id = f->friendcon_id;
    const Friend_Conn *connection = get_conn(m->fr_c, friend_connection_id);

    if (connection == nullptr) {
        return false;
    }

    const IP_Port *friend_ip_port = friend_conn_get_dht_ip_port(connection);

    if (!ipport_isset(friend_ip_port)) {
        return false;
    }

    gconn->addr.ip_port = *friend_ip_port;

    return true;
}

int handle_gc_invite_confirmed_packet(const GC_Session *c, int friend_number, const uint8_t *data, uint16_t length)
{
    if (length < GC_JOIN_DATA_LENGTH) {
        return -1;
    }

    if (!friend_is_valid(c->messenger, friend_number)) {
        return -4;
    }

    uint8_t chat_id[CHAT_ID_SIZE];
    uint8_t invite_chat_pk[ENC_PUBLIC_KEY_SIZE];

    memcpy(chat_id, data, CHAT_ID_SIZE);
    memcpy(invite_chat_pk, data + CHAT_ID_SIZE, ENC_PUBLIC_KEY_SIZE);

    const GC_Chat *chat = gc_get_group_by_public_key(c, chat_id);

    if (chat == nullptr) {
        return -2;
    }

    const int peer_number = get_peer_number_of_enc_pk(chat, invite_chat_pk, false);

    GC_Connection *gconn = get_gc_connection(chat, peer_number);

    if (gconn == nullptr) {
        return -3;
    }

    Node_format tcp_relays[GCC_MAX_TCP_SHARED_RELAYS];
    const int num_nodes = unpack_nodes(tcp_relays, GCC_MAX_TCP_SHARED_RELAYS,
                                       nullptr, data + ENC_PUBLIC_KEY_SIZE + CHAT_ID_SIZE,
                                       length - GC_JOIN_DATA_LENGTH, true);

    const bool copy_ip_port_result = copy_friend_ip_port_to_gconn(c->messenger, friend_number, gconn);

    uint32_t tcp_relays_added = 0;

    if (num_nodes > 0) {
        tcp_relays_added = add_gc_tcp_relays(chat, gconn, tcp_relays, num_nodes);
    } else {
        LOGGER_WARNING(chat->log, "Invite confirm packet did not contain any TCP relays");
    }

    if (tcp_relays_added == 0 && !copy_ip_port_result) {
        LOGGER_ERROR(chat->log, "Got invalid connection info from peer");
        return -5;
    }

    gconn->pending_handshake_type = HS_INVITE_REQUEST;

    return 0;
}

/** Return true if we have a pending sent invite for our friend designated by `friend_number`. */
non_null()
static bool friend_was_invited(const Messenger *m, GC_Chat *chat, int friend_number)
{
    for (size_t i = 0; i < MAX_GC_SAVED_INVITES; ++i) {
        if (chat->saved_invites[i] == friend_number) {
            chat->saved_invites[i] = -1;
            return friend_is_valid(m, friend_number);
        }
    }

    return false;
}

bool handle_gc_invite_accepted_packet(const GC_Session *c, int friend_number, const uint8_t *data, uint16_t length)
{
    if (length < GC_JOIN_DATA_LENGTH) {
        return false;
    }

    const Messenger *m = c->messenger;

    const uint8_t *chat_id = data;

    GC_Chat *chat = gc_get_group_by_public_key(c, chat_id);

    if (chat == nullptr || !group_can_handle_packets(chat)) {
        return false;
    }

    const uint8_t *invite_chat_pk = data + CHAT_ID_SIZE;

    const int peer_number = peer_add(chat, nullptr, invite_chat_pk);

    if (!friend_was_invited(m, chat, friend_number)) {
        return false;
    }

    GC_Connection *gconn = get_gc_connection(chat, peer_number);

    if (gconn == nullptr) {
        return false;
    }

    Node_format tcp_relays[GCC_MAX_TCP_SHARED_RELAYS];
    const uint32_t num_tcp_relays = tcp_copy_connected_relays(chat->tcp_conn, tcp_relays, GCC_MAX_TCP_SHARED_RELAYS);

    const bool copy_ip_port_result = copy_friend_ip_port_to_gconn(m, friend_number, gconn);

    if (num_tcp_relays == 0 && !copy_ip_port_result) {
        return false;
    }

    uint16_t len = GC_JOIN_DATA_LENGTH;
    uint8_t out_data[GC_JOIN_DATA_LENGTH + (GCC_MAX_TCP_SHARED_RELAYS * PACKED_NODE_SIZE_IP6)];

    memcpy(out_data, chat_id, CHAT_ID_SIZE);
    memcpy(out_data + CHAT_ID_SIZE, chat->self_public_key, ENC_PUBLIC_KEY_SIZE);

    if (num_tcp_relays > 0) {
        const uint32_t tcp_relays_added = add_gc_tcp_relays(chat, gconn, tcp_relays, num_tcp_relays);

        if (tcp_relays_added == 0 && !copy_ip_port_result) {
            LOGGER_ERROR(chat->log, "Got invalid connection info from peer");
            return false;
        }

        const int nodes_len = pack_nodes(chat->log, out_data + len, sizeof(out_data) - len, tcp_relays,
                                         (uint16_t)num_tcp_relays);

        if (nodes_len <= 0 && !copy_ip_port_result) {
            return false;
        }

        len += nodes_len;
    }

    return send_gc_invite_confirmed_packet(m, chat, friend_number, out_data, len);
}

int gc_accept_invite(GC_Session *c, int32_t friend_number, const uint8_t *data, uint16_t length, const uint8_t *nick,
                     size_t nick_length, const uint8_t *passwd, uint16_t passwd_len)
{
    if (length < CHAT_ID_SIZE + ENC_PUBLIC_KEY_SIZE) {
        return -1;
    }

    if (nick_length > MAX_GC_NICK_SIZE) {
        return -3;
    }

    if (nick == nullptr || nick_length == 0) {
        return -4;
    }

    if (!friend_is_valid(c->messenger, friend_number)) {
        return -6;
    }

    const uint8_t *chat_id = data;
    const uint8_t *invite_chat_pk = data + CHAT_ID_SIZE;

    const int group_number = create_new_group(c, nick, nick_length, false, GI_PUBLIC);

    if (group_number == -1) {
        return -2;
    }

    GC_Chat *chat = gc_get_group(c, group_number);

    if (chat == nullptr) {
        return -2;
    }

    if (!expand_chat_id(chat->chat_public_key, chat_id)) {
        group_delete(c, chat);
        return -2;
    }

    if (passwd != nullptr && passwd_len > 0) {
        if (!set_gc_password_local(chat, passwd, passwd_len)) {
            group_delete(c, chat);
            return -5;
        }
    }

    const int peer_id = peer_add(chat, nullptr, invite_chat_pk);

    if (peer_id < 0) {
        return -2;
    }

    chat->join_type = HJ_PRIVATE;

    if (send_gc_invite_accepted_packet(c->messenger, chat, friend_number) != 0) {
        return -7;
    }

    return group_number;
}

non_null(1, 3) nullable(5)
static bool gc_handle_announce_response_callback(Onion_Client *onion_c, uint32_t sendback_num, const uint8_t *data,
        size_t data_length, void *user_data);

GC_Session *new_dht_groupchats(Messenger *m)
{
    if (m == nullptr) {
        return nullptr;
    }

    GC_Session *c = (GC_Session *)calloc(1, sizeof(GC_Session));

    if (c == nullptr) {
        return nullptr;
    }

    c->messenger = m;
    c->announces_list = m->group_announce;

    networking_registerhandler(m->net, NET_PACKET_GC_LOSSLESS, &handle_gc_udp_packet, m);
    networking_registerhandler(m->net, NET_PACKET_GC_LOSSY, &handle_gc_udp_packet, m);
    networking_registerhandler(m->net, NET_PACKET_GC_HANDSHAKE, &handle_gc_udp_packet, m);
    onion_group_announce_register(m->onion_c, gc_handle_announce_response_callback, c);

    return c;
}

static void group_cleanup(GC_Session *c, GC_Chat *chat)
{
    kill_group_friend_connection(c, chat);

    mod_list_cleanup(&chat->moderation);
    sanctions_list_cleanup(&chat->moderation);

    if (chat->tcp_conn != nullptr) {
        kill_tcp_connections(chat->tcp_conn);
    }

    gcc_cleanup(chat);

    if (chat->group != nullptr) {
        free(chat->group);
        chat->group = nullptr;
    }

    crypto_memunlock(chat->self_secret_key, sizeof(chat->self_secret_key));
    crypto_memunlock(chat->chat_secret_key, sizeof(chat->chat_secret_key));
    crypto_memunlock(chat->shared_state.password, sizeof(chat->shared_state.password));
}

/** Deletes chat from group chat array and cleans up. */
static void group_delete(GC_Session *c, GC_Chat *chat)
{
    if (c == nullptr || chat == nullptr) {
        if (chat != nullptr) {
            LOGGER_ERROR(chat->log, "Null pointer");
        }

        return;
    }

    group_cleanup(c, chat);

    c->chats[chat->group_number] = empty_gc_chat;

    uint32_t i;

    for (i = c->chats_index; i > 0; --i) {
        if (c->chats[i - 1].connection_state != CS_NONE) {
            break;
        }
    }

    if (c->chats_index != i) {
        c->chats_index = i;

        if (!realloc_groupchats(c, c->chats_index)) {
            LOGGER_ERROR(chat->log, "Failed to reallocate groupchats array");
        }
    }
}

int gc_group_exit(GC_Session *c, GC_Chat *chat, const uint8_t *message, uint16_t length)
{
    chat->flag_exit = true;
    return group_can_handle_packets(chat) ? send_gc_self_exit(chat, message, length) : 0;
}

non_null()
static int kill_group(GC_Session *c, GC_Chat *chat)
{
    const int ret = gc_group_exit(c, chat, nullptr, 0);
    group_delete(c, chat);
    return ret;
}

void kill_dht_groupchats(GC_Session *c)
{
    if (c == nullptr) {
        return;
    }

    for (uint32_t i = 0; i < c->chats_index; ++i) {
        GC_Chat *chat = &c->chats[i];

        if (chat->connection_state == CS_NONE) {
            continue;
        }

        if (kill_group(c, chat) != 0) {
            LOGGER_WARNING(chat->log, "Failed to send group exit packet");
        }
    }

    networking_registerhandler(c->messenger->net, NET_PACKET_GC_LOSSY, nullptr, nullptr);
    networking_registerhandler(c->messenger->net, NET_PACKET_GC_LOSSLESS, nullptr, nullptr);
    networking_registerhandler(c->messenger->net, NET_PACKET_GC_HANDSHAKE, nullptr, nullptr);
    onion_group_announce_register(c->messenger->onion_c, nullptr, nullptr);

    free(c->chats);
    free(c);
}

bool gc_group_is_valid(const GC_Chat *chat)
{
    return chat->connection_state != CS_NONE && chat->shared_state.version > 0;
}

/** Return true if `group_number` designates an active group in session `c`. */
static bool group_number_valid(const GC_Session *c, int group_number)
{
    if (group_number < 0 || group_number >= c->chats_index) {
        return false;
    }

    if (c->chats == nullptr) {
        return false;
    }

    return c->chats[group_number].connection_state != CS_NONE;
}

uint32_t gc_count_groups(const GC_Session *c)
{
    uint32_t count = 0;

    for (uint32_t i = 0; i < c->chats_index; ++i) {
        const GC_Chat *chat = &c->chats[i];

        if (gc_group_is_valid(chat)) {
            ++count;
        }
    }

    return count;
}

uint32_t copy_grouplist(const GC_Session *c, uint32_t *out_list, uint32_t list_size)
{
    if (out_list == nullptr) {
        return 0;
    }

    if (c->chats_index == 0) {
        return 0;
    }

    uint32_t ret = 0;

    for (uint32_t i = 0; i < c->chats_index; ++i) {
        if (ret >= list_size) {
            break;  /* Abandon ship */
        }

        if (c->chats[i].connection_state != CS_NONE) {
            out_list[ret] = i;
            ++ret;
        }
    }

    return ret;
}

uint32_t get_group_peercount(const GC_Chat *chat)
{
    if (chat == nullptr) {
        return 0;
    }

    if (chat->numpeers == 0) {
        return 0;
    }

    uint32_t sum = 0;

    for (uint32_t i = 0; i < chat->numpeers; ++i) {
        const GC_Connection *gconn = get_gc_connection(chat, i);

        assert(gconn != nullptr);

        if (gconn->confirmed) {
            ++sum;
        }
    }

    return sum;
}

uint32_t get_group_offline_peercount(const GC_Chat *chat)
{
    if (chat == nullptr) {
        return 0;
    }

    uint32_t sum = 0;
    for (uint16_t i = 0; i < GC_MAX_SAVED_PEERS; ++i) {
        const GC_SavedPeerInfo *saved_peer = &chat->saved_peers[i];
        if (saved_peer_is_valid(saved_peer)) {
            const int peernumber = get_peer_number_of_enc_pk(chat, saved_peer->public_key, true);
            if (peernumber < 0) {
                ++sum;
            }
        }
    }

    return sum;
}

void copy_peerlist(const GC_Chat *chat, uint32_t *out_list)
{
    if (out_list == nullptr) {
        return;
    }

    if (chat == nullptr) {
        return;
    }

    if (chat->numpeers == 0) {
        return;
    }

    uint32_t index = 0;

    for (uint32_t i = 0; i < chat->numpeers; ++i) {
        const GC_Connection *gconn = get_gc_connection(chat, i);

        assert(gconn != nullptr);

        if (gconn->confirmed) {
            out_list[index] = chat->group[i].peer_id;
            ++index;
        }
    }
}

GC_Chat *gc_get_group(const GC_Session *c, int group_number)
{
    if (!group_number_valid(c, group_number)) {
        return nullptr;
    }

    return &c->chats[group_number];
}

GC_Chat *gc_get_group_by_public_key(const GC_Session *c, const uint8_t *public_key)
{
    for (uint32_t i = 0; i < c->chats_index; ++i) {
        GC_Chat *chat = &c->chats[i];

        if (chat->connection_state == CS_NONE) {
            continue;
        }

        if (memcmp(public_key, get_chat_id(chat->chat_public_key), CHAT_ID_SIZE) == 0) {
            return chat;
        }
    }

    return nullptr;
}

/** Return True if chat_id exists in the session chat array */
static bool group_exists(const GC_Session *c, const uint8_t *chat_id)
{
    for (uint32_t i = 0; i < c->chats_index; ++i) {
        const GC_Chat *chat = &c->chats[i];

        if (chat->connection_state == CS_NONE) {
            continue;
        }

        if (memcmp(get_chat_id(chat->chat_public_key), chat_id, CHAT_ID_SIZE) == 0) {
            return true;
        }
    }

    return false;
}

/** Creates a new 32-byte session encryption keypair and puts the results in `public_key` and `secret_key`. */
static void create_gc_session_keypair(const Logger *log, const Random *rng, uint8_t *public_key, uint8_t *secret_key)
{
    if (crypto_new_keypair(rng, public_key, secret_key) != 0) {
        LOGGER_FATAL(log, "Failed to create group session keypair");
    }
}

/**
 * Creates a new 64-byte extended keypair for `chat` and puts results in `self_public_key`
 * and `self_secret_key` buffers. The first 32-bytes of the generated keys are used for
 * encryption, while the remaining 32-bytes are used for signing.
 *
 * Return false if key generation fails.
 */
non_null()
static bool create_new_chat_ext_keypair(GC_Chat *chat)
{
    crypto_memlock(chat->self_secret_key, sizeof(chat->self_secret_key));

    if (!create_extended_keypair(chat->self_public_key, chat->self_secret_key)) {
        crypto_memunlock(chat->self_secret_key, sizeof(chat->self_secret_key));
        return false;
    }

    return true;
}

/** @brief Handles a group announce onion response.
 *
 * Return true on success.
 */
static bool gc_handle_announce_response_callback(Onion_Client *onion_c, uint32_t sendback_num, const uint8_t *data,
        size_t data_length, void *user_data)
{
    const GC_Session *c = (GC_Session *)user_data;

    if (c == nullptr) {
        return false;
    }

    if (sendback_num == 0) {
        return false;
    }

    GC_Announce announces[GCA_MAX_SENT_ANNOUNCES];
    const uint8_t *gc_public_key = onion_friend_get_gc_public_key_num(onion_c, sendback_num - 1);
    GC_Chat *chat = gc_get_group_by_public_key(c, gc_public_key);

    if (chat == nullptr) {
        return false;
    }

    const int gc_announces_count = gca_unpack_announces_list(chat->log, data, data_length,
                                   announces, GCA_MAX_SENT_ANNOUNCES);

    if (gc_announces_count == -1) {
        return false;
    }

    const int added_peers = gc_add_peers_from_announces(chat, announces, gc_announces_count);

    return added_peers >= 0;
}

/** @brief Adds TCP relays from `announce` to the TCP relays list for `gconn`.
 *
 * Returns the number of relays successfully added.
 */
non_null()
static uint32_t add_gc_tcp_relays_from_announce(const GC_Chat *chat, GC_Connection *gconn, const GC_Announce *announce)
{
    uint32_t added_relays = 0;

    for (uint8_t j = 0; j < announce->tcp_relays_count; ++j) {
        const int add_tcp_result = add_tcp_relay_connection(chat->tcp_conn, gconn->tcp_connection_num,
                                   &announce->tcp_relays[j].ip_port,
                                   announce->tcp_relays[j].public_key);

        if (add_tcp_result == -1) {
            continue;
        }

        if (gcc_save_tcp_relay(chat->rng, gconn, &announce->tcp_relays[j]) == -1) {
            continue;
        }

        if (added_relays == 0) {
            memcpy(gconn->oob_relay_pk, announce->tcp_relays[j].public_key, CRYPTO_PUBLIC_KEY_SIZE);
        }

        ++added_relays;
    }

    return added_relays;
}

int gc_add_peers_from_announces(GC_Chat *chat, const GC_Announce *announces, uint8_t gc_announces_count)
{
    if (chat == nullptr || announces == nullptr) {
        return -1;
    }

    if (!is_public_chat(chat)) {
        return 0;
    }

    int added_peers = 0;

    for (uint8_t i = 0; i < gc_announces_count; ++i) {
        const GC_Announce *announce = &announces[i];

        if (!gca_is_valid_announce(announce)) {
            continue;
        }

        const bool ip_port_set = announce->ip_port_is_set;
        const IP_Port *ip_port = ip_port_set ? &announce->ip_port : nullptr;
        const int peer_number = peer_add(chat, ip_port, announce->peer_public_key);

        GC_Connection *gconn = get_gc_connection(chat, peer_number);

        if (gconn == nullptr) {
            continue;
        }

        const uint32_t added_tcp_relays = add_gc_tcp_relays_from_announce(chat, gconn, announce);

        if (!ip_port_set && added_tcp_relays == 0) {
            LOGGER_ERROR(chat->log, "Got invalid announcement: %u relays, IPP set: %d",
                         added_tcp_relays, ip_port_set);
            continue;
        }

        gconn->pending_handshake_type = HS_INVITE_REQUEST;

        if (!ip_port_set) {
            gconn->is_oob_handshake = true;
        }

        ++added_peers;
    }

    return added_peers;
}
#endif  // VANILLA_NACL
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2020 The TokTok team.
 * Copyright © 2015 Tox project.
 */

/**
 * An implementation of massive text only group chats.
 */


#include <assert.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>


#ifndef VANILLA_NACL

/** Seconds since last direct UDP packet was received before the connection is considered dead */
#define GCC_UDP_DIRECT_TIMEOUT (GC_PING_TIMEOUT + 4)

/** Returns true if array entry does not contain an active packet. */
non_null()
static bool array_entry_is_empty(const GC_Message_Array_Entry *array_entry)
{
    assert(array_entry != nullptr);
    return array_entry->time_added == 0;
}

/** @brief Clears an array entry. */
non_null()
static void clear_array_entry(GC_Message_Array_Entry *const array_entry)
{
    if (array_entry->data != nullptr) {
        free(array_entry->data);
    }

    *array_entry = (GC_Message_Array_Entry) {
        nullptr
    };
}

/**
 * Clears every send array message from queue starting at the index designated by
 * `start_id` and ending at `end_id`, and sets the send_message_id for `gconn`
 * to `start_id`.
 */
non_null()
static void clear_send_queue_id_range(GC_Connection *gconn, uint64_t start_id, uint64_t end_id)
{
    const uint16_t start_idx = gcc_get_array_index(start_id);
    const uint16_t end_idx = gcc_get_array_index(end_id);

    for (uint16_t i = start_idx; i != end_idx; i = (i + 1) % GCC_BUFFER_SIZE) {
        GC_Message_Array_Entry *entry = &gconn->send_array[i];
        clear_array_entry(entry);
    }

    gconn->send_message_id = start_id;
}

uint16_t gcc_get_array_index(uint64_t message_id)
{
    return message_id % GCC_BUFFER_SIZE;
}

void gcc_set_send_message_id(GC_Connection *gconn, uint64_t id)
{
    gconn->send_message_id = id;
    gconn->send_array_start = id % GCC_BUFFER_SIZE;
}

void gcc_set_recv_message_id(GC_Connection *gconn, uint64_t id)
{
    gconn->received_message_id = id;
}

/** @brief Puts packet data in array_entry.
 *
 * Return true on success.
 */
non_null(1, 2) nullable(3)
static bool create_array_entry(const Mono_Time *mono_time, GC_Message_Array_Entry *array_entry, const uint8_t *data,
                               uint16_t length, uint8_t packet_type, uint64_t message_id)
{
    if (length > 0) {
        if (data == nullptr) {
            return false;
        }

        array_entry->data = (uint8_t *)malloc(sizeof(uint8_t) * length);

        if (array_entry->data == nullptr) {
            return false;
        }

        memcpy(array_entry->data, data, length);
    }

    const uint64_t tm = mono_time_get(mono_time);

    array_entry->data_length = length;
    array_entry->packet_type = packet_type;
    array_entry->message_id = message_id;
    array_entry->time_added = tm;
    array_entry->last_send_try = tm;

    return true;
}

/** @brief Adds data of length to gconn's send_array.
 *
 * Returns true on success and increments gconn's send_message_id.
 */
non_null(1, 2, 3) nullable(4)
static bool add_to_send_array(const Logger *log, const Mono_Time *mono_time, GC_Connection *gconn, const uint8_t *data,
                              uint16_t length, uint8_t packet_type)
{
    /* check if send_array is full */
    if ((gconn->send_message_id % GCC_BUFFER_SIZE) == (uint16_t)(gconn->send_array_start - 1)) {
        LOGGER_DEBUG(log, "Send array overflow");
        return false;
    }

    const uint16_t idx = gcc_get_array_index(gconn->send_message_id);
    GC_Message_Array_Entry *array_entry = &gconn->send_array[idx];

    if (!array_entry_is_empty(array_entry)) {
        LOGGER_DEBUG(log, "Send array entry isn't empty");
        return false;
    }

    if (!create_array_entry(mono_time, array_entry, data, length, packet_type, gconn->send_message_id)) {
        LOGGER_WARNING(log, "Failed to create array entry");
        return false;
    }

    ++gconn->send_message_id;

    return true;
}

int gcc_send_lossless_packet(const GC_Chat *chat, GC_Connection *gconn, const uint8_t *data, uint16_t length,
                             uint8_t packet_type)
{
    const uint64_t message_id = gconn->send_message_id;

    if (!add_to_send_array(chat->log, chat->mono_time, gconn, data, length, packet_type)) {
        LOGGER_WARNING(chat->log, "Failed to add payload to send array: (type: 0x%02x, length: %d)", packet_type, length);
        return -1;
    }

    if (!gcc_encrypt_and_send_lossless_packet(chat, gconn, data, length, message_id, packet_type)) {
        LOGGER_DEBUG(chat->log, "Failed to send payload: (type: 0x%02x, length: %d)", packet_type, length);
        return -2;
    }

    return 0;
}


bool gcc_send_lossless_packet_fragments(const GC_Chat *chat, GC_Connection *gconn, const uint8_t *data,
                                        uint16_t length, uint8_t packet_type)
{
    if (length <= MAX_GC_PACKET_CHUNK_SIZE || data == nullptr) {
        LOGGER_FATAL(chat->log, "invalid length or null data pointer");
        return false;
    }

    const uint16_t start_id = gconn->send_message_id;

    // First packet segment is comprised of packet type + first chunk of payload
    uint8_t chunk[MAX_GC_PACKET_CHUNK_SIZE];
    chunk[0] = packet_type;
    memcpy(chunk + 1, data, MAX_GC_PACKET_CHUNK_SIZE - 1);

    if (!add_to_send_array(chat->log, chat->mono_time, gconn, chunk, MAX_GC_PACKET_CHUNK_SIZE, GP_FRAGMENT)) {
        return false;
    }

    uint16_t processed = MAX_GC_PACKET_CHUNK_SIZE - 1;

    // The rest of the segments are added in chunks
    while (length > processed) {
        const uint16_t chunk_len = min_u16(MAX_GC_PACKET_CHUNK_SIZE, length - processed);

        memcpy(chunk, data + processed, chunk_len);
        processed += chunk_len;

        if (!add_to_send_array(chat->log, chat->mono_time, gconn, chunk, chunk_len, GP_FRAGMENT)) {
            clear_send_queue_id_range(gconn, start_id, gconn->send_message_id);
            return false;
        }
    }

    // empty packet signals the end of the sequence
    if (!add_to_send_array(chat->log, chat->mono_time, gconn, nullptr, 0, GP_FRAGMENT)) {
        clear_send_queue_id_range(gconn, start_id, gconn->send_message_id);
        return false;
    }

    const uint16_t start_idx = gcc_get_array_index(start_id);
    const uint16_t end_idx = gcc_get_array_index(gconn->send_message_id);

    for (uint16_t i = start_idx; i != end_idx; i = (i + 1) % GCC_BUFFER_SIZE) {
        GC_Message_Array_Entry *entry = &gconn->send_array[i];

        if (array_entry_is_empty(entry)) {
            LOGGER_FATAL(chat->log, "array entry for packet chunk is empty");
            return false;
        }

        assert(entry->packet_type == GP_FRAGMENT);

        gcc_encrypt_and_send_lossless_packet(chat, gconn, entry->data, entry->data_length,
                                             entry->message_id, entry->packet_type);
    }

    return true;
}

bool gcc_handle_ack(const Logger *log, GC_Connection *gconn, uint64_t message_id)
{
    uint16_t idx = gcc_get_array_index(message_id);
    GC_Message_Array_Entry *array_entry = &gconn->send_array[idx];

    if (array_entry_is_empty(array_entry)) {
        return true;
    }

    if (array_entry->message_id != message_id) {  // wrap-around indicates a connection problem
        LOGGER_DEBUG(log, "Wrap-around on message %llu", (unsigned long long)message_id);
        return false;
    }

    clear_array_entry(array_entry);

    /* Put send_array_start in proper position */
    if (idx == gconn->send_array_start) {
        const uint16_t end = gconn->send_message_id % GCC_BUFFER_SIZE;

        while (array_entry_is_empty(&gconn->send_array[idx]) && gconn->send_array_start != end) {
            gconn->send_array_start = (gconn->send_array_start + 1) % GCC_BUFFER_SIZE;
            idx = (idx + 1) % GCC_BUFFER_SIZE;
        }
    }

    return true;
}

bool gcc_ip_port_is_set(const GC_Connection *gconn)
{
    return ipport_isset(&gconn->addr.ip_port);
}

void gcc_set_ip_port(GC_Connection *gconn, const IP_Port *ipp)
{
    if (ipp != nullptr && ipport_isset(ipp)) {
        gconn->addr.ip_port = *ipp;
    }
}

bool gcc_copy_tcp_relay(const Random *rng, Node_format *tcp_node, const GC_Connection *gconn)
{
    if (gconn == nullptr || tcp_node == nullptr) {
        return false;
    }

    if (gconn->tcp_relays_count == 0) {
        return false;
    }

    const uint32_t rand_idx = random_range_u32(rng, gconn->tcp_relays_count);

    if (!ipport_isset(&gconn->connected_tcp_relays[rand_idx].ip_port)) {
        return false;
    }

    *tcp_node = gconn->connected_tcp_relays[rand_idx];

    return true;
}

int gcc_save_tcp_relay(const Random *rng, GC_Connection *gconn, const Node_format *tcp_node)
{
    if (gconn == nullptr || tcp_node == nullptr) {
        return -1;
    }

    if (!ipport_isset(&tcp_node->ip_port)) {
        return -1;
    }

    for (uint16_t i = 0; i < gconn->tcp_relays_count; ++i) {
        if (pk_equal(gconn->connected_tcp_relays[i].public_key, tcp_node->public_key)) {
            return -2;
        }
    }

    uint32_t idx = gconn->tcp_relays_count;

    if (gconn->tcp_relays_count >= MAX_FRIEND_TCP_CONNECTIONS) {
        idx = random_range_u32(rng, gconn->tcp_relays_count);
    } else {
        ++gconn->tcp_relays_count;
    }

    gconn->connected_tcp_relays[idx] = *tcp_node;

    return 0;
}

/** @brief Stores `data` of length `length` in the receive array for `gconn`.
 *
 * Return true on success.
 */
non_null(1, 2, 3) nullable(4)
static bool store_in_recv_array(const Logger *log, const Mono_Time *mono_time, GC_Connection *gconn,
                                const uint8_t *data,
                                uint16_t length, uint8_t packet_type, uint64_t message_id)
{
    const uint16_t idx = gcc_get_array_index(message_id);
    GC_Message_Array_Entry *ary_entry = &gconn->recv_array[idx];

    if (!array_entry_is_empty(ary_entry)) {
        LOGGER_DEBUG(log, "Recv array is not empty");
        return false;
    }

    if (!create_array_entry(mono_time, ary_entry, data, length, packet_type, message_id)) {
        LOGGER_WARNING(log, "Failed to create array entry");
        return false;
    }

    return true;
}

/**
 * Reassembles a fragmented packet sequence ending with the data in the receive
 * array at slot `message_id - 1` and starting with the last found slot containing
 * a GP_FRAGMENT packet when searching backwards in the array.
 *
 * The fully reassembled packet is stored in `payload`, which must be passed as a
 * null pointer, and must be free'd by the caller.
 *
 * Return the length of the fully reassembled packet on success.
 * Return 0 on failure.
 */
non_null(1, 3) nullable(2)
static uint16_t reassemble_packet(const Logger *log, GC_Connection *gconn, uint8_t **payload, uint64_t message_id)
{
    uint16_t end_idx = gcc_get_array_index(message_id - 1);
    uint16_t start_idx = end_idx;
    uint16_t packet_length = 0;

    GC_Message_Array_Entry *entry = &gconn->recv_array[end_idx];

    // search backwards in recv array until we find an empty slot or a non-fragment packet type
    while (!array_entry_is_empty(entry) && entry->packet_type == GP_FRAGMENT) {
        assert(entry->data != nullptr);
        assert(entry->data_length <= MAX_GC_PACKET_CHUNK_SIZE);

        const uint16_t diff = packet_length + entry->data_length;

        assert(diff > packet_length);  // overflow check
        packet_length = diff;

        if (packet_length > MAX_GC_PACKET_SIZE) {
            LOGGER_ERROR(log, "Payload of size %u exceeded max packet size", packet_length);  // should never happen
            return 0;
        }

        start_idx = start_idx > 0 ? start_idx - 1 : GCC_BUFFER_SIZE - 1;
        entry = &gconn->recv_array[start_idx];

        if (start_idx == end_idx) {
            LOGGER_ERROR(log, "Packet reassemble wrap-around");
            return 0;
        }
    }

    if (packet_length == 0) {
        return 0;
    }

    assert(*payload == nullptr);
    *payload = (uint8_t *)malloc(packet_length);

    if (*payload == nullptr) {
        LOGGER_ERROR(log, "Failed to allocate %u bytes for payload buffer", packet_length);
        return 0;
    }

    start_idx = (start_idx + 1) % GCC_BUFFER_SIZE;
    end_idx = (end_idx + 1) % GCC_BUFFER_SIZE;

    uint16_t processed = 0;

    for (uint16_t i = start_idx; i != end_idx; i = (i + 1) % GCC_BUFFER_SIZE) {
        entry = &gconn->recv_array[i];

        assert(processed + entry->data_length <= packet_length);
        memcpy(*payload + processed, entry->data, entry->data_length);
        processed += entry->data_length;

        clear_array_entry(entry);
    }

    return processed;
}

int gcc_handle_packet_fragment(const GC_Session *c, GC_Chat *chat, uint32_t peer_number,
                               GC_Connection *gconn, const uint8_t *chunk, uint16_t length, uint8_t packet_type,
                               uint64_t message_id, void *userdata)
{
    if (length > 0) {
        if (!store_in_recv_array(chat->log, chat->mono_time, gconn, chunk, length, packet_type, message_id)) {
            return -1;
        }

        gcc_set_recv_message_id(gconn, gconn->received_message_id + 1);
        gconn->last_chunk_id = message_id;

        return 1;
    }

    uint8_t sender_pk[ENC_PUBLIC_KEY_SIZE];
    memcpy(sender_pk, get_enc_key(gconn->addr.public_key), ENC_PUBLIC_KEY_SIZE);

    uint8_t *payload = nullptr;
    const uint16_t processed_len = reassemble_packet(chat->log, gconn, &payload, message_id);

    if (processed_len == 0) {
        free(payload);
        return -1;
    }

    if (!handle_gc_lossless_helper(c, chat, peer_number, payload + 1, processed_len - 1, payload[0], userdata)) {
        free(payload);
        return -1;
    }

    /* peer number can change from peer add operations in packet handlers */
    peer_number = get_peer_number_of_enc_pk(chat, sender_pk, false);
    gconn = get_gc_connection(chat, peer_number);

    if (gconn == nullptr) {
        return 0;
    }

    gcc_set_recv_message_id(gconn, gconn->received_message_id + 1);
    gconn->last_chunk_id = 0;

    free(payload);

    return 0;
}

int gcc_handle_received_message(const Logger *log, const Mono_Time *mono_time, GC_Connection *gconn,
                                const uint8_t *data, uint16_t length, uint8_t packet_type, uint64_t message_id,
                                bool direct_conn)
{
    if (direct_conn) {
        gconn->last_received_direct_time = mono_time_get(mono_time);
    }

    /* Appears to be a duplicate packet so we discard it */
    if (message_id < gconn->received_message_id + 1) {
        return 0;
    }

    if (packet_type == GP_FRAGMENT) { // we handle packet fragments as a special case
        return 3;
    }

    /* we're missing an older message from this peer so we store it in recv_array */
    if (message_id > gconn->received_message_id + 1) {
        if (!store_in_recv_array(log, mono_time, gconn, data, length, packet_type, message_id)) {
            return -1;
        }

        return 1;
    }

    gcc_set_recv_message_id(gconn, gconn->received_message_id + 1);

    return 2;
}

/** @brief Handles peer_number's array entry with appropriate handler and clears it from array.
 *
 * This function increments the received message ID for `gconn`.
 *
 * Return true on success.
 */
non_null(1, 2, 3, 5) nullable(6)
static bool process_recv_array_entry(const GC_Session *c, GC_Chat *chat, GC_Connection *gconn, uint32_t peer_number,
                                     GC_Message_Array_Entry *const array_entry, void *userdata)
{
    uint8_t sender_pk[ENC_PUBLIC_KEY_SIZE];
    memcpy(sender_pk, get_enc_key(gconn->addr.public_key), ENC_PUBLIC_KEY_SIZE);

    const bool ret = handle_gc_lossless_helper(c, chat, peer_number, array_entry->data, array_entry->data_length,
                     array_entry->packet_type, userdata);

    /* peer number can change from peer add operations in packet handlers */
    peer_number = get_peer_number_of_enc_pk(chat, sender_pk, false);
    gconn = get_gc_connection(chat, peer_number);

    clear_array_entry(array_entry);

    if (gconn == nullptr) {
        return true;
    }

    if (!ret) {
        gc_send_message_ack(chat, gconn, array_entry->message_id, GR_ACK_REQ);
        return false;
    }

    gc_send_message_ack(chat, gconn, array_entry->message_id, GR_ACK_RECV);

    gcc_set_recv_message_id(gconn, gconn->received_message_id + 1);

    return true;
}

void gcc_check_recv_array(const GC_Session *c, GC_Chat *chat, GC_Connection *gconn, uint32_t peer_number,
                          void *userdata)
{
    if (gconn->last_chunk_id != 0) {  // dont check array if we have an unfinished fragment sequence
        return;
    }

    const uint16_t idx = (gconn->received_message_id + 1) % GCC_BUFFER_SIZE;
    GC_Message_Array_Entry *const array_entry = &gconn->recv_array[idx];

    if (!array_entry_is_empty(array_entry)) {
        process_recv_array_entry(c, chat, gconn, peer_number, array_entry, userdata);
    }
}

void gcc_resend_packets(const GC_Chat *chat, GC_Connection *gconn)
{
    const uint64_t tm = mono_time_get(chat->mono_time);
    const uint16_t start = gconn->send_array_start;
    const uint16_t end = gconn->send_message_id % GCC_BUFFER_SIZE;

    GC_Message_Array_Entry *array_entry = &gconn->send_array[start];

    if (array_entry_is_empty(array_entry)) {
        return;
    }

    if (mono_time_is_timeout(chat->mono_time, array_entry->time_added, GC_CONFIRMED_PEER_TIMEOUT)) {
        gcc_mark_for_deletion(gconn, chat->tcp_conn, GC_EXIT_TYPE_TIMEOUT, nullptr, 0);
        LOGGER_DEBUG(chat->log, "Send array stuck; timing out peer");
        return;
    }

    for (uint16_t i = start; i != end; i = (i + 1) % GCC_BUFFER_SIZE) {
        array_entry = &gconn->send_array[i];

        if (array_entry_is_empty(array_entry)) {
            continue;
        }

        if (tm == array_entry->last_send_try) {
            continue;
        }

        const uint64_t delta = array_entry->last_send_try - array_entry->time_added;
        array_entry->last_send_try = tm;

        /* if this occurrs less than once per second this won't be reliable */
        if (delta > 1 && is_power_of_2(delta)) {
            gcc_encrypt_and_send_lossless_packet(chat, gconn, array_entry->data, array_entry->data_length,
                                                 array_entry->message_id, array_entry->packet_type);
        }
    }
}

bool gcc_send_packet(const GC_Chat *chat, const GC_Connection *gconn, const uint8_t *packet, uint16_t length)
{
    if (packet == nullptr || length == 0) {
        return false;
    }

    bool direct_send_attempt = false;

    if (gcc_direct_conn_is_possible(chat, gconn)) {
        if (gcc_conn_is_direct(chat->mono_time, gconn)) {
            return (uint16_t) sendpacket(chat->net, &gconn->addr.ip_port, packet, length) == length;
        }

        if ((uint16_t) sendpacket(chat->net, &gconn->addr.ip_port, packet, length) == length) {
            direct_send_attempt = true;
        }
    }

    const int ret = send_packet_tcp_connection(chat->tcp_conn, gconn->tcp_connection_num, packet, length);
    return ret == 0 || direct_send_attempt;
}

bool gcc_encrypt_and_send_lossless_packet(const GC_Chat *chat, const GC_Connection *gconn, const uint8_t *data,
        uint16_t length, uint64_t message_id, uint8_t packet_type)
{
    const uint16_t packet_size = gc_get_wrapped_packet_size(length, NET_PACKET_GC_LOSSLESS);
    uint8_t *packet = (uint8_t *)malloc(packet_size);

    if (packet == nullptr) {
        LOGGER_ERROR(chat->log, "Failed to allocate memory for packet buffer");
        return false;
    }

    const int enc_len = group_packet_wrap(
                            chat->log, chat->rng, chat->self_public_key, gconn->session_shared_key, packet,
                            packet_size, data, length, message_id, packet_type, NET_PACKET_GC_LOSSLESS);

    if (enc_len < 0) {
        LOGGER_ERROR(chat->log, "Failed to wrap packet (type: 0x%02x, error: %d)", packet_type, enc_len);
        free(packet);
        return false;
    }

    if (!gcc_send_packet(chat, gconn, packet, (uint16_t)enc_len)) {
        LOGGER_DEBUG(chat->log, "Failed to send packet (type: 0x%02x, enc_len: %d)", packet_type, enc_len);
        free(packet);
        return false;
    }

    free(packet);

    return true;
}

void gcc_make_session_shared_key(GC_Connection *gconn, const uint8_t *sender_pk)
{
    encrypt_precompute(sender_pk, gconn->session_secret_key, gconn->session_shared_key);
}

bool gcc_conn_is_direct(const Mono_Time *mono_time, const GC_Connection *gconn)
{
    return GCC_UDP_DIRECT_TIMEOUT + gconn->last_received_direct_time > mono_time_get(mono_time);
}

bool gcc_direct_conn_is_possible(const GC_Chat *chat, const GC_Connection *gconn)
{
    return !net_family_is_unspec(gconn->addr.ip_port.ip.family) && !net_family_is_unspec(net_family(chat->net));
}

void gcc_mark_for_deletion(GC_Connection *gconn, TCP_Connections *tcp_conn, Group_Exit_Type type,
                           const uint8_t *part_message, uint16_t length)
{
    if (gconn == nullptr) {
        return;
    }

    if (gconn->pending_delete) {
        return;
    }

    gconn->pending_delete = true;
    gconn->exit_info.exit_type = type;

    kill_tcp_connection_to(tcp_conn, gconn->tcp_connection_num);

    if (length > 0 && length <= MAX_GC_PART_MESSAGE_SIZE  && part_message != nullptr) {
        memcpy(gconn->exit_info.part_message, part_message, length);
        gconn->exit_info.length = length;
    }
}

void gcc_peer_cleanup(GC_Connection *gconn)
{
    for (size_t i = 0; i < GCC_BUFFER_SIZE; ++i) {
        free(gconn->send_array[i].data);
        free(gconn->recv_array[i].data);
    }

    free(gconn->recv_array);
    free(gconn->send_array);

    crypto_memunlock(gconn->session_secret_key, sizeof(gconn->session_secret_key));
    crypto_memunlock(gconn->session_shared_key, sizeof(gconn->session_shared_key));
    crypto_memzero(gconn, sizeof(GC_Connection));
}

void gcc_cleanup(const GC_Chat *chat)
{
    for (uint32_t i = 0; i < chat->numpeers; ++i) {
        GC_Connection *gconn = get_gc_connection(chat, i);
        assert(gconn != nullptr);

        gcc_peer_cleanup(gconn);
    }
}

#endif // VANILLA_NACL
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2020 The TokTok team.
 * Copyright © 2015 Tox project.
 */

/**
 * An implementation of massive text only group chats.
 */


#include <assert.h>

#include <stdlib.h>
#include <string.h>
#include <time.h>


static_assert(MOD_SANCTIONS_CREDS_SIZE <= MAX_PACKET_SIZE_NO_HEADERS,
              "MOD_SANCTIONS_CREDS_SIZE must be <= the maximum allowed payload size");
static_assert(MOD_MAX_NUM_SANCTIONS * MOD_SANCTION_PACKED_SIZE + MOD_SANCTIONS_CREDS_SIZE <= MAX_PACKET_SIZE_NO_HEADERS,
              "MOD_MAX_NUM_SANCTIONS must be able to fit inside the maximum allowed payload size");
static_assert(MOD_MAX_NUM_MODERATORS * MOD_LIST_ENTRY_SIZE <= MAX_PACKET_SIZE_NO_HEADERS,
              "MOD_MAX_NUM_MODERATORS must be able to fit insize the maximum allowed payload size");
static_assert(MOD_MAX_NUM_MODERATORS <= MOD_MAX_NUM_MODERATORS_LIMIT,
              "MOD_MAX_NUM_MODERATORS must be <= MOD_MAX_NUM_MODERATORS_LIMIT");
static_assert(MOD_MAX_NUM_SANCTIONS <= MOD_MAX_NUM_SANCTIONS_LIMIT,
              "MOD_MAX_NUM_SANCTIONS must be <= MOD_MAX_NUM_SANCTIONS_LIMIT");

uint16_t mod_list_packed_size(const Moderation *moderation)
{
    return moderation->num_mods * MOD_LIST_ENTRY_SIZE;
}

int mod_list_unpack(Moderation *moderation, const uint8_t *data, uint16_t length, uint16_t num_mods)
{
    if (length < num_mods * MOD_LIST_ENTRY_SIZE) {
        return -1;
    }

    mod_list_cleanup(moderation);

    if (num_mods == 0) {
        return 0;
    }

    uint8_t **tmp_list = (uint8_t **)calloc(num_mods, sizeof(uint8_t *));

    if (tmp_list == nullptr) {
        return -1;
    }

    uint16_t unpacked_len = 0;

    for (uint16_t i = 0; i < num_mods; ++i) {
        tmp_list[i] = (uint8_t *)malloc(sizeof(uint8_t) * MOD_LIST_ENTRY_SIZE);

        if (tmp_list[i] == nullptr) {
            free_uint8_t_pointer_array(tmp_list, i);
            return -1;
        }

        memcpy(tmp_list[i], &data[i * MOD_LIST_ENTRY_SIZE], MOD_LIST_ENTRY_SIZE);
        unpacked_len += MOD_LIST_ENTRY_SIZE;
    }

    moderation->mod_list = tmp_list;
    moderation->num_mods = num_mods;

    return unpacked_len;
}

void mod_list_pack(const Moderation *moderation, uint8_t *data)
{
    for (uint16_t i = 0; i < moderation->num_mods; ++i) {
        memcpy(&data[i * MOD_LIST_ENTRY_SIZE], moderation->mod_list[i], MOD_LIST_ENTRY_SIZE);
    }
}

void mod_list_get_data_hash(uint8_t *hash, const uint8_t *packed_mod_list, uint16_t length)
{
    crypto_sha256(hash, packed_mod_list, length);
}

bool mod_list_make_hash(const Moderation *moderation, uint8_t *hash)
{
    if (moderation->num_mods == 0) {
        memset(hash, 0, MOD_MODERATION_HASH_SIZE);
        return true;
    }

    const size_t data_buf_size = mod_list_packed_size(moderation);

    assert(data_buf_size > 0);

    uint8_t *data = (uint8_t *)malloc(data_buf_size);

    if (data == nullptr) {
        return false;
    }

    mod_list_pack(moderation, data);

    mod_list_get_data_hash(hash, data, data_buf_size);

    free(data);

    return true;
}

/**
 * Returns moderator list index for public_sig_key.
 * Returns -1 if key is not in the list.
 */
non_null()
static int mod_list_index_of_sig_pk(const Moderation *moderation, const uint8_t *public_sig_key)
{
    for (uint16_t i = 0; i < moderation->num_mods; ++i) {
        if (memcmp(moderation->mod_list[i], public_sig_key, SIG_PUBLIC_KEY_SIZE) == 0) {
            return i;
        }
    }

    return -1;
}

bool mod_list_verify_sig_pk(const Moderation *moderation, const uint8_t *sig_pk)
{
    if (memcmp(moderation->founder_public_sig_key, sig_pk, SIG_PUBLIC_KEY_SIZE) == 0) {
        return true;
    }

    for (uint16_t i = 0; i < moderation->num_mods; ++i) {
        if (memcmp(moderation->mod_list[i], sig_pk, SIG_PUBLIC_KEY_SIZE) == 0) {
            return true;
        }
    }

    return false;
}

bool mod_list_remove_index(Moderation *moderation, uint16_t index)
{
    if (index >= moderation->num_mods) {
        return false;
    }

    if ((moderation->num_mods - 1) == 0) {
        mod_list_cleanup(moderation);
        return true;
    }

    --moderation->num_mods;

    if (index != moderation->num_mods) {
        memcpy(moderation->mod_list[index], moderation->mod_list[moderation->num_mods],
               MOD_LIST_ENTRY_SIZE);
    }

    free(moderation->mod_list[moderation->num_mods]);
    moderation->mod_list[moderation->num_mods] = nullptr;

    uint8_t **tmp_list = (uint8_t **)realloc(moderation->mod_list, moderation->num_mods * sizeof(uint8_t *));

    if (tmp_list == nullptr) {
        return false;
    }

    moderation->mod_list = tmp_list;

    return true;
}

bool mod_list_remove_entry(Moderation *moderation, const uint8_t *public_sig_key)
{
    if (moderation->num_mods == 0) {
        return false;
    }

    const int idx = mod_list_index_of_sig_pk(moderation, public_sig_key);

    if (idx == -1) {
        return false;
    }

    assert(idx <= UINT16_MAX);

    return mod_list_remove_index(moderation, (uint16_t)idx);
}

bool mod_list_add_entry(Moderation *moderation, const uint8_t *mod_data)
{
    if (moderation->num_mods >= MOD_MAX_NUM_MODERATORS) {
        return false;
    }

    uint8_t **tmp_list = (uint8_t **)realloc(moderation->mod_list, (moderation->num_mods + 1) * sizeof(uint8_t *));

    if (tmp_list == nullptr) {
        return false;
    }

    moderation->mod_list = tmp_list;

    tmp_list[moderation->num_mods] = (uint8_t *)malloc(sizeof(uint8_t) * MOD_LIST_ENTRY_SIZE);

    if (tmp_list[moderation->num_mods] == nullptr) {
        return false;
    }

    memcpy(tmp_list[moderation->num_mods], mod_data, MOD_LIST_ENTRY_SIZE);
    ++moderation->num_mods;

    return true;
}

void mod_list_cleanup(Moderation *moderation)
{
    free_uint8_t_pointer_array(moderation->mod_list, moderation->num_mods);
    moderation->num_mods = 0;
    moderation->mod_list = nullptr;
}

uint16_t sanctions_creds_pack(const Mod_Sanction_Creds *creds, uint8_t *data)
{
    uint16_t packed_len = 0;

    net_pack_u32(data + packed_len, creds->version);
    packed_len += sizeof(uint32_t);
    memcpy(data + packed_len, creds->hash, MOD_SANCTION_HASH_SIZE);
    packed_len += MOD_SANCTION_HASH_SIZE;
    net_pack_u16(data + packed_len, creds->checksum);
    packed_len += sizeof(uint16_t);
    memcpy(data + packed_len, creds->sig_pk, SIG_PUBLIC_KEY_SIZE);
    packed_len += SIG_PUBLIC_KEY_SIZE;
    memcpy(data + packed_len, creds->sig, SIGNATURE_SIZE);
    packed_len += SIGNATURE_SIZE;

    return packed_len;
}

uint16_t sanctions_list_packed_size(uint16_t num_sanctions)
{
    return MOD_SANCTION_PACKED_SIZE * num_sanctions;
}

int sanctions_list_pack(uint8_t *data, uint16_t length, const Mod_Sanction *sanctions, uint16_t num_sanctions,
                        const Mod_Sanction_Creds *creds)
{
    assert(sanctions != nullptr || num_sanctions == 0);
    assert(sanctions != nullptr || creds != nullptr);

    uint16_t packed_len = 0;

    for (uint16_t i = 0; i < num_sanctions; ++i) {
        if (packed_len + sizeof(uint8_t) + SIG_PUBLIC_KEY_SIZE + TIME_STAMP_SIZE > length) {
            return -1;
        }

        memcpy(data + packed_len, &sanctions[i].type, sizeof(uint8_t));
        packed_len += sizeof(uint8_t);
        memcpy(data + packed_len, sanctions[i].setter_public_sig_key, SIG_PUBLIC_KEY_SIZE);
        packed_len += SIG_PUBLIC_KEY_SIZE;
        net_pack_u64(data + packed_len, sanctions[i].time_set);
        packed_len += TIME_STAMP_SIZE;

        const uint8_t sanctions_type = sanctions[i].type;

        if (sanctions_type == SA_OBSERVER) {
            if (packed_len + ENC_PUBLIC_KEY_SIZE > length) {
                return -1;
            }

            memcpy(data + packed_len, sanctions[i].target_public_enc_key, ENC_PUBLIC_KEY_SIZE);
            packed_len += ENC_PUBLIC_KEY_SIZE;
        } else {
            return -1;
        }

        if (packed_len + SIGNATURE_SIZE > length) {
            return -1;
        }

        /* Signature must be packed last */
        memcpy(data + packed_len, sanctions[i].signature, SIGNATURE_SIZE);
        packed_len += SIGNATURE_SIZE;
    }

    if (creds == nullptr) {
        return packed_len;
    }

    if (length < packed_len || length - packed_len < MOD_SANCTIONS_CREDS_SIZE) {
        return -1;
    }

    const uint16_t cred_len = sanctions_creds_pack(creds, data + packed_len);

    if (cred_len != MOD_SANCTIONS_CREDS_SIZE) {
        return -1;
    }

    return (int)(packed_len + cred_len);
}

uint16_t sanctions_creds_unpack(Mod_Sanction_Creds *creds, const uint8_t *data)
{
    uint16_t len_processed = 0;

    net_unpack_u32(data + len_processed, &creds->version);
    len_processed += sizeof(uint32_t);
    memcpy(creds->hash, data + len_processed, MOD_SANCTION_HASH_SIZE);
    len_processed += MOD_SANCTION_HASH_SIZE;
    net_unpack_u16(data + len_processed, &creds->checksum);
    len_processed += sizeof(uint16_t);
    memcpy(creds->sig_pk, data + len_processed, SIG_PUBLIC_KEY_SIZE);
    len_processed += SIG_PUBLIC_KEY_SIZE;
    memcpy(creds->sig, data + len_processed, SIGNATURE_SIZE);
    len_processed += SIGNATURE_SIZE;

    return len_processed;
}

int sanctions_list_unpack(Mod_Sanction *sanctions, Mod_Sanction_Creds *creds, uint16_t max_sanctions,
                          const uint8_t *data, uint16_t length, uint16_t *processed_data_len)
{
    uint16_t num = 0;
    uint16_t len_processed = 0;

    while (num < max_sanctions && num < MOD_MAX_NUM_SANCTIONS && len_processed < length) {
        if (len_processed + sizeof(uint8_t) + SIG_PUBLIC_KEY_SIZE + TIME_STAMP_SIZE > length) {
            return -1;
        }

        memcpy(&sanctions[num].type, data + len_processed, sizeof(uint8_t));
        len_processed += sizeof(uint8_t);
        memcpy(sanctions[num].setter_public_sig_key, data + len_processed, SIG_PUBLIC_KEY_SIZE);
        len_processed += SIG_PUBLIC_KEY_SIZE;
        net_unpack_u64(data + len_processed, &sanctions[num].time_set);
        len_processed += TIME_STAMP_SIZE;

        if (sanctions[num].type == SA_OBSERVER) {
            if (len_processed + ENC_PUBLIC_KEY_SIZE > length) {
                return -1;
            }

            memcpy(sanctions[num].target_public_enc_key, data + len_processed, ENC_PUBLIC_KEY_SIZE);
            len_processed += ENC_PUBLIC_KEY_SIZE;
        } else {
            return -1;
        }

        if (len_processed + SIGNATURE_SIZE > length) {
            return -1;
        }

        memcpy(sanctions[num].signature, data + len_processed, SIGNATURE_SIZE);
        len_processed += SIGNATURE_SIZE;

        ++num;
    }

    if (length <= len_processed || length - len_processed < MOD_SANCTIONS_CREDS_SIZE) {
        if (length != len_processed) {
            return -1;
        }

        if (processed_data_len != nullptr) {
            *processed_data_len = len_processed;
        }

        return num;
    }

    const uint16_t creds_len = sanctions_creds_unpack(creds, data + len_processed);

    if (creds_len != MOD_SANCTIONS_CREDS_SIZE) {
        return -1;
    }

    if (processed_data_len != nullptr) {
        *processed_data_len = len_processed + creds_len;
    }

    return num;
}


/** @brief Creates a new sanction list hash and puts it in hash.
 *
 * The hash is derived from the signature of all entries plus the version number.
 * hash must have room for at least MOD_SANCTION_HASH_SIZE bytes.
 *
 * If num_sanctions is 0 the hash is zeroed.
 *
 * Return true on success.
 */
non_null(4) nullable(1)
static bool sanctions_list_make_hash(const Mod_Sanction *sanctions, uint32_t new_version, uint16_t num_sanctions,
                                     uint8_t *hash)
{
    if (num_sanctions == 0 || sanctions == nullptr) {
        memset(hash, 0, MOD_SANCTION_HASH_SIZE);
        return true;
    }

    const size_t sig_data_size = num_sanctions * SIGNATURE_SIZE;
    const size_t data_buf_size = sig_data_size + sizeof(uint32_t);

    // check for integer overflower
    if (data_buf_size < num_sanctions) {
        return false;
    }

    uint8_t *data = (uint8_t *)malloc(data_buf_size);

    if (data == nullptr) {
        return false;
    }

    for (uint16_t i = 0; i < num_sanctions; ++i) {
        memcpy(&data[i * SIGNATURE_SIZE], sanctions[i].signature, SIGNATURE_SIZE);
    }

    memcpy(&data[sig_data_size], &new_version, sizeof(uint32_t));
    crypto_sha256(hash, data, data_buf_size);

    free(data);

    return true;
}

/** @brief Verifies that sanction contains valid info and was assigned by a current mod or group founder.
 *
 * Returns true on success.
 */
non_null()
static bool sanctions_list_validate_entry(const Moderation *moderation, const Mod_Sanction *sanction)
{
    if (!mod_list_verify_sig_pk(moderation, sanction->setter_public_sig_key)) {
        return false;
    }

    if (sanction->type >= SA_INVALID) {
        return false;
    }

    if (sanction->time_set == 0) {
        return false;
    }

    uint8_t packed_data[MOD_SANCTION_PACKED_SIZE];
    const int packed_len = sanctions_list_pack(packed_data, sizeof(packed_data), sanction, 1, nullptr);

    if (packed_len <= (int) SIGNATURE_SIZE) {
        return false;
    }

    return crypto_signature_verify(sanction->signature, packed_data, packed_len - SIGNATURE_SIZE,
                                   sanction->setter_public_sig_key);
}

non_null()
static uint16_t sanctions_creds_get_checksum(const Mod_Sanction_Creds *creds)
{
    return data_checksum(creds->hash, sizeof(creds->hash));
}

non_null()
static void sanctions_creds_set_checksum(Mod_Sanction_Creds *creds)
{
    creds->checksum = sanctions_creds_get_checksum(creds);
}

bool sanctions_list_make_creds(Moderation *moderation)
{
    const Mod_Sanction_Creds old_creds = moderation->sanctions_creds;

    ++moderation->sanctions_creds.version;

    memcpy(moderation->sanctions_creds.sig_pk, moderation->self_public_sig_key, SIG_PUBLIC_KEY_SIZE);

    uint8_t hash[MOD_SANCTION_HASH_SIZE];

    if (!sanctions_list_make_hash(moderation->sanctions, moderation->sanctions_creds.version,
                                  moderation->num_sanctions, hash)) {
        moderation->sanctions_creds = old_creds;
        return false;
    }

    memcpy(moderation->sanctions_creds.hash, hash, MOD_SANCTION_HASH_SIZE);

    sanctions_creds_set_checksum(&moderation->sanctions_creds);

    if (!crypto_signature_create(moderation->sanctions_creds.sig, moderation->sanctions_creds.hash,
                                 MOD_SANCTION_HASH_SIZE, moderation->self_secret_sig_key)) {
        moderation->sanctions_creds = old_creds;
        return false;
    }

    return true;
}

/** @brief Validates sanction list credentials.
 *
 * Verifies that:
 * - the public signature key belongs to a mod or the founder
 * - the signature for the hash was made by the owner of the public signature key.
 * - the received hash matches our own hash of the new sanctions list
 * - the received checksum matches the received hash
 * - the new version is >= our current version
 *
 * Returns true on success.
 */
non_null(1, 3) nullable(2)
static bool sanctions_creds_validate(const Moderation *moderation, const Mod_Sanction *sanctions,
                                     const Mod_Sanction_Creds *creds, uint16_t num_sanctions)
{
    if (!mod_list_verify_sig_pk(moderation, creds->sig_pk)) {
        LOGGER_WARNING(moderation->log, "Invalid credentials signature pk");
        return false;
    }

    uint8_t hash[MOD_SANCTION_HASH_SIZE];

    if (!sanctions_list_make_hash(sanctions, creds->version, num_sanctions, hash)) {
        return false;
    }

    if (memcmp(hash, creds->hash, MOD_SANCTION_HASH_SIZE) != 0) {
        LOGGER_WARNING(moderation->log, "Invalid credentials hash");
        return false;
    }

    if (creds->checksum != sanctions_creds_get_checksum(creds)) {
        LOGGER_WARNING(moderation->log, "Invalid credentials checksum");
        return false;
    }

    if (moderation->shared_state_version > 0) {
        if ((creds->version < moderation->sanctions_creds.version)
                && !(creds->version == 0 && moderation->sanctions_creds.version == UINT32_MAX)) {
            LOGGER_WARNING(moderation->log, "Invalid version");
            return false;
        }
    }

    if (!crypto_signature_verify(creds->sig, hash, MOD_SANCTION_HASH_SIZE, creds->sig_pk)) {
        LOGGER_WARNING(moderation->log, "Invalid signature");
        return false;
    }

    return true;
}

bool sanctions_list_check_integrity(const Moderation *moderation, const Mod_Sanction_Creds *creds,
                                    const Mod_Sanction *sanctions, uint16_t num_sanctions)
{
    for (uint16_t i = 0; i < num_sanctions; ++i) {
        if (!sanctions_list_validate_entry(moderation, &sanctions[i])) {
            LOGGER_WARNING(moderation->log, "Invalid entry");
            return false;
        }
    }

    return sanctions_creds_validate(moderation, sanctions, creds, num_sanctions);
}

/** @brief Validates a sanctions list if credentials are supplied. If successful,
 *   or if no credentials are supplied, assigns new sanctions list and credentials
 *   to moderation object.
 *
 * @param moderation The moderation object being operated on.
 * @param new_sanctions The sanctions list to validate and assign to moderation object.
 * @param new_creds The new sanctions credentials to be assigned to moderation object.
 * @param num_sanctions The number of sanctions in the sanctions list.
 *
 * @retval false if sanctions credentials validation fails.
 */
non_null(1, 2) nullable(3)
static bool sanctions_apply_new(Moderation *moderation, Mod_Sanction *new_sanctions,
                                const Mod_Sanction_Creds *new_creds,
                                uint16_t num_sanctions)
{
    if (new_creds != nullptr) {
        if (!sanctions_creds_validate(moderation, new_sanctions, new_creds, num_sanctions)) {
            LOGGER_WARNING(moderation->log, "Failed to validate credentials");
            return false;
        }

        moderation->sanctions_creds = *new_creds;
    }

    sanctions_list_cleanup(moderation);
    moderation->sanctions = new_sanctions;
    moderation->num_sanctions = num_sanctions;

    return true;
}

/** @brief Returns a copy of the sanctions list. The caller is responsible for freeing the
 * memory returned by this function.
 */
non_null()
static Mod_Sanction *sanctions_list_copy(const Mod_Sanction *sanctions, uint16_t num_sanctions)
{
    Mod_Sanction *copy = (Mod_Sanction *)calloc(num_sanctions, sizeof(Mod_Sanction));

    if (copy == nullptr) {
        return nullptr;
    }

    memcpy(copy, sanctions, num_sanctions * sizeof(Mod_Sanction));

    return copy;
}

/** @brief Removes index-th sanction list entry.
 *
 * New credentials will be validated if creds is non-null.
 *
 * Returns true on success.
 */
non_null(1) nullable(3)
static bool sanctions_list_remove_index(Moderation *moderation, uint16_t index, const Mod_Sanction_Creds *creds)
{
    if (index >= moderation->num_sanctions) {
        return false;
    }

    const uint16_t new_num = moderation->num_sanctions - 1;

    if (new_num == 0) {
        if (creds != nullptr) {
            if (!sanctions_creds_validate(moderation, nullptr, creds, 0)) {
                return false;
            }

            moderation->sanctions_creds = *creds;
        }

        sanctions_list_cleanup(moderation);

        return true;
    }

    /* Operate on a copy of the list in case something goes wrong. */
    Mod_Sanction *sanctions_copy = sanctions_list_copy(moderation->sanctions, moderation->num_sanctions);

    if (sanctions_copy == nullptr) {
        return false;
    }

    if (index != new_num) {
        sanctions_copy[index] = sanctions_copy[new_num];
    }

    Mod_Sanction *new_list = (Mod_Sanction *)realloc(sanctions_copy, new_num * sizeof(Mod_Sanction));

    if (new_list == nullptr) {
        free(sanctions_copy);
        return false;
    }

    if (!sanctions_apply_new(moderation, new_list, creds, new_num)) {
        free(new_list);
        return false;
    }

    return true;
}

bool sanctions_list_remove_observer(Moderation *moderation, const uint8_t *public_key,
                                    const Mod_Sanction_Creds *creds)
{
    for (uint16_t i = 0; i < moderation->num_sanctions; ++i) {
        const Mod_Sanction *curr_sanction = &moderation->sanctions[i];

        if (curr_sanction->type != SA_OBSERVER) {
            continue;
        }

        if (memcmp(public_key, curr_sanction->target_public_enc_key, ENC_PUBLIC_KEY_SIZE) == 0) {
            if (!sanctions_list_remove_index(moderation, i, creds)) {
                return false;
            }

            if (creds == nullptr) {
                return sanctions_list_make_creds(moderation);
            }

            return true;
        }
    }

    return false;
}

bool sanctions_list_is_observer(const Moderation *moderation, const uint8_t *public_key)
{
    for (uint16_t i = 0; i < moderation->num_sanctions; ++i) {
        const Mod_Sanction *curr_sanction = &moderation->sanctions[i];

        if (curr_sanction->type != SA_OBSERVER) {
            continue;
        }

        if (memcmp(curr_sanction->target_public_enc_key, public_key, ENC_PUBLIC_KEY_SIZE) == 0) {
            return true;
        }
    }

    return false;
}

bool sanctions_list_entry_exists(const Moderation *moderation, const Mod_Sanction *sanction)
{
    if (sanction->type == SA_OBSERVER) {
        return sanctions_list_is_observer(moderation, sanction->target_public_enc_key);
    }

    return false;
}

bool sanctions_list_add_entry(Moderation *moderation, const Mod_Sanction *sanction, const Mod_Sanction_Creds *creds)
{
    if (moderation->num_sanctions >= MOD_MAX_NUM_SANCTIONS) {
        LOGGER_WARNING(moderation->log, "num_sanctions %d exceeds maximum", moderation->num_sanctions);
        return false;
    }

    if (!sanctions_list_validate_entry(moderation, sanction)) {
        LOGGER_ERROR(moderation->log, "Failed to validate sanction");
        return false;
    }

    if (sanctions_list_entry_exists(moderation, sanction)) {
        LOGGER_WARNING(moderation->log, "Attempted to add duplicate sanction");
        return false;
    }

    /* Operate on a copy of the list in case something goes wrong. */
    Mod_Sanction *sanctions_copy = nullptr;

    if (moderation->num_sanctions > 0) {
        sanctions_copy = sanctions_list_copy(moderation->sanctions, moderation->num_sanctions);

        if (sanctions_copy == nullptr) {
            return false;
        }
    }

    const uint16_t index = moderation->num_sanctions;
    Mod_Sanction *new_list = (Mod_Sanction *)realloc(sanctions_copy, (index + 1) * sizeof(Mod_Sanction));

    if (new_list == nullptr) {
        free(sanctions_copy);
        return false;
    }

    new_list[index] = *sanction;

    if (!sanctions_apply_new(moderation, new_list, creds, index + 1)) {
        free(new_list);
        return false;
    }

    return true;
}

/** @brief Signs packed sanction data.
 *
 * This function must be called by the owner of the entry's public_sig_key.
 *
 * Returns true on success.
 */
non_null()
static bool sanctions_list_sign_entry(const Moderation *moderation, Mod_Sanction *sanction)
{
    uint8_t packed_data[MOD_SANCTION_PACKED_SIZE];
    const int packed_len = sanctions_list_pack(packed_data, sizeof(packed_data), sanction, 1, nullptr);

    if (packed_len <= (int) SIGNATURE_SIZE) {
        LOGGER_ERROR(moderation->log, "Failed to pack sanctions list: %d", packed_len);
        return false;
    }

    return crypto_signature_create(sanction->signature, packed_data, packed_len - SIGNATURE_SIZE,
                                   moderation->self_secret_sig_key);
}

bool sanctions_list_make_entry(Moderation *moderation, const uint8_t *public_key, Mod_Sanction *sanction,
                               uint8_t type)
{
    *sanction = (Mod_Sanction) {
        0
    };

    if (type == SA_OBSERVER) {
        memcpy(sanction->target_public_enc_key, public_key, ENC_PUBLIC_KEY_SIZE);
    } else {
        LOGGER_ERROR(moderation->log, "Tried to create sanction with invalid type: %u", type);
        return false;
    }

    memcpy(sanction->setter_public_sig_key, moderation->self_public_sig_key, SIG_PUBLIC_KEY_SIZE);

    sanction->time_set = (uint64_t)time(nullptr);
    sanction->type = type;

    if (!sanctions_list_sign_entry(moderation, sanction)) {
        LOGGER_ERROR(moderation->log, "Failed to sign sanction");
        return false;
    }

    if (!sanctions_list_add_entry(moderation, sanction, nullptr)) {
        return false;
    }

    if (!sanctions_list_make_creds(moderation)) {
        LOGGER_ERROR(moderation->log, "Failed to make credentials for new sanction");
        return false;
    }

    return true;
}
uint16_t sanctions_list_replace_sig(Moderation *moderation, const uint8_t *public_sig_key)
{
    uint16_t count = 0;

    for (uint16_t i = 0; i < moderation->num_sanctions; ++i) {
        if (memcmp(moderation->sanctions[i].setter_public_sig_key, public_sig_key, SIG_PUBLIC_KEY_SIZE) != 0) {
            continue;
        }

        memcpy(moderation->sanctions[i].setter_public_sig_key, moderation->self_public_sig_key, SIG_PUBLIC_KEY_SIZE);

        if (!sanctions_list_sign_entry(moderation, &moderation->sanctions[i])) {
            LOGGER_ERROR(moderation->log, "Failed to sign sanction");
            continue;
        }

        ++count;
    }

    if (count > 0) {
        if (!sanctions_list_make_creds(moderation)) {
            return 0;
        }
    }

    return count;
}

void sanctions_list_cleanup(Moderation *moderation)
{
    if (moderation->sanctions != nullptr) {
        free(moderation->sanctions);
    }

    moderation->sanctions = nullptr;
    moderation->num_sanctions = 0;
}
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2020 The TokTok team.
 * Copyright © 2015 Tox project.
 */


#include <assert.h>
#include <string.h>


static_assert(GCA_ANNOUNCE_MAX_SIZE <= ONION_MAX_EXTRA_DATA_SIZE,
              "GC_Announce does not fit into the onion packet extra data");

static pack_extra_data_cb pack_group_announces;
non_null()
static int pack_group_announces(void *object, const Logger *logger, const Mono_Time *mono_time,
                                uint8_t num_nodes, uint8_t *plain, uint16_t plain_size,
                                uint8_t *response, uint16_t response_size, uint16_t offset)
{
    GC_Announces_List *gc_announces_list = (GC_Announces_List *)object;
    GC_Public_Announce public_announce;

    if (gca_unpack_public_announce(logger, plain, plain_size,
                                   &public_announce) == -1) {
        LOGGER_WARNING(logger, "Failed to unpack public group announce");
        return -1;
    }

    const GC_Peer_Announce *new_announce = gca_add_announce(mono_time, gc_announces_list, &public_announce);

    if (new_announce == nullptr) {
        LOGGER_ERROR(logger, "Failed to add group announce");
        return -1;
    }

    GC_Announce gc_announces[GCA_MAX_SENT_ANNOUNCES];
    const int num_ann = gca_get_announces(gc_announces_list,
                                          gc_announces,
                                          GCA_MAX_SENT_ANNOUNCES,
                                          public_announce.chat_public_key,
                                          new_announce->base_announce.peer_public_key);

    if (num_ann < 0) {
        LOGGER_ERROR(logger, "failed to get group announce");
        return -1;
    }

    assert(num_ann <= UINT8_MAX);

    size_t announces_length = 0;

    if (gca_pack_announces_list(logger, response + offset, response_size - offset, gc_announces, (uint8_t)num_ann,
                                &announces_length) != num_ann) {
        LOGGER_WARNING(logger, "Failed to pack group announces list");
        return -1;
    }

    return announces_length;
}

void gca_onion_init(GC_Announces_List *group_announce, Onion_Announce *onion_a)
{
    onion_announce_extra_data_callback(onion_a, GCA_MAX_SENT_ANNOUNCES * sizeof(GC_Announce), pack_group_announces,
                                       group_announce);
}

#ifndef VANILLA_NACL

int create_gca_announce_request(
    const Random *rng, uint8_t *packet, uint16_t max_packet_length, const uint8_t *dest_client_id,
    const uint8_t *public_key, const uint8_t *secret_key, const uint8_t *ping_id,
    const uint8_t *client_id, const uint8_t *data_public_key, uint64_t sendback_data,
    const uint8_t *gc_data, uint16_t gc_data_length)
{
    if (max_packet_length < ONION_ANNOUNCE_REQUEST_MAX_SIZE || gc_data_length == 0) {
        return -1;
    }

    uint8_t plain[ONION_PING_ID_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_PUBLIC_KEY_SIZE +
                                     ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + GCA_ANNOUNCE_MAX_SIZE];
    uint8_t *position_in_plain = plain;
    const size_t encrypted_size = sizeof(plain) - GCA_ANNOUNCE_MAX_SIZE + gc_data_length;

    memcpy(plain, ping_id, ONION_PING_ID_SIZE);
    position_in_plain += ONION_PING_ID_SIZE;

    memcpy(position_in_plain, client_id, CRYPTO_PUBLIC_KEY_SIZE);
    position_in_plain += CRYPTO_PUBLIC_KEY_SIZE;

    memcpy(position_in_plain, data_public_key, CRYPTO_PUBLIC_KEY_SIZE);
    position_in_plain += CRYPTO_PUBLIC_KEY_SIZE;

    memcpy(position_in_plain, &sendback_data, sizeof(sendback_data));
    position_in_plain += sizeof(sendback_data);

    memcpy(position_in_plain, gc_data, gc_data_length);

    packet[0] = NET_PACKET_ANNOUNCE_REQUEST;
    random_nonce(rng, packet + 1);
    memcpy(packet + 1 + CRYPTO_NONCE_SIZE, public_key, CRYPTO_PUBLIC_KEY_SIZE);

    const int len = encrypt_data(dest_client_id, secret_key, packet + 1, plain,
                                 encrypted_size, packet + 1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE);

    const uint32_t full_length = (uint32_t)len + 1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE;

    if (full_length != ONION_ANNOUNCE_REQUEST_MIN_SIZE + gc_data_length) {
        return -1;
    }

    return full_length;
}
#endif  // VANILLA_NACL
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2020 The TokTok team.
 * Copyright © 2015 Tox project.
 */

/**
 * Packer and unpacker functions for saving and loading groups.
 */


#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


non_null()
static bool load_unpack_state_values(GC_Chat *chat, Bin_Unpack *bu)
{
    if (!bin_unpack_array_fixed(bu, 8)) {
        LOGGER_ERROR(chat->log, "Group state values array malformed");
        return false;
    }

    bool manually_disconnected = false;
    uint8_t privacy_state = 0;
    uint8_t voice_state = 0;

    if (!(bin_unpack_bool(bu, &manually_disconnected)
            && bin_unpack_u16(bu, &chat->shared_state.group_name_len)
            && bin_unpack_u08(bu, &privacy_state)
            && bin_unpack_u16(bu, &chat->shared_state.maxpeers)
            && bin_unpack_u16(bu, &chat->shared_state.password_length)
            && bin_unpack_u32(bu, &chat->shared_state.version)
            && bin_unpack_u32(bu, &chat->shared_state.topic_lock)
            && bin_unpack_u08(bu, &voice_state))) {
        LOGGER_ERROR(chat->log, "Failed to unpack state value");
        return false;
    }

    chat->connection_state = manually_disconnected ? CS_DISCONNECTED : CS_CONNECTING;
    chat->shared_state.privacy_state = (Group_Privacy_State)privacy_state;
    chat->shared_state.voice_state = (Group_Voice_State)voice_state;

    // we always load saved groups as private in case the group became private while we were offline.
    // this will have no detrimental effect if the group is public, as the correct privacy
    // state will be set via sync.
    chat->join_type = HJ_PRIVATE;

    return true;
}

non_null()
static bool load_unpack_state_bin(GC_Chat *chat, Bin_Unpack *bu)
{
    if (!bin_unpack_array_fixed(bu, 5)) {
        LOGGER_ERROR(chat->log, "Group state binary array malformed");
        return false;
    }

    if (!(bin_unpack_bin_fixed(bu, chat->shared_state_sig, SIGNATURE_SIZE)
            && bin_unpack_bin_fixed(bu, chat->shared_state.founder_public_key, EXT_PUBLIC_KEY_SIZE)
            && bin_unpack_bin_fixed(bu, chat->shared_state.group_name, chat->shared_state.group_name_len)
            && bin_unpack_bin_fixed(bu, chat->shared_state.password, chat->shared_state.password_length)
            && bin_unpack_bin_fixed(bu, chat->shared_state.mod_list_hash, MOD_MODERATION_HASH_SIZE))) {
        LOGGER_ERROR(chat->log, "Failed to unpack state binary data");
        return false;
    }

    return true;
}

non_null()
static bool load_unpack_topic_info(GC_Chat *chat, Bin_Unpack *bu)
{
    if (!bin_unpack_array_fixed(bu, 6)) {
        LOGGER_ERROR(chat->log, "Group topic array malformed");
        return false;
    }

    if (!(bin_unpack_u32(bu, &chat->topic_info.version)
            && bin_unpack_u16(bu, &chat->topic_info.length)
            && bin_unpack_u16(bu, &chat->topic_info.checksum)
            && bin_unpack_bin_fixed(bu, chat->topic_info.topic, chat->topic_info.length)
            && bin_unpack_bin_fixed(bu, chat->topic_info.public_sig_key, SIG_PUBLIC_KEY_SIZE)
            && bin_unpack_bin_fixed(bu, chat->topic_sig, SIGNATURE_SIZE))) {
        LOGGER_ERROR(chat->log, "Failed to unpack topic info");
        return false;
    }

    return true;
}

non_null()
static bool load_unpack_mod_list(GC_Chat *chat, Bin_Unpack *bu)
{
    if (!bin_unpack_array_fixed(bu, 2)) {
        LOGGER_ERROR(chat->log, "Group mod list array malformed");
        return false;
    }

    if (!bin_unpack_u16(bu, &chat->moderation.num_mods)) {
        LOGGER_ERROR(chat->log, "Failed to unpack mod list value");
        return false;
    }

    if (chat->moderation.num_mods == 0) {
        bin_unpack_nil(bu);
        return true;
    }

    if (chat->moderation.num_mods > MOD_MAX_NUM_MODERATORS) {
        LOGGER_ERROR(chat->log, "moderation count %u exceeds maximum %u", chat->moderation.num_mods, MOD_MAX_NUM_MODERATORS);
        chat->moderation.num_mods = MOD_MAX_NUM_MODERATORS;
    }

    uint8_t *packed_mod_list = (uint8_t *)malloc(chat->moderation.num_mods * MOD_LIST_ENTRY_SIZE);

    if (packed_mod_list == nullptr) {
        LOGGER_ERROR(chat->log, "Failed to allocate memory for packed mod list");
        return false;
    }

    const size_t packed_size = chat->moderation.num_mods * MOD_LIST_ENTRY_SIZE;

    if (!bin_unpack_bin_fixed(bu, packed_mod_list, packed_size)) {
        LOGGER_ERROR(chat->log, "Failed to unpack mod list binary data");
        free(packed_mod_list);
        return false;
    }

    if (mod_list_unpack(&chat->moderation, packed_mod_list, packed_size, chat->moderation.num_mods) == -1) {
        LOGGER_ERROR(chat->log, "Failed to unpack mod list info");
        free(packed_mod_list);
        return false;
    }

    free(packed_mod_list);

    return true;
}

non_null()
static bool load_unpack_keys(GC_Chat *chat, Bin_Unpack *bu)
{
    if (!bin_unpack_array_fixed(bu, 4)) {
        LOGGER_ERROR(chat->log, "Group keys array malformed");
        return false;
    }

    if (!(bin_unpack_bin_fixed(bu, chat->chat_public_key, EXT_PUBLIC_KEY_SIZE)
            && bin_unpack_bin_fixed(bu, chat->chat_secret_key, EXT_SECRET_KEY_SIZE)
            && bin_unpack_bin_fixed(bu, chat->self_public_key, EXT_PUBLIC_KEY_SIZE)
            && bin_unpack_bin_fixed(bu, chat->self_secret_key, EXT_SECRET_KEY_SIZE))) {
        LOGGER_ERROR(chat->log, "Failed to unpack keys");
        return false;
    }

    return true;
}

non_null()
static bool load_unpack_self_info(GC_Chat *chat, Bin_Unpack *bu)
{
    if (!bin_unpack_array_fixed(bu, 4)) {
        LOGGER_ERROR(chat->log, "Group self info array malformed");
        return false;
    }

    uint8_t self_nick[MAX_GC_NICK_SIZE];
    uint16_t self_nick_len = 0;
    uint8_t self_role = GR_USER;
    uint8_t self_status = GS_NONE;

    if (!(bin_unpack_u16(bu, &self_nick_len)
            && bin_unpack_u08(bu, &self_role)
            && bin_unpack_u08(bu, &self_status))) {
        LOGGER_ERROR(chat->log, "Failed to unpack self values");
        return false;
    }

    if (self_nick_len > MAX_GC_NICK_SIZE) {
        LOGGER_ERROR(chat->log, "self_nick too big (%u bytes), truncating to %d", self_nick_len, MAX_GC_NICK_SIZE);
        self_nick_len = MAX_GC_NICK_SIZE;
    }

    if (!bin_unpack_bin_fixed(bu, self_nick, self_nick_len)) {
        LOGGER_ERROR(chat->log, "Failed to unpack self nick bytes");
        return false;
    }

    // we have to add ourself before setting self info
    if (peer_add(chat, nullptr, chat->self_public_key) != 0) {
        LOGGER_ERROR(chat->log, "Failed to add self to peer list");
        return false;
    }

    if (chat->numpeers == 0) {
        LOGGER_ERROR(chat->log, "Failed to unpack self: numpeers should be > 0");
        return false;
    }

    GC_Peer *self = &chat->group[0];

    memcpy(self->gconn.addr.public_key, chat->self_public_key, EXT_PUBLIC_KEY_SIZE);
    memcpy(self->nick, self_nick, self_nick_len);
    self->nick_length = self_nick_len;
    self->role = (Group_Role)self_role;
    self->status = (Group_Peer_Status)self_status;
    self->gconn.confirmed = true;

    return true;
}

non_null()
static bool load_unpack_saved_peers(GC_Chat *chat, Bin_Unpack *bu)
{
    if (!bin_unpack_array_fixed(bu, 2)) {
        LOGGER_ERROR(chat->log, "Group saved peers array malformed");
        return false;
    }

    // Saved peers
    uint16_t saved_peers_size = 0;

    if (!bin_unpack_u16(bu, &saved_peers_size)) {
        LOGGER_ERROR(chat->log, "Failed to unpack saved peers value");
        return false;
    }

    if (saved_peers_size == 0) {
        bin_unpack_nil(bu);
        return true;
    }

    uint8_t *saved_peers = (uint8_t *)malloc(saved_peers_size * GC_SAVED_PEER_SIZE);

    if (saved_peers == nullptr) {
        LOGGER_ERROR(chat->log, "Failed to allocate memory for saved peer list");
        return false;
    }

    if (!bin_unpack_bin_fixed(bu, saved_peers, saved_peers_size)) {
        LOGGER_ERROR(chat->log, "Failed to unpack saved peers binary data");
        free(saved_peers);
        return false;
    }

    if (unpack_gc_saved_peers(chat, saved_peers, saved_peers_size) == -1) {
        LOGGER_ERROR(chat->log, "Failed to unpack saved peers");  // recoverable error
    }

    free(saved_peers);

    return true;
}

bool gc_load_unpack_group(GC_Chat *chat, Bin_Unpack *bu)
{
    if (!bin_unpack_array_fixed(bu, 7)) {
        LOGGER_ERROR(chat->log, "Group info array malformed");
        return false;
    }

    return load_unpack_state_values(chat, bu)
           && load_unpack_state_bin(chat, bu)
           && load_unpack_topic_info(chat, bu)
           && load_unpack_mod_list(chat, bu)
           && load_unpack_keys(chat, bu)
           && load_unpack_self_info(chat, bu)
           && load_unpack_saved_peers(chat, bu);
}

non_null()
static void save_pack_state_values(const GC_Chat *chat, Bin_Pack *bp)
{
    bin_pack_array(bp, 8);
    bin_pack_bool(bp, chat->connection_state == CS_DISCONNECTED); // 1
    bin_pack_u16(bp, chat->shared_state.group_name_len); // 2
    bin_pack_u08(bp, chat->shared_state.privacy_state); // 3
    bin_pack_u16(bp, chat->shared_state.maxpeers); // 4
    bin_pack_u16(bp, chat->shared_state.password_length); // 5
    bin_pack_u32(bp, chat->shared_state.version); // 6
    bin_pack_u32(bp, chat->shared_state.topic_lock); // 7
    bin_pack_u08(bp, chat->shared_state.voice_state); // 8
}

non_null()
static void save_pack_state_bin(const GC_Chat *chat, Bin_Pack *bp)
{
    bin_pack_array(bp, 5);

    bin_pack_bin(bp, chat->shared_state_sig, SIGNATURE_SIZE); // 1
    bin_pack_bin(bp, chat->shared_state.founder_public_key, EXT_PUBLIC_KEY_SIZE); // 2
    bin_pack_bin(bp, chat->shared_state.group_name, chat->shared_state.group_name_len); // 3
    bin_pack_bin(bp, chat->shared_state.password, chat->shared_state.password_length); // 4
    bin_pack_bin(bp, chat->shared_state.mod_list_hash, MOD_MODERATION_HASH_SIZE); // 5
}

non_null()
static void save_pack_topic_info(const GC_Chat *chat, Bin_Pack *bp)
{
    bin_pack_array(bp, 6);

    bin_pack_u32(bp, chat->topic_info.version); // 1
    bin_pack_u16(bp, chat->topic_info.length); // 2
    bin_pack_u16(bp, chat->topic_info.checksum); // 3
    bin_pack_bin(bp, chat->topic_info.topic, chat->topic_info.length); // 4
    bin_pack_bin(bp, chat->topic_info.public_sig_key, SIG_PUBLIC_KEY_SIZE); // 5
    bin_pack_bin(bp, chat->topic_sig, SIGNATURE_SIZE); // 6
}

non_null()
static void save_pack_mod_list(const GC_Chat *chat, Bin_Pack *bp)
{
    bin_pack_array(bp, 2);

    const uint16_t num_mods = min_u16(chat->moderation.num_mods, MOD_MAX_NUM_MODERATORS);

    if (num_mods == 0) {
        bin_pack_u16(bp, num_mods); // 1
        bin_pack_nil(bp); // 2
        return;
    }

    uint8_t *packed_mod_list = (uint8_t *)malloc(num_mods * MOD_LIST_ENTRY_SIZE);

    // we can still recover without the mod list
    if (packed_mod_list == nullptr) {
        bin_pack_u16(bp, 0); // 1
        bin_pack_nil(bp); // 2
        LOGGER_ERROR(chat->log, "Failed to allocate memory for moderation list");
        return;
    }

    bin_pack_u16(bp, num_mods); // 1

    mod_list_pack(&chat->moderation, packed_mod_list);

    const size_t packed_size = num_mods * MOD_LIST_ENTRY_SIZE;

    bin_pack_bin(bp, packed_mod_list, packed_size); // 2

    free(packed_mod_list);
}

non_null()
static void save_pack_keys(const GC_Chat *chat, Bin_Pack *bp)
{
    bin_pack_array(bp, 4);

    bin_pack_bin(bp, chat->chat_public_key, EXT_PUBLIC_KEY_SIZE); // 1
    bin_pack_bin(bp, chat->chat_secret_key, EXT_SECRET_KEY_SIZE); // 2
    bin_pack_bin(bp, chat->self_public_key, EXT_PUBLIC_KEY_SIZE); // 3
    bin_pack_bin(bp, chat->self_secret_key, EXT_SECRET_KEY_SIZE); // 4
}

non_null()
static void save_pack_self_info(const GC_Chat *chat, Bin_Pack *bp)
{
    bin_pack_array(bp, 4);

    GC_Peer *self = &chat->group[0];

    if (self->nick_length > MAX_GC_NICK_SIZE) {
        LOGGER_ERROR(chat->log, "self_nick is too big (%u). Truncating to %d", self->nick_length, MAX_GC_NICK_SIZE);
        self->nick_length = MAX_GC_NICK_SIZE;
    }

    bin_pack_u16(bp, self->nick_length); // 1
    bin_pack_u08(bp, (uint8_t)self->role); // 2
    bin_pack_u08(bp, (uint8_t)self->status); // 3
    bin_pack_bin(bp, self->nick, self->nick_length); // 4
}

non_null()
static void save_pack_saved_peers(const GC_Chat *chat, Bin_Pack *bp)
{
    bin_pack_array(bp, 2);

    uint8_t *saved_peers = (uint8_t *)malloc(GC_MAX_SAVED_PEERS * GC_SAVED_PEER_SIZE);

    // we can still recover without the saved peers list
    if (saved_peers == nullptr) {
        bin_pack_u16(bp, 0); // 1
        bin_pack_nil(bp); // 2
        LOGGER_ERROR(chat->log, "Failed to allocate memory for saved peers list");
        return;
    }

    uint16_t packed_size = 0;
    const int count = pack_gc_saved_peers(chat, saved_peers, GC_MAX_SAVED_PEERS * GC_SAVED_PEER_SIZE, &packed_size);

    if (count < 0) {
        LOGGER_ERROR(chat->log, "Failed to pack saved peers");
    }

    bin_pack_u16(bp, packed_size); // 1

    if (packed_size == 0) {
        bin_pack_nil(bp); // 2
        free(saved_peers);
        return;
    }

    bin_pack_bin(bp, saved_peers, packed_size); // 2

    free(saved_peers);
}

void gc_save_pack_group(const GC_Chat *chat, Bin_Pack *bp)
{
    if (chat->numpeers == 0) {
        LOGGER_ERROR(chat->log, "Failed to pack group: numpeers is 0");
        return;
    }

    bin_pack_array(bp, 7);

#if 0
    // --------------------------------------
    // HINT: dump chat struct with data
#if defined __GNUC__
    #ifdef __MINGW32__
        #define COMPILER "MinGW GCC %d.%d.%d"
    #else
        #define COMPILER "GCC %d.%d.%d"
    #endif

    #if defined(__clang__)
        #define COMP_VERSION __clang_major__, __clang_minor__, __clang_patchlevel__
        #define COMPILER_CLANG "Clang %d.%d.%d"
        printf("  Compiled using " COMPILER_CLANG "\n", COMP_VERSION);
    #else
        #define COMP_VERSION __GNUC__, __GNUC_MINOR__, __GNUC_PATCHLEVEL__
        printf("  Compiled using " COMPILER "\n", COMP_VERSION);
    #endif
#endif

#if defined(__clang__) && (__clang_major__ > 7)
    printf("\n");
    printf("\n");
    printf("========= START =========\n");
    __builtin_dump_struct(chat, &printf);
    printf("=========  END  =========\n");
    printf("\n");
    printf("\n");
#endif
    // HINT: dump chat struct with data
    // ---------------------------------------
#endif

    save_pack_state_values(chat, bp); // 1
    save_pack_state_bin(chat, bp); // 2
    save_pack_topic_info(chat, bp); // 3
    save_pack_mod_list(chat, bp); // 4
    save_pack_keys(chat, bp); // 5
    save_pack_self_info(chat, bp); // 6
    save_pack_saved_peers(chat, bp); // 7
}
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2018 The TokTok team.
 * Copyright © 2013 Tox project.
 */

/**
 * LAN discovery implementation.
 */

#include <stdlib.h>
#include <string.h>

#if defined(_WIN32) || defined(__WIN32__) || defined(WIN32)
// The mingw32/64 Windows library warns about including winsock2.h after
// windows.h even though with the above it's a valid thing to do. So, to make
// mingw32 headers happy, we include winsock2.h first.
#include <winsock2.h>

#include <windows.h>
#include <ws2tcpip.h>

#include <iphlpapi.h>
#endif

#if defined(__linux__) || defined(__FreeBSD__) || defined(__DragonFly__)
#include <netinet/in.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <unistd.h>
#endif

#ifdef __linux__
#include <linux/netdevice.h>
#endif

#if defined(__FreeBSD__) || defined(__DragonFly__)
#include <net/if.h>
#endif


#define MAX_INTERFACES 16


struct Broadcast_Info {
    uint32_t count;
    IP ips[MAX_INTERFACES];
};

#if defined(_WIN32) || defined(__WIN32__) || defined(WIN32)

non_null()
static Broadcast_Info *fetch_broadcast_info(const Network *ns)
{
    Broadcast_Info *broadcast = (Broadcast_Info *)calloc(1, sizeof(Broadcast_Info));

    if (broadcast == nullptr) {
        return nullptr;
    }

    IP_ADAPTER_INFO *pAdapterInfo = (IP_ADAPTER_INFO *)malloc(sizeof(IP_ADAPTER_INFO));
    unsigned long ulOutBufLen = sizeof(IP_ADAPTER_INFO);

    if (pAdapterInfo == nullptr) {
        free(broadcast);
        return nullptr;
    }

    if (GetAdaptersInfo(pAdapterInfo, &ulOutBufLen) == ERROR_BUFFER_OVERFLOW) {
        free(pAdapterInfo);
        pAdapterInfo = (IP_ADAPTER_INFO *)malloc(ulOutBufLen);

        if (pAdapterInfo == nullptr) {
            free(broadcast);
            return nullptr;
        }
    }

    const int ret = GetAdaptersInfo(pAdapterInfo, &ulOutBufLen);

    if (ret == NO_ERROR) {
        IP_ADAPTER_INFO *pAdapter = pAdapterInfo;

        while (pAdapter != nullptr) {
            IP gateway = {0};
            IP subnet_mask = {0};

            if (addr_parse_ip(pAdapter->IpAddressList.IpMask.String, &subnet_mask)
                    && addr_parse_ip(pAdapter->GatewayList.IpAddress.String, &gateway)) {
                if (net_family_is_ipv4(gateway.family) && net_family_is_ipv4(subnet_mask.family)) {
                    IP *ip = &broadcast->ips[broadcast->count];
                    ip->family = net_family_ipv4();
                    const uint32_t gateway_ip = net_ntohl(gateway.ip.v4.uint32);
                    const uint32_t subnet_ip = net_ntohl(subnet_mask.ip.v4.uint32);
                    const uint32_t broadcast_ip = gateway_ip + ~subnet_ip - 1;
                    ip->ip.v4.uint32 = net_htonl(broadcast_ip);
                    ++broadcast->count;

                    if (broadcast->count >= MAX_INTERFACES) {
                        break;
                    }
                }
            }

            pAdapter = pAdapter->Next;
        }
    }

    if (pAdapterInfo != nullptr) {
        free(pAdapterInfo);
    }

    return broadcast;
}

#elif !defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION) && (defined(__linux__) || defined(__FreeBSD__) || defined(__DragonFly__))

non_null()
static bool ip4_is_local(const IP4 *ip4);

non_null()
static Broadcast_Info *fetch_broadcast_info(const Network *ns)
{
    Broadcast_Info *broadcast = (Broadcast_Info *)calloc(1, sizeof(Broadcast_Info));

    if (broadcast == nullptr) {
        return nullptr;
    }

    /* Not sure how many platforms this will run on,
     * so it's wrapped in `__linux__` for now.
     * Definitely won't work like this on Windows...
     */
    const Socket sock = net_socket(ns, net_family_ipv4(), TOX_SOCK_STREAM, 0);

    if (!sock_valid(sock)) {
        free(broadcast);
        return nullptr;
    }

    /* Configure ifconf for the ioctl call. */
    struct ifreq i_faces[MAX_INTERFACES];
    memset(i_faces, 0, sizeof(struct ifreq) * MAX_INTERFACES);

    struct ifconf ifc;
    ifc.ifc_buf = (char *)i_faces;
    ifc.ifc_len = sizeof(i_faces);

    if (ioctl(sock.sock, SIOCGIFCONF, &ifc) < 0) {
        kill_sock(ns, sock);
        free(broadcast);
        return nullptr;
    }

    /* `ifc.ifc_len` is set by the `ioctl()` to the actual length used.
     * On usage of the complete array the call should be repeated with
     * a larger array, not done (640kB and 16 interfaces shall be
     * enough, for everybody!)
     */
    const int n = ifc.ifc_len / sizeof(struct ifreq);

    for (int i = 0; i < n; ++i) {
        /* there are interfaces with are incapable of broadcast
         * on Linux, `lo` has no broadcast address, but this function returns >=0
         */
        if (ioctl(sock.sock, SIOCGIFBRDADDR, &i_faces[i]) < 0) {
            continue;
        }

        /* moot check: only AF_INET returned (backwards compat.) */
        if (i_faces[i].ifr_broadaddr.sa_family != AF_INET) {
            continue;
        }

        const struct sockaddr_in *broadaddr4 = (const struct sockaddr_in *)(void *)&i_faces[i].ifr_broadaddr;

        if (broadcast->count >= MAX_INTERFACES) {
            break;
        }

        IP *ip = &broadcast->ips[broadcast->count];
        ip->family = net_family_ipv4();
        ip->ip.v4.uint32 = broadaddr4->sin_addr.s_addr;

        /* if no broadcast address */
        if (ip->ip.v4.uint32 == 0) {
            if (ioctl(sock.sock, SIOCGIFADDR, &i_faces[i]) < 0) {
                continue;
            }

            const struct sockaddr_in *addr4 = (const struct sockaddr_in *)(void *)&i_faces[i].ifr_addr;
            IP4 ip4_staging;
            ip4_staging.uint32 = addr4->sin_addr.s_addr;

            if (ip4_is_local(&ip4_staging)) {
                /* this is 127.x.x.x */
                ip->ip.v4.uint32 = ip4_staging.uint32;
            } else {
                /* give up. */
                continue;
            }
        }

        ++broadcast->count;
    }

    kill_sock(ns, sock);

    return broadcast;
}

#else // TODO(irungentoo): Other platforms?

non_null()
static Broadcast_Info *fetch_broadcast_info(const Network *ns)
{
    return (Broadcast_Info *)calloc(1, sizeof(Broadcast_Info));
}

#endif

/** @brief Send packet to all IPv4 broadcast addresses
 *
 * @retval true if sent to at least one broadcast target.
 * @retval false on failure to find any valid broadcast target.
 */
non_null()
static bool send_broadcasts(const Networking_Core *net, const Broadcast_Info *broadcast, uint16_t port,
                            const uint8_t *data, uint16_t length)
{
    if (broadcast->count == 0) {
        return false;
    }

    for (uint32_t i = 0; i < broadcast->count; ++i) {
        IP_Port ip_port;
        ip_port.ip = broadcast->ips[i];
        ip_port.port = port;
        sendpacket(net, &ip_port, data, length);
    }

    return true;
}

/** Return the broadcast ip. */
static IP broadcast_ip(Family family_socket, Family family_broadcast)
{
    IP ip;
    ip_reset(&ip);

    if (net_family_is_ipv6(family_socket)) {
        if (net_family_is_ipv6(family_broadcast)) {
            ip.family = net_family_ipv6();
            /* `FF02::1` is - according to RFC 4291 - multicast all-nodes link-local */
            /* `FE80::*:` MUST be exact, for that we would need to look over all
             * interfaces and check in which status they are */
            ip.ip.v6.uint8[ 0] = 0xFF;
            ip.ip.v6.uint8[ 1] = 0x02;
            ip.ip.v6.uint8[15] = 0x01;
        } else if (net_family_is_ipv4(family_broadcast)) {
            ip.family = net_family_ipv6();
            ip.ip.v6 = ip6_broadcast;
        }
    } else if (net_family_is_ipv4(family_socket) && net_family_is_ipv4(family_broadcast)) {
        ip.family = net_family_ipv4();
        ip.ip.v4 = ip4_broadcast;
    }

    return ip;
}

non_null()
static bool ip4_is_local(const IP4 *ip4)
{
    /* Loopback. */
    return ip4->uint8[0] == 127;
}

/**
 * Is IP a local ip or not.
 */
bool ip_is_local(const IP *ip)
{
    if (net_family_is_ipv4(ip->family)) {
        return ip4_is_local(&ip->ip.v4);
    }

    /* embedded IPv4-in-IPv6 */
    if (ipv6_ipv4_in_v6(&ip->ip.v6)) {
        IP4 ip4;
        ip4.uint32 = ip->ip.v6.uint32[3];
        return ip4_is_local(&ip4);
    }

    /* localhost in IPv6 (::1) */
    return ip->ip.v6.uint64[0] == 0 && ip->ip.v6.uint32[2] == 0 && ip->ip.v6.uint32[3] == net_htonl(1);
}

non_null()
static bool ip4_is_lan(const IP4 *ip4)
{
    /* 10.0.0.0 to 10.255.255.255 range. */
    if (ip4->uint8[0] == 10) {
        return true;
    }

    /* 172.16.0.0 to 172.31.255.255 range. */
    if (ip4->uint8[0] == 172 && ip4->uint8[1] >= 16 && ip4->uint8[1] <= 31) {
        return true;
    }

    /* 192.168.0.0 to 192.168.255.255 range. */
    if (ip4->uint8[0] == 192 && ip4->uint8[1] == 168) {
        return true;
    }

    /* 169.254.1.0 to 169.254.254.255 range. */
    if (ip4->uint8[0] == 169 && ip4->uint8[1] == 254 && ip4->uint8[2] != 0
            && ip4->uint8[2] != 255) {
        return true;
    }

    /* RFC 6598: 100.64.0.0 to 100.127.255.255 (100.64.0.0/10)
     * (shared address space to stack another layer of NAT) */
    return (ip4->uint8[0] == 100) && ((ip4->uint8[1] & 0xC0) == 0x40);
}

bool ip_is_lan(const IP *ip)
{
    if (ip_is_local(ip)) {
        return true;
    }

    if (net_family_is_ipv4(ip->family)) {
        return ip4_is_lan(&ip->ip.v4);
    }

    if (net_family_is_ipv6(ip->family)) {
        /* autogenerated for each interface: `FE80::*` (up to `FEBF::*`)
         * `FF02::1` is - according to RFC 4291 - multicast all-nodes link-local */
        if (((ip->ip.v6.uint8[0] == 0xFF) && (ip->ip.v6.uint8[1] < 3) && (ip->ip.v6.uint8[15] == 1)) ||
                ((ip->ip.v6.uint8[0] == 0xFE) && ((ip->ip.v6.uint8[1] & 0xC0) == 0x80))) {
            return true;
        }

        /* embedded IPv4-in-IPv6 */
        if (ipv6_ipv4_in_v6(&ip->ip.v6)) {
            IP4 ip4;
            ip4.uint32 = ip->ip.v6.uint32[3];
            return ip4_is_lan(&ip4);
        }
    }

    return false;
}


bool lan_discovery_send(const Networking_Core *net, const Broadcast_Info *broadcast, const uint8_t *dht_pk,
                        uint16_t port)
{
    if (broadcast == nullptr) {
        return false;
    }

    uint8_t data[CRYPTO_PUBLIC_KEY_SIZE + 1];
    data[0] = NET_PACKET_LAN_DISCOVERY;
    pk_copy(data + 1, dht_pk);

    send_broadcasts(net, broadcast, port, data, 1 + CRYPTO_PUBLIC_KEY_SIZE);

    bool res = false;
    IP_Port ip_port;
    ip_port.port = port;

    /* IPv6 multicast */
    if (net_family_is_ipv6(net_family(net))) {
        ip_port.ip = broadcast_ip(net_family_ipv6(), net_family_ipv6());

        if (ip_isset(&ip_port.ip) && sendpacket(net, &ip_port, data, 1 + CRYPTO_PUBLIC_KEY_SIZE) > 0) {
            res = true;
        }
    }

    /* IPv4 broadcast (has to be IPv4-in-IPv6 mapping if socket is IPv6 */
    ip_port.ip = broadcast_ip(net_family(net), net_family_ipv4());

    if (ip_isset(&ip_port.ip) && sendpacket(net, &ip_port, data, 1 + CRYPTO_PUBLIC_KEY_SIZE) > 0) {
        res = true;
    }

    return res;
}


Broadcast_Info *lan_discovery_init(const Network *ns)
{
    return fetch_broadcast_info(ns);
}

void lan_discovery_kill(Broadcast_Info *broadcast)
{
    free(broadcast);
}
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2018 The TokTok team.
 * Copyright © 2014 Tox project.
 */

/**
 * Simple struct with functions to create a list which associates ids with data
 * - Allows for finding ids associated with data such as IPs or public keys in a short time
 * - Should only be used if there are relatively few add/remove calls to the list
 */

#include <stdbool.h>
#include <stdlib.h>
#include <string.h>


/**
 * Basically, the elements in the list are placed in order so that they can be searched for easily
 * - each element is seen as a big-endian integer when ordering them
 * - the ids array is maintained so that each id always matches
 * - the search algorithm cuts down the time to find the id associated with a piece of data
 *   at the cost of slow add/remove functions for large lists
 * - Starts at `1/2` of the array, compares the element in the array with the data,
 *   then moves `+/- 1/4` of the array depending on whether the value is greater or lower,
 *   then `+- 1/8`, etc, until the value is matched or its position where it should be in the array is found
 * - some considerations since the array size is never perfect
 */

static int32_t
list_index(uint32_t i)
{
    return ~i;
}

/** @brief Find data in list
 *
 * @retval >=0 index of data in array
 * @retval <0  no match, returns index (return value is `list_index(index)`) where
 *   the data should be inserted
 */
non_null()
static int find(const BS_List *list, const uint8_t *data)
{
    // should work well, but could be improved
    if (list->n == 0) {
        return list_index(0);
    }

    uint32_t i = list->n / 2; // current position in the array
    uint32_t delta = i / 2;   // how much we move in the array

    if (delta == 0) {
        delta = 1;
    }

    int d = -1; // used to determine if closest match is found
    // closest match is found if we move back to where we have already been

    while (true) {
        const int r = memcmp(data, list->data + list->element_size * i, list->element_size);

        if (r == 0) {
            return i;
        }

        if (r > 0) {
            // data is greater
            // move down
            i += delta;

            if (d == 0 || i == list->n) {
                // reached bottom of list, or closest match
                return list_index(i);
            }

            delta = delta / 2;

            if (delta == 0) {
                delta = 1;
                d = 1;
            }
        } else {
            // data is smaller
            if (d == 1 || i == 0) {
                // reached top or list or closest match
                return list_index(i);
            }

            // move up
            i -= delta;

            delta = delta / 2;

            if (delta == 0) {
                delta = 1;
                d = 0;
            }
        }
    }
}

/**
 * Resizes the list.
 *
 * @return true on success.
 */
non_null()
static bool resize(BS_List *list, uint32_t new_size)
{
    if (new_size == 0) {
        bs_list_free(list);
        return true;
    }

    uint8_t *data = (uint8_t *)realloc(list->data, list->element_size * new_size);

    if (data == nullptr) {
        return false;
    }

    list->data = data;

    int *ids = (int *)realloc(list->ids, sizeof(int) * new_size);

    if (ids == nullptr) {
        return false;
    }

    list->ids = ids;

    return true;
}


int bs_list_init(BS_List *list, uint32_t element_size, uint32_t initial_capacity)
{
    // set initial values
    list->n = 0;
    list->element_size = element_size;
    list->capacity = 0;
    list->data = nullptr;
    list->ids = nullptr;

    if (initial_capacity != 0) {
        if (!resize(list, initial_capacity)) {
            return 0;
        }
    }

    list->capacity = initial_capacity;

    return 1;
}

void bs_list_free(BS_List *list)
{
    if (list == nullptr) {
        return;
    }

    // free both arrays
    free(list->data);
    list->data = nullptr;

    free(list->ids);
    list->ids = nullptr;
}

int bs_list_find(const BS_List *list, const uint8_t *data)
{
    const int r = find(list, data);

    // return only -1 and positive values
    if (r < 0) {
        return -1;
    }

    return list->ids[r];
}

bool bs_list_add(BS_List *list, const uint8_t *data, int id)
{
    // find where the new element should be inserted
    // see: return value of find()
    int i = find(list, data);

    if (i >= 0) {
        // already in list
        return false;
    }

    i = ~i;

    // increase the size of the arrays if needed
    if (list->n == list->capacity) {
        // 1.5 * n + 1
        const uint32_t new_capacity = list->n + list->n / 2 + 1;

        if (!resize(list, new_capacity)) {
            return false;
        }

        list->capacity = new_capacity;
    }

    // insert data to element array
    memmove(list->data + (i + 1) * list->element_size, list->data + i * list->element_size,
            (list->n - i) * list->element_size);
    memcpy(list->data + i * list->element_size, data, list->element_size);

    // insert id to id array
    memmove(&list->ids[i + 1], &list->ids[i], (list->n - i) * sizeof(int));
    list->ids[i] = id;

    // increase n
    ++list->n;

    return true;
}

bool bs_list_remove(BS_List *list, const uint8_t *data, int id)
{
    const int i = find(list, data);

    if (i < 0) {
        return false;
    }

    if (list->ids[i] != id) {
        // this should never happen
        return false;
    }

    // decrease the size of the arrays if needed
    if (list->n < list->capacity / 2) {
        const uint32_t new_capacity = list->capacity / 2;

        if (resize(list, new_capacity)) {
            list->capacity = new_capacity;
        }
    }

    --list->n;

    memmove(list->data + i * list->element_size, list->data + (i + 1) * list->element_size,
            (list->n - i) * list->element_size);
    memmove(&list->ids[i], &list->ids[i + 1], (list->n - i) * sizeof(int));

    return true;
}
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2018 The TokTok team.
 * Copyright © 2013-2015 Tox project.
 */

/**
 * Text logging abstraction.
 */

#include <assert.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>


struct Logger {
    logger_cb *callback;
    void *context;
    void *userdata;
};

static const char *logger_level_name(Logger_Level level)
{
    switch (level) {
        case LOGGER_LEVEL_TRACE:
            return "TRACE";

        case LOGGER_LEVEL_DEBUG:
            return "DEBUG";

        case LOGGER_LEVEL_INFO:
            return "INFO";

        case LOGGER_LEVEL_WARNING:
            return "WARNING";

        case LOGGER_LEVEL_ERROR:
            return "ERROR";
    }

    return "<unknown>";
}

non_null(1, 3, 5, 6) nullable(7)
static void logger_stderr_handler(void *context, Logger_Level level, const char *file, int line, const char *func,
                                  const char *message, void *userdata);

non_null(1, 3, 5, 6) nullable(7)
static void logger_stderr_handler(void *context, Logger_Level level, const char *file, int line, const char *func,
                                  const char *message, void *userdata)
{
#if (defined(MUTEXLOCKINGDEBUG) || defined(USE_STDERR_LOGGER))
    // GL stands for "global logger".
    fprintf(stderr, "[GL] %s %s:%d(%s): %s\n", logger_level_name(level), file, line, func, message);
#else
#ifndef NDEBUG
    // GL stands for "global logger".
    fprintf(stderr, "[GL] %s %s:%d(%s): %s\n", logger_level_name(level), file, line, func, message);
    fprintf(stderr, "Default stderr logger triggered; aborting program\n");
    abort();
#endif
#endif
}

static const Logger logger_stderr = {
    logger_stderr_handler,
    nullptr,
    nullptr,
};

/*
 * Public Functions
 */

Logger *logger_new(void)
{
    return (Logger *)calloc(1, sizeof(Logger));
}

void logger_kill(Logger *log)
{
    free(log);
}

void logger_callback_log(Logger *log, logger_cb *function, void *context, void *userdata)
{
    log->callback = function;
    log->context  = context;
    log->userdata = userdata;
}

void logger_write(const Logger *log, Logger_Level level, const char *file, int line, const char *func,
                  const char *format, ...)
{
    if (log == nullptr) {
        log = &logger_stderr;
    }

    if (log->callback == nullptr) {
        return;
    }

    // Only pass the file name, not the entire file path, for privacy reasons.
    // The full path may contain PII of the person compiling toxcore (their
    // username and directory layout).
    const char *filename = strrchr(file, '/');
    file = filename != nullptr ? filename + 1 : file;
#if defined(_WIN32) || defined(__CYGWIN__)
    // On Windows, the path separator *may* be a backslash, so we look for that
    // one too.
    const char *windows_filename = strrchr(file, '\\');
    file = windows_filename != nullptr ? windows_filename + 1 : file;
#endif

    // Format message
    char msg[1024];
    va_list args;
    va_start(args, format);
    vsnprintf(msg, sizeof(msg), format, args);
    va_end(args);

    log->callback(log->context, level, file, line, func, msg, log->userdata);
}


void logger_api_write(const Logger *log, Logger_Level level, const char *file, int line, const char *func,
                      const char *format, va_list args)
{
    if (!log) {
#ifdef USE_STDERR_LOGGER
        log = &logger_stderr;
#else
        fprintf(stderr, "NULL logger not permitted.\n");
        abort();
#endif
    }

    if (!log->callback) {
        return;
    }

    // Only pass the file name, not the entire file path, for privacy reasons.
    // The full path may contain PII of the person compiling toxcore (their
    // username and directory layout).
    const char *filename = strrchr(file, '/');
    file = filename ? filename + 1 : file;
#if defined(_WIN32) || defined(__CYGWIN__)
    // On Windows, the path separator *may* be a backslash, so we look for that
    // one too.
    const char *windows_filename = strrchr(file, '\\');
    file = windows_filename ? windows_filename + 1 : file;
#endif

    // Format message
    char msg[1024];
    vsnprintf(msg, sizeof(msg), format, args);

    log->callback(log->context, level, file, line, func, msg, log->userdata);
}

/*
 * hook mutex function so we can nicely log them (to the NULL logger!)
 */
int my_pthread_mutex_lock(pthread_mutex_t *mutex, const char *mutex_name, const char *file, int line, const char *func)
{
    pthread_t cur_pthread_tid = pthread_self();
#if !(defined(_WIN32) || defined(__WIN32__) || defined(WIN32))
    logger_write(NULL, LOGGER_LEVEL_DEBUG, file, line, func, "TID:%ld:MTX_LOCK:S:%s:m=%p", (int64_t)cur_pthread_tid, mutex_name, (void*)mutex);
#else
    logger_write(NULL, LOGGER_LEVEL_DEBUG, file, line, func, "MTX_LOCK:S:%s:m=%p",
                 mutex_name, (void *)mutex);
#endif
    int ret = (pthread_mutex_lock)(mutex);
#if !(defined(_WIN32) || defined(__WIN32__) || defined(WIN32))
    logger_write(NULL, LOGGER_LEVEL_DEBUG, file, line, func, "TID:%ld:MTX_LOCK:E:%s:m=%p", (int64_t)cur_pthread_tid, mutex_name, (void*)mutex);
#else
    logger_write(NULL, LOGGER_LEVEL_DEBUG, file, line, func, "MTX_LOCK:E:%s:m=%p",
                 mutex_name, (void *)mutex);
#endif
    return ret;
}

int my_pthread_mutex_unlock(pthread_mutex_t *mutex, const char *mutex_name, const char *file, int line, const char *func)
{
    pthread_t cur_pthread_tid = pthread_self();
#if !(defined(_WIN32) || defined(__WIN32__) || defined(WIN32))
    logger_write(NULL, LOGGER_LEVEL_DEBUG, file, line, func, "TID:%ld:MTX_unLOCK:S:%s:m=%p", (int64_t)cur_pthread_tid, mutex_name, (void*)mutex);
#else
    logger_write(NULL, LOGGER_LEVEL_DEBUG, file, line, func, "MTX_unLOCK:S:%s:m=%p",
                 mutex_name, (void *)mutex);
#endif
    int ret = (pthread_mutex_unlock)(mutex);
#if !(defined(_WIN32) || defined(__WIN32__) || defined(WIN32))
    logger_write(NULL, LOGGER_LEVEL_DEBUG, file, line, func, "TID:%ld:MTX_unLOCK:E:%s:m=%p", (int64_t)cur_pthread_tid, mutex_name, (void*)mutex);
#else
    logger_write(NULL, LOGGER_LEVEL_DEBUG, file, line, func, "MTX_unLOCK:E:%s:m=%p",
                 mutex_name, (void *)mutex);
#endif
    return ret;
}
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2018 The TokTok team.
 * Copyright © 2013 Tox project.
 */

/**
 * An implementation of a simple text chat only messenger on the tox network core.
 */

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>



/**
 * This is defined in tox.h and "copied" here.
 * it's wanted not to include tox.h here.
 * but this solution is BAD, "future me" please fix.
 */
#define HACK_TOX_FILE_KIND_MESSAGEV2_SEND 2
#define HACK_TOX_FILE_KIND_MESSAGEV2_ANSWER 3
#define HACK_TOX_FILE_KIND_MESSAGEV2_ALTER 4
#define HACK_TOX_FILE_KIND_MESSAGEV2_SYNC 5

#define HACK_TOX_MESSAGEV2_MAX_NON_SYNC_HEADER_SIZE  (32 + 4 + 2 + 1 + 32)
#define HACK_TOX_MESSAGEV2_MAX_HEADER_SIZE  (32 + 4 + 2 + 32 + 4)
#define HACK_TOX_MESSAGEV2_MAX_TEXT_LENGTH  4096
#define HACK_TOX_MAX_FILETRANSFER_SIZE_MSGV2 (HACK_TOX_MESSAGEV2_MAX_TEXT_LENGTH + HACK_TOX_MESSAGEV2_MAX_HEADER_SIZE + HACK_TOX_MESSAGEV2_MAX_NON_SYNC_HEADER_SIZE)
/**
 * This is defined in tox.h and "copied" here.
 * someone wanted not to include tox.h here
 */

#ifdef NOGLOBALVARS
static bool global_force_udp_only_mode = false;
static bool global_onion_active = true;
#else
extern bool global_force_udp_only_mode;
extern bool global_onion_active;
#endif

static_assert(MAX_CONCURRENT_FILE_PIPES <= UINT8_MAX + 1,
              "uint8_t cannot represent all file transfer numbers");

#define PAUSE_CYCLES_ON_FTV2_SEEK_RECEIVED 20
#define STALE_CYCLES_ON_FTV2_RECEIVER 2000
#define STALE_CYCLES_ON_FTV2_SEND 1000

static const Friend empty_friend = {{0}};

non_null()
static struct File_Transfers *get_file_transfer(bool outbound, uint8_t filenumber,
        uint32_t *real_filenumber, Friend *sender);

/**
 * Determines if the friendnumber passed is valid in the Messenger object.
 *
 * @param friendnumber The index in the friend list.
 */
bool friend_is_valid(const Messenger *m, int32_t friendnumber)
{
    return (uint32_t)friendnumber < m->numfriends && m->friendlist[friendnumber].status != 0;
}

/** @brief Set the size of the friend list to numfriends.
 *
 * @retval -1 if realloc fails.
 */
non_null()
static int realloc_friendlist(Messenger *m, uint32_t num)
{
    if (num == 0) {
        free(m->friendlist);
        m->friendlist = nullptr;
        return 0;
    }

    Friend *newfriendlist = (Friend *)realloc(m->friendlist, num * sizeof(Friend));

    if (newfriendlist == nullptr) {
        return -1;
    }

    m->friendlist = newfriendlist;
    return 0;
}

/** @return the friend number associated to that public key.
 * @retval -1 if no such friend.
 */
int32_t getfriend_id(const Messenger *m, const uint8_t *real_pk)
{
    for (uint32_t i = 0; i < m->numfriends; ++i) {
        if (m->friendlist[i].status > 0 && pk_equal(real_pk, m->friendlist[i].real_pk)) {
            return i;
        }
    }

    return -1;
}

/** @brief Copies the public key associated to that friend id into real_pk buffer.
 *
 * Make sure that real_pk is of size CRYPTO_PUBLIC_KEY_SIZE.
 *
 * @retval 0 if success.
 * @retval -1 if failure.
 */
int get_real_pk(const Messenger *m, int32_t friendnumber, uint8_t *real_pk)
{
    if (!m_friend_exists(m, friendnumber)) {
        return -1;
    }

    memcpy(real_pk, m->friendlist[friendnumber].real_pk, CRYPTO_PUBLIC_KEY_SIZE);
    return 0;
}

/** @return friend connection id on success.
 * @retval -1 if failure.
 */
int getfriendcon_id(const Messenger *m, int32_t friendnumber)
{
    if (!m_friend_exists(m, friendnumber)) {
        return -1;
    }

    return m->friendlist[friendnumber].friendcon_id;
}

/**
 * Format: `[real_pk (32 bytes)][nospam number (4 bytes)][checksum (2 bytes)]`
 *
 * @param[out] address FRIEND_ADDRESS_SIZE byte address to give to others.
 */
void getaddress(const Messenger *m, uint8_t *address)
{
    pk_copy(address, nc_get_self_public_key(m->net_crypto));
    uint32_t nospam = get_nospam(m->fr);
    memcpy(address + CRYPTO_PUBLIC_KEY_SIZE, &nospam, sizeof(nospam));
    uint16_t checksum = data_checksum(address, FRIEND_ADDRESS_SIZE - sizeof(checksum));
    memcpy(address + CRYPTO_PUBLIC_KEY_SIZE + sizeof(nospam), &checksum, sizeof(checksum));
}

non_null()
static bool send_online_packet(Messenger *m, int friendcon_id)
{
    uint8_t buf[TOX_CAPABILITIES_SIZE + 1];
    buf[0] = PACKET_ID_ONLINE;
    net_pack_u64(buf + 1, TOX_CAPABILITIES_CURRENT);

    if (write_cryptpacket(m->net_crypto, friend_connection_crypt_connection_id(m->fr_c,
                          friendcon_id), buf, (TOX_CAPABILITIES_SIZE + 1), false) == -1) {
        return false;
    }

    uint8_t packet = PACKET_ID_ONLINE;
    return write_cryptpacket(m->net_crypto, friend_connection_crypt_connection_id(m->fr_c, friendcon_id), &packet,
                             sizeof(packet), false) != -1;
}

non_null()
static bool send_offline_packet(Messenger *m, int friendcon_id)
{
    uint8_t packet = PACKET_ID_OFFLINE;
    return write_cryptpacket(m->net_crypto, friend_connection_crypt_connection_id(m->fr_c, friendcon_id), &packet,
                             sizeof(packet), false) != -1;
}

non_null(1) nullable(4)
static int m_handle_status(void *object, int i, bool status, void *userdata);
non_null(1, 3) nullable(5)
static int m_handle_packet(void *object, int i, const uint8_t *temp, uint16_t len, void *userdata);
non_null(1, 3) nullable(5)
static int m_handle_lossy_packet(void *object, int friend_num, const uint8_t *packet, uint16_t length,
                                 void *userdata);

non_null()
static int32_t init_new_friend(Messenger *m, const uint8_t *real_pk, uint8_t status)
{
    if (m->numfriends == UINT32_MAX) {
        LOGGER_ERROR(m->log, "Friend list full: we have more than 4 billion friends");
        /* This is technically incorrect, but close enough. */
        return FAERR_NOMEM;
    }

    /* Resize the friend list if necessary. */
    if (realloc_friendlist(m, m->numfriends + 1) != 0) {
        return FAERR_NOMEM;
    }

    m->friendlist[m->numfriends] = empty_friend;

    const int friendcon_id = new_friend_connection(m->fr_c, real_pk);

    if (friendcon_id == -1) {
        return FAERR_NOMEM;
    }

    for (uint32_t i = 0; i <= m->numfriends; ++i) {
        if (m->friendlist[i].status == NOFRIEND) {
            m->friendlist[i].status = status;
            m->friendlist[i].friendcon_id = friendcon_id;
            m->friendlist[i].friendrequest_lastsent = 0;
            pk_copy(m->friendlist[i].real_pk, real_pk);
            m->friendlist[i].statusmessage_length = 0;
            m->friendlist[i].userstatus = USERSTATUS_NONE;
            m->friendlist[i].is_typing = false;
            m->friendlist[i].message_id = 0;
            m->friendlist[i].num_sending_files = 0;
            m->friendlist[i].num_receiving_files = 0;
            m->friendlist[i].toxcore_capabilities = TOX_CAPABILITY_BASIC;
            friend_connection_callbacks(m->fr_c, friendcon_id, MESSENGER_CALLBACK_INDEX, &m_handle_status, &m_handle_packet,
                                        &m_handle_lossy_packet, m, i);

            if (m->numfriends == i) {
                ++m->numfriends;
            }

            if (friend_con_connected(m->fr_c, friendcon_id) == FRIENDCONN_STATUS_CONNECTED) {
                send_online_packet(m, friendcon_id);
            }

            return i;
        }
    }

    return FAERR_NOMEM;
}

non_null()
static int32_t m_add_friend_contact_norequest(Messenger *m, const uint8_t *real_pk)
{
    if (getfriend_id(m, real_pk) != -1) {
        return FAERR_ALREADYSENT;
    }

    if (pk_equal(real_pk, nc_get_self_public_key(m->net_crypto))) {
        return FAERR_OWNKEY;
    }

    return init_new_friend(m, real_pk, FRIEND_CONFIRMED);
}

/**
 * Add a friend.
 *
 * Set the data that will be sent along with friend request.
 *
 * @param address is the address of the friend (returned by getaddress of the friend
 *   you wish to add) it must be FRIEND_ADDRESS_SIZE bytes.
 *   TODO(irungentoo): add checksum.
 * @param data is the data.
 * @param length is the length.
 *
 * @return the friend number if success.
 * @retval FA_TOOLONG if message length is too long.
 * @retval FAERR_NOMESSAGE if no message (message length must be >= 1 byte).
 * @retval FAERR_OWNKEY if user's own key.
 * @retval FAERR_ALREADYSENT if friend request already sent or already a friend.
 * @retval FAERR_BADCHECKSUM if bad checksum in address.
 * @retval FAERR_SETNEWNOSPAM if the friend was already there but the nospam was different.
 *   (the nospam for that friend was set to the new one).
 * @retval FAERR_NOMEM if increasing the friend list size fails.
 */
int32_t m_addfriend(Messenger *m, const uint8_t *address, const uint8_t *data, uint16_t length)
{
    if (length > MAX_FRIEND_REQUEST_DATA_SIZE) {
        return FAERR_TOOLONG;
    }

    uint8_t real_pk[CRYPTO_PUBLIC_KEY_SIZE];
    pk_copy(real_pk, address);

    if (!public_key_valid(real_pk)) {
        return FAERR_BADCHECKSUM;
    }

    uint16_t check;
    const uint16_t checksum = data_checksum(address, FRIEND_ADDRESS_SIZE - sizeof(checksum));
    memcpy(&check, address + CRYPTO_PUBLIC_KEY_SIZE + sizeof(uint32_t), sizeof(check));

    if (check != checksum) {
        return FAERR_BADCHECKSUM;
    }

    if (length < 1) {
        return FAERR_NOMESSAGE;
    }

    if (pk_equal(real_pk, nc_get_self_public_key(m->net_crypto))) {
        return FAERR_OWNKEY;
    }

    const int32_t friend_id = getfriend_id(m, real_pk);

    if (friend_id != -1) {
        if (m->friendlist[friend_id].status >= FRIEND_CONFIRMED) {
            return FAERR_ALREADYSENT;
        }

        uint32_t nospam;
        memcpy(&nospam, address + CRYPTO_PUBLIC_KEY_SIZE, sizeof(nospam));

        if (m->friendlist[friend_id].friendrequest_nospam == nospam) {
            return FAERR_ALREADYSENT;
        }

        m->friendlist[friend_id].friendrequest_nospam = nospam;
        return FAERR_SETNEWNOSPAM;
    }

    const int32_t ret = init_new_friend(m, real_pk, FRIEND_ADDED);

    if (ret < 0) {
        return ret;
    }

    m->friendlist[ret].friendrequest_timeout = FRIENDREQUEST_TIMEOUT;
    memcpy(m->friendlist[ret].info, data, length);
    m->friendlist[ret].info_size = length;
    memcpy(&m->friendlist[ret].friendrequest_nospam, address + CRYPTO_PUBLIC_KEY_SIZE, sizeof(uint32_t));

    return ret;
}

int32_t m_addfriend_norequest(Messenger *m, const uint8_t *real_pk)
{
    if (!public_key_valid(real_pk)) {
        return FAERR_BADCHECKSUM;
    }

    if (pk_equal(real_pk, nc_get_self_public_key(m->net_crypto))) {
        return FAERR_OWNKEY;
    }

    return m_add_friend_contact_norequest(m, real_pk);
}

non_null()
static int clear_receipts(Messenger *m, int32_t friendnumber)
{
    if (!m_friend_exists(m, friendnumber)) {
        return -1;
    }

    struct Receipts *receipts = m->friendlist[friendnumber].receipts_start;

    while (receipts != nullptr) {
        struct Receipts *temp_r = receipts->next;
        free(receipts);
        receipts = temp_r;
    }

    m->friendlist[friendnumber].receipts_start = nullptr;
    m->friendlist[friendnumber].receipts_end = nullptr;
    return 0;
}

non_null()
static int add_receipt(Messenger *m, int32_t friendnumber, uint32_t packet_num, uint32_t msg_id)
{
    if (!m_friend_exists(m, friendnumber)) {
        return -1;
    }

    struct Receipts *new_receipts = (struct Receipts *)calloc(1, sizeof(struct Receipts));

    if (new_receipts == nullptr) {
        return -1;
    }

    new_receipts->packet_num = packet_num;
    new_receipts->msg_id = msg_id;

    if (m->friendlist[friendnumber].receipts_start == nullptr) {
        m->friendlist[friendnumber].receipts_start = new_receipts;
    } else {
        m->friendlist[friendnumber].receipts_end->next = new_receipts;
    }

    m->friendlist[friendnumber].receipts_end = new_receipts;
    new_receipts->next = nullptr;
    return 0;
}
/**
 * return -1 on failure.
 * return 0 if packet was received.
 */
non_null()
static int friend_received_packet(const Messenger *m, int32_t friendnumber, uint32_t number)
{
    if (!m_friend_exists(m, friendnumber)) {
        return -1;
    }

    return cryptpacket_received(m->net_crypto, friend_connection_crypt_connection_id(m->fr_c,
                                m->friendlist[friendnumber].friendcon_id), number);
}

bool m_create_group_connection(Messenger *m, GC_Chat *chat)
{
    random_bytes(m->rng, chat->m_group_public_key, CRYPTO_PUBLIC_KEY_SIZE);
    const int friendcon_id = new_friend_connection(m->fr_c, chat->m_group_public_key);

    if (friendcon_id == -1) {
        return false;
    }

    const Friend_Conn *connection = get_conn(m->fr_c, friendcon_id);

    if (connection == nullptr) {
        return false;
    }

    chat->friend_connection_id = friendcon_id;

    if (friend_con_connected(m->fr_c, friendcon_id) == FRIENDCONN_STATUS_CONNECTED) {
        send_online_packet(m, friendcon_id);
    }

    const int onion_friend_number = friend_conn_get_onion_friendnum(connection);
    Onion_Friend *onion_friend = onion_get_friend(m->onion_c, (uint16_t)onion_friend_number);

    onion_friend_set_gc_public_key(onion_friend, get_chat_id(chat->chat_public_key));
    onion_friend_set_gc_data(onion_friend, nullptr, 0);

    return true;
}

/**
 * Kills the friend connection for a groupchat.
 */
void m_kill_group_connection(Messenger *m, const GC_Chat *chat)
{
    remove_request_received(m->fr, chat->m_group_public_key);

    friend_connection_callbacks(m->fr_c, chat->friend_connection_id, MESSENGER_CALLBACK_INDEX, nullptr,
                                nullptr, nullptr, nullptr, 0);

    if (friend_con_connected(m->fr_c, chat->friend_connection_id) == FRIENDCONN_STATUS_CONNECTED) {
        send_offline_packet(m, chat->friend_connection_id);
    }

    kill_friend_connection(m->fr_c, chat->friend_connection_id);
}

non_null(1) nullable(3)
static int do_receipts(Messenger *m, int32_t friendnumber, void *userdata)
{
    if (!m_friend_exists(m, friendnumber)) {
        return -1;
    }

    struct Receipts *receipts = m->friendlist[friendnumber].receipts_start;

    while (receipts != nullptr) {
        if (friend_received_packet(m, friendnumber, receipts->packet_num) == -1) {
            break;
        }

        if (m->read_receipt != nullptr) {
            m->read_receipt(m, friendnumber, receipts->msg_id, userdata);
        }

        struct Receipts *r_next = receipts->next;

        free(receipts);

        m->friendlist[friendnumber].receipts_start = r_next;

        receipts = r_next;
    }

    if (m->friendlist[friendnumber].receipts_start == nullptr) {
        m->friendlist[friendnumber].receipts_end = nullptr;
    }

    return 0;
}

/** @brief Remove a friend.
 *
 * @retval 0 if success.
 * @retval -1 if failure.
 */
int m_delfriend(Messenger *m, int32_t friendnumber)
{
    if (!m_friend_exists(m, friendnumber)) {
        return -1;
    }

    clear_receipts(m, friendnumber);
    remove_request_received(m->fr, m->friendlist[friendnumber].real_pk);
    friend_connection_callbacks(m->fr_c, m->friendlist[friendnumber].friendcon_id, MESSENGER_CALLBACK_INDEX, nullptr,
                                nullptr, nullptr, nullptr, 0);

    if (friend_con_connected(m->fr_c, m->friendlist[friendnumber].friendcon_id) == FRIENDCONN_STATUS_CONNECTED) {
        send_offline_packet(m, m->friendlist[friendnumber].friendcon_id);
    }

    kill_friend_connection(m->fr_c, m->friendlist[friendnumber].friendcon_id);
    m->friendlist[friendnumber] = empty_friend;

    uint32_t i;

    for (i = m->numfriends; i != 0; --i) {
        if (m->friendlist[i - 1].status != NOFRIEND) {
            break;
        }
    }

    m->numfriends = i;

    if (realloc_friendlist(m, m->numfriends) != 0) {
        return FAERR_NOMEM;
    }

    return 0;
}

int m_get_friend_connectionstatus(const Messenger *m, int32_t friendnumber)
{
    if (!m_friend_exists(m, friendnumber)) {
        return -1;
    }

    if (m->friendlist[friendnumber].status != FRIEND_ONLINE) {
        return CONNECTION_NONE;
    }

    bool direct_connected = false;
    uint32_t num_online_relays = 0;
    const int crypt_conn_id = friend_connection_crypt_connection_id(m->fr_c, m->friendlist[friendnumber].friendcon_id);

    if (!crypto_connection_status(m->net_crypto, crypt_conn_id, &direct_connected, &num_online_relays)) {
        return CONNECTION_NONE;
    }

    if (direct_connected) {
        return CONNECTION_UDP;
    }

    if (num_online_relays != 0) {
        return CONNECTION_TCP;
    }

    /* if we have a valid friend connection but do not have an established connection
     * we leave the connection status unchanged until the friend connection is either
     * established or dropped.
     */
    return m->friendlist[friendnumber].last_connection_udp_tcp;
}


void m_get_friend_connection_ip(const Messenger *m, int32_t friendnumber, uint8_t *ip_str)
{
    if (ip_str == nullptr) {
        return;
    }

    if (!m_friend_exists(m, friendnumber)) {
        return;
    }

    if (m->friendlist[friendnumber].status != FRIEND_ONLINE) {
        return;
    }

    bool direct_connected = false;
    uint32_t num_online_relays = 0;
    const int crypt_conn_id = friend_connection_crypt_connection_id(m->fr_c, m->friendlist[friendnumber].friendcon_id);

    if (!crypto_connection_status(m->net_crypto, crypt_conn_id, &direct_connected, &num_online_relays)) {
        return;
    }

    if (direct_connected) {
        // CONNECTION_UDP;
        copy_friend_ip_port(m->net_crypto, crypt_conn_id, (char *)ip_str, direct_connected);
        return;
    }

    if (num_online_relays != 0) {
        // CONNECTION_TCP;
        copy_friend_ip_port(m->net_crypto, crypt_conn_id, (char *)ip_str, direct_connected);
    }
}

/**
 * Checks if there exists a friend with given friendnumber.
 *
 * @param friendnumber The index in the friend list.
 *
 * @retval true if friend exists.
 * @retval false if friend doesn't exist.
 */
bool m_friend_exists(const Messenger *m, int32_t friendnumber)
{
    return (unsigned int)friendnumber < m->numfriends && m->friendlist[friendnumber].status != 0;
}

/** @brief Send a message of type to an online friend.
 *
 * @retval -1 if friend not valid.
 * @retval -2 if too large.
 * @retval -3 if friend not online.
 * @retval -4 if send failed (because queue is full).
 * @retval -5 if bad type.
 * @retval 0 if success.
 *
 * The value in message_id will be passed to your read_receipt callback when the other receives the message.
 */
int m_send_message_generic(Messenger *m, int32_t friendnumber, uint8_t type, const uint8_t *message, uint32_t length,
                           uint32_t *message_id)
{
    if (type > MESSAGE_HIGH_LEVEL_ACK) {
        LOGGER_WARNING(m->log, "message type %d is invalid", type);
        return -5;
    }

    if (!m_friend_exists(m, friendnumber)) {
        LOGGER_WARNING(m->log, "friend number %d is invalid", friendnumber);
        return -1;
    }

    if (length >= MAX_CRYPTO_DATA_SIZE) {
        LOGGER_WARNING(m->log, "message length %u is too large", length);
        return -2;
    }

    if (m->friendlist[friendnumber].status != FRIEND_ONLINE) {
        LOGGER_WARNING(m->log, "friend %d is not online", friendnumber);
        return -3;
    }

    VLA(uint8_t, packet, length + 1);
    packet[0] = PACKET_ID_MESSAGE + type;

    assert(message != nullptr);
    memcpy(packet + 1, message, length);

    const int64_t packet_num = write_cryptpacket(m->net_crypto, friend_connection_crypt_connection_id(m->fr_c,
                                           m->friendlist[friendnumber].friendcon_id), packet, length + 1, false);

    if (packet_num == -1) {
        return -4;
    }

    const uint32_t msg_id = ++m->friendlist[friendnumber].message_id;

    add_receipt(m, friendnumber, packet_num, msg_id);

    if (message_id != nullptr) {
        *message_id = msg_id;
    }

    return 0;
}

non_null()
static bool write_cryptpacket_id(const Messenger *m, int32_t friendnumber, uint8_t packet_id, const uint8_t *data,
                                 uint32_t length, bool congestion_control)
{
    if (!m_friend_exists(m, friendnumber)) {
        return false;
    }

    if (length >= MAX_CRYPTO_DATA_SIZE || m->friendlist[friendnumber].status != FRIEND_ONLINE) {
        return false;
    }

    VLA(uint8_t, packet, length + 1);
    packet[0] = packet_id;

    assert(data != nullptr);
    memcpy(packet + 1, data, length);

    return write_cryptpacket(m->net_crypto, friend_connection_crypt_connection_id(m->fr_c,
                             m->friendlist[friendnumber].friendcon_id), packet, length + 1, congestion_control) != -1;
}

/** @brief Send a name packet to friendnumber.
 * length is the length with the NULL terminator.
 */
non_null()
static bool m_sendname(const Messenger *m, int32_t friendnumber, const uint8_t *name, uint16_t length)
{
    if (length > MAX_NAME_LENGTH) {
        return false;
    }

    return write_cryptpacket_id(m, friendnumber, PACKET_ID_NICKNAME, name, length, false);
}

/** @brief Set the name and name_length of a friend.
 *
 * name must be a string of maximum MAX_NAME_LENGTH length.
 * length must be at least 1 byte.
 * length is the length of name with the NULL terminator.
 *
 * @retval 0 if success.
 * @retval -1 if failure.
 */
int setfriendname(Messenger *m, int32_t friendnumber, const uint8_t *name, uint16_t length)
{
    if (!m_friend_exists(m, friendnumber)) {
        return -1;
    }

    if (length > MAX_NAME_LENGTH || length == 0) {
        return -1;
    }

    m->friendlist[friendnumber].name_length = length;
    memcpy(m->friendlist[friendnumber].name, name, length);
    return 0;
}

/** @brief Set our nickname.
 *
 * name must be a string of maximum MAX_NAME_LENGTH length.
 * length must be at least 1 byte.
 * length is the length of name with the NULL terminator.
 *
 * @retval 0 if success.
 * @retval -1 if failure.
 */
int setname(Messenger *m, const uint8_t *name, uint16_t length)
{
    if (length > MAX_NAME_LENGTH) {
        return -1;
    }

    if (m->name_length == length && (length == 0 || memcmp(name, m->name, length) == 0)) {
        return 0;
    }

    if (length > 0) {
        memcpy(m->name, name, length);
    }

    m->name_length = length;

    for (uint32_t i = 0; i < m->numfriends; ++i) {
        m->friendlist[i].name_sent = false;
    }

    return 0;
}

/**
 * @brief Get your nickname.
 *
 * m - The messenger context to use.
 * name needs to be a valid memory location with a size of at least MAX_NAME_LENGTH bytes.
 *
 * @return length of the name.
 * @retval 0 on error.
 */
uint16_t getself_name(const Messenger *m, uint8_t *name)
{
    if (name == nullptr) {
        return 0;
    }

    memcpy(name, m->name, m->name_length);

    return m->name_length;
}

/** @brief Get name of friendnumber and put it in name.
 *
 * name needs to be a valid memory location with a size of at least MAX_NAME_LENGTH (128) bytes.
 *
 * @return length of name if success.
 * @retval -1 if failure.
 */
int getname(const Messenger *m, int32_t friendnumber, uint8_t *name)
{
    if (!m_friend_exists(m, friendnumber)) {
        return -1;
    }

    memcpy(name, m->friendlist[friendnumber].name, m->friendlist[friendnumber].name_length);
    return m->friendlist[friendnumber].name_length;
}

int m_get_name_size(const Messenger *m, int32_t friendnumber)
{
    if (!m_friend_exists(m, friendnumber)) {
        return -1;
    }

    return m->friendlist[friendnumber].name_length;
}

int m_get_self_name_size(const Messenger *m)
{
    return m->name_length;
}

int m_set_statusmessage(Messenger *m, const uint8_t *status, uint16_t length)
{
    if (length > MAX_STATUSMESSAGE_LENGTH) {
        return -1;
    }

    if (m->statusmessage_length == length && (length == 0 || memcmp(m->statusmessage, status, length) == 0)) {
        return 0;
    }

    if (length > 0) {
        memcpy(m->statusmessage, status, length);
    }

    m->statusmessage_length = length;

    for (uint32_t i = 0; i < m->numfriends; ++i) {
        m->friendlist[i].statusmessage_sent = false;
    }

    return 0;
}

int m_set_userstatus(Messenger *m, uint8_t status)
{
    if (status >= USERSTATUS_INVALID) {
        return -1;
    }

    if (m->userstatus == status) {
        return 0;
    }

    m->userstatus = (Userstatus)status;

    for (uint32_t i = 0; i < m->numfriends; ++i) {
        m->friendlist[i].userstatus_sent = false;
    }

    return 0;
}

/**
 * Guaranteed to be at most MAX_STATUSMESSAGE_LENGTH.
 *
 * @return the length of friendnumber's status message, including null on success.
 * @retval -1 on failure.
 */
int m_get_statusmessage_size(const Messenger *m, int32_t friendnumber)
{
    if (!m_friend_exists(m, friendnumber)) {
        return -1;
    }

    return m->friendlist[friendnumber].statusmessage_length;
}

/** @brief Copy friendnumber's status message into buf, truncating if size is over maxlen.
 *
 * Get the size you need to allocate from m_get_statusmessage_size.
 * The self variant will copy our own status message.
 *
 * @return the length of the copied data on success
 * @retval -1 on failure.
 */
int m_copy_statusmessage(const Messenger *m, int32_t friendnumber, uint8_t *buf, uint32_t maxlen)
{
    if (!m_friend_exists(m, friendnumber)) {
        return -1;
    }

    // TODO(iphydf): This should be uint16_t and min_u16. If maxlen exceeds
    // uint16_t's range, it won't affect the result.
    const uint32_t msglen = min_u32(maxlen, m->friendlist[friendnumber].statusmessage_length);

    memcpy(buf, m->friendlist[friendnumber].statusmessage, msglen);
    memset(buf + msglen, 0, maxlen - msglen);
    return msglen;
}

/** @return the size of friendnumber's user status.
 * Guaranteed to be at most MAX_STATUSMESSAGE_LENGTH.
 */
int m_get_self_statusmessage_size(const Messenger *m)
{
    return m->statusmessage_length;
}

int m_copy_self_statusmessage(const Messenger *m, uint8_t *buf)
{
    memcpy(buf, m->statusmessage, m->statusmessage_length);
    return m->statusmessage_length;
}

uint8_t m_get_userstatus(const Messenger *m, int32_t friendnumber)
{
    if (!m_friend_exists(m, friendnumber)) {
        return USERSTATUS_INVALID;
    }

    uint8_t status = m->friendlist[friendnumber].userstatus;

    if (status >= USERSTATUS_INVALID) {
        status = USERSTATUS_NONE;
    }

    return status;
}

uint8_t m_get_self_userstatus(const Messenger *m)
{
    return m->userstatus;
}

uint64_t m_get_last_online(const Messenger *m, int32_t friendnumber)
{
    if (!m_friend_exists(m, friendnumber)) {
        return UINT64_MAX;
    }

    return m->friendlist[friendnumber].last_seen_time;
}

int m_set_usertyping(Messenger *m, int32_t friendnumber, bool is_typing)
{
    if (!m_friend_exists(m, friendnumber)) {
        return -1;
    }

    if (m->friendlist[friendnumber].user_istyping == is_typing) {
        return 0;
    }

    m->friendlist[friendnumber].user_istyping = is_typing;
    m->friendlist[friendnumber].user_istyping_sent = false;

    return 0;
}

int m_get_istyping(const Messenger *m, int32_t friendnumber)
{
    if (!m_friend_exists(m, friendnumber)) {
        return -1;
    }

    return m->friendlist[friendnumber].is_typing ? 1 : 0;
}

non_null()
static bool send_statusmessage(const Messenger *m, int32_t friendnumber, const uint8_t *status, uint16_t length)
{
    return write_cryptpacket_id(m, friendnumber, PACKET_ID_STATUSMESSAGE, status, length, false);
}

non_null()
static bool send_userstatus(const Messenger *m, int32_t friendnumber, uint8_t status)
{
    return write_cryptpacket_id(m, friendnumber, PACKET_ID_USERSTATUS, &status, sizeof(status), false);
}

non_null()
static bool send_user_istyping(const Messenger *m, int32_t friendnumber, bool is_typing)
{
    const uint8_t typing = is_typing ? 1 : 0;
    return write_cryptpacket_id(m, friendnumber, PACKET_ID_TYPING, &typing, sizeof(typing), false);
}

non_null()
static int set_friend_statusmessage(const Messenger *m, int32_t friendnumber, const uint8_t *status, uint16_t length)
{
    if (!m_friend_exists(m, friendnumber)) {
        return -1;
    }

    if (length > MAX_STATUSMESSAGE_LENGTH) {
        return -1;
    }

    if (length > 0) {
        memcpy(m->friendlist[friendnumber].statusmessage, status, length);
    }

    m->friendlist[friendnumber].statusmessage_length = length;
    return 0;
}

non_null()
static void set_friend_userstatus(const Messenger *m, int32_t friendnumber, uint8_t status)
{
    m->friendlist[friendnumber].userstatus = (Userstatus)status;
}

non_null()
static void set_friend_typing(const Messenger *m, int32_t friendnumber, bool is_typing)
{
    m->friendlist[friendnumber].is_typing = is_typing;
}

/** Set the function that will be executed when a friend request is received. */
void m_callback_friendrequest(Messenger *m, m_friend_request_cb *function)
{
    m->friend_request = function;
}

/** Set the function that will be executed when a message from a friend is received. */
void m_callback_friendmessage(Messenger *m, m_friend_message_cb *function)
{
    m->friend_message = function;
}

void m_callback_namechange(Messenger *m, m_friend_name_cb *function)
{
    m->friend_namechange = function;
}

void m_callback_statusmessage(Messenger *m, m_friend_status_message_cb *function)
{
    m->friend_statusmessagechange = function;
}

void m_callback_userstatus(Messenger *m, m_friend_status_cb *function)
{
    m->friend_userstatuschange = function;
}

void m_callback_typingchange(Messenger *m, m_friend_typing_cb *function)
{
    m->friend_typingchange = function;
}

void m_callback_read_receipt(Messenger *m, m_friend_read_receipt_cb *function)
{
    m->read_receipt = function;
}

void m_callback_connectionstatus(Messenger *m, m_friend_connection_status_cb *function)
{
    m->friend_connectionstatuschange = function;
}

void m_callback_core_connection(Messenger *m, m_self_connection_status_cb *function)
{
    m->core_connection_change = function;
}

non_null(1) nullable(3)
static void check_friend_tcp_udp(Messenger *m, int32_t friendnumber, void *userdata)
{
    const int last_connection_udp_tcp = m->friendlist[friendnumber].last_connection_udp_tcp;

    const int ret = m_get_friend_connectionstatus(m, friendnumber);

    if (ret == -1) {
        return;
    }

    if (last_connection_udp_tcp != ret) {
        if (m->friend_connectionstatuschange != nullptr) {
            m->friend_connectionstatuschange(m, friendnumber, ret, userdata);
        }
    }

    m->friendlist[friendnumber].last_connection_udp_tcp = (Connection_Status)ret;
}

non_null()
static void break_files(const Messenger *m, int32_t friendnumber);

non_null(1) nullable(4)
static void check_friend_connectionstatus(Messenger *m, int32_t friendnumber, uint8_t status, void *userdata)
{
    if (status == NOFRIEND) {
        return;
    }

    const bool was_online = m->friendlist[friendnumber].status == FRIEND_ONLINE;
    const bool is_online = status == FRIEND_ONLINE;

    if (is_online != was_online) {
        if (was_online) {
            break_files(m, friendnumber);
            clear_receipts(m, friendnumber);
        } else {
            m->friendlist[friendnumber].name_sent = false;
            m->friendlist[friendnumber].userstatus_sent = false;
            m->friendlist[friendnumber].statusmessage_sent = false;
            m->friendlist[friendnumber].user_istyping_sent = false;
        }

        m->friendlist[friendnumber].status = status;

        check_friend_tcp_udp(m, friendnumber, userdata);
    }
}

non_null(1) nullable(4)
static void set_friend_status(Messenger *m, int32_t friendnumber, uint8_t status, void *userdata)
{
    check_friend_connectionstatus(m, friendnumber, status, userdata);
    m->friendlist[friendnumber].status = status;
}

/*** CONFERENCES */


/** @brief Set the callback for conference invites. */
void m_callback_conference_invite(Messenger *m, m_conference_invite_cb *function)
{
    m->conference_invite = function;
}

/** @brief the callback for group invites. */
void m_callback_group_invite(Messenger *m, m_group_invite_cb *function)
{
    m->group_invite = function;
}

/** @brief Send a conference invite packet.
 *
 * return true on success
 * return false on failure
 */
bool send_conference_invite_packet(const Messenger *m, int32_t friendnumber, const uint8_t *data, uint16_t length)
{
    return write_cryptpacket_id(m, friendnumber, PACKET_ID_INVITE_CONFERENCE, data, length, false);
}


/** @brief Send a group invite packet.
 *
 * @retval true if success
 */
bool send_group_invite_packet(const Messenger *m, uint32_t friendnumber, const uint8_t *data, uint16_t length)
{
    return write_cryptpacket_id(m, friendnumber, PACKET_ID_INVITE_GROUPCHAT, data, length, false);
}


/*** FILE SENDING */


/** @brief Set the callback for file send requests. */
void callback_file_sendrequest(Messenger *m, m_file_recv_cb *function)
{
    m->file_sendrequest = function;
}

/** @brief Set the callback for file control requests. */
void callback_file_control(Messenger *m, m_file_recv_control_cb *function)
{
    m->file_filecontrol = function;
}

/** @brief Set the callback for file data. */
void callback_file_data(Messenger *m, m_file_recv_chunk_cb *function)
{
    m->file_filedata = function;
}

/** @brief Set the callback for file request chunk. */
void callback_file_reqchunk(Messenger *m, m_file_chunk_request_cb *function)
{
    m->file_reqchunk = function;
}

#define MAX_FILENAME_LENGTH 255

/** @brief Copy the file transfer file id to file_id
 *
 * @retval 0 on success.
 * @retval -1 if friend not valid.
 * @retval -2 if filenumber not valid
 */
int file_get_id(const Messenger *m, int32_t friendnumber, uint32_t filenumber, uint8_t *file_id)
{
    if (!m_friend_exists(m, friendnumber)) {
        return -1;
    }

    if (m->friendlist[friendnumber].status != FRIEND_ONLINE) {
        return -2;
    }

    uint32_t temp_filenum;
    bool inbound;
    uint8_t file_number;

    if (filenumber >= (1 << 16)) {
        inbound = true;
        temp_filenum = (filenumber >> 16) - 1;
    } else {
        inbound = false;
        temp_filenum = filenumber;
    }

    if (temp_filenum >= MAX_CONCURRENT_FILE_PIPES) {
        return -2;
    }

    file_number = temp_filenum;

    const struct File_Transfers *const ft = inbound
        ? &m->friendlist[friendnumber].file_receiving[file_number]
        : &m->friendlist[friendnumber].file_sending[file_number];

    if (ft->status == FILESTATUS_NONE) {
        return -2;
    }

    memcpy(file_id, ft->id, FILE_ID_LENGTH);
    return 0;
}

/** @brief Send a file send request.
 * Maximum filename length is 255 bytes.
 * @retval 1 on success
 * @retval 0 on failure
 */
non_null()
static bool file_sendrequest(const Messenger *m, int32_t friendnumber, uint8_t filenumber, uint32_t file_type,
                             uint64_t filesize, const uint8_t *file_id, const uint8_t *filename, uint16_t filename_length)
{
    if (!m_friend_exists(m, friendnumber)) {
        return false;
    }

    if (filename_length > MAX_FILENAME_LENGTH) {
        return false;
    }

    VLA(uint8_t, packet, 1 + sizeof(file_type) + sizeof(filesize) + FILE_ID_LENGTH + filename_length);
    packet[0] = filenumber;
    file_type = net_htonl(file_type);
    memcpy(packet + 1, &file_type, sizeof(file_type));
    net_pack_u64(packet + 1 + sizeof(file_type), filesize);
    memcpy(packet + 1 + sizeof(file_type) + sizeof(filesize), file_id, FILE_ID_LENGTH);

    if (filename_length > 0) {
        memcpy(packet + 1 + sizeof(file_type) + sizeof(filesize) + FILE_ID_LENGTH, filename, filename_length);
    }

    return write_cryptpacket_id(m, friendnumber, PACKET_ID_FILE_SENDREQUEST, packet, SIZEOF_VLA(packet), false);
}

/** @brief Send a file send request.
 *
 * Maximum filename length is 255 bytes.
 *
 * @return file number on success
 * @retval -1 if friend not found.
 * @retval -2 if filename length invalid.
 * @retval -3 if no more file sending slots left.
 * @retval -4 if could not send packet (friend offline).
 */
long int new_filesender(const Messenger *m, int32_t friendnumber, uint32_t file_type, uint64_t filesize,
                        const uint8_t *file_id, const uint8_t *filename, uint16_t filename_length)
{
    if (!m_friend_exists(m, friendnumber)) {
        return -1;
    }

    if (filename_length > MAX_FILENAME_LENGTH) {
        return -2;
    }

    if ((file_type == HACK_TOX_FILE_KIND_MESSAGEV2_SEND)
            ||
            (file_type == HACK_TOX_FILE_KIND_MESSAGEV2_ANSWER)
            ||
            (file_type == HACK_TOX_FILE_KIND_MESSAGEV2_SYNC)
            ||
            (file_type == HACK_TOX_FILE_KIND_MESSAGEV2_ALTER)) {
        if ((uint64_t)filesize > (uint64_t)HACK_TOX_MAX_FILETRANSFER_SIZE_MSGV2) {
            // TODO(zoff): define a new error code for this
            return -2;
        }
    }

    uint32_t i;

    for (i = 0; i < MAX_CONCURRENT_FILE_PIPES; ++i) {
        if (m->friendlist[friendnumber].file_sending[i].status == FILESTATUS_NONE) {
            break;
        }
    }

    if (i == MAX_CONCURRENT_FILE_PIPES) {
        return -3;
    }

    if (!file_sendrequest(m, friendnumber, i, file_type, filesize, file_id, filename, filename_length)) {
        return -4;
    }

    struct File_Transfers *ft = &m->friendlist[friendnumber].file_sending[i];

    ft->file_type = file_type;

    memset(ft->filename, 0, MAX_FILENAME_LENGTH);
    if (filename_length > 0) {
        memcpy(ft->filename, filename, filename_length);
    }
    ft->filename_length = filename_length;

    ft->received_seek_control = false;
    ft->received_seek_control_counter = 0;
    ft->ft_send_ackd = false;
    ft->file_receiver_last_received_chunk_this_many_iterations_ago = 0;
    ft->file_sender_started_this_many_iterations_ago = 0;

    if ((file_type == HACK_TOX_FILE_KIND_MESSAGEV2_SEND)
            ||
            (file_type == HACK_TOX_FILE_KIND_MESSAGEV2_ANSWER)
            ||
            (file_type == HACK_TOX_FILE_KIND_MESSAGEV2_SYNC)
            ||
            (file_type == HACK_TOX_FILE_KIND_MESSAGEV2_ALTER)) {
        ft->status = FILESTATUS_TRANSFERRING;
        ++m->friendlist[friendnumber].num_sending_files;
    } else {
        ft->status = FILESTATUS_NOT_ACCEPTED;
    }

    ft->size = filesize;

    ft->transferred = 0;

    ft->requested = 0;

    ft->paused = FILE_PAUSE_NOT;

    memcpy(ft->id, file_id, FILE_ID_LENGTH);

    return i;
}

non_null(1) nullable(6)
static bool send_file_control_packet(const Messenger *m, int32_t friendnumber, bool inbound, uint8_t filenumber,
                                     uint8_t control_type, const uint8_t *data, uint16_t data_length)
{
    assert(data_length == 0 || data != nullptr);

    if ((unsigned int)(1 + 3 + data_length) > MAX_CRYPTO_DATA_SIZE) {
        return false;
    }

    VLA(uint8_t, packet, 3 + data_length);

    packet[0] = inbound ? 1 : 0;
    packet[1] = filenumber;
    packet[2] = control_type;

    if (data_length > 0) {
        memcpy(packet + 3, data, data_length);
    }

    return write_cryptpacket_id(m, friendnumber, PACKET_ID_FILE_CONTROL, packet, SIZEOF_VLA(packet), false);
}

/** @brief Send a file control request.
 *
 * @retval 0 on success
 * @retval -1 if friend not valid.
 * @retval -2 if friend not online.
 * @retval -3 if file number invalid.
 * @retval -4 if file control is bad.
 * @retval -5 if file already paused.
 * @retval -6 if resume file failed because it was only paused by the other.
 * @retval -7 if resume file failed because it wasn't paused.
 * @retval -8 if packet failed to send.
 */
int file_control(const Messenger *m, int32_t friendnumber, uint32_t filenumber, unsigned int control)
{
    if (!m_friend_exists(m, friendnumber)) {
        return -1;
    }

    if (m->friendlist[friendnumber].status != FRIEND_ONLINE) {
        return -2;
    }

    uint32_t temp_filenum;
    bool inbound;
    uint8_t file_number;

    if (filenumber >= (1 << 16)) {
        inbound = true;
        temp_filenum = (filenumber >> 16) - 1;
    } else {
        inbound = false;
        temp_filenum = filenumber;
    }

    if (temp_filenum >= MAX_CONCURRENT_FILE_PIPES) {
        return -3;
    }

    file_number = temp_filenum;

    struct File_Transfers *ft;

    if (inbound) {
        ft = &m->friendlist[friendnumber].file_receiving[file_number];
    } else {
        ft = &m->friendlist[friendnumber].file_sending[file_number];
    }

    if (ft->status == FILESTATUS_NONE) {
        return -3;
    }

    if ((control != FILECONTROL_ACCEPT)
        &&
        (control != FILECONTROL_PAUSE)
        &&
        (control != FILECONTROL_KILL)
        &&
        (control != FILECONTROL_FINISHED))
    {
        return -4;
    }

    if (control == FILECONTROL_PAUSE && ((ft->paused & FILE_PAUSE_US) != 0 || ft->status != FILESTATUS_TRANSFERRING)) {
        return -5;
    }

    if (control == FILECONTROL_ACCEPT) {
        if (ft->status == FILESTATUS_TRANSFERRING) {
            if ((ft->paused & FILE_PAUSE_US) == 0) {
                if ((ft->paused & FILE_PAUSE_OTHER) != 0) {
                    return -6;
                }

                return -7;
            }
        } else {
            if (ft->status != FILESTATUS_NOT_ACCEPTED) {
                return -7;
            }

            if (!inbound) {
                return -6;
            }
        }
    }

    if (send_file_control_packet(m, friendnumber, inbound, file_number, control, nullptr, 0)) {
        switch (control) {
            case FILECONTROL_KILL: {
                if (!inbound && (ft->status == FILESTATUS_TRANSFERRING || ft->status == FILESTATUS_FINISHED)) {
                    // We are actively sending that file, remove from list
                    --m->friendlist[friendnumber].num_sending_files;
                    LOGGER_DEBUG(m->log, "friendcon->num_sending_files=%d", m->friendlist[friendnumber].num_sending_files);
                }

                if (inbound && (ft->status != FILESTATUS_NONE)) {
                    --m->friendlist[friendnumber].num_receiving_files;
                }

                ft->file_type = 0;
                ft->received_seek_control = false;
                ft->received_seek_control_counter = 0;
                ft->ft_send_ackd = false;
                ft->file_receiver_last_received_chunk_this_many_iterations_ago = 0;
                ft->file_sender_started_this_many_iterations_ago = 0;
                memset(ft->filename, 0, MAX_FILENAME_LENGTH);
                ft->filename_length = 0;
                ft->status = FILESTATUS_NONE;
                break;
            }
            case FILECONTROL_PAUSE: {
                ft->paused |= FILE_PAUSE_US;
                break;
            }
            case FILECONTROL_ACCEPT: {
                ft->status = FILESTATUS_TRANSFERRING;
                LOGGER_DEBUG(m->log, "ft->status set to FILESTATUS_TRANSFERRING");
                if ((ft->paused & FILE_PAUSE_US) != 0) {
                    ft->paused ^= FILE_PAUSE_US;
                }
                break;
            }
            case FILECONTROL_FINISHED: {
                // do nothing here
                break;
            }
        }
    } else {
        return -8;
    }

    return 0;
}

/** @brief Send a seek file control request.
 *
 * @retval 0 on success
 * @retval -1 if friend not valid.
 * @retval -2 if friend not online.
 * @retval -3 if file number invalid.
 * @retval -4 if not receiving file.
 * @retval -5 if file status wrong.
 * @retval -6 if position bad.
 * @retval -8 if packet failed to send.
 */
int file_seek(const Messenger *m, int32_t friendnumber, uint32_t filenumber, uint64_t position)
{
    if (!m_friend_exists(m, friendnumber)) {
        return -1;
    }

    if (m->friendlist[friendnumber].status != FRIEND_ONLINE) {
        return -2;
    }

    if (filenumber < (1 << 16)) {
        // Not receiving.
        return -4;
    }

    const uint32_t temp_filenum = (filenumber >> 16) - 1;

    if (temp_filenum >= MAX_CONCURRENT_FILE_PIPES) {
        return -3;
    }

    assert(temp_filenum <= UINT8_MAX);
    const uint8_t file_number = temp_filenum;

    // We're always receiving at this point.
    struct File_Transfers *ft = &m->friendlist[friendnumber].file_receiving[file_number];

    if (ft->status == FILESTATUS_NONE) {
        return -3;
    }

    if (ft->status != FILESTATUS_NOT_ACCEPTED) {
        return -5;
    }

    if (position >= ft->size) {
        return -6;
    }

    uint8_t sending_pos[sizeof(uint64_t)];
    net_pack_u64(sending_pos, position);

    if (send_file_control_packet(m, friendnumber, true, file_number, FILECONTROL_SEEK, sending_pos,
                                 sizeof(sending_pos))) {
        ft->transferred = position;
    } else {
        return -8;
    }

    return 0;
}

/** @return packet number on success.
 * @retval -1 on failure.
 */
non_null(1) nullable(4)
static int64_t send_file_data_packet(const Messenger *m, int32_t friendnumber, uint8_t filenumber, const uint8_t *data,
                                     uint16_t length)
{
    assert(length == 0 || data != nullptr);

    if (!m_friend_exists(m, friendnumber)) {
        return -1;
    }

    VLA(uint8_t, packet, 2 + length);
    packet[0] = PACKET_ID_FILE_DATA;
    packet[1] = filenumber;

    if (length > 0) {
        memcpy(packet + 2, data, length);
    }

    return write_cryptpacket(m->net_crypto, friend_connection_crypt_connection_id(m->fr_c,
                             m->friendlist[friendnumber].friendcon_id), packet, SIZEOF_VLA(packet), true);
}

#define MAX_FILE_DATA_SIZE (MAX_CRYPTO_DATA_SIZE - 2)
#define MIN_SLOTS_FREE (CRYPTO_MIN_QUEUE_LENGTH / 4)
/** @brief Send file data.
 *
 * @retval 0 on success
 * @retval -1 if friend not valid.
 * @retval -2 if friend not online.
 * @retval -3 if filenumber invalid.
 * @retval -4 if file transfer not transferring.
 * @retval -5 if bad data size.
 * @retval -6 if packet queue full.
 * @retval -7 if wrong position.
 */
int send_file_data(const Messenger *m, int32_t friendnumber, uint32_t filenumber, uint64_t position,
                   const uint8_t *data, uint16_t length)
{
    assert(length == 0 || data != nullptr);

    if (!m_friend_exists(m, friendnumber)) {
        return -1;
    }

    if (m->friendlist[friendnumber].status != FRIEND_ONLINE) {
        return -2;
    }

    if (filenumber >= MAX_CONCURRENT_FILE_PIPES) {
        return -3;
    }

    struct File_Transfers *ft = &m->friendlist[friendnumber].file_sending[filenumber];

    if (ft->status != FILESTATUS_TRANSFERRING) {
        return -4;
    }

    if (length > MAX_FILE_DATA_SIZE) {
        return -5;
    }

    if (ft->file_type == FILEKIND_FTV2) {
        if (length > (MAX_FILE_DATA_SIZE - FILE_OFFSET_LENGTH)) {
            LOGGER_WARNING(m->log, "sending FT chunk too large. size=%d max=%d", length, (MAX_FILE_DATA_SIZE - FILE_OFFSET_LENGTH));
            return -5;
        }

        uint16_t length_raw = length - FILE_ID_LENGTH;

        if ((ft->size - ft->transferred) < length_raw) {
            LOGGER_WARNING(m->log, "sending FT chunk length error.");
            return -5;
        }

        if (position != ft->transferred || (ft->requested <= position && ft->size != 0)) {
            LOGGER_WARNING(m->log, "wrong position.");
            return -7;
        }

        /* Prevent file sending from filling up the entire buffer preventing messages from being sent.
         * TODO(irungentoo): remove */
        if (crypto_num_free_sendqueue_slots(m->net_crypto, friend_connection_crypt_connection_id(m->fr_c,
                                            m->friendlist[friendnumber].friendcon_id)) < MIN_SLOTS_FREE) {
            return -6;
        }

        uint16_t length_send = length + FILE_OFFSET_LENGTH;
        uint8_t *data_send = (uint8_t *)calloc(1, length_send);
        if (data_send)
        {
            net_pack_u64(data_send, position);
            memcpy((data_send + FILE_OFFSET_LENGTH), data, length);
            const int64_t ret = send_file_data_packet(m, friendnumber, filenumber, data_send, length_send);
            free(data_send);

            if (ret != -1) {
                ft->transferred += length_raw;
                return 0;
            }
        }
        else
        {
            LOGGER_WARNING(m->log, "could not allocate buffer.");
            return -6;
        }

    } else {
        if (ft->size - ft->transferred < length) {
            return -5;
        }

        if (ft->size != UINT64_MAX && length != MAX_FILE_DATA_SIZE && (ft->transferred + length) != ft->size) {
            return -5;
        }

        if (position != ft->transferred || (ft->requested <= position && ft->size != 0)) {
            return -7;
        }

        /* Prevent file sending from filling up the entire buffer preventing messages from being sent.
         * TODO(irungentoo): remove */
        if (crypto_num_free_sendqueue_slots(m->net_crypto, friend_connection_crypt_connection_id(m->fr_c,
                                            m->friendlist[friendnumber].friendcon_id)) < MIN_SLOTS_FREE) {
            return -6;
        }

        const int64_t ret = send_file_data_packet(m, friendnumber, filenumber, data, length);

        if (ret != -1) {
            // TODO(irungentoo): record packet ids to check if other received complete file.
            ft->transferred += length;

            if (length != MAX_FILE_DATA_SIZE || ft->size == ft->transferred) {
                ft->status = FILESTATUS_FINISHED;
                ft->last_packet_number = ret;
            }

            return 0;
        }
    }

    return -6;
}

/**
 * Iterate over all file sending transfers and request chunks (from the client) for each
 * of them.
 *
 * The free_slots parameter is updated by this function.
 *
 * @param m Our messenger object.
 * @param friendnumber The friend we're sending files to.
 * @param userdata The client userdata to pass along to chunk request callbacks.
 * @param free_slots A pointer to the number of free send queue slots in the
 *   crypto connection.
 * @return true if there's still work to do, false otherwise.
 *
 */
non_null()
static bool do_all_filetransfers(Messenger *m, int32_t friendnumber, void *userdata, uint32_t *free_slots)
{
    Friend *const friendcon = &m->friendlist[friendnumber];

    // Iterate over file transfers as long as we're sending files
    for (uint32_t i = 0; i < MAX_CONCURRENT_FILE_PIPES; ++i) {
        if (friendcon->num_sending_files == 0) {
            // no active file transfers anymore
            return false;
        }

        if (*free_slots == 0) {
            // send buffer full enough
            return false;
        }

        struct File_Transfers *const ft = &friendcon->file_sending[i];

        if (ft->status == FILESTATUS_NONE || ft->status == FILESTATUS_NOT_ACCEPTED) {
            // Filetransfers not actively sending, nothing to do
            continue;
        }

        if (max_speed_reached(m->net_crypto, friend_connection_crypt_connection_id(
                                  m->fr_c, friendcon->friendcon_id))) {
            LOGGER_DEBUG(m->log, "maximum connection speed reached");
            // connection doesn't support any more data
            return false;
        }

        if (ft->file_type == FILEKIND_FTV2) {
            // If the file transfer is complete, we request a chunk of size 0.
            if (ft->status == FILESTATUS_FINISHED) {
                LOGGER_DEBUG(m->log, "The file transfer is complete, we request a chunk of size 0");
                if (m->file_reqchunk != nullptr) {
                    m->file_reqchunk(m, friendnumber, i, ft->transferred, 0, userdata);
                }
                // Now it's inactive, we're no longer sending this.
                ft->status = FILESTATUS_NONE;
                ft->file_type = 0;
                ft->received_seek_control = false;
                ft->ft_send_ackd = false;
                ft->received_seek_control_counter = 0;
                ft->file_receiver_last_received_chunk_this_many_iterations_ago = 0;
                ft->file_sender_started_this_many_iterations_ago = 0;
                memset(ft->filename, 0, MAX_FILENAME_LENGTH);
                ft->filename_length = 0;
                --friendcon->num_sending_files;
            } else if (ft->status == FILESTATUS_TRANSFERRING && ft->paused == FILE_PAUSE_NOT) {
                if (ft->size == ft->requested) {
                    // HINT: this is overkill in the log // LOGGER_DEBUG(m->log, "we as sender think this FTv2 is already finished");
                    // we as sender think this FTv2 is already finished,
                    // so we wait for either the receiver to send FILECONTROL_FINISHED
                    // or to send a SEEK to a new position
                    continue;
                }

                if (ft->received_seek_control) {
                    LOGGER_TRACE(m->log, "we are processing a SEEK control, so do not send new chunks for %d tox_iterate() cycles", (int)PAUSE_CYCLES_ON_FTV2_SEEK_RECEIVED);
                    continue;
                }

                uint16_t length = min_u64(ft->size - ft->requested, (MAX_FILE_DATA_SIZE - FILE_OFFSET_LENGTH - FILE_ID_LENGTH));
                const uint64_t position = ft->requested;
                ft->requested += length;

                if (m->file_reqchunk != nullptr) {
                    m->file_reqchunk(m, friendnumber, i, position, length, userdata);
                }

                // The allocated slot is no longer free.
                --*free_slots;
            }
        } else {
            // If the file transfer is complete, we request a chunk of size 0.
            if (ft->status == FILESTATUS_FINISHED && friend_received_packet(m, friendnumber, ft->last_packet_number) == 0) {
                if (m->file_reqchunk != nullptr) {
                    m->file_reqchunk(m, friendnumber, i, ft->transferred, 0, userdata);
                }

                // Now it's inactive, we're no longer sending this.
                ft->status = FILESTATUS_NONE;
                ft->file_type = 0;
                ft->received_seek_control = false;
                ft->ft_send_ackd = false;
                ft->received_seek_control_counter = 0;
                ft->file_receiver_last_received_chunk_this_many_iterations_ago = 0;
                ft->file_sender_started_this_many_iterations_ago = 0;
                memset(ft->filename, 0, MAX_FILENAME_LENGTH);
                ft->filename_length = 0;
                --friendcon->num_sending_files;
            } else if (ft->status == FILESTATUS_TRANSFERRING && ft->paused == FILE_PAUSE_NOT) {
                if (ft->size == 0) {
                    /* Send 0 data to friend if file is 0 length. */
                    send_file_data(m, friendnumber, i, 0, nullptr, 0);
                    continue;
                }

                if (ft->size == ft->requested) {
                    // This file transfer is done.
                    continue;
                }

                const uint16_t length = min_u64(ft->size - ft->requested, MAX_FILE_DATA_SIZE);
                const uint64_t position = ft->requested;
                ft->requested += length;

                if (m->file_reqchunk != nullptr) {
                    m->file_reqchunk(m, friendnumber, i, position, length, userdata);
                }

                // The allocated slot is no longer free.
                --*free_slots;
            }
        }
    }

    return true;
}

non_null(1) nullable(3)
static void do_reqchunk_filecb(Messenger *m, int32_t friendnumber, void *userdata)
{
    // HINT: check if we need to send some sending file requests again
    Friend *const friendcon2 = &m->friendlist[friendnumber];
    // Iterate over file transfers
    for (uint32_t i = 0; i < MAX_CONCURRENT_FILE_PIPES; ++i) {
        struct File_Transfers *const ft_check_for_received = &friendcon2->file_sending[i];
        if (ft_check_for_received->status == FILESTATUS_NOT_ACCEPTED) {
            if (ft_check_for_received->file_type == FILEKIND_FTV2) {
                // HINT: this is a sending filetransfer thats waiting to be started
                //       lets check if the receiver has actually received our request
                if (ft_check_for_received->ft_send_ackd == false) {
                    if (ft_check_for_received->file_sender_started_this_many_iterations_ago > (uint32_t)STALE_CYCLES_ON_FTV2_SEND) {
                        ft_check_for_received->file_sender_started_this_many_iterations_ago = 0;
                        // HINT: try to send the FT again
                        uint32_t real_filenumber;
                        struct File_Transfers *ft_s = get_file_transfer(true, i, &real_filenumber, friendcon2);
                        LOGGER_DEBUG(m->log, "sending FT again:friendnum: %d filenum: %d", friendnumber, real_filenumber);
                        if (!file_sendrequest(m, friendnumber, i, ft_check_for_received->file_type,
                            ft_check_for_received->size,
                            ft_check_for_received->id, ft_check_for_received->filename,
                            ft_check_for_received->filename_length)) {
                            LOGGER_DEBUG(m->log, "ERROR on sending FT again:friendnum: %d filenum: %d", friendnumber, real_filenumber);
                        }
                    } else {
                        ++ft_check_for_received->file_sender_started_this_many_iterations_ago;
                    }
                }
            }
        }
    }

    // check stale receiving file transfers.
    if (m->friendlist[friendnumber].num_receiving_files > 0) {
        Friend *const friendcon = &m->friendlist[friendnumber];
        bool found_sending_ft = false;
        for (uint32_t i = 0; i < MAX_CONCURRENT_FILE_PIPES; ++i) {
            struct File_Transfers *const ft = &friendcon->file_receiving[i];
            if (ft->status != FILESTATUS_NONE) {
                found_sending_ft = true;
                if (ft->file_type == FILEKIND_FTV2) {
                    if (ft->file_receiver_last_received_chunk_this_many_iterations_ago > (uint32_t)STALE_CYCLES_ON_FTV2_RECEIVER) {
                        ft->file_receiver_last_received_chunk_this_many_iterations_ago = 0;
                        // the receiving FT has not received a data chunk for many tox_iterate cycles. send a SEEK control to the sender
                        uint32_t real_filenumber;
                        struct File_Transfers *ft_unused = get_file_transfer(false, i, &real_filenumber, &m->friendlist[friendnumber]);
                        uint8_t wanted_offset[sizeof(uint64_t)];
                        net_pack_u64(wanted_offset, ft->transferred);
                        if (!send_file_control_packet(m, friendnumber, true, i, FILECONTROL_SEEK, wanted_offset, sizeof(wanted_offset))) {
                            // sending SEEK file control failed
                            LOGGER_DEBUG(m->log, "stale receiving FT detected:sending SEEK file control failed. friendnum: %d filenum: %d",
                                friendnumber, real_filenumber);
                        } else {
                            LOGGER_DEBUG(m->log, "stale receiving FT detected:sending SEEK file control to friendnum: %d filenum: %d",
                                friendnumber, real_filenumber);
                            send_file_control_packet(m, friendnumber, true, i, FILECONTROL_ACCEPT, wanted_offset, sizeof(wanted_offset));
                            if (ft->status == FILESTATUS_TRANSFERRING) {
                                // HINT: we need to send ACCEPT (==TRANSFERRING) again, since it could have been lost when the other party went offline
                                LOGGER_INFO(m->log, "stale receiving FT detected:sending FILECONTROL_ACCEPT file control to friendnum: %d filenum: %d",
                                    friendnumber, real_filenumber);
                            }
                        }
                    } else {
                        ++ft->file_receiver_last_received_chunk_this_many_iterations_ago;
                    }
                }
            }
        }

        // as a safety check, if for some reason the counting of `num_receiving_files` is wrong
        if (!found_sending_ft) {
            m->friendlist[friendnumber].num_receiving_files = 0;
        }
    }

    // We're not currently doing any sending file transfers.
    if (m->friendlist[friendnumber].num_sending_files == 0) {
        return;
    }

    // The number of packet slots left in the sendbuffer.
    // This is a per friend count (CRYPTO_PACKET_BUFFER_SIZE).
    uint32_t free_slots = crypto_num_free_sendqueue_slots(
                              m->net_crypto,
                              friend_connection_crypt_connection_id(
                                  m->fr_c,
                                  m->friendlist[friendnumber].friendcon_id));

    // We keep MIN_SLOTS_FREE slots free for other packets, otherwise file
    // transfers might block other traffic for a long time.
    free_slots = max_s32(0, (int32_t)free_slots - MIN_SLOTS_FREE);

    // Maximum number of outer loops below. If the client doesn't send file
    // chunks from within the chunk request callback handler, we never realise
    // that the file transfer has finished and may end up in an infinite loop.
    //
    // Request up to that number of chunks per file from the client
    //
    // TODO(Jfreegman): set this cap dynamically
    const uint32_t max_ft_loops = 128;

    for (uint32_t i = 0; i < max_ft_loops; ++i) {
        if (!do_all_filetransfers(m, friendnumber, userdata, &free_slots)) {
            break;
        }

        if (free_slots == 0) {
            // stop when the buffer is full enough
            break;
        }
    }

    // reset `received_seek_control` flag for sending FTs
    Friend *const friendcon = &m->friendlist[friendnumber];
    if (friendcon->num_sending_files > 0) {
        for (uint32_t i = 0; i < MAX_CONCURRENT_FILE_PIPES; ++i) {
            struct File_Transfers *const ft = &friendcon->file_sending[i];
            if (ft->received_seek_control) {
                --ft->received_seek_control_counter;
                // we also check for the unlikely event that the previous line has rolled over `received_seek_control_counter`
                if ((ft->received_seek_control_counter < 1) || (ft->received_seek_control_counter > (uint8_t)PAUSE_CYCLES_ON_FTV2_SEEK_RECEIVED)) {
                    ft->received_seek_control = false;
                }
            }
        }
    }
}


/** @brief Run this when the friend disconnects.
 * Kill all current file transfers.
 */
static void break_files(const Messenger *m, int32_t friendnumber)
{
    Friend *const f = &m->friendlist[friendnumber];

    // TODO(irungentoo): Inform the client which file transfers get killed with a callback?
    for (uint32_t i = 0; i < MAX_CONCURRENT_FILE_PIPES; ++i) {
        if (f->file_sending[i].file_type != FILEKIND_FTV2)
        {
            f->file_sending[i].status = FILESTATUS_NONE;
            f->file_sending[i].file_type = 0;
            f->file_sending[i].received_seek_control = false;
            f->file_sending[i].ft_send_ackd = false;
            f->file_sending[i].received_seek_control_counter = 0;
            f->file_sending[i].file_receiver_last_received_chunk_this_many_iterations_ago = 0;
            f->file_sending[i].file_sender_started_this_many_iterations_ago = 0;
            memset(f->file_sending[i].filename, 0, MAX_FILENAME_LENGTH);
            f->file_sending[i].filename_length = 0;
        }

        if (f->file_receiving[i].file_type != FILEKIND_FTV2)
        {
            f->file_receiving[i].status = FILESTATUS_NONE;
            f->file_receiving[i].file_type = 0;
            f->file_receiving[i].received_seek_control = false;
            f->file_receiving[i].ft_send_ackd = false;
            f->file_receiving[i].received_seek_control_counter = 0;
            f->file_receiving[i].file_receiver_last_received_chunk_this_many_iterations_ago = 0;
            f->file_receiving[i].file_sender_started_this_many_iterations_ago = 0;
            memset(f->file_receiving[i].filename, 0, MAX_FILENAME_LENGTH);
            f->file_receiving[i].filename_length = 0;
        }
    }
}

non_null()
static struct File_Transfers *get_file_transfer(bool outbound, uint8_t filenumber,
        uint32_t *real_filenumber, Friend *sender)
{
    struct File_Transfers *ft;

    if (outbound) {
        *real_filenumber = filenumber;
        ft = &sender->file_sending[filenumber];
    } else {
        *real_filenumber = (filenumber + 1) << 16;
        ft = &sender->file_receiving[filenumber];
    }

    if (ft->status == FILESTATUS_NONE) {
        return nullptr;
    }

    return ft;
}

/** @retval -1 on failure
 * @retval 0 on success.
 */
non_null(1, 6) nullable(8)
static int handle_filecontrol(Messenger *m, int32_t friendnumber, bool outbound, uint8_t filenumber,
                              uint8_t control_type, const uint8_t *data, uint16_t length, void *userdata)
{
    uint32_t real_filenumber;
    struct File_Transfers *ft = get_file_transfer(outbound, filenumber, &real_filenumber, &m->friendlist[friendnumber]);

    LOGGER_TRACE(m->log, "file control (friend %d, file %d): control=%d", friendnumber, filenumber, control_type);

    if (ft == nullptr) {
        LOGGER_DEBUG(m->log, "file control (friend %d, file %d): file transfer does not exist",
                     friendnumber, filenumber);
        if (control_type != FILECONTROL_KILL) {
            LOGGER_DEBUG(m->log, "file control (friend %d, file %d): file transfer does not exist -> telling the other to kill it",
                        friendnumber, filenumber);
            send_file_control_packet(m, friendnumber, !outbound, filenumber, FILECONTROL_KILL, nullptr, 0);
        }
        return -1;
    }

    switch (control_type) {
        case FILECONTROL_ACCEPT: {
            LOGGER_DEBUG(m->log, "file control FILECONTROL_ACCEPT incoming");
            ft->ft_send_ackd = true;
            if (outbound && ft->status == FILESTATUS_NOT_ACCEPTED) {
                ft->status = FILESTATUS_TRANSFERRING;
                ++m->friendlist[friendnumber].num_sending_files;
            } else {
                if ((ft->paused & FILE_PAUSE_OTHER) != 0) {
                    ft->paused ^= FILE_PAUSE_OTHER;
                } else {
                    LOGGER_DEBUG(m->log, "file control (friend %d, file %d): friend told us to resume file transfer that wasn't paused",
                                 friendnumber, filenumber);
                    return -1;
                }
            }

            if (m->file_filecontrol != nullptr) {
                m->file_filecontrol(m, friendnumber, real_filenumber, control_type, userdata);
            }

            return 0;
        }

        case FILECONTROL_SEND_ACK: {
            if (ft->file_type == FILEKIND_FTV2) {
                if (!outbound) {
                    LOGGER_DEBUG(m->log,
                                 "file control (friend %d, file %d): FILECONTROL_SEND_ACK was sent by a sender",
                                 friendnumber, filenumber);
                    return -1;
                } else {
                    LOGGER_DEBUG(m->log,
                                 "file control (friend %d, file %d): FILECONTROL_SEND_ACK outbound=%d", friendnumber, filenumber, (int)outbound);
                }

                if (length != FILE_ID_LENGTH) {
                    LOGGER_DEBUG(m->log, "file control (friend %d, file %d): FILECONTROL_SEND_ACK expected payload of length %d, but got %d",
                                 friendnumber, filenumber, (uint32_t)FILE_ID_LENGTH, length);
                    return -1;
                }
                // HINT: check that we are actually on the correct FT ID
                if (memcmp(data, ft->id, FILE_ID_LENGTH) != 0)
                {
                    // 32byte file ID does not match received data file ID
                    LOGGER_WARNING(m->log, "FILECONTROL_SEND_ACK: 32byte file ID does not match received data file ID. friendnum: %d filenum: %d",
                        friendnumber, filenumber);
                    return -1;
                }
                // HINT: the receiver has sent us confirmation the our file send request was received and also fully processed.
                ft->ft_send_ackd = true;
                LOGGER_INFO(m->log, "FILECONTROL_SEND_ACK: received");
            }
            return 0;
        }

        case FILECONTROL_PAUSE: {
            ft->ft_send_ackd = true;
            if ((ft->paused & FILE_PAUSE_OTHER) != 0 || ft->status != FILESTATUS_TRANSFERRING) {
                LOGGER_DEBUG(m->log, "file control (friend %d, file %d): friend told us to pause file transfer that is already paused",
                             friendnumber, filenumber);
                return -1;
            }

            ft->paused |= FILE_PAUSE_OTHER;

            if (m->file_filecontrol != nullptr) {
                m->file_filecontrol(m, friendnumber, real_filenumber, control_type, userdata);
            }

            return 0;
        }

        case FILECONTROL_KILL: {
            ft->ft_send_ackd = true;
            if (outbound && (ft->status == FILESTATUS_FINISHED) && (ft->file_type == FILEKIND_FTV2)) {
                LOGGER_DEBUG(m->log, "FILECONTROL_KILL:do not KILL a FINISHED sending FT. fnum=%d ftnum=%d", friendnumber, filenumber);
                return 0;
            }

            if (m->file_filecontrol != nullptr) {
                m->file_filecontrol(m, friendnumber, real_filenumber, control_type, userdata);
            }

            if (outbound && (ft->status == FILESTATUS_TRANSFERRING || ft->status == FILESTATUS_FINISHED)) {
                --m->friendlist[friendnumber].num_sending_files;
                LOGGER_DEBUG(m->log, "friendcon->num_sending_files=%d", m->friendlist[friendnumber].num_sending_files);
            }

            if (!outbound && (ft->status != FILESTATUS_NONE)) {
                --m->friendlist[friendnumber].num_receiving_files;
                LOGGER_DEBUG(m->log, "friendcon->num_receiving_files=%d", m->friendlist[friendnumber].num_receiving_files);
            }

            LOGGER_DEBUG(m->log, "FILECONTROL_KILL:friendcon->num_sending_files=%d", m->friendlist[friendnumber].num_sending_files);
            ft->status = FILESTATUS_NONE;
            ft->file_type = 0;
            ft->received_seek_control = false;
            ft->ft_send_ackd = false;
            ft->received_seek_control_counter = 0;
            ft->file_receiver_last_received_chunk_this_many_iterations_ago = 0;
            ft->file_sender_started_this_many_iterations_ago = 0;
            memset(ft->filename, 0, MAX_FILENAME_LENGTH);
            ft->filename_length = 0;

            return 0;
        }

        case FILECONTROL_SEEK: {
            ft->ft_send_ackd = true;
            uint64_t position;

            LOGGER_DEBUG(m->log, "file control SEEK **incoming** (friend %d, file %d)", friendnumber, filenumber);
            if (length != sizeof(position)) {
                LOGGER_DEBUG(m->log, "file control (friend %d, file %d): expected payload of length %d, but got %d",
                             friendnumber, filenumber, (uint32_t)sizeof(position), length);
                return -1;
            }

            /* seek can only be sent by the receiver to seek before resuming broken transfers.
             * or to resume at a different position for FILEKIND_FTV2
             */
            if (ft->file_type == FILEKIND_FTV2) {
                if (!outbound) {
                    LOGGER_DEBUG(m->log,
                                 "file control (friend %d, file %d): seek was sent by a sender",
                                 friendnumber, filenumber);
                    return -1;
                }
            } else {
                if (ft->status != FILESTATUS_NOT_ACCEPTED || !outbound) {
                    LOGGER_DEBUG(m->log,
                                 "file control (friend %d, file %d): seek was either sent by a sender or by the receiver after accepting",
                                 friendnumber, filenumber);
                    return -1;
                }
            }

            net_unpack_u64(data, &position);

            if (position >= ft->size) {
                LOGGER_DEBUG(m->log,
                             "file control (friend %d, file %d): seek position %ld exceeds file size %ld",
                             friendnumber, filenumber, (unsigned long)position, (unsigned long)ft->size);
                return -1;
            }

            LOGGER_DEBUG(m->log,
                         "file control (friend %d, file %d): seek to position %ld was before seek transferred:%ld requested:%ld",
                         friendnumber, filenumber, (unsigned long)position, (unsigned long)ft->transferred, (unsigned long)ft->requested);
            ft->received_seek_control = true;
            ft->received_seek_control_counter = PAUSE_CYCLES_ON_FTV2_SEEK_RECEIVED;
            ft->file_receiver_last_received_chunk_this_many_iterations_ago = 0;
            ft->file_sender_started_this_many_iterations_ago = 0;
            ft->requested = position;
            ft->transferred = position;
            return 0;
        }

        case FILECONTROL_FINISHED: {
            ft->ft_send_ackd = true;
            if (outbound && (ft->status == FILESTATUS_TRANSFERRING) && (ft->file_type == FILEKIND_FTV2))
            {
                /* Full file received by the receiver. stop sending.
                 * setting status = FILESTATUS_FINISHED here will make `do_all_filetransfers` do the rest to properly finish the sending FTv2
                 */
                LOGGER_DEBUG(m->log,
                             "file control (friend %d, file %d): received FILECONTROL_FINISHED",
                             friendnumber, filenumber);
                ft->status = FILESTATUS_FINISHED;
            }
            return 0;
        }

        default: {
            LOGGER_DEBUG(m->log, "file control (friend %d, file %d): invalid file control: %d",
                         friendnumber, filenumber, control_type);
            return -1;
        }
    }
}

static int m_handle_lossy_packet(void *object, int friend_num, const uint8_t *packet, uint16_t length,
                                 void *userdata)
{
    Messenger *m = (Messenger *)object;

    if (!m_friend_exists(m, friend_num)) {
        return 1;
    }

    if (m->lossy_packethandler != nullptr) {
        m->lossy_packethandler(m, friend_num, packet[0], packet, length, userdata);
    }

    return 1;
}

void custom_lossy_packet_registerhandler(Messenger *m, m_friend_lossy_packet_cb *lossy_packethandler)
{
    m->lossy_packethandler = lossy_packethandler;
}

int m_send_custom_lossy_packet(const Messenger *m, int32_t friendnumber, const uint8_t *data, uint32_t length)
{
    if (!m_friend_exists(m, friendnumber)) {
        return -1;
    }

    if (length == 0 || length > MAX_CRYPTO_DATA_SIZE) {
        return -2;
    }

    if (data[0] < PACKET_ID_RANGE_LOSSY_START || data[0] > PACKET_ID_RANGE_LOSSY_END) {
        return -3;
    }

    if (m->friendlist[friendnumber].status != FRIEND_ONLINE) {
        return -4;
    }

    if (send_lossy_cryptpacket(m->net_crypto, friend_connection_crypt_connection_id(m->fr_c,
                               m->friendlist[friendnumber].friendcon_id), data, length) == -1) {
        return -5;
    }

    return 0;
}

non_null(1, 3) nullable(5)
static int handle_custom_lossless_packet(void *object, int friend_num, const uint8_t *packet, uint16_t length,
        void *userdata)
{
    Messenger *m = (Messenger *)object;

    if (!m_friend_exists(m, friend_num)) {
        return -1;
    }

    if (packet[0] < PACKET_ID_RANGE_LOSSLESS_CUSTOM_START || packet[0] > PACKET_ID_RANGE_LOSSLESS_CUSTOM_END) {
        // allow PACKET_ID_MSI packets to be handled by custom packet handler
        if (packet[0] != PACKET_ID_MSI) {
            return -1;
        }
    }

    if (m->lossless_packethandler != nullptr) {
        m->lossless_packethandler(m, friend_num, packet[0], packet, length, userdata);
    }

    return 1;
}

void custom_lossless_packet_registerhandler(Messenger *m, m_friend_lossless_packet_cb *lossless_packethandler)
{
    m->lossless_packethandler = lossless_packethandler;
}

int send_custom_lossless_packet(const Messenger *m, int32_t friendnumber, const uint8_t *data, uint32_t length)
{
    if (!m_friend_exists(m, friendnumber)) {
        return -1;
    }

    if (length == 0 || length > MAX_CRYPTO_DATA_SIZE) {
        return -2;
    }

    if ((data[0] < PACKET_ID_RANGE_LOSSLESS_CUSTOM_START || data[0] > PACKET_ID_RANGE_LOSSLESS_CUSTOM_END)
            && data[0] != PACKET_ID_MSI) {
        return -3;
    }

    if (m->friendlist[friendnumber].status != FRIEND_ONLINE) {
        return -4;
    }

    if (write_cryptpacket(m->net_crypto, friend_connection_crypt_connection_id(m->fr_c,
                          m->friendlist[friendnumber].friendcon_id), data, length, true) == -1) {
        return -5;
    }

    return 0;
}

/** Function to filter out some friend requests*/
non_null()
static int friend_already_added(const uint8_t *real_pk, void *data)
{
    const Messenger *m = (const Messenger *)data;

    if (getfriend_id(m, real_pk) == -1) {
        return 0;
    }

    return -1;
}

/** @brief Check for and handle a timed-out friend request.
 *
 * If the request has timed-out then the friend status is set back to FRIEND_ADDED.
 * @param i friendlist index of the timed-out friend
 * @param t time
 */
non_null(1) nullable(4)
static void check_friend_request_timed_out(Messenger *m, uint32_t i, uint64_t t, void *userdata)
{
    Friend *f = &m->friendlist[i];

    if (f->friendrequest_lastsent + f->friendrequest_timeout < t) {
        set_friend_status(m, i, FRIEND_ADDED, userdata);
        /* Double the default timeout every time if friendrequest is assumed
         * to have been sent unsuccessfully.
         */
        f->friendrequest_timeout *= 2;
    }
}

static int m_handle_status(void *object, int i, bool status, void *userdata)
{
    Messenger *m = (Messenger *)object;

    if (status) { /* Went online. */
        send_online_packet(m, m->friendlist[i].friendcon_id);
    } else { /* Went offline. */
        if (m->friendlist[i].status == FRIEND_ONLINE) {
            set_friend_status(m, i, FRIEND_CONFIRMED, userdata);
        }
    }

    return 0;
}

/* get capabilities of friend's toxcore
 * return TOX_CAPABILITY_BASIC on any error
 */
uint64_t m_get_friend_toxcore_capabilities(const Messenger *m, int32_t friendnumber)
{
    if (!m_friend_exists(m, friendnumber)) {
        return TOX_CAPABILITY_BASIC;
    }

    // return toxcore_capabilities for friend, not matter if ONLINE or OFFLINE
    return m->friendlist[friendnumber].toxcore_capabilities;
}

static int m_handle_packet(void *object, int i, const uint8_t *temp, uint16_t len, void *userdata)
{
    if (len == 0) {
        return -1;
    }

    Messenger *m = (Messenger *)object;
    const uint8_t packet_id = temp[0];
    const uint8_t *data = temp + 1;
    const uint16_t data_length = len - 1;

    if (m->friendlist[i].status != FRIEND_ONLINE) {
        if (packet_id == PACKET_ID_ONLINE) {
            if (len == (TOX_CAPABILITIES_SIZE + 1)) {
                uint64_t received_caps;
                net_unpack_u64(data, &received_caps);
                m->friendlist[i].toxcore_capabilities = received_caps;
                LOGGER_DEBUG(m->log, "got capabilties: %llu friendnum: %d",
                             (long long unsigned int)m->friendlist[i].toxcore_capabilities, (int)i);
            } else if (len == 1) {
                set_friend_status(m, i, FRIEND_ONLINE, userdata);
                send_online_packet(m, i);
                LOGGER_DEBUG(m->log, "got online packet for friendnum: %d", (int)i);
            } else {
                return -1;
            }
        } else {
            return -1;
        }
    }

    switch (packet_id) {
        case PACKET_ID_OFFLINE: {
            if (data_length > 0) {
                break;
            }

            set_friend_status(m, i, FRIEND_CONFIRMED, userdata);
            break;
        }

        case PACKET_ID_NICKNAME: {
            if (data_length > MAX_NAME_LENGTH) {
                break;
            }

            /* Make sure the NULL terminator is present. */
            VLA(uint8_t, data_terminated, data_length + 1);
            memcpy(data_terminated, data, data_length);
            data_terminated[data_length] = 0;

            /* inform of namechange before we overwrite the old name */
            if (m->friend_namechange != nullptr) {
                m->friend_namechange(m, i, data_terminated, data_length, userdata);
            }

            memcpy(m->friendlist[i].name, data_terminated, data_length);
            m->friendlist[i].name_length = data_length;

            break;
        }

        case PACKET_ID_STATUSMESSAGE: {
            if (data_length > MAX_STATUSMESSAGE_LENGTH) {
                break;
            }

            /* Make sure the NULL terminator is present. */
            VLA(uint8_t, data_terminated, data_length + 1);
            memcpy(data_terminated, data, data_length);
            data_terminated[data_length] = 0;

            if (m->friend_statusmessagechange != nullptr) {
                m->friend_statusmessagechange(m, i, data_terminated, data_length, userdata);
            }

            set_friend_statusmessage(m, i, data_terminated, data_length);
            break;
        }

        case PACKET_ID_USERSTATUS: {
            if (data_length != 1) {
                break;
            }

            const Userstatus status = (Userstatus)data[0];

            if (status >= USERSTATUS_INVALID) {
                break;
            }

            if (m->friend_userstatuschange != nullptr) {
                m->friend_userstatuschange(m, i, status, userdata);
            }

            set_friend_userstatus(m, i, status);
            break;
        }

        case PACKET_ID_TYPING: {
            if (data_length != 1) {
                break;
            }

            const bool typing = data[0] != 0;

            set_friend_typing(m, i, typing);

            if (m->friend_typingchange != nullptr) {
                m->friend_typingchange(m, i, typing, userdata);
            }

            break;
        }

        case PACKET_ID_MESSAGE: // fall-through
        case PACKET_ID_ACTION:
        case PACKET_ID_HIGH_LEVEL_ACK: {
            if (data_length == 0) {
                break;
            }

            const uint8_t *message = data;
            const uint16_t message_length = data_length;

            /* Make sure the NULL terminator is present. */
            VLA(uint8_t, message_terminated, message_length + 1);
            memcpy(message_terminated, message, message_length);
            message_terminated[message_length] = 0;
            const uint8_t type = packet_id - PACKET_ID_MESSAGE;

            if (m->friend_message != nullptr) {
                m->friend_message(m, i, type, message_terminated, message_length, userdata);
            }

            break;
        }

        case PACKET_ID_INVITE_CONFERENCE: {
            if (data_length == 0) {
                break;
            }

            if (m->conference_invite != nullptr) {
                m->conference_invite(m, i, data, data_length, userdata);
            }

            break;
        }

        case PACKET_ID_FILE_SENDREQUEST: {
            const unsigned int head_length = 1 + sizeof(uint32_t) + sizeof(uint64_t) + FILE_ID_LENGTH;

            if (data_length < head_length) {
                break;
            }

            const uint8_t filenumber = data[0];

#if UINT8_MAX >= MAX_CONCURRENT_FILE_PIPES

            if (filenumber >= MAX_CONCURRENT_FILE_PIPES) {
                break;
            }

#endif

            uint64_t filesize;
            uint32_t file_type;
            const uint16_t filename_length = data_length - head_length;

            if (filename_length > MAX_FILENAME_LENGTH) {
                break;
            }

            memcpy(&file_type, data + 1, sizeof(file_type));
            file_type = net_ntohl(file_type);

            net_unpack_u64(data + 1 + sizeof(uint32_t), &filesize);
            struct File_Transfers *ft = &m->friendlist[i].file_receiving[filenumber];

            if (ft->status != FILESTATUS_NONE) {
                // HINT: this ftnum "i" is already in use
                if (ft->file_type == FILEKIND_FTV2) {
                    LOGGER_DEBUG(m->log, "PACKET_ID_FILE_SENDREQUEST:already_in_use:file_type == FILEKIND_FTV2");
                    if (send_file_control_packet(m, i, true, filenumber, FILECONTROL_SEND_ACK, ft->id, FILE_ID_LENGTH)) {
                        // HINT: if this fails the sender will resend the FT anyway, so no need to handle any error here
                        LOGGER_INFO(m->log, "PACKET_ID_FILE_SENDREQUEST:already_in_use:sent FILECONTROL_SEND_ACK to sender");
                    }
                }
                break;
            }

            if ((file_type == HACK_TOX_FILE_KIND_MESSAGEV2_SEND)
                    ||
                    (file_type == HACK_TOX_FILE_KIND_MESSAGEV2_ANSWER)
                    ||
                    (file_type == HACK_TOX_FILE_KIND_MESSAGEV2_SYNC)
                    ||
                    (file_type == HACK_TOX_FILE_KIND_MESSAGEV2_ALTER)) {
                ft->status = FILESTATUS_TRANSFERRING;

                if ((uint64_t)filesize > (uint64_t)HACK_TOX_MAX_FILETRANSFER_SIZE_MSGV2) {
                    break;
                }

            } else {
                ft->status = FILESTATUS_NOT_ACCEPTED;
            }

            ft->file_type = file_type;
            ft->size = filesize;
            ft->transferred = 0;
            ft->paused = FILE_PAUSE_NOT;
            memcpy(ft->id, data + 1 + sizeof(uint32_t) + sizeof(uint64_t), FILE_ID_LENGTH);

            ++m->friendlist[i].num_receiving_files;

            VLA(uint8_t, filename_terminated, filename_length + 1);
            const uint8_t *filename = nullptr;

            if (filename_length > 0) {
                /* Force NULL terminate file name. */
                memcpy(filename_terminated, data + head_length, filename_length);
                filename_terminated[filename_length] = 0;
                filename = filename_terminated;
            }

            uint32_t real_filenumber = filenumber;
            real_filenumber += 1;
            real_filenumber <<= 16;

            if (m->file_sendrequest != nullptr) {
                m->file_sendrequest(m, i, real_filenumber, file_type, filesize, filename, filename_length,
                                    userdata);
            }

            // HINT: ftv2a: tell the sender that we have actually received the file send request and have fully processed it
            if (ft->file_type == FILEKIND_FTV2) {
                LOGGER_DEBUG(m->log, "PACKET_ID_FILE_SENDREQUEST:file_type == FILEKIND_FTV2");
                if (send_file_control_packet(m, i, true, filenumber, FILECONTROL_SEND_ACK, ft->id, FILE_ID_LENGTH)) {
                    // HINT: if this fails the sender will resend the FT anyway, so no need to handle any error here
                    LOGGER_INFO(m->log, "PACKET_ID_FILE_SENDREQUEST:sent FILECONTROL_SEND_ACK to sender");
                }
            }

            break;
        }

        case PACKET_ID_FILE_CONTROL: {
            if (data_length < 3) {
                break;
            }

            // On the other side, "outbound" is "inbound", i.e. if they send 1,
            // that means "inbound" on their side, but we call it "outbound"
            // here.
            const bool outbound = data[0] == 1;
            uint8_t filenumber = data[1];
            const uint8_t control_type = data[2];

#if UINT8_MAX >= MAX_CONCURRENT_FILE_PIPES

            if (filenumber >= MAX_CONCURRENT_FILE_PIPES) {
                break;
            }

#endif

            if (handle_filecontrol(m, i, outbound, filenumber, control_type, data + 3, data_length - 3, userdata) == -1) {
                // TODO(iphydf): Do something different here? Right now, this
                // check is pointless.
                break;
            }

            break;
        }

        case PACKET_ID_FILE_DATA: {
            // This includes all of Tox_File_Kind file types.

            if (data_length < 1) {
                break;
            }

            uint8_t filenumber = data[0];

#if UINT8_MAX >= MAX_CONCURRENT_FILE_PIPES

            if (filenumber >= MAX_CONCURRENT_FILE_PIPES) {
                break;
            }

#endif

            struct File_Transfers *ft = &m->friendlist[i].file_receiving[filenumber];

            if (ft->status != FILESTATUS_TRANSFERRING) {
                if (ft->status == FILESTATUS_NONE) {
                    LOGGER_DEBUG(m->log, "we have received an FT data packet for and unknown FT. friendnum: %d filenum: %d",
                        i, filenumber);
                    // send FT KILL control to the sender, we dont need to stop ourselves, since we do not know about this FT.
                    send_file_control_packet(m, i, true, filenumber, FILECONTROL_KILL, nullptr, 0);
                }
                break;
            }

            uint64_t position = ft->transferred;
            uint32_t real_filenumber = filenumber;
            real_filenumber += 1;
            real_filenumber <<= 16;
            uint16_t file_data_length = data_length - 1;
            const uint8_t *file_data;

            if (file_data_length == 0) {
                file_data = nullptr;
            } else {
                file_data = data + 1;
            }

            ft->ft_send_ackd = true;

            if (ft->file_type == FILEKIND_FTV2)
            {
                if (file_data == nullptr)
                {
                    // file data has zero length. that should never happen
                    LOGGER_WARNING(m->log, "file data has zero length. that should never happen. friendnum: %d filenum: %d",
                        i, real_filenumber);
                    break;
                }

                if (file_data_length < (FILE_OFFSET_LENGTH + FILE_ID_LENGTH + 1))
                {
                    // not enough length for 8bytes offset and 32bytes ID and at least 1 data byte
                    LOGGER_WARNING(m->log, "not enough length for 8bytes offset and 32bytes ID and at least 1 data byte. friendnum: %d filenum: %d",
                        i, real_filenumber);
                    break;
                }
                uint64_t offset;
                net_unpack_u64(file_data, &offset);

                uint16_t file_data_length_raw = file_data_length - FILE_OFFSET_LENGTH;
                uint16_t file_data_length_raw_ft = file_data_length - FILE_OFFSET_LENGTH - FILE_ID_LENGTH;
                const uint8_t *file_data_raw = file_data + FILE_OFFSET_LENGTH;

                uint8_t id[FILE_ID_LENGTH];
                memcpy(id, file_data_raw, FILE_ID_LENGTH);

                if (memcmp(id, ft->id, FILE_ID_LENGTH) != 0)
                {
                    // 32byte file ID does not match received data file ID
                    LOGGER_WARNING(m->log, "32byte file ID does not match received data file ID. friendnum: %d filenum: %d",
                        i, real_filenumber);
                    // send FT KILL control to sender
                    send_file_control_packet(m, i, true, filenumber, FILECONTROL_KILL, nullptr, 0);
                    // send FT KILL control also to our attached tox client
                    if (m->file_filecontrol != nullptr) {
                        m->file_filecontrol(m, i, real_filenumber, FILECONTROL_KILL, userdata);
                    }
                    break;
                }

                if (offset > (ft->size - file_data_length_raw_ft))
                {
                    // received offset is larger than filesize plus this chunk size
                    LOGGER_WARNING(m->log, "received offset is larger than filesize plus this chunk size offset=%lu size=%lu chunklen=%u. friendnum: %d filenum: %d",
                        offset, ft->size, file_data_length_raw_ft, i, real_filenumber);
                    break;
                }

                if (offset != ft->transferred)
                {
                    // received out of order chunk of data
                    LOGGER_DEBUG(m->log, "received out of order chunk of data offset=%lu transferred=%lu. friendnum: %d filenum: %d",
                        offset, ft->transferred, i, real_filenumber);

                    // send SEEK file control to friend, to seek to our current position
                    uint8_t wanted_offset[sizeof(uint64_t)];
                    net_pack_u64(wanted_offset, ft->transferred);

                    if (!send_file_control_packet(m, i, true, filenumber, FILECONTROL_SEEK, wanted_offset, sizeof(wanted_offset))) {
                        // sending SEEK file control failed
                        LOGGER_WARNING(m->log, "sending SEEK file control failed. friendnum: %d filenum: %d",
                            i, real_filenumber);
                    } else {
                        LOGGER_DEBUG(m->log, "sending SEEK file control to friendnum: %d filenum: %d",
                            i, real_filenumber);
                    }

                    break;
                }

                // we have received a data packet, reset the stale counter
                ft->file_receiver_last_received_chunk_this_many_iterations_ago = 0;

                if (m->file_filedata != nullptr) {
                    m->file_filedata(m, i, real_filenumber, ft->transferred, file_data_raw, file_data_length_raw, userdata);
                }

                ft->transferred += file_data_length_raw_ft;

                if (ft->transferred == ft->size)
                {
                    if (!send_file_control_packet(m, i, true, filenumber, FILECONTROL_FINISHED, nullptr, 0)) {
                        // sending FILECONTROL_FINISHED failed
                        LOGGER_DEBUG(m->log, "sending FILECONTROL_FINISHED failed. friendnum: %d filenum: %d", i, real_filenumber);
                        // TODO: if sending of FILECONTROL_FINISHED failed, what happens then?
                        //       do we resend this? and also call `m->file_filedata` ?
                    } else {
                        /* Full file received. */
                        --m->friendlist[i].num_receiving_files;
                        if (m->file_filedata != nullptr) {
                            m->file_filedata(m, i, real_filenumber, ft->transferred, nullptr, 0, userdata);
                        }
                        ft->status = FILESTATUS_NONE;
                        ft->transferred = 0;
                        ft->file_type = 0;
                        ft->received_seek_control = false;
                        ft->ft_send_ackd = false;
                        ft->received_seek_control_counter = 0;
                        ft->file_receiver_last_received_chunk_this_many_iterations_ago = 0;
                        ft->file_sender_started_this_many_iterations_ago = 0;
                        memset(ft->filename, 0, MAX_FILENAME_LENGTH);
                        ft->filename_length = 0;
                    }
                }
            }
            else
            {
                /* Prevent more data than the filesize from being passed to clients. */
                if ((ft->transferred + file_data_length) > ft->size) {
                    file_data_length = ft->size - ft->transferred;
                }

                if (m->file_filedata != nullptr) {
                    m->file_filedata(m, i, real_filenumber, position, file_data, file_data_length, userdata);
                }

                ft->transferred += file_data_length;

                if (file_data_length > 0 && (ft->transferred >= ft->size || file_data_length != MAX_FILE_DATA_SIZE)) {
                    file_data_length = 0;
                    file_data = nullptr;
                    position = ft->transferred;
                    --m->friendlist[i].num_receiving_files;
                    /* Full file received. */
                    if (m->file_filedata != nullptr) {
                        m->file_filedata(m, i, real_filenumber, position, file_data, file_data_length, userdata);
                    }
                }

                /* Data is zero, filetransfer is over. */
                if (file_data_length == 0) {
                    --m->friendlist[i].num_receiving_files;
                    ft->status = FILESTATUS_NONE;
                }
            }

            break;
        }

        case PACKET_ID_MSI: {
            // allow MSI packets to be handled by custom packet handler
            handle_custom_lossless_packet(object, i, temp, len, userdata);
            break;
        }

        case PACKET_ID_INVITE_GROUPCHAT: {
#ifndef VANILLA_NACL

            // first two bytes are messenger packet type and group invite type
            if (data_length < 2 + GC_JOIN_DATA_LENGTH) {
                break;
            }

            const uint8_t invite_type = data[1];
            const uint8_t *join_data = data + 2;
            const uint32_t join_data_len = data_length - 2;

            if (m->group_invite != nullptr && data[1] == GROUP_INVITE && data_length != 2 + GC_JOIN_DATA_LENGTH) {
                if (group_not_added(m->group_handler, join_data, join_data_len)) {
                    m->group_invite(m, i, join_data, GC_JOIN_DATA_LENGTH,
                                    join_data + GC_JOIN_DATA_LENGTH, join_data_len - GC_JOIN_DATA_LENGTH, userdata);
                }
            } else if (invite_type == GROUP_INVITE_ACCEPTED) {
                handle_gc_invite_accepted_packet(m->group_handler, i, join_data, join_data_len);
            } else if (invite_type == GROUP_INVITE_CONFIRMATION) {
                handle_gc_invite_confirmed_packet(m->group_handler, i, join_data, join_data_len);
            }

#endif
            break;
        }

        default: {
            handle_custom_lossless_packet(object, i, temp, len, userdata);
            break;
        }
    }

    return 0;
}

non_null(1) nullable(2)
static void do_friends(Messenger *m, void *userdata)
{
    const uint64_t temp_time = mono_time_get(m->mono_time);

    for (uint32_t i = 0; i < m->numfriends; ++i) {
        if (m->friendlist[i].status == FRIEND_ADDED) {
            const int fr = send_friend_request_packet(m->fr_c, m->friendlist[i].friendcon_id, m->friendlist[i].friendrequest_nospam,
                                                m->friendlist[i].info,
                                                m->friendlist[i].info_size);

            if (fr >= 0) {
                set_friend_status(m, i, FRIEND_REQUESTED, userdata);
                m->friendlist[i].friendrequest_lastsent = temp_time;
            }
        }

        if (m->friendlist[i].status == FRIEND_REQUESTED
                || m->friendlist[i].status == FRIEND_CONFIRMED) { /* friend is not online. */
            if (m->friendlist[i].status == FRIEND_REQUESTED) {
                /* If we didn't connect to friend after successfully sending him a friend request the request is deemed
                 * unsuccessful so we set the status back to FRIEND_ADDED and try again.
                 */
                check_friend_request_timed_out(m, i, temp_time, userdata);
            }
        }

        if (m->friendlist[i].status == FRIEND_ONLINE) { /* friend is online. */
            if (!m->friendlist[i].name_sent) {
                if (m_sendname(m, i, m->name, m->name_length)) {
                    m->friendlist[i].name_sent = true;
                }
            }

            if (!m->friendlist[i].statusmessage_sent) {
                if (send_statusmessage(m, i, m->statusmessage, m->statusmessage_length)) {
                    m->friendlist[i].statusmessage_sent = true;
                }
            }

            if (!m->friendlist[i].userstatus_sent) {
                if (send_userstatus(m, i, m->userstatus)) {
                    m->friendlist[i].userstatus_sent = true;
                }
            }

            if (!m->friendlist[i].user_istyping_sent) {
                if (send_user_istyping(m, i, m->friendlist[i].user_istyping)) {
                    m->friendlist[i].user_istyping_sent = true;
                }
            }

            check_friend_tcp_udp(m, i, userdata);
            do_receipts(m, i, userdata);
            do_reqchunk_filecb(m, i, userdata);

            m->friendlist[i].last_seen_time = (uint64_t) time(nullptr);
        }
    }
}

non_null(1) nullable(2)
static void m_connection_status_callback(Messenger *m, void *userdata)
{
    const Onion_Connection_Status conn_status = onion_connection_status(m->onion_c, true);

    if (conn_status != m->last_connection_status) {
        if (m->core_connection_change != nullptr) {
            m->core_connection_change(m, conn_status, userdata);
        }

        m->last_connection_status = conn_status;
    }
}


#define DUMPING_CLIENTS_FRIENDS_EVERY_N_SECONDS 60UL

#define IDSTRING_LEN (CRYPTO_PUBLIC_KEY_SIZE * 2 + 1)
/** id_str should be of length at least IDSTRING_LEN */
non_null()
static char *id_to_string(const uint8_t *pk, char *id_str, size_t length)
{
    if (length < IDSTRING_LEN) {
        snprintf(id_str, length, "Bad buf length");
        return id_str;
    }

    for (uint32_t i = 0; i < CRYPTO_PUBLIC_KEY_SIZE; ++i) {
        snprintf(&id_str[i * 2], length - i * 2, "%02X", pk[i]);
    }

    id_str[CRYPTO_PUBLIC_KEY_SIZE * 2] = '\0';
    return id_str;
}

/** @brief Minimum messenger run interval in ms
 * TODO(mannol): A/V
 */
#define MIN_RUN_INTERVAL 50

/**
 * @brief Return the time in milliseconds before `do_messenger()` should be called again
 *   for optimal performance.
 *
 * @return time (in ms) before the next `do_messenger()` needs to be run on success.
 */
uint32_t messenger_run_interval(const Messenger *m)
{
    const uint32_t crypto_interval = crypto_run_interval(m->net_crypto);

    if (crypto_interval > MIN_RUN_INTERVAL) {
        return MIN_RUN_INTERVAL;
    }

    return crypto_interval;
}

/** @brief Attempts to create a DHT announcement for a group chat with our connection info. An
 * announcement can only be created if we either have a UDP or TCP connection to the network.
 *
 * @retval true if success.
 */
#ifndef VANILLA_NACL
non_null()
static bool self_announce_group(const Messenger *m, GC_Chat *chat, Onion_Friend *onion_friend)
{
    GC_Public_Announce announce = {{{{{0}}}}};

    const bool ip_port_is_set = chat->self_udp_status != SELF_UDP_STATUS_NONE;
    const int tcp_num = tcp_copy_connected_relays(chat->tcp_conn, announce.base_announce.tcp_relays,
                        GCA_MAX_ANNOUNCED_TCP_RELAYS);

    if (tcp_num == 0 && !ip_port_is_set) {
        onion_friend_set_gc_data(onion_friend, nullptr, 0);
        return false;
    }

    announce.base_announce.tcp_relays_count = (uint8_t)tcp_num;
    announce.base_announce.ip_port_is_set = (uint8_t)(ip_port_is_set ? 1 : 0);

    if (ip_port_is_set) {
        memcpy(&announce.base_announce.ip_port, &chat->self_ip_port, sizeof(IP_Port));
    }

    memcpy(announce.base_announce.peer_public_key, chat->self_public_key, ENC_PUBLIC_KEY_SIZE);
    memcpy(announce.chat_public_key, get_chat_id(chat->chat_public_key), ENC_PUBLIC_KEY_SIZE);

    uint8_t gc_data[GCA_MAX_DATA_LENGTH];
    const int length = gca_pack_public_announce(m->log, gc_data, GCA_MAX_DATA_LENGTH, &announce);

    if (length <= 0) {
        onion_friend_set_gc_data(onion_friend, nullptr, 0);
        return false;
    }

    if (gca_add_announce(m->mono_time, m->group_announce, &announce) == nullptr) {
        onion_friend_set_gc_data(onion_friend, nullptr, 0);
        return false;
    }

    onion_friend_set_gc_data(onion_friend, gc_data, (uint16_t)length);
    chat->update_self_announces = false;
    chat->last_time_self_announce = mono_time_get(chat->mono_time);

    if (tcp_num > 0) {
        pk_copy(chat->announced_tcp_relay_pk, announce.base_announce.tcp_relays[0].public_key);
    } else {
        memset(chat->announced_tcp_relay_pk, 0, sizeof(chat->announced_tcp_relay_pk));
    }

    LOGGER_DEBUG(chat->log, "Published group announce. TCP relays: %d, UDP status: %d", tcp_num,
                 chat->self_udp_status);
    return true;
}

non_null()
static void do_gc_onion_friends(const Messenger *m)
{
    const uint16_t num_friends = onion_get_friend_count(m->onion_c);

    for (uint16_t i = 0; i < num_friends; ++i) {
        Onion_Friend *onion_friend = onion_get_friend(m->onion_c, i);

        if (!onion_friend_is_groupchat(onion_friend)) {
            continue;
        }

        GC_Chat *chat = gc_get_group_by_public_key(m->group_handler, onion_friend_get_gc_public_key(onion_friend));

        if (chat == nullptr) {
            continue;
        }

        if (chat->update_self_announces) {
            self_announce_group(m, chat, onion_friend);
        }
    }
}
#endif  // VANILLA_NACL

// #define DEBUG_DO_MESSENGER 1

/** @brief The main loop that needs to be run at least 20 times per second. */
void do_messenger(Messenger *m, void *userdata)
{
#ifdef DEBUG_DO_MESSENGER
    uint64_t ttt1;
    uint64_t ttt12;
    uint64_t xttt1;
    uint64_t xttt12;
#endif

#ifdef DEBUG_DO_MESSENGER
    xttt1 = current_time_monotonic(m->mono_time);
#endif

    // Add the TCP relays, but only if this is the first time calling do_messenger
    if (!m->has_added_relays) {
        m->has_added_relays = true;

        for (uint16_t i = 0; i < m->num_loaded_relays; ++i) {
            add_tcp_relay(m->net_crypto, &m->loaded_relays[i].ip_port, m->loaded_relays[i].public_key);
        }

        m->num_loaded_relays = 0;

        if (m->tcp_server != nullptr) {
            /* Add self tcp server. */
            IP_Port local_ip_port;
            local_ip_port.port = net_htons(m->options.tcp_server_port);
            local_ip_port.ip.family = net_family_ipv4();
            local_ip_port.ip.ip.v4 = get_ip4_loopback();
            add_tcp_relay(m->net_crypto, &local_ip_port, tcp_server_public_key(m->tcp_server));
        }
    }

    if (!m->options.udp_disabled) {
        networking_poll(m->net, userdata);
        do_dht(m->dht);
    }

    if (m->tcp_server != nullptr) {
        do_TCP_server(m->tcp_server, m->mono_time);
    }

#ifdef DEBUG_DO_MESSENGER
    ttt1 = current_time_monotonic(m->mono_time);
#endif

    do_net_crypto(m->net_crypto, userdata);

#ifdef DEBUG_DO_MESSENGER
    ttt12 = current_time_monotonic(m->mono_time);
    if ((ttt12 - ttt1) > 10)
    {
        LOGGER_WARNING(m->log, "do_messenger:3:do_net_crypto:rt %d ms", (int)(ttt12 - ttt1));
    }
#endif

    if (global_onion_active) {

#ifdef DEBUG_DO_MESSENGER
        ttt1 = current_time_monotonic(m->mono_time);
#endif
        do_onion_client(m->onion_c);

#ifdef DEBUG_DO_MESSENGER
        ttt12 = current_time_monotonic(m->mono_time);
        if ((ttt12 - ttt1) > 10)
        {
            LOGGER_WARNING(m->log, "do_messenger:4:do_onion_client:rt %d ms", (int)(ttt12 - ttt1));
        }
#endif
    }
    do_friend_connections(m->fr_c, userdata);
    do_friends(m, userdata);
#ifndef VANILLA_NACL

#ifdef DEBUG_DO_MESSENGER
        ttt1 = current_time_monotonic(m->mono_time);
#endif
    do_gc(m->group_handler, userdata);
#ifdef DEBUG_DO_MESSENGER
        ttt12 = current_time_monotonic(m->mono_time);
        if ((ttt12 - ttt1) > 10)
        {
            LOGGER_WARNING(m->log, "do_messenger:5:do_gc:rt %d ms", (int)(ttt12 - ttt1));
        }
#endif

#ifdef DEBUG_DO_MESSENGER
        ttt1 = current_time_monotonic(m->mono_time);
#endif
    do_gca(m->mono_time, m->group_announce);
#ifdef DEBUG_DO_MESSENGER
        ttt12 = current_time_monotonic(m->mono_time);
        if ((ttt12 - ttt1) > 10)
        {
            LOGGER_WARNING(m->log, "do_messenger:6:do_gca:rt %d ms", (int)(ttt12 - ttt1));
        }
#endif

#ifdef DEBUG_DO_MESSENGER
        ttt1 = current_time_monotonic(m->mono_time);
#endif
    do_gc_onion_friends(m);
#ifdef DEBUG_DO_MESSENGER
        ttt12 = current_time_monotonic(m->mono_time);
        if ((ttt12 - ttt1) > 10)
        {
            LOGGER_WARNING(m->log, "do_messenger:7:do_gc_onion_friends:rt %d ms", (int)(ttt12 - ttt1));
        }
#endif

#endif
    m_connection_status_callback(m, userdata);

    if (mono_time_get(m->mono_time) > m->lastdump + DUMPING_CLIENTS_FRIENDS_EVERY_N_SECONDS) {
        m->lastdump = mono_time_get(m->mono_time);
        uint32_t last_pinged;

        for (uint32_t client = 0; client < LCLIENT_LIST; ++client) {
            const Client_data *cptr = dht_get_close_client(m->dht, client);
            const IPPTsPng *const assocs[] = { &cptr->assoc4, &cptr->assoc6, nullptr };

            for (const IPPTsPng * const *it = assocs; *it != nullptr; ++it) {
                const IPPTsPng *const assoc = *it;

                if (ip_isset(&assoc->ip_port.ip)) {
                    last_pinged = m->lastdump - assoc->last_pinged;

                    if (last_pinged > 999) {
                        last_pinged = 999;
                    }

                    Ip_Ntoa ip_str;
                    char id_str[IDSTRING_LEN];
                    LOGGER_TRACE(m->log, "C[%2u] %s:%u [%3u] %s",
                                 client, net_ip_ntoa(&assoc->ip_port.ip, &ip_str),
                                 net_ntohs(assoc->ip_port.port), last_pinged,
                                 id_to_string(cptr->public_key, id_str, sizeof(id_str)));
                }
            }
        }


        /* dht contains additional "friends" (requests) */
        const uint32_t num_dhtfriends = dht_get_num_friends(m->dht);
        VLA(int32_t, m2dht, num_dhtfriends);
        VLA(int32_t, dht2m, num_dhtfriends);

        for (uint32_t friend_idx = 0; friend_idx < num_dhtfriends; ++friend_idx) {
            m2dht[friend_idx] = -1;
            dht2m[friend_idx] = -1;

            if (friend_idx >= m->numfriends) {
                continue;
            }

            for (uint32_t dhtfriend = 0; dhtfriend < dht_get_num_friends(m->dht); ++dhtfriend) {
                if (pk_equal(m->friendlist[friend_idx].real_pk, dht_get_friend_public_key(m->dht, dhtfriend))) {
                    assert(dhtfriend < INT32_MAX);
                    m2dht[friend_idx] = (int32_t)dhtfriend;
                    break;
                }
            }
        }

        for (uint32_t friend_idx = 0; friend_idx < num_dhtfriends; ++friend_idx) {
            if (m2dht[friend_idx] >= 0) {
                assert(friend_idx < INT32_MAX);
                dht2m[m2dht[friend_idx]] = (int32_t)friend_idx;
            }
        }

        if (m->numfriends != dht_get_num_friends(m->dht)) {
            LOGGER_TRACE(m->log, "Friend num in DHT %u != friend num in msger %u", dht_get_num_friends(m->dht), m->numfriends);
        }

        for (uint32_t friend_idx = 0; friend_idx < num_dhtfriends; ++friend_idx) {
            const Friend *const msgfptr = dht2m[friend_idx] >= 0 ?  &m->friendlist[dht2m[friend_idx]] : nullptr;
            const DHT_Friend *const dhtfptr = dht_get_friend(m->dht, friend_idx);

            if (msgfptr != nullptr) {
                char id_str[IDSTRING_LEN];
                LOGGER_TRACE(m->log, "F[%2u:%2u] <%s> %s",
                             dht2m[friend_idx], friend_idx, msgfptr->name,
                             id_to_string(msgfptr->real_pk, id_str, sizeof(id_str)));
            } else {
                char id_str[IDSTRING_LEN];
                LOGGER_TRACE(m->log, "F[--:%2u] %s", friend_idx,
                             id_to_string(dht_friend_public_key(dhtfptr), id_str, sizeof(id_str)));
            }

            for (uint32_t client = 0; client < MAX_FRIEND_CLIENTS; ++client) {
                const Client_data *cptr = dht_friend_client(dhtfptr, client);
                const IPPTsPng *const assocs[] = {&cptr->assoc4, &cptr->assoc6};

                for (size_t a = 0; a < sizeof(assocs) / sizeof(assocs[0]); ++a) {
                    const IPPTsPng *const assoc = assocs[a];

                    if (ip_isset(&assoc->ip_port.ip)) {
                        last_pinged = m->lastdump - assoc->last_pinged;

                        if (last_pinged > 999) {
                            last_pinged = 999;
                        }

                        Ip_Ntoa ip_str;
                        char id_str[IDSTRING_LEN];
                        LOGGER_TRACE(m->log, "F[%2u] => C[%2u] %s:%u [%3u] %s",
                                     friend_idx, client, net_ip_ntoa(&assoc->ip_port.ip, &ip_str),
                                     net_ntohs(assoc->ip_port.port), last_pinged,
                                     id_to_string(cptr->public_key, id_str, sizeof(id_str)));
                    }
                }
            }
        }
    }

#ifdef DEBUG_DO_MESSENGER
        xttt12 = current_time_monotonic(m->mono_time);
        if ((xttt12 - xttt1) > 10)
        {
            LOGGER_WARNING(m->log, "do_messenger:999:full_time:rt %d ms", (int)(xttt12 - xttt1));
        }
#endif
}

/** new messenger format for load/save, more robust and forward compatible */

#define SAVED_FRIEND_REQUEST_SIZE 1024
#define NUM_SAVED_PATH_NODES 8

struct Saved_Friend {
    uint8_t status;
    uint8_t real_pk[CRYPTO_PUBLIC_KEY_SIZE];
    uint8_t info[SAVED_FRIEND_REQUEST_SIZE]; // the data that is sent during the friend requests we do.
    uint16_t info_size; // Length of the info.
    uint8_t name[MAX_NAME_LENGTH];
    uint16_t name_length;
    uint8_t statusmessage[MAX_STATUSMESSAGE_LENGTH];
    uint16_t statusmessage_length;
    uint8_t userstatus;
    uint32_t friendrequest_nospam;
    uint8_t last_seen_time[sizeof(uint64_t)];
};

static uint32_t friend_size(void)
{
    uint32_t data = 0;
    const struct Saved_Friend *const temp = nullptr;

#define VALUE_MEMBER(data, name) \
    do {                         \
        data += sizeof(name);    \
    } while (0)
#define ARRAY_MEMBER(data, name) \
    do {                         \
        data += sizeof(name);    \
    } while (0)

    // Exactly the same in friend_load, friend_save, and friend_size
    VALUE_MEMBER(data, temp->status);
    ARRAY_MEMBER(data, temp->real_pk);
    ARRAY_MEMBER(data, temp->info);
    ++data; // padding
    VALUE_MEMBER(data, temp->info_size);
    ARRAY_MEMBER(data, temp->name);
    VALUE_MEMBER(data, temp->name_length);
    ARRAY_MEMBER(data, temp->statusmessage);
    ++data; // padding
    VALUE_MEMBER(data, temp->statusmessage_length);
    VALUE_MEMBER(data, temp->userstatus);
    data += 3; // padding
    VALUE_MEMBER(data, temp->friendrequest_nospam);
    ARRAY_MEMBER(data, temp->last_seen_time);

#undef VALUE_MEMBER
#undef ARRAY_MEMBER

    return data;
}

non_null()
static uint8_t *friend_save(const struct Saved_Friend *temp, uint8_t *data)
{
#define VALUE_MEMBER(data, name)           \
    do {                                   \
        memcpy(data, &name, sizeof(name)); \
        data += sizeof(name);              \
    } while (0)

#define ARRAY_MEMBER(data, name)          \
    do {                                  \
        memcpy(data, name, sizeof(name)); \
        data += sizeof(name);             \
    } while (0)

    // Exactly the same in friend_load, friend_save, and friend_size
    VALUE_MEMBER(data, temp->status);
    ARRAY_MEMBER(data, temp->real_pk);
    ARRAY_MEMBER(data, temp->info);
    ++data; // padding
    VALUE_MEMBER(data, temp->info_size);
    ARRAY_MEMBER(data, temp->name);
    VALUE_MEMBER(data, temp->name_length);
    ARRAY_MEMBER(data, temp->statusmessage);
    ++data; // padding
    VALUE_MEMBER(data, temp->statusmessage_length);
    VALUE_MEMBER(data, temp->userstatus);
    data += 3; // padding
    VALUE_MEMBER(data, temp->friendrequest_nospam);
    ARRAY_MEMBER(data, temp->last_seen_time);

#undef VALUE_MEMBER
#undef ARRAY_MEMBER

    return data;
}


non_null()
static const uint8_t *friend_load(struct Saved_Friend *temp, const uint8_t *data)
{
#define VALUE_MEMBER(data, name)           \
    do {                                   \
        memcpy(&name, data, sizeof(name)); \
        data += sizeof(name);              \
    } while (0)

#define ARRAY_MEMBER(data, name)          \
    do {                                  \
        memcpy(name, data, sizeof(name)); \
        data += sizeof(name);             \
    } while (0)

    // Exactly the same in friend_load, friend_save, and friend_size
    VALUE_MEMBER(data, temp->status);
    ARRAY_MEMBER(data, temp->real_pk);
    ARRAY_MEMBER(data, temp->info);
    ++data; // padding
    VALUE_MEMBER(data, temp->info_size);
    ARRAY_MEMBER(data, temp->name);
    VALUE_MEMBER(data, temp->name_length);
    ARRAY_MEMBER(data, temp->statusmessage);
    ++data; // padding
    VALUE_MEMBER(data, temp->statusmessage_length);
    VALUE_MEMBER(data, temp->userstatus);
    data += 3; // padding
    VALUE_MEMBER(data, temp->friendrequest_nospam);
    ARRAY_MEMBER(data, temp->last_seen_time);

#undef VALUE_MEMBER
#undef ARRAY_MEMBER

    return data;
}


non_null()
static uint32_t m_state_plugins_size(const Messenger *m)
{
    const uint32_t size32 = sizeof(uint32_t);
    const uint32_t sizesubhead = size32 * 2;

    uint32_t size = 0;

    for (const Messenger_State_Plugin *plugin = m->options.state_plugins;
            plugin != m->options.state_plugins + m->options.state_plugins_length;
            ++plugin) {
        size += sizesubhead + plugin->size(m);
    }

    return size;
}

/** @brief Registers a state plugin for saving, loading, and getting the size of a section of the save.
 *
 * @retval true on success
 * @retval false on error
 */
bool m_register_state_plugin(Messenger *m, State_Type type, m_state_size_cb *size_callback,
                             m_state_load_cb *load_callback,
                             m_state_save_cb *save_callback)
{
    Messenger_State_Plugin *temp = (Messenger_State_Plugin *)realloc(m->options.state_plugins,
                                   sizeof(Messenger_State_Plugin) * (m->options.state_plugins_length + 1));

    if (temp == nullptr) {
        return false;
    }

    m->options.state_plugins = temp;
    ++m->options.state_plugins_length;

    const uint8_t index = m->options.state_plugins_length - 1;
    m->options.state_plugins[index].type = type;
    m->options.state_plugins[index].size = size_callback;
    m->options.state_plugins[index].load = load_callback;
    m->options.state_plugins[index].save = save_callback;

    return true;
}

non_null()
static uint32_t m_plugin_size(const Messenger *m, State_Type type)
{
    for (uint8_t i = 0; i < m->options.state_plugins_length; ++i) {
        const Messenger_State_Plugin plugin = m->options.state_plugins[i];

        if (plugin.type == type) {
            return plugin.size(m);
        }
    }

    LOGGER_ERROR(m->log, "Unknown type encountered: %u", type);

    return UINT32_MAX;
}

/** return size of the messenger data (for saving). */
uint32_t messenger_size(const Messenger *m)
{
    return m_state_plugins_size(m);
}

/** Save the messenger in data (must be allocated memory of size at least `Messenger_size()`) */
uint8_t *messenger_save(const Messenger *m, uint8_t *data)
{
    for (uint8_t i = 0; i < m->options.state_plugins_length; ++i) {
        const Messenger_State_Plugin plugin = m->options.state_plugins[i];
        data = plugin.save(m, data);
    }

    return data;
}

// nospam state plugin
non_null()
static uint32_t nospam_keys_size(const Messenger *m)
{
    return sizeof(uint32_t) + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_SECRET_KEY_SIZE;
}

non_null()
static State_Load_Status load_nospam_keys(Messenger *m, const uint8_t *data, uint32_t length)
{
    if (length != m_plugin_size(m, STATE_TYPE_NOSPAMKEYS)) {
        return STATE_LOAD_STATUS_ERROR;
    }

    uint32_t nospam;
    lendian_bytes_to_host32(&nospam, data);
    set_nospam(m->fr, nospam);
    load_secret_key(m->net_crypto, data + sizeof(uint32_t) + CRYPTO_PUBLIC_KEY_SIZE);

    if (!pk_equal(data + sizeof(uint32_t), nc_get_self_public_key(m->net_crypto))) {
        LOGGER_ERROR(m->log, "public key stored in savedata does not match its secret key");
        return STATE_LOAD_STATUS_ERROR;
    }

    return STATE_LOAD_STATUS_CONTINUE;
}

non_null()
static uint8_t *save_nospam_keys(const Messenger *m, uint8_t *data)
{
    const uint32_t len = m_plugin_size(m, STATE_TYPE_NOSPAMKEYS);
    static_assert(sizeof(get_nospam(m->fr)) == sizeof(uint32_t), "nospam doesn't fit in a 32 bit int");
    data = state_write_section_header(data, STATE_COOKIE_TYPE, len, STATE_TYPE_NOSPAMKEYS);
    const uint32_t nospam = get_nospam(m->fr);
    host_to_lendian_bytes32(data, nospam);
    save_keys(m->net_crypto, data + sizeof(uint32_t));
    data += len;
    return data;
}

// DHT state plugin
non_null()
static uint32_t m_dht_size(const Messenger *m)
{
    return dht_size(m->dht);
}

non_null()
static uint8_t *save_dht(const Messenger *m, uint8_t *data)
{
    const uint32_t len = m_plugin_size(m, STATE_TYPE_DHT);
    data = state_write_section_header(data, STATE_COOKIE_TYPE, len, STATE_TYPE_DHT);
    dht_save(m->dht, data);
    data += len;
    return data;
}

non_null()
static State_Load_Status m_dht_load(Messenger *m, const uint8_t *data, uint32_t length)
{
    dht_load(m->dht, data, length); // TODO(endoffile78): Should we throw an error if dht_load fails?
    return STATE_LOAD_STATUS_CONTINUE;
}

// friendlist state plugin
non_null()
static uint32_t saved_friendslist_size(const Messenger *m)
{
    return count_friendlist(m) * friend_size();
}

non_null()
static uint8_t *friends_list_save(const Messenger *m, uint8_t *data)
{
    const uint32_t len = m_plugin_size(m, STATE_TYPE_FRIENDS);
    data = state_write_section_header(data, STATE_COOKIE_TYPE, len, STATE_TYPE_FRIENDS);

    uint32_t num = 0;
    uint8_t *cur_data = data;

    for (uint32_t i = 0; i < m->numfriends; ++i) {
        if (m->friendlist[i].status > 0) {
            struct Saved_Friend temp = { 0 };
            temp.status = m->friendlist[i].status;
            memcpy(temp.real_pk, m->friendlist[i].real_pk, CRYPTO_PUBLIC_KEY_SIZE);

            if (temp.status < 3) {
                // TODO(iphydf): Use uint16_t and min_u16 here.
                const size_t friendrequest_length =
                    min_u32(m->friendlist[i].info_size,
                            min_u32(SAVED_FRIEND_REQUEST_SIZE, MAX_FRIEND_REQUEST_DATA_SIZE));
                memcpy(temp.info, m->friendlist[i].info, friendrequest_length);

                temp.info_size = net_htons(m->friendlist[i].info_size);
                temp.friendrequest_nospam = m->friendlist[i].friendrequest_nospam;
            } else {
                temp.status = 3;
                memcpy(temp.name, m->friendlist[i].name, m->friendlist[i].name_length);
                temp.name_length = net_htons(m->friendlist[i].name_length);
                memcpy(temp.statusmessage, m->friendlist[i].statusmessage, m->friendlist[i].statusmessage_length);
                temp.statusmessage_length = net_htons(m->friendlist[i].statusmessage_length);
                temp.userstatus = m->friendlist[i].userstatus;

                net_pack_u64(temp.last_seen_time, m->friendlist[i].last_seen_time);
            }

            uint8_t *next_data = friend_save(&temp, cur_data);
            assert(next_data - cur_data == friend_size());
#ifdef __LP64__
            assert(memcmp(cur_data, &temp, friend_size()) == 0);
#endif
            cur_data = next_data;
            ++num;
        }
    }

    assert(cur_data - data == num * friend_size());
    data += len;

    return data;
}

non_null()
static State_Load_Status friends_list_load(Messenger *m, const uint8_t *data, uint32_t length)
{
    const uint32_t l_friend_size = friend_size();

    if (length % l_friend_size != 0) {
        return STATE_LOAD_STATUS_ERROR; // TODO(endoffile78): error or continue?
    }

    const uint32_t num = length / l_friend_size;
    const uint8_t *cur_data = data;

    for (uint32_t i = 0; i < num; ++i) {
        struct Saved_Friend temp = { 0 };
        const uint8_t *next_data = friend_load(&temp, cur_data);
        assert(next_data - cur_data == l_friend_size);

        cur_data = next_data;

        if (temp.status >= 3) {
            const int fnum = m_addfriend_norequest(m, temp.real_pk);

            if (fnum < 0) {
                continue;
            }

            setfriendname(m, fnum, temp.name, net_ntohs(temp.name_length));
            set_friend_statusmessage(m, fnum, temp.statusmessage, net_ntohs(temp.statusmessage_length));
            set_friend_userstatus(m, fnum, temp.userstatus);
            net_unpack_u64(temp.last_seen_time, &m->friendlist[fnum].last_seen_time);
        } else if (temp.status != 0) {
            /* TODO(irungentoo): This is not a good way to do this. */
            uint8_t address[FRIEND_ADDRESS_SIZE];
            pk_copy(address, temp.real_pk);
            memcpy(address + CRYPTO_PUBLIC_KEY_SIZE, &temp.friendrequest_nospam, sizeof(uint32_t));
            uint16_t checksum = data_checksum(address, FRIEND_ADDRESS_SIZE - sizeof(checksum));
            memcpy(address + CRYPTO_PUBLIC_KEY_SIZE + sizeof(uint32_t), &checksum, sizeof(checksum));
            m_addfriend(m, address, temp.info, net_ntohs(temp.info_size));
        }
    }

    return STATE_LOAD_STATUS_CONTINUE;
}

#ifndef VANILLA_NACL
non_null()
static void pack_groupchats(const GC_Session *c, Bin_Pack *bp)
{
    assert(bp != nullptr && c != nullptr);
    bin_pack_array(bp, gc_count_groups(c));

    for (uint32_t i = 0; i < c->chats_index; ++i) { // this loop must match the one in gc_count_groups()
        const GC_Chat *chat = &c->chats[i];

        if (!gc_group_is_valid(chat)) {
            continue;
        }

        gc_group_save(chat, bp);
    }
}

non_null()
static bool pack_groupchats_handler(Bin_Pack *bp, const void *obj)
{
    pack_groupchats((const GC_Session *)obj, bp);
    return true;  // TODO(iphydf): Return bool from pack functions.
}

non_null()
static uint32_t saved_groups_size(const Messenger *m)
{
    GC_Session *c = m->group_handler;
    return bin_pack_obj_size(pack_groupchats_handler, c);
}

non_null()
static uint8_t *groups_save(const Messenger *m, uint8_t *data)
{
    const GC_Session *c = m->group_handler;

    const uint32_t num_groups = gc_count_groups(c);

    if (num_groups == 0) {
        return data;
    }

    const uint32_t len = m_plugin_size(m, STATE_TYPE_GROUPS);

    if (len == 0) {
        return data;
    }

    data = state_write_section_header(data, STATE_COOKIE_TYPE, len, STATE_TYPE_GROUPS);

    if (!bin_pack_obj(pack_groupchats_handler, c, data, len)) {
        LOGGER_FATAL(m->log, "failed to pack group chats into buffer of length %u", len);
        return data;
    }

    data += len;

    LOGGER_DEBUG(m->log, "Saved %u groups (length %u)", num_groups, len);

    return data;
}

non_null()
static State_Load_Status groups_load(Messenger *m, const uint8_t *data, uint32_t length)
{
    Bin_Unpack *bu = bin_unpack_new(data, length);
    if (bu == nullptr) {
        LOGGER_ERROR(m->log, "failed to allocate binary unpacker");
        return STATE_LOAD_STATUS_ERROR;
    }

    uint32_t num_groups;
    if (!bin_unpack_array(bu, &num_groups)) {
        LOGGER_ERROR(m->log, "msgpack failed to unpack groupchats array: expected array");
        bin_unpack_free(bu);
        return STATE_LOAD_STATUS_ERROR;
    }

    LOGGER_DEBUG(m->log, "Loading %u groups (length %u)", num_groups, length);

    for (uint32_t i = 0; i < num_groups; ++i) {
        const int group_number = gc_group_load(m->group_handler, bu);

        if (group_number < 0) {
            LOGGER_WARNING(m->log, "Failed to load group %u", i);
            // Can't recover trivially. We may need to skip over some data here.
        }
    }

    LOGGER_DEBUG(m->log, "Successfully loaded %u groups", gc_count_groups(m->group_handler));

    bin_unpack_free(bu);

    return STATE_LOAD_STATUS_CONTINUE;
}
#endif /* VANILLA_NACL */

// name state plugin
non_null()
static uint32_t name_size(const Messenger *m)
{
    return m->name_length;
}

non_null()
static uint8_t *save_name(const Messenger *m, uint8_t *data)
{
    const uint32_t len = m_plugin_size(m, STATE_TYPE_NAME);
    data = state_write_section_header(data, STATE_COOKIE_TYPE, len, STATE_TYPE_NAME);
    memcpy(data, m->name, len);
    data += len;
    return data;
}

non_null()
static State_Load_Status load_name(Messenger *m, const uint8_t *data, uint32_t length)
{
    if (length > 0 && length <= MAX_NAME_LENGTH) {
        setname(m, data, length);
    }

    return STATE_LOAD_STATUS_CONTINUE;
}

// status message state plugin
non_null()
static uint32_t status_message_size(const Messenger *m)
{
    return m->statusmessage_length;
}

non_null()
static uint8_t *save_status_message(const Messenger *m, uint8_t *data)
{
    const uint32_t len = m_plugin_size(m, STATE_TYPE_STATUSMESSAGE);
    data = state_write_section_header(data, STATE_COOKIE_TYPE, len, STATE_TYPE_STATUSMESSAGE);
    memcpy(data, m->statusmessage, len);
    data += len;
    return data;
}

non_null()
static State_Load_Status load_status_message(Messenger *m, const uint8_t *data, uint32_t length)
{
    if (length > 0 && length <= MAX_STATUSMESSAGE_LENGTH) {
        m_set_statusmessage(m, data, length);
    }

    return STATE_LOAD_STATUS_CONTINUE;
}

// status state plugin
non_null()
static uint32_t status_size(const Messenger *m)
{
    return 1;
}

non_null()
static uint8_t *save_status(const Messenger *m, uint8_t *data)
{
    const uint32_t len = m_plugin_size(m, STATE_TYPE_STATUS);
    data = state_write_section_header(data, STATE_COOKIE_TYPE, len, STATE_TYPE_STATUS);
    *data = m->userstatus;
    data += len;
    return data;
}

non_null()
static State_Load_Status load_status(Messenger *m, const uint8_t *data, uint32_t length)
{
    if (length == 1) {
        m_set_userstatus(m, *data);
    }

    return STATE_LOAD_STATUS_CONTINUE;
}

// TCP Relay state plugin
non_null()
static uint32_t tcp_relay_size(const Messenger *m)
{
    return NUM_SAVED_TCP_RELAYS * packed_node_size(net_family_tcp_ipv6());
}

non_null()
void print_all_udp_connections(const Messenger *m, char *connections_report_string)
{
    char *p = connections_report_string;
    const int max_conn_to_print = 1000;
    uint32_t num1 = 0;
    p += snprintf(p, 60, "UDP:FRS:=================\n");
    p = copy_all_udp_connections(m->net_crypto, p, max_conn_to_print, &num1);

    Self_UDP_Status self_udp_status;
    IP_Port         self_ip_port;

    p += snprintf(p, 60, "UDP:FRS:NUM:%d\n", num1);

    p += snprintf(p, 60, "UDP:GRP:=================\n");
    const GC_Session *c = m->group_handler;
    uint32_t num2 = 0;
    for (uint32_t i = 0; i < c->chats_index; ++i) {
        const GC_Chat *chat = &c->chats[i];
        if (!gc_group_is_valid(chat)) {
            continue;
        }

        if (chat->self_udp_status != SELF_UDP_STATUS_NONE) {
            p = udp_copy_all_connected(chat->self_ip_port, p, (max_conn_to_print - num1), &num2);
        }
    }
    p += snprintf(p, 60, "UDP:GRP:NUM:%d\n", num2);

    p += snprintf(p, 60, "UDP:END:=================\n");
}

non_null()
void print_all_tcp_relays(const Messenger *m, char *relays_report_string)
{
    char *p = relays_report_string;
    const int max_relay_to_print = 1000;
    uint32_t num1 = 0;
    p += snprintf(p, 60, "FRS:=================\n");
    p = copy_all_connected_relays(m->net_crypto, p, max_relay_to_print, &num1);
    p += snprintf(p, 60, "FRS:NUM:%d\n", num1);

    p += snprintf(p, 60, "GRP:=================\n");
    const GC_Session *c = m->group_handler;
    uint32_t num2 = 0;
    for (uint32_t i = 0; i < c->chats_index; ++i) {
        const GC_Chat *chat = &c->chats[i];
        if (!gc_group_is_valid(chat)) {
            continue;
        }
        p = tcp_copy_all_connected_relays(chat->tcp_conn, p, (max_relay_to_print - num1), &num2);
    }
    p += snprintf(p, 60, "GRP:NUM:%d\n", num2);
    p += snprintf(p, 60, "END:=================\n");
}

non_null()
static uint8_t *save_tcp_relays(const Messenger *m, uint8_t *data)
{
    Node_format relays[NUM_SAVED_TCP_RELAYS] = {{{0}}};
    uint8_t *temp_data = data;
    data = state_write_section_header(temp_data, STATE_COOKIE_TYPE, 0, STATE_TYPE_TCP_RELAY);

    if (m->num_loaded_relays > 0) {
        memcpy(relays, m->loaded_relays, sizeof(Node_format) * m->num_loaded_relays);
    }

    uint32_t num = m->num_loaded_relays;
    num += copy_connected_tcp_relays(m->net_crypto, relays + num, NUM_SAVED_TCP_RELAYS - num);

    const int l = pack_nodes(m->log, data, NUM_SAVED_TCP_RELAYS * packed_node_size(net_family_tcp_ipv6()), relays, num);

    if (l > 0) {
        const uint32_t len = l;
        data = state_write_section_header(temp_data, STATE_COOKIE_TYPE, len, STATE_TYPE_TCP_RELAY);
        data += len;
    }

    return data;
}

non_null()
static State_Load_Status load_tcp_relays(Messenger *m, const uint8_t *data, uint32_t length)
{
    if (!global_force_udp_only_mode) {
        if (length > 0) {
            const int num = unpack_nodes(m->loaded_relays, NUM_SAVED_TCP_RELAYS, nullptr, data, length, true);

            if (num == -1) {
                m->num_loaded_relays = 0;
                return STATE_LOAD_STATUS_CONTINUE;
            }

            m->num_loaded_relays = num;
            m->has_added_relays = false;
        }
    }
    return STATE_LOAD_STATUS_CONTINUE;
}

// path node state plugin
non_null()
static uint32_t path_node_size(const Messenger *m)
{
    return NUM_SAVED_PATH_NODES * packed_node_size(net_family_tcp_ipv6());
}

non_null()
static uint8_t *save_path_nodes(const Messenger *m, uint8_t *data)
{
    Node_format nodes[NUM_SAVED_PATH_NODES];
    uint8_t *temp_data = data;
    data = state_write_section_header(data, STATE_COOKIE_TYPE, 0, STATE_TYPE_PATH_NODE);
    memset(nodes, 0, sizeof(nodes));
    const unsigned int num = onion_backup_nodes(m->onion_c, nodes, NUM_SAVED_PATH_NODES);
    const int l = pack_nodes(m->log, data, NUM_SAVED_PATH_NODES * packed_node_size(net_family_tcp_ipv6()), nodes, num);

    if (l > 0) {
        const uint32_t len = l;
        data = state_write_section_header(temp_data, STATE_COOKIE_TYPE, len, STATE_TYPE_PATH_NODE);
        data += len;
    }

    return data;
}

non_null()
static State_Load_Status load_path_nodes(Messenger *m, const uint8_t *data, uint32_t length)
{
    if (length > 0) {
        Node_format nodes[NUM_SAVED_PATH_NODES];
        const int num = unpack_nodes(nodes, NUM_SAVED_PATH_NODES, nullptr, data, length, false);

        if (num == -1) {
            return STATE_LOAD_STATUS_CONTINUE;
        }

        for (int i = 0; i < num; ++i) {
            onion_add_bs_path_node(m->onion_c, &nodes[i].ip_port, nodes[i].public_key);
        }
    }

    return STATE_LOAD_STATUS_CONTINUE;
}

non_null()
static void m_register_default_plugins(Messenger *m)
{
    m_register_state_plugin(m, STATE_TYPE_NOSPAMKEYS, nospam_keys_size, load_nospam_keys, save_nospam_keys);
    m_register_state_plugin(m, STATE_TYPE_DHT, m_dht_size, m_dht_load, save_dht);
    m_register_state_plugin(m, STATE_TYPE_FRIENDS, saved_friendslist_size, friends_list_load, friends_list_save);
    m_register_state_plugin(m, STATE_TYPE_NAME, name_size, load_name, save_name);
    m_register_state_plugin(m, STATE_TYPE_STATUSMESSAGE, status_message_size, load_status_message,
                            save_status_message);
    m_register_state_plugin(m, STATE_TYPE_STATUS, status_size, load_status, save_status);
#ifndef VANILLA_NACL
    m_register_state_plugin(m, STATE_TYPE_GROUPS, saved_groups_size, groups_load, groups_save);
#endif
    m_register_state_plugin(m, STATE_TYPE_TCP_RELAY, tcp_relay_size, load_tcp_relays, save_tcp_relays);
    m_register_state_plugin(m, STATE_TYPE_PATH_NODE, path_node_size, load_path_nodes, save_path_nodes);
}

bool messenger_load_state_section(Messenger *m, const uint8_t *data, uint32_t length, uint16_t type,
                                  State_Load_Status *status)
{
    for (uint8_t i = 0; i < m->options.state_plugins_length; ++i) {
        const Messenger_State_Plugin *const plugin = &m->options.state_plugins[i];

        if (plugin->type == type) {
            *status = plugin->load(m, data, length);
            return true;
        }
    }

    return false;
}

/** @brief Return the number of friends in the instance m.
 *
 * You should use this to determine how much memory to allocate
 * for copy_friendlist.
 */
uint32_t count_friendlist(const Messenger *m)
{
    uint32_t ret = 0;

    for (uint32_t i = 0; i < m->numfriends; ++i) {
        if (m->friendlist[i].status > 0) {
            ++ret;
        }
    }

    return ret;
}

/** @brief Copy a list of valid friend IDs into the array out_list.
 * If out_list is NULL, returns 0.
 * Otherwise, returns the number of elements copied.
 * If the array was too small, the contents
 * of out_list will be truncated to list_size.
 */
uint32_t copy_friendlist(Messenger const *m, uint32_t *out_list, uint32_t list_size)
{
    if (out_list == nullptr) {
        return 0;
    }

    if (m->numfriends == 0) {
        return 0;
    }

    uint32_t ret = 0;

    for (uint32_t i = 0; i < m->numfriends; ++i) {
        if (ret >= list_size) {
            break; /* Abandon ship */
        }

        if (m->friendlist[i].status > 0) {
            out_list[ret] = i;
            ++ret;
        }
    }

    return ret;
}

static fr_friend_request_cb m_handle_friend_request;
non_null(1, 2, 3) nullable(5)
static void m_handle_friend_request(
    void *object, const uint8_t *public_key, const uint8_t *message, size_t length, void *user_data)
{
    Messenger *m = (Messenger *)object;
    assert(m != nullptr);
    m->friend_request(m, public_key, message, length, user_data);
}

/** @brief Run this at startup.
 *
 * @return allocated instance of Messenger on success.
 * @retval 0 if there are problems.
 *
 * if error is not NULL it will be set to one of the values in the enum above.
 */
Messenger *new_messenger(Mono_Time *mono_time, const Random *rng, const Network *ns, Messenger_Options *options, Messenger_Error *error)
{
    if (options == nullptr) {
        return nullptr;
    }

    if (error != nullptr) {
        *error = MESSENGER_ERROR_OTHER;
    }

    Messenger *m = (Messenger *)calloc(1, sizeof(Messenger));

    if (m == nullptr) {
        return nullptr;
    }

    m->mono_time = mono_time;
    m->rng = rng;
    m->ns = ns;

    m->fr = friendreq_new();

    if (m->fr == nullptr) {
        free(m);
        return nullptr;
    }

    m->log = logger_new();

    if (m->log == nullptr) {
        friendreq_kill(m->fr);
        free(m);
        return nullptr;
    }

    logger_callback_log(m->log, options->log_callback, options->log_context, options->log_user_data);

    unsigned int net_err = 0;

    if (!options->udp_disabled && options->proxy_info.proxy_type != TCP_PROXY_NONE) {
        // We don't currently support UDP over proxy.
        LOGGER_INFO(m->log, "UDP enabled and proxy set: disabling UDP");
        options->udp_disabled = true;
    }

    if (options->udp_disabled) {
        m->net = new_networking_no_udp(m->log, m->ns);
    } else {
        IP ip;
        ip_init(&ip, options->ipv6enabled);
        m->net = new_networking_ex(m->log, m->ns, &ip, options->port_range[0], options->port_range[1], &net_err);
    }

    if (m->net == nullptr) {
        friendreq_kill(m->fr);
        logger_kill(m->log);
        free(m);

        if (error != nullptr && net_err == 1) {
            *error = MESSENGER_ERROR_PORT;
        }

        return nullptr;
    }

    m->dht = new_dht(m->log, m->rng, m->ns, m->mono_time, m->net, options->hole_punching_enabled, options->local_discovery_enabled);

    if (m->dht == nullptr) {
        kill_networking(m->net);
        friendreq_kill(m->fr);
        logger_kill(m->log);
        free(m);
        return nullptr;
    }

    m->net_crypto = new_net_crypto(m->log, m->rng, m->ns, m->mono_time, m->dht, &options->proxy_info);

    if (m->net_crypto == nullptr) {
        kill_dht(m->dht);
        kill_networking(m->net);
        friendreq_kill(m->fr);
        logger_kill(m->log);
        free(m);
        return nullptr;
    }

#ifndef VANILLA_NACL
    m->group_announce = new_gca_list();

    if (m->group_announce == nullptr) {
        kill_net_crypto(m->net_crypto);
        kill_dht(m->dht);
        kill_networking(m->net);
        friendreq_kill(m->fr);
        logger_kill(m->log);
        free(m);
        return nullptr;
    }

#endif /* VANILLA_NACL */

    if (options->dht_announcements_enabled) {
        m->forwarding = new_forwarding(m->log, m->rng, m->mono_time, m->dht);
        m->announce = new_announcements(m->log, m->rng, m->mono_time, m->forwarding);
    } else {
        m->forwarding = nullptr;
        m->announce = nullptr;
    }

    m->onion = new_onion(m->log, m->mono_time, m->rng, m->dht);
    m->onion_a = new_onion_announce(m->log, m->rng, m->mono_time, m->dht);
    m->onion_c = new_onion_client(m->log, m->rng, m->mono_time, m->net_crypto);
    m->fr_c = new_friend_connections(m->log, m->mono_time, m->ns, m->onion_c, options->local_discovery_enabled);

    if ((options->dht_announcements_enabled && (m->forwarding == nullptr || m->announce == nullptr)) ||
            m->onion == nullptr || m->onion_a == nullptr || m->onion_c == nullptr || m->fr_c == nullptr) {
        kill_onion(m->onion);
        kill_onion_announce(m->onion_a);
        kill_onion_client(m->onion_c);
#ifndef VANILLA_NACL
        kill_gca(m->group_announce);
#endif /* VANILLA_NACL */
        kill_friend_connections(m->fr_c);
        kill_announcements(m->announce);
        kill_forwarding(m->forwarding);
        kill_net_crypto(m->net_crypto);
        kill_dht(m->dht);
        kill_networking(m->net);
        friendreq_kill(m->fr);
        logger_kill(m->log);
        free(m);
        return nullptr;
    }

#ifndef VANILLA_NACL
    gca_onion_init(m->group_announce, m->onion_a);

    m->group_handler = new_dht_groupchats(m);

    if (m->group_handler == nullptr) {
        kill_onion(m->onion);
        kill_onion_announce(m->onion_a);
        kill_onion_client(m->onion_c);
        kill_gca(m->group_announce);
        kill_friend_connections(m->fr_c);
        kill_announcements(m->announce);
        kill_forwarding(m->forwarding);
        kill_net_crypto(m->net_crypto);
        kill_dht(m->dht);
        kill_networking(m->net);
        friendreq_kill(m->fr);
        logger_kill(m->log);
        free(m);
        return nullptr;
    }

#endif /* VANILLA_NACL */

    if (options->tcp_server_port != 0) {
        m->tcp_server = new_TCP_server(m->log, m->rng, m->ns, options->ipv6enabled, 1, &options->tcp_server_port,
                                       dht_get_self_secret_key(m->dht), m->onion, m->forwarding);

        if (m->tcp_server == nullptr) {
            kill_onion(m->onion);
            kill_onion_announce(m->onion_a);
#ifndef VANILLA_NACL
            kill_dht_groupchats(m->group_handler);
#endif
            kill_friend_connections(m->fr_c);
            kill_onion_client(m->onion_c);
#ifndef VANILLA_NACL
            kill_gca(m->group_announce);
#endif
            kill_announcements(m->announce);
            kill_forwarding(m->forwarding);
            kill_net_crypto(m->net_crypto);
            kill_dht(m->dht);
            kill_networking(m->net);
            friendreq_kill(m->fr);
            logger_kill(m->log);
            free(m);

            if (error != nullptr) {
                *error = MESSENGER_ERROR_TCP_SERVER;
            }

            return nullptr;
        }
    }

    m->options = *options;
    friendreq_init(m->fr, m->fr_c);
    set_nospam(m->fr, random_u32(m->rng));
    set_filter_function(m->fr, &friend_already_added, m);

    m->lastdump = 0;

    m_register_default_plugins(m);
    callback_friendrequest(m->fr, m_handle_friend_request, m);

    if (error != nullptr) {
        *error = MESSENGER_ERROR_NONE;
    }

    return m;
}

/** @brief Run this before closing shop.
 *
 * Free all datastructures.
 */
void kill_messenger(Messenger *m)
{
    if (m == nullptr) {
        return;
    }

    if (m->tcp_server != nullptr) {
        kill_TCP_server(m->tcp_server);
    }

    kill_onion(m->onion);
    kill_onion_announce(m->onion_a);
#ifndef VANILLA_NACL
    kill_dht_groupchats(m->group_handler);
#endif
    kill_friend_connections(m->fr_c);
    kill_onion_client(m->onion_c);
#ifndef VANILLA_NACL
    kill_gca(m->group_announce);
#endif
    kill_announcements(m->announce);
    kill_forwarding(m->forwarding);
    kill_net_crypto(m->net_crypto);
    kill_dht(m->dht);
    kill_networking(m->net);

    for (uint32_t i = 0; i < m->numfriends; ++i) {
        clear_receipts(m, i);
    }

    logger_kill(m->log);
    free(m->friendlist);
    friendreq_kill(m->fr);

    free(m->options.state_plugins);
    free(m);
}
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2020 The TokTok team.
 * Copyright © 2014 Tox project.
 */
#ifndef _XOPEN_SOURCE
#define _XOPEN_SOURCE 600
#endif

#if !defined(OS_WIN32) && (defined(_WIN32) || defined(__WIN32__) || defined(WIN32))
#define OS_WIN32
#endif


#ifdef OS_WIN32
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#endif

#ifdef __APPLE__
#include <mach/clock.h>
#include <mach/mach.h>
#endif

#ifndef OS_WIN32
#include <sys/time.h>
#endif

#include <assert.h>
#include <pthread.h>
#include <stdlib.h>
#include <time.h>


/** don't call into system billions of times for no reason */
struct Mono_Time {
    uint64_t cur_time;
    uint64_t base_time;
#ifdef OS_WIN32
    /* protect `last_clock_update` and `last_clock_mono` from concurrent access */
    pthread_mutex_t last_clock_lock;
    uint32_t last_clock_mono;
    bool last_clock_update;
#endif

#ifndef ESP_PLATFORM
    /* protect `time` from concurrent access */
    pthread_rwlock_t *time_update_lock;
#endif

    mono_time_current_time_cb *current_time_callback;
    void *user_data;
};

#ifdef OS_WIN32
non_null()
static uint64_t current_time_monotonic_default(void *user_data)
{
    Mono_Time *const mono_time = (Mono_Time *)user_data;

    /* Must hold mono_time->last_clock_lock here */

    /* GetTickCount provides only a 32 bit counter, but we can't use
     * GetTickCount64 for backwards compatibility, so we handle wraparound
     * ourselves.
     */
    const uint32_t ticks = GetTickCount();

    /* the higher 32 bits count the number of wrap arounds */
    uint64_t old_ovf = mono_time->cur_time & ~((uint64_t)UINT32_MAX);

    /* Check if time has decreased because of 32 bit wrap from GetTickCount() */
    if (ticks < mono_time->last_clock_mono) {
        /* account for overflow */
        old_ovf += UINT32_MAX + UINT64_C(1);
    }

    if (mono_time->last_clock_update) {
        mono_time->last_clock_mono = ticks;
        mono_time->last_clock_update = false;
    }

    /* splice the low and high bits back together */
    return old_ovf + ticks;
}
#else // !OS_WIN32
static uint64_t timespec_to_u64(struct timespec clock_mono)
{
    return 1000ULL * clock_mono.tv_sec + (clock_mono.tv_nsec / 1000000ULL);
}
#ifdef __APPLE__
non_null()
static uint64_t current_time_monotonic_default(void *user_data)
{
    struct timespec clock_mono;
    clock_serv_t muhclock;
    mach_timespec_t machtime;

    host_get_clock_service(mach_host_self(), SYSTEM_CLOCK, &muhclock);
    clock_get_time(muhclock, &machtime);
    mach_port_deallocate(mach_task_self(), muhclock);

    clock_mono.tv_sec = machtime.tv_sec;
    clock_mono.tv_nsec = machtime.tv_nsec;
    return timespec_to_u64(clock_mono);
}
#else // !__APPLE__
non_null()
static uint64_t current_time_monotonic_default(void *user_data)
{
#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
    // This assert should always fail. If it does, the fuzzing harness didn't
    // override the mono time callback.
    assert(user_data == nullptr);
#endif
    struct timespec clock_mono;
    clock_gettime(CLOCK_MONOTONIC, &clock_mono);
    return timespec_to_u64(clock_mono);
}
#endif // !__APPLE__
#endif // !OS_WIN32


Mono_Time *mono_time_new(mono_time_current_time_cb *current_time_callback, void *user_data)
{
    Mono_Time *mono_time = (Mono_Time *)calloc(1, sizeof(Mono_Time));

    if (mono_time == nullptr) {
        return nullptr;
    }

#ifndef ESP_PLATFORM
    mono_time->time_update_lock = (pthread_rwlock_t *)calloc(1, sizeof(pthread_rwlock_t));

    if (mono_time->time_update_lock == nullptr) {
        free(mono_time);
        return nullptr;
    }

    if (pthread_rwlock_init(mono_time->time_update_lock, nullptr) < 0) {
        free(mono_time->time_update_lock);
        free(mono_time);
        return nullptr;
    }
#endif

    mono_time_set_current_time_callback(mono_time, current_time_callback, user_data);

#ifdef OS_WIN32

    mono_time->last_clock_mono = 0;
    mono_time->last_clock_update = false;

    if (pthread_mutex_init(&mono_time->last_clock_lock, nullptr) < 0) {
        free(mono_time->time_update_lock);
        free(mono_time);
        return nullptr;
    }

#endif

    mono_time->cur_time = 0;
#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
    // Maximum reproducibility. Never return time = 0.
    mono_time->base_time = 1;
#else
    mono_time->base_time = (uint64_t)time(nullptr) - (current_time_monotonic(mono_time) / 1000ULL);
#endif

    mono_time_update(mono_time);

    return mono_time;
}

void mono_time_free(Mono_Time *mono_time)
{
    if (mono_time == nullptr) {
        return;
    }
#ifdef OS_WIN32
    pthread_mutex_destroy(&mono_time->last_clock_lock);
#endif
#ifndef ESP_PLATFORM
    pthread_rwlock_destroy(mono_time->time_update_lock);
    free(mono_time->time_update_lock);
#endif
    free(mono_time);
}

void mono_time_update(Mono_Time *mono_time)
{
    uint64_t cur_time = 0;
#ifdef OS_WIN32
    /* we actually want to update the overflow state of mono_time here */
    pthread_mutex_lock(&mono_time->last_clock_lock);
    mono_time->last_clock_update = true;
#endif
    cur_time = mono_time->current_time_callback(mono_time->user_data) / 1000ULL;
    cur_time += mono_time->base_time;
#ifdef OS_WIN32
    pthread_mutex_unlock(&mono_time->last_clock_lock);
#endif

#ifndef ESP_PLATFORM
    pthread_rwlock_wrlock(mono_time->time_update_lock);
#endif
    mono_time->cur_time = cur_time;
#ifndef ESP_PLATFORM
    pthread_rwlock_unlock(mono_time->time_update_lock);
#endif
}

uint64_t mono_time_get(const Mono_Time *mono_time)
{
#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
    // Fuzzing is only single thread for now, no locking needed */
    return mono_time->cur_time;
#else
#ifndef ESP_PLATFORM
    pthread_rwlock_rdlock(mono_time->time_update_lock);
#endif
    const uint64_t cur_time = mono_time->cur_time;
#ifndef ESP_PLATFORM
    pthread_rwlock_unlock(mono_time->time_update_lock);
#endif
    return cur_time;
#endif
}

bool mono_time_is_timeout(const Mono_Time *mono_time, uint64_t timestamp, uint64_t timeout)
{
    return timestamp + timeout <= mono_time_get(mono_time);
}

void mono_time_set_current_time_callback(Mono_Time *mono_time,
        mono_time_current_time_cb *current_time_callback, void *user_data)
{
    if (current_time_callback == nullptr) {
        mono_time->current_time_callback = current_time_monotonic_default;
        mono_time->user_data = mono_time;
    } else {
        mono_time->current_time_callback = current_time_callback;
        mono_time->user_data = user_data;
    }
}

/**
 * Return current monotonic time in milliseconds (ms). The starting point is
 * unspecified.
 */
uint64_t current_time_monotonic(Mono_Time *mono_time)
{
    /* For WIN32 we don't want to change overflow state of mono_time here */
#ifdef OS_WIN32
    /* We don't want to update the overflow state of mono_time here,
     * but must protect against other threads */
    pthread_mutex_lock(&mono_time->last_clock_lock);
#endif
    const uint64_t cur_time = mono_time->current_time_callback(mono_time->user_data);
#ifdef OS_WIN32
    pthread_mutex_unlock(&mono_time->last_clock_lock);
#endif
    return cur_time;
}
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2018 The TokTok team.
 * Copyright © 2013 Tox project.
 */

/**
 * Functions for the core network crypto.
 *
 * NOTE: This code has to be perfect. We don't mess around with encryption.
 */

#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


typedef struct Packet_Data {
    uint64_t sent_time;
    uint16_t length;
    uint8_t data[MAX_CRYPTO_DATA_SIZE];
} Packet_Data;

typedef struct Packets_Array {
    Packet_Data *buffer[CRYPTO_PACKET_BUFFER_SIZE];
    uint32_t  buffer_start;
    uint32_t  buffer_end; /* packet numbers in array: `{buffer_start, buffer_end)` */
} Packets_Array;

typedef enum Crypto_Conn_State {
    /* the connection slot is free. This value is 0 so it is valid after
     * `crypto_memzero(...)` of the parent struct
     */
    CRYPTO_CONN_FREE = 0,
    CRYPTO_CONN_NO_CONNECTION,       /* the connection is allocated, but not yet used */
    CRYPTO_CONN_COOKIE_REQUESTING,   /* we are sending cookie request packets */
    CRYPTO_CONN_HANDSHAKE_SENT,      /* we are sending handshake packets */
    /* we are sending handshake packets.
     * we have received one from the other, but no data */
    CRYPTO_CONN_NOT_CONFIRMED,
    CRYPTO_CONN_ESTABLISHED,         /* the connection is established */
} Crypto_Conn_State;

typedef struct Crypto_Connection {
    uint8_t public_key[CRYPTO_PUBLIC_KEY_SIZE]; /* The real public key of the peer. */
    uint8_t recv_nonce[CRYPTO_NONCE_SIZE]; /* Nonce of received packets. */
    uint8_t sent_nonce[CRYPTO_NONCE_SIZE]; /* Nonce of sent packets. */
    uint8_t sessionpublic_key[CRYPTO_PUBLIC_KEY_SIZE]; /* Our public key for this session. */
    uint8_t sessionsecret_key[CRYPTO_SECRET_KEY_SIZE]; /* Our private key for this session. */
    uint8_t peersessionpublic_key[CRYPTO_PUBLIC_KEY_SIZE]; /* The public key of the peer. */
    uint8_t shared_key[CRYPTO_SHARED_KEY_SIZE]; /* The precomputed shared key from encrypt_precompute. */
    Crypto_Conn_State status; /* See Crypto_Conn_State documentation */
    uint64_t cookie_request_number; /* number used in the cookie request packets for this connection */
    uint8_t dht_public_key[CRYPTO_PUBLIC_KEY_SIZE]; /* The dht public key of the peer */

    uint8_t *temp_packet; /* Where the cookie request/handshake packet is stored while it is being sent. */
    uint16_t temp_packet_length;
    uint64_t temp_packet_sent_time; /* The time at which the last temp_packet was sent in ms. */
    uint32_t temp_packet_num_sent;

    IP_Port ip_portv4; /* The ip and port to contact this guy directly.*/
    IP_Port ip_portv6;
    uint64_t direct_lastrecv_timev4; /* The Time at which we last received a direct packet in ms. */
    uint64_t direct_lastrecv_timev6;

    uint64_t last_tcp_sent; /* Time the last TCP packet was sent. */

    Packets_Array send_array;
    Packets_Array recv_array;

    connection_status_cb *connection_status_callback;
    void *connection_status_callback_object;
    int connection_status_callback_id;

    connection_data_cb *connection_data_callback;
    void *connection_data_callback_object;
    int connection_data_callback_id;

    connection_lossy_data_cb *connection_lossy_data_callback;
    void *connection_lossy_data_callback_object;
    int connection_lossy_data_callback_id;

    uint64_t last_request_packet_sent;
    uint64_t direct_send_attempt_time;

    uint32_t packet_counter;
    double packet_recv_rate;
    uint64_t packet_counter_set;

    double packet_send_rate;
    uint32_t packets_left;
    uint64_t last_packets_left_set;
    double last_packets_left_rem;

    double packet_send_rate_requested;
    uint32_t packets_left_requested;
    uint64_t last_packets_left_requested_set;
    double last_packets_left_requested_rem;

    uint32_t last_sendqueue_size[CONGESTION_QUEUE_ARRAY_SIZE];
    uint32_t last_sendqueue_counter;
    long signed int last_num_packets_sent[CONGESTION_LAST_SENT_ARRAY_SIZE];
    long signed int last_num_packets_resent[CONGESTION_LAST_SENT_ARRAY_SIZE];
    uint32_t packets_sent;
    uint32_t packets_resent;
    uint64_t last_congestion_event;
    uint64_t rtt_time;

    /* TCP_connection connection_number */
    unsigned int connection_number_tcp;

    bool maximum_speed_reached;

    dht_pk_cb *dht_pk_callback;
    void *dht_pk_callback_object;
    uint32_t dht_pk_callback_number;
} Crypto_Connection;

static const Crypto_Connection empty_crypto_connection = {{0}};

struct Net_Crypto {
    const Logger *log;
    const Random *rng;
    Mono_Time *mono_time;
    const Network *ns;

    DHT *dht;
    TCP_Connections *tcp_c;

    Crypto_Connection *crypto_connections;

    uint32_t crypto_connections_length; /* Length of connections array. */

    /* Our public and secret keys. */
    uint8_t self_public_key[CRYPTO_PUBLIC_KEY_SIZE];
    uint8_t self_secret_key[CRYPTO_SECRET_KEY_SIZE];

    /* The secret key used for cookies */
    uint8_t secret_symmetric_key[CRYPTO_SYMMETRIC_KEY_SIZE];

    new_connection_cb *new_connection_callback;
    void *new_connection_callback_object;

    /* The current optimal sleep time */
    uint32_t current_sleep_time;

    BS_List ip_port_list;
};

const uint8_t *nc_get_self_public_key(const Net_Crypto *c)
{
    return c->self_public_key;
}

const uint8_t *nc_get_self_secret_key(const Net_Crypto *c)
{
    return c->self_secret_key;
}

TCP_Connections *nc_get_tcp_c(const Net_Crypto *c)
{
    return c->tcp_c;
}

DHT *nc_get_dht(const Net_Crypto *c)
{
    return c->dht;
}

non_null()
static bool crypt_connection_id_is_valid(const Net_Crypto *c, int crypt_connection_id)
{
    if ((uint32_t)crypt_connection_id >= c->crypto_connections_length) {
        return false;
    }

    if (c->crypto_connections == nullptr) {
        return false;
    }

    const Crypto_Conn_State status = c->crypto_connections[crypt_connection_id].status;

    return status != CRYPTO_CONN_NO_CONNECTION && status != CRYPTO_CONN_FREE;
}

/** cookie timeout in seconds */
#define COOKIE_TIMEOUT 15
#define COOKIE_DATA_LENGTH (uint16_t)(CRYPTO_PUBLIC_KEY_SIZE * 2)
#define COOKIE_CONTENTS_LENGTH (uint16_t)(sizeof(uint64_t) + COOKIE_DATA_LENGTH)
#define COOKIE_LENGTH (uint16_t)(CRYPTO_NONCE_SIZE + COOKIE_CONTENTS_LENGTH + CRYPTO_MAC_SIZE)

#define COOKIE_REQUEST_PLAIN_LENGTH (uint16_t)(COOKIE_DATA_LENGTH + sizeof(uint64_t))
#define COOKIE_REQUEST_LENGTH (uint16_t)(1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + COOKIE_REQUEST_PLAIN_LENGTH + CRYPTO_MAC_SIZE)
#define COOKIE_RESPONSE_LENGTH (uint16_t)(1 + CRYPTO_NONCE_SIZE + COOKIE_LENGTH + sizeof(uint64_t) + CRYPTO_MAC_SIZE)

/** @brief Create a cookie request packet and put it in packet.
 *
 * dht_public_key is the dht public key of the other
 *
 * packet must be of size COOKIE_REQUEST_LENGTH or bigger.
 *
 * @retval -1 on failure.
 * @retval COOKIE_REQUEST_LENGTH on success.
 */
non_null()
static int create_cookie_request(const Net_Crypto *c, uint8_t *packet, const uint8_t *dht_public_key,
                                 uint64_t number, uint8_t *shared_key)
{
    uint8_t plain[COOKIE_REQUEST_PLAIN_LENGTH];
    uint8_t padding[CRYPTO_PUBLIC_KEY_SIZE] = {0};

    memcpy(plain, c->self_public_key, CRYPTO_PUBLIC_KEY_SIZE);
    memcpy(plain + CRYPTO_PUBLIC_KEY_SIZE, padding, CRYPTO_PUBLIC_KEY_SIZE);
    memcpy(plain + (CRYPTO_PUBLIC_KEY_SIZE * 2), &number, sizeof(uint64_t));
    const uint8_t *tmp_shared_key = dht_get_shared_key_sent(c->dht, dht_public_key);
    memcpy(shared_key, tmp_shared_key, CRYPTO_SHARED_KEY_SIZE);
    uint8_t nonce[CRYPTO_NONCE_SIZE];
    random_nonce(c->rng, nonce);
    packet[0] = NET_PACKET_COOKIE_REQUEST;
    memcpy(packet + 1, dht_get_self_public_key(c->dht), CRYPTO_PUBLIC_KEY_SIZE);
    memcpy(packet + 1 + CRYPTO_PUBLIC_KEY_SIZE, nonce, CRYPTO_NONCE_SIZE);
    const int len = encrypt_data_symmetric(shared_key, nonce, plain, sizeof(plain),
                                           packet + 1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE);

    if (len != COOKIE_REQUEST_PLAIN_LENGTH + CRYPTO_MAC_SIZE) {
        return -1;
    }

    return 1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + len;
}

/** @brief Create cookie of length COOKIE_LENGTH from bytes of length COOKIE_DATA_LENGTH using encryption_key
 *
 * @retval -1 on failure.
 * @retval 0 on success.
 */
non_null()
static int create_cookie(const Random *rng, const Mono_Time *mono_time, uint8_t *cookie, const uint8_t *bytes,
                         const uint8_t *encryption_key)
{
    uint8_t contents[COOKIE_CONTENTS_LENGTH];
    const uint64_t temp_time = mono_time_get(mono_time);
    memcpy(contents, &temp_time, sizeof(temp_time));
    memcpy(contents + sizeof(temp_time), bytes, COOKIE_DATA_LENGTH);
    random_nonce(rng, cookie);
    const int len = encrypt_data_symmetric(encryption_key, cookie, contents, sizeof(contents), cookie + CRYPTO_NONCE_SIZE);

    if (len != COOKIE_LENGTH - CRYPTO_NONCE_SIZE) {
        return -1;
    }

    return 0;
}

/** @brief Open cookie of length COOKIE_LENGTH to bytes of length COOKIE_DATA_LENGTH using encryption_key
 *
 * @retval -1 on failure.
 * @retval 0 on success.
 */
non_null()
static int open_cookie(const Mono_Time *mono_time, uint8_t *bytes, const uint8_t *cookie,
                       const uint8_t *encryption_key)
{
    uint8_t contents[COOKIE_CONTENTS_LENGTH];
    const int len = decrypt_data_symmetric(encryption_key, cookie, cookie + CRYPTO_NONCE_SIZE,
                                           COOKIE_LENGTH - CRYPTO_NONCE_SIZE, contents);

    if (len != sizeof(contents)) {
        return -1;
    }

    uint64_t cookie_time;
    memcpy(&cookie_time, contents, sizeof(cookie_time));
    const uint64_t temp_time = mono_time_get(mono_time);

    if (cookie_time + COOKIE_TIMEOUT < temp_time || temp_time < cookie_time) {
        return -1;
    }

    memcpy(bytes, contents + sizeof(cookie_time), COOKIE_DATA_LENGTH);
    return 0;
}


/** @brief Create a cookie response packet and put it in packet.
 * @param request_plain must be COOKIE_REQUEST_PLAIN_LENGTH bytes.
 * @param packet must be of size COOKIE_RESPONSE_LENGTH or bigger.
 *
 * @retval -1 on failure.
 * @retval COOKIE_RESPONSE_LENGTH on success.
 */
non_null()
static int create_cookie_response(const Net_Crypto *c, uint8_t *packet, const uint8_t *request_plain,
                                  const uint8_t *shared_key, const uint8_t *dht_public_key)
{
    uint8_t cookie_plain[COOKIE_DATA_LENGTH];
    memcpy(cookie_plain, request_plain, CRYPTO_PUBLIC_KEY_SIZE);
    memcpy(cookie_plain + CRYPTO_PUBLIC_KEY_SIZE, dht_public_key, CRYPTO_PUBLIC_KEY_SIZE);
    uint8_t plain[COOKIE_LENGTH + sizeof(uint64_t)];

    if (create_cookie(c->rng, c->mono_time, plain, cookie_plain, c->secret_symmetric_key) != 0) {
        return -1;
    }

    memcpy(plain + COOKIE_LENGTH, request_plain + COOKIE_DATA_LENGTH, sizeof(uint64_t));
    packet[0] = NET_PACKET_COOKIE_RESPONSE;
    random_nonce(c->rng, packet + 1);
    const int len = encrypt_data_symmetric(shared_key, packet + 1, plain, sizeof(plain), packet + 1 + CRYPTO_NONCE_SIZE);

    if (len != COOKIE_RESPONSE_LENGTH - (1 + CRYPTO_NONCE_SIZE)) {
        return -1;
    }

    return COOKIE_RESPONSE_LENGTH;
}

/** @brief Handle the cookie request packet of length length.
 * Put what was in the request in request_plain (must be of size COOKIE_REQUEST_PLAIN_LENGTH)
 * Put the key used to decrypt the request into shared_key (of size CRYPTO_SHARED_KEY_SIZE) for use in the response.
 *
 * @retval -1 on failure.
 * @retval 0 on success.
 */
non_null()
static int handle_cookie_request(const Net_Crypto *c, uint8_t *request_plain, uint8_t *shared_key,
                                 uint8_t *dht_public_key, const uint8_t *packet, uint16_t length)
{
    if (length != COOKIE_REQUEST_LENGTH) {
        return -1;
    }

    memcpy(dht_public_key, packet + 1, CRYPTO_PUBLIC_KEY_SIZE);
    const uint8_t *tmp_shared_key = dht_get_shared_key_sent(c->dht, dht_public_key);
    memcpy(shared_key, tmp_shared_key, CRYPTO_SHARED_KEY_SIZE);
    const int len = decrypt_data_symmetric(shared_key, packet + 1 + CRYPTO_PUBLIC_KEY_SIZE,
                                           packet + 1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE, COOKIE_REQUEST_PLAIN_LENGTH + CRYPTO_MAC_SIZE,
                                           request_plain);

    if (len != COOKIE_REQUEST_PLAIN_LENGTH) {
        return -1;
    }

    return 0;
}

/** Handle the cookie request packet (for raw UDP) */
non_null(1, 2, 3) nullable(5)
static int udp_handle_cookie_request(void *object, const IP_Port *source, const uint8_t *packet, uint16_t length,
                                     void *userdata)
{
    const Net_Crypto *c = (const Net_Crypto *)object;
    uint8_t request_plain[COOKIE_REQUEST_PLAIN_LENGTH];
    uint8_t shared_key[CRYPTO_SHARED_KEY_SIZE];
    uint8_t dht_public_key[CRYPTO_PUBLIC_KEY_SIZE];

    if (handle_cookie_request(c, request_plain, shared_key, dht_public_key, packet, length) != 0) {
        return 1;
    }

    uint8_t data[COOKIE_RESPONSE_LENGTH];

    if (create_cookie_response(c, data, request_plain, shared_key, dht_public_key) != sizeof(data)) {
        return 1;
    }

    if ((uint32_t)sendpacket(dht_get_net(c->dht), source, data, sizeof(data)) != sizeof(data)) {
        return 1;
    }

    return 0;
}

/** Handle the cookie request packet (for TCP) */
non_null()
static int tcp_handle_cookie_request(const Net_Crypto *c, int connections_number, const uint8_t *packet,
                                     uint16_t length)
{
    uint8_t request_plain[COOKIE_REQUEST_PLAIN_LENGTH];
    uint8_t shared_key[CRYPTO_SHARED_KEY_SIZE];
    uint8_t dht_public_key[CRYPTO_PUBLIC_KEY_SIZE];

    if (handle_cookie_request(c, request_plain, shared_key, dht_public_key, packet, length) != 0) {
        return -1;
    }

    uint8_t data[COOKIE_RESPONSE_LENGTH];

    if (create_cookie_response(c, data, request_plain, shared_key, dht_public_key) != sizeof(data)) {
        return -1;
    }

    const int ret = send_packet_tcp_connection(c->tcp_c, connections_number, data, sizeof(data));
    return ret;
}

/** Handle the cookie request packet (for TCP oob packets) */
non_null()
static int tcp_oob_handle_cookie_request(const Net_Crypto *c, unsigned int tcp_connections_number,
        const uint8_t *dht_public_key, const uint8_t *packet, uint16_t length)
{
    uint8_t request_plain[COOKIE_REQUEST_PLAIN_LENGTH];
    uint8_t shared_key[CRYPTO_SHARED_KEY_SIZE];
    uint8_t dht_public_key_temp[CRYPTO_PUBLIC_KEY_SIZE];

    if (handle_cookie_request(c, request_plain, shared_key, dht_public_key_temp, packet, length) != 0) {
        return -1;
    }

    if (!pk_equal(dht_public_key, dht_public_key_temp)) {
        return -1;
    }

    uint8_t data[COOKIE_RESPONSE_LENGTH];

    if (create_cookie_response(c, data, request_plain, shared_key, dht_public_key) != sizeof(data)) {
        return -1;
    }

    const int ret = tcp_send_oob_packet(c->tcp_c, tcp_connections_number, dht_public_key, data, sizeof(data));
    return ret;
}

/** @brief Handle a cookie response packet of length encrypted with shared_key.
 * put the cookie in the response in cookie
 *
 * @param cookie must be of length COOKIE_LENGTH.
 *
 * @retval -1 on failure.
 * @retval COOKIE_LENGTH on success.
 */
non_null()
static int handle_cookie_response(uint8_t *cookie, uint64_t *number,
                                  const uint8_t *packet, uint16_t length,
                                  const uint8_t *shared_key)
{
    if (length != COOKIE_RESPONSE_LENGTH) {
        return -1;
    }

    uint8_t plain[COOKIE_LENGTH + sizeof(uint64_t)];
    const int len = decrypt_data_symmetric(shared_key, packet + 1, packet + 1 + CRYPTO_NONCE_SIZE,
                                           length - (1 + CRYPTO_NONCE_SIZE), plain);

    if (len != sizeof(plain)) {
        return -1;
    }

    memcpy(cookie, plain, COOKIE_LENGTH);
    memcpy(number, plain + COOKIE_LENGTH, sizeof(uint64_t));
    return COOKIE_LENGTH;
}

#define HANDSHAKE_PACKET_LENGTH (1 + COOKIE_LENGTH + CRYPTO_NONCE_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_SHA512_SIZE + COOKIE_LENGTH + CRYPTO_MAC_SIZE)

/** @brief Create a handshake packet and put it in packet.
 * @param cookie must be COOKIE_LENGTH bytes.
 * @param packet must be of size HANDSHAKE_PACKET_LENGTH or bigger.
 *
 * @retval -1 on failure.
 * @retval HANDSHAKE_PACKET_LENGTH on success.
 */
non_null()
static int create_crypto_handshake(const Net_Crypto *c, uint8_t *packet, const uint8_t *cookie, const uint8_t *nonce,
                                   const uint8_t *session_pk, const uint8_t *peer_real_pk, const uint8_t *peer_dht_pubkey)
{
    uint8_t plain[CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_SHA512_SIZE + COOKIE_LENGTH];
    memcpy(plain, nonce, CRYPTO_NONCE_SIZE);
    memcpy(plain + CRYPTO_NONCE_SIZE, session_pk, CRYPTO_PUBLIC_KEY_SIZE);
    crypto_sha512(plain + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE, cookie, COOKIE_LENGTH);
    uint8_t cookie_plain[COOKIE_DATA_LENGTH];
    memcpy(cookie_plain, peer_real_pk, CRYPTO_PUBLIC_KEY_SIZE);
    memcpy(cookie_plain + CRYPTO_PUBLIC_KEY_SIZE, peer_dht_pubkey, CRYPTO_PUBLIC_KEY_SIZE);

    if (create_cookie(c->rng, c->mono_time, plain + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_SHA512_SIZE,
                      cookie_plain, c->secret_symmetric_key) != 0) {
        return -1;
    }

    random_nonce(c->rng, packet + 1 + COOKIE_LENGTH);
    const int len = encrypt_data(peer_real_pk, c->self_secret_key, packet + 1 + COOKIE_LENGTH, plain, sizeof(plain),
                                 packet + 1 + COOKIE_LENGTH + CRYPTO_NONCE_SIZE);

    if (len != HANDSHAKE_PACKET_LENGTH - (1 + COOKIE_LENGTH + CRYPTO_NONCE_SIZE)) {
        return -1;
    }

    packet[0] = NET_PACKET_CRYPTO_HS;
    memcpy(packet + 1, cookie, COOKIE_LENGTH);

    return HANDSHAKE_PACKET_LENGTH;
}

/** @brief Handle a crypto handshake packet of length.
 * put the nonce contained in the packet in nonce,
 * the session public key in session_pk
 * the real public key of the peer in peer_real_pk
 * the dht public key of the peer in dht_public_key and
 * the cookie inside the encrypted part of the packet in cookie.
 *
 * if expected_real_pk isn't NULL it denotes the real public key
 * the packet should be from.
 *
 * nonce must be at least CRYPTO_NONCE_SIZE
 * session_pk must be at least CRYPTO_PUBLIC_KEY_SIZE
 * peer_real_pk must be at least CRYPTO_PUBLIC_KEY_SIZE
 * cookie must be at least COOKIE_LENGTH
 *
 * @retval false on failure.
 * @retval true on success.
 */
non_null(1, 2, 3, 4, 5, 6, 7) nullable(9)
static bool handle_crypto_handshake(const Net_Crypto *c, uint8_t *nonce, uint8_t *session_pk, uint8_t *peer_real_pk,
                                    uint8_t *dht_public_key, uint8_t *cookie, const uint8_t *packet, uint16_t length, const uint8_t *expected_real_pk)
{
    if (length != HANDSHAKE_PACKET_LENGTH) {
        return false;
    }

    uint8_t cookie_plain[COOKIE_DATA_LENGTH];

    if (open_cookie(c->mono_time, cookie_plain, packet + 1, c->secret_symmetric_key) != 0) {
        return false;
    }

    if (expected_real_pk != nullptr && !pk_equal(cookie_plain, expected_real_pk)) {
        return false;
    }

    uint8_t cookie_hash[CRYPTO_SHA512_SIZE];
    crypto_sha512(cookie_hash, packet + 1, COOKIE_LENGTH);

    uint8_t plain[CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_SHA512_SIZE + COOKIE_LENGTH];
    const int len = decrypt_data(cookie_plain, c->self_secret_key, packet + 1 + COOKIE_LENGTH,
                                 packet + 1 + COOKIE_LENGTH + CRYPTO_NONCE_SIZE,
                                 HANDSHAKE_PACKET_LENGTH - (1 + COOKIE_LENGTH + CRYPTO_NONCE_SIZE), plain);

    if (len != sizeof(plain)) {
        return false;
    }

    if (!crypto_sha512_eq(cookie_hash, plain + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE)) {
        return false;
    }

    memcpy(nonce, plain, CRYPTO_NONCE_SIZE);
    memcpy(session_pk, plain + CRYPTO_NONCE_SIZE, CRYPTO_PUBLIC_KEY_SIZE);
    memcpy(cookie, plain + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_SHA512_SIZE, COOKIE_LENGTH);
    memcpy(peer_real_pk, cookie_plain, CRYPTO_PUBLIC_KEY_SIZE);
    memcpy(dht_public_key, cookie_plain + CRYPTO_PUBLIC_KEY_SIZE, CRYPTO_PUBLIC_KEY_SIZE);
    return true;
}


non_null()
static Crypto_Connection *get_crypto_connection(const Net_Crypto *c, int crypt_connection_id)
{
    if (!crypt_connection_id_is_valid(c, crypt_connection_id)) {
        return nullptr;
    }

    return &c->crypto_connections[crypt_connection_id];
}


/** @brief Associate an ip_port to a connection.
 *
 * @retval -1 on failure.
 * @retval 0 on success.
 */
non_null()
static int add_ip_port_connection(Net_Crypto *c, int crypt_connection_id, const IP_Port *ip_port)
{
    Crypto_Connection *conn = get_crypto_connection(c, crypt_connection_id);

    if (conn == nullptr) {
        return -1;
    }

    if (net_family_is_ipv4(ip_port->ip.family)) {
        if (!ipport_equal(ip_port, &conn->ip_portv4) && !ip_is_lan(&conn->ip_portv4.ip)) {
            if (!bs_list_add(&c->ip_port_list, (const uint8_t *)ip_port, crypt_connection_id)) {
                return -1;
            }

            bs_list_remove(&c->ip_port_list, (uint8_t *)&conn->ip_portv4, crypt_connection_id);
            conn->ip_portv4 = *ip_port;
            return 0;
        }
    } else if (net_family_is_ipv6(ip_port->ip.family)) {
        if (!ipport_equal(ip_port, &conn->ip_portv6)) {
            if (!bs_list_add(&c->ip_port_list, (const uint8_t *)ip_port, crypt_connection_id)) {
                return -1;
            }

            bs_list_remove(&c->ip_port_list, (uint8_t *)&conn->ip_portv6, crypt_connection_id);
            conn->ip_portv6 = *ip_port;
            return 0;
        }
    }

    return -1;
}

/** @brief Return the IP_Port that should be used to send packets to the other peer.
 *
 * @retval IP_Port with family 0 on failure.
 * @return IP_Port on success.
 */
non_null()
static IP_Port return_ip_port_connection(const Net_Crypto *c, int crypt_connection_id)
{
    const IP_Port empty = {{{0}}};

    const Crypto_Connection *conn = get_crypto_connection(c, crypt_connection_id);

    if (conn == nullptr) {
        return empty;
    }

    const uint64_t current_time = mono_time_get(c->mono_time);
    bool v6 = false;
    bool v4 = false;

    if ((UDP_DIRECT_TIMEOUT + conn->direct_lastrecv_timev4) > current_time) {
        v4 = true;
    }

    if ((UDP_DIRECT_TIMEOUT + conn->direct_lastrecv_timev6) > current_time) {
        v6 = true;
    }

    /* Prefer IP_Ports which haven't timed out to those which have.
     * To break ties, prefer ipv4 lan, then ipv6, then non-lan ipv4.
     */
    if (v4 && ip_is_lan(&conn->ip_portv4.ip)) {
        return conn->ip_portv4;
    }

    if (v6 && net_family_is_ipv6(conn->ip_portv6.ip.family)) {
        return conn->ip_portv6;
    }

    if (v4 && net_family_is_ipv4(conn->ip_portv4.ip.family)) {
        return conn->ip_portv4;
    }

    if (ip_is_lan(&conn->ip_portv4.ip)) {
        return conn->ip_portv4;
    }

    if (net_family_is_ipv6(conn->ip_portv6.ip.family)) {
        return conn->ip_portv6;
    }

    if (net_family_is_ipv4(conn->ip_portv4.ip.family)) {
        return conn->ip_portv4;
    }

    return empty;
}

/** @brief Sends a packet to the peer using the fastest route.
 *
 * @retval -1 on failure.
 * @retval 0 on success.
 */
non_null()
static int send_packet_to(Net_Crypto *c, int crypt_connection_id, const uint8_t *data, uint16_t length)
{
// TODO(irungentoo): TCP, etc...
    Crypto_Connection *conn = get_crypto_connection(c, crypt_connection_id);

    if (conn == nullptr) {
        return -1;
    }

    bool direct_send_attempt = false;

    IP_Port ip_port = return_ip_port_connection(c, crypt_connection_id);

    // TODO(irungentoo): on bad networks, direct connections might not last indefinitely.
    if (!net_family_is_unspec(ip_port.ip.family)) {
        bool direct_connected = false;

        // FIXME(sudden6): handle return value
        crypto_connection_status(c, crypt_connection_id, &direct_connected, nullptr);

        if (direct_connected) {
            if ((uint32_t)sendpacket(dht_get_net(c->dht), &ip_port, data, length) == length) {
                return 0;
            }

            LOGGER_WARNING(c->log, "sending packet of length %d failed", length);
            return -1;
        }

        // TODO(irungentoo): a better way of sending packets directly to confirm the others ip.
        const uint64_t current_time = mono_time_get(c->mono_time);

        if ((((UDP_DIRECT_TIMEOUT / 2) + conn->direct_send_attempt_time) < current_time && length < 96)
                || data[0] == NET_PACKET_COOKIE_REQUEST || data[0] == NET_PACKET_CRYPTO_HS) {
            if ((uint32_t)sendpacket(dht_get_net(c->dht), &ip_port, data, length) == length) {
                direct_send_attempt = true;
                conn->direct_send_attempt_time = mono_time_get(c->mono_time);
            }
        }
    }

    const int ret = send_packet_tcp_connection(c->tcp_c, conn->connection_number_tcp, data, length);

    if (ret == 0) {
        conn->last_tcp_sent = current_time_monotonic(c->mono_time);
    }

    if (direct_send_attempt) {
        return 0;
    }

    return ret;
}

/*** START: Array Related functions */


/** @brief Return number of packets in array
 * Note that holes are counted too.
 */
non_null()
static uint32_t num_packets_array(const Packets_Array *array)
{
    return array->buffer_end - array->buffer_start;
}

/** @brief Add data with packet number to array.
 *
 * @retval -1 on failure.
 * @retval 0 on success.
 */
non_null()
static int add_data_to_buffer(Packets_Array *array, uint32_t number, const Packet_Data *data)
{
    if (number - array->buffer_start >= CRYPTO_PACKET_BUFFER_SIZE) {
        return -1;
    }

    const uint32_t num = number % CRYPTO_PACKET_BUFFER_SIZE;

    if (array->buffer[num] != nullptr) {
        return -1;
    }

    Packet_Data *new_d = (Packet_Data *)calloc(1, sizeof(Packet_Data));

    if (new_d == nullptr) {
        return -1;
    }

    *new_d = *data;
    array->buffer[num] = new_d;

    if (number - array->buffer_start >= num_packets_array(array)) {
        array->buffer_end = number + 1;
    }

    return 0;
}

/** @brief Get pointer of data with packet number.
 *
 * @retval -1 on failure.
 * @retval 0 if data at number is empty.
 * @retval 1 if data pointer was put in data.
 */
non_null()
static int get_data_pointer(const Packets_Array *array, Packet_Data **data, uint32_t number)
{
    const uint32_t num_spots = num_packets_array(array);

    if (array->buffer_end - number > num_spots || number - array->buffer_start >= num_spots) {
        return -1;
    }

    const uint32_t num = number % CRYPTO_PACKET_BUFFER_SIZE;

    if (array->buffer[num] == nullptr) {
        return 0;
    }

    *data = array->buffer[num];
    return 1;
}

/** @brief Add data to end of array.
 *
 * @retval -1 on failure.
 * @return packet number on success.
 */
non_null()
static int64_t add_data_end_of_buffer(const Logger *logger, Packets_Array *array, const Packet_Data *data)
{
    const uint32_t num_spots = num_packets_array(array);

    if (num_spots >= CRYPTO_PACKET_BUFFER_SIZE) {
        LOGGER_WARNING(logger, "crypto packet buffer size exceeded; rejecting packet of length %d", data->length);
        return -1;
    }

    Packet_Data *new_d = (Packet_Data *)calloc(1, sizeof(Packet_Data));

    if (new_d == nullptr) {
        LOGGER_ERROR(logger, "packet data allocation failed");
        return -1;
    }

    *new_d = *data;
    const uint32_t id = array->buffer_end;
    array->buffer[id % CRYPTO_PACKET_BUFFER_SIZE] = new_d;
    ++array->buffer_end;
    return id;
}

/** @brief Read data from beginning of array.
 *
 * @retval -1 on failure.
 * @return packet number on success.
 */
non_null()
static int64_t read_data_beg_buffer(Packets_Array *array, Packet_Data *data)
{
    if (array->buffer_end == array->buffer_start) {
        return -1;
    }

    const uint32_t num = array->buffer_start % CRYPTO_PACKET_BUFFER_SIZE;

    if (array->buffer[num] == nullptr) {
        return -1;
    }

    *data = *array->buffer[num];
    const uint32_t id = array->buffer_start;
    ++array->buffer_start;
    free(array->buffer[num]);
    array->buffer[num] = nullptr;
    return id;
}

/** @brief Delete all packets in array before number (but not number)
 *
 * @retval -1 on failure.
 * @retval 0 on success
 */
non_null()
static int clear_buffer_until(Packets_Array *array, uint32_t number)
{
    const uint32_t num_spots = num_packets_array(array);

    if (array->buffer_end - number >= num_spots || number - array->buffer_start > num_spots) {
        return -1;
    }

    uint32_t i;

    for (i = array->buffer_start; i != number; ++i) {
        const uint32_t num = i % CRYPTO_PACKET_BUFFER_SIZE;

        if (array->buffer[num] != nullptr) {
            free(array->buffer[num]);
            array->buffer[num] = nullptr;
        }
    }

    array->buffer_start = i;
    return 0;
}

non_null()
static int clear_buffer(Packets_Array *array)
{
    uint32_t i;

    for (i = array->buffer_start; i != array->buffer_end; ++i) {
        const uint32_t num = i % CRYPTO_PACKET_BUFFER_SIZE;

        if (array->buffer[num] != nullptr) {
            free(array->buffer[num]);
            array->buffer[num] = nullptr;
        }
    }

    array->buffer_start = i;
    return 0;
}

/** @brief Set array buffer end to number.
 *
 * @retval -1 on failure.
 * @retval 0 on success.
 */
non_null()
static int set_buffer_end(Packets_Array *array, uint32_t number)
{
    if (number - array->buffer_start > CRYPTO_PACKET_BUFFER_SIZE) {
        return -1;
    }

    if (number - array->buffer_end > CRYPTO_PACKET_BUFFER_SIZE) {
        return -1;
    }

    array->buffer_end = number;
    return 0;
}

/**
 * @brief Create a packet request packet from recv_array and send_buffer_end into
 *   data of length.
 *
 * @retval -1 on failure.
 * @return length of packet on success.
 */
non_null()
static int generate_request_packet(uint8_t *data, uint16_t length, const Packets_Array *recv_array)
{
    if (length == 0) {
        return -1;
    }

    data[0] = PACKET_ID_REQUEST;

    uint16_t cur_len = 1;

    if (recv_array->buffer_start == recv_array->buffer_end) {
        return cur_len;
    }

    if (length <= cur_len) {
        return cur_len;
    }

    uint32_t n = 1;

    for (uint32_t i = recv_array->buffer_start; i != recv_array->buffer_end; ++i) {
        const uint32_t num = i % CRYPTO_PACKET_BUFFER_SIZE;

        if (recv_array->buffer[num] == nullptr) {
            data[cur_len] = n;
            n = 0;
            ++cur_len;

            if (length <= cur_len) {
                return cur_len;
            }
        } else if (n == 255) {
            data[cur_len] = 0;
            n = 0;
            ++cur_len;

            if (length <= cur_len) {
                return cur_len;
            }
        }

        ++n;
    }

    return cur_len;
}

/** @brief Handle a request data packet.
 * Remove all the packets the other received from the array.
 *
 * @retval -1 on failure.
 * @return number of requested packets on success.
 */
non_null()
static int handle_request_packet(Mono_Time *mono_time, Packets_Array *send_array,
                                 const uint8_t *data, uint16_t length,
                                 uint64_t *latest_send_time, uint64_t rtt_time)
{
    if (length == 0) {
        return -1;
    }

    if (data[0] != PACKET_ID_REQUEST) {
        return -1;
    }

    if (length == 1) {
        return 0;
    }

    ++data;
    --length;

    uint32_t n = 1;
    uint32_t requested = 0;

    const uint64_t temp_time = current_time_monotonic(mono_time);
    uint64_t l_sent_time = 0;

    for (uint32_t i = send_array->buffer_start; i != send_array->buffer_end; ++i) {
        if (length == 0) {
            break;
        }

        const uint32_t num = i % CRYPTO_PACKET_BUFFER_SIZE;

        if (n == data[0]) {
            if (send_array->buffer[num] != nullptr) {
                const uint64_t sent_time = send_array->buffer[num]->sent_time;

                if ((sent_time + rtt_time) < temp_time) {
                    send_array->buffer[num]->sent_time = 0;
                }
            }

            ++data;
            --length;
            n = 0;
            ++requested;
        } else {
            if (send_array->buffer[num] != nullptr) {
                l_sent_time = max_u64(l_sent_time, send_array->buffer[num]->sent_time);

                free(send_array->buffer[num]);
                send_array->buffer[num] = nullptr;
            }
        }

        if (n == 255) {
            n = 1;

            if (data[0] != 0) {
                return -1;
            }

            ++data;
            --length;
        } else {
            ++n;
        }
    }

    *latest_send_time = max_u64(*latest_send_time, l_sent_time);

    return requested;
}

/** END: Array Related functions */

#define MAX_DATA_DATA_PACKET_SIZE (MAX_CRYPTO_PACKET_SIZE - (1 + sizeof(uint16_t) + CRYPTO_MAC_SIZE))

/** @brief Creates and sends a data packet to the peer using the fastest route.
 *
 * @retval -1 on failure.
 * @retval 0 on success.
 */
non_null()
static int send_data_packet(Net_Crypto *c, int crypt_connection_id, const uint8_t *data, uint16_t length)
{
    const uint16_t max_length = MAX_CRYPTO_PACKET_SIZE - (1 + sizeof(uint16_t) + CRYPTO_MAC_SIZE);

    if (length == 0 || length > max_length) {
        LOGGER_ERROR(c->log, "zero-length or too large data packet: %d (max: %d)", length, max_length);
        return -1;
    }

    Crypto_Connection *conn = get_crypto_connection(c, crypt_connection_id);

    if (conn == nullptr) {
        LOGGER_ERROR(c->log, "connection id %d not found", crypt_connection_id);
        return -1;
    }

    const uint16_t packet_size = 1 + sizeof(uint16_t) + length + CRYPTO_MAC_SIZE;
    VLA(uint8_t, packet, packet_size);
    packet[0] = NET_PACKET_CRYPTO_DATA;
    memcpy(packet + 1, conn->sent_nonce + (CRYPTO_NONCE_SIZE - sizeof(uint16_t)), sizeof(uint16_t));
    const int len = encrypt_data_symmetric(conn->shared_key, conn->sent_nonce, data, length, packet + 1 + sizeof(uint16_t));

    if (len + 1 + sizeof(uint16_t) != packet_size) {
        LOGGER_ERROR(c->log, "encryption failed: %d", len);
        return -1;
    }

    increment_nonce(conn->sent_nonce);

    return send_packet_to(c, crypt_connection_id, packet, SIZEOF_VLA(packet));
}

/** @brief Creates and sends a data packet with buffer_start and num to the peer using the fastest route.
 *
 * @retval -1 on failure.
 * @retval 0 on success.
 */
non_null()
static int send_data_packet_helper(Net_Crypto *c, int crypt_connection_id, uint32_t buffer_start, uint32_t num,
                                   const uint8_t *data, uint16_t length)
{
    if (length == 0 || length > MAX_CRYPTO_DATA_SIZE) {
        LOGGER_ERROR(c->log, "zero-length or too large data packet: %d (max: %d)", length, MAX_CRYPTO_PACKET_SIZE);
        return -1;
    }

    num = net_htonl(num);
    buffer_start = net_htonl(buffer_start);
    const uint16_t padding_length = (MAX_CRYPTO_DATA_SIZE - length) % CRYPTO_MAX_PADDING;
    VLA(uint8_t, packet, sizeof(uint32_t) + sizeof(uint32_t) + padding_length + length);
    memcpy(packet, &buffer_start, sizeof(uint32_t));
    memcpy(packet + sizeof(uint32_t), &num, sizeof(uint32_t));
    memset(packet + (sizeof(uint32_t) * 2), PACKET_ID_PADDING, padding_length);
    memcpy(packet + (sizeof(uint32_t) * 2) + padding_length, data, length);

    return send_data_packet(c, crypt_connection_id, packet, SIZEOF_VLA(packet));
}

non_null()
static int reset_max_speed_reached(Net_Crypto *c, int crypt_connection_id)
{
    Crypto_Connection *conn = get_crypto_connection(c, crypt_connection_id);

    if (conn == nullptr) {
        return -1;
    }

    /* If last packet send failed, try to send packet again.
     * If sending it fails we won't be able to send the new packet. */
    if (conn->maximum_speed_reached) {
        Packet_Data *dt = nullptr;
        const uint32_t packet_num = conn->send_array.buffer_end - 1;
        const int ret = get_data_pointer(&conn->send_array, &dt, packet_num);

        if (ret == 1 && dt->sent_time == 0) {
            if (send_data_packet_helper(c, crypt_connection_id, conn->recv_array.buffer_start, packet_num,
                                        dt->data, dt->length) != 0) {
                return -1;
            }

            dt->sent_time = current_time_monotonic(c->mono_time);
        }

        conn->maximum_speed_reached = false;
    }

    return 0;
}

/**
 * @retval -1 if data could not be put in packet queue.
 * @return positive packet number if data was put into the queue.
 */
non_null()
static int64_t send_lossless_packet(Net_Crypto *c, int crypt_connection_id, const uint8_t *data, uint16_t length,
                                    bool congestion_control)
{
    if (length == 0 || length > MAX_CRYPTO_DATA_SIZE) {
        LOGGER_ERROR(c->log, "rejecting too large (or empty) packet of size %d on crypt connection %d", length,
                     crypt_connection_id);
        return -1;
    }

    Crypto_Connection *conn = get_crypto_connection(c, crypt_connection_id);

    if (conn == nullptr) {
        return -1;
    }

    /* If last packet send failed, try to send packet again.
     * If sending it fails we won't be able to send the new packet. */
    reset_max_speed_reached(c, crypt_connection_id);

    if (conn->maximum_speed_reached && congestion_control) {
        LOGGER_INFO(c->log, "congestion control: maximum speed reached on crypt connection %d", crypt_connection_id);
        return -1;
    }

    Packet_Data dt;
    dt.sent_time = 0;
    dt.length = length;
    memcpy(dt.data, data, length);
    const int64_t packet_num = add_data_end_of_buffer(c->log, &conn->send_array, &dt);

    if (packet_num == -1) {
        return -1;
    }

    if (!congestion_control && conn->maximum_speed_reached) {
        return packet_num;
    }

    if (send_data_packet_helper(c, crypt_connection_id, conn->recv_array.buffer_start, packet_num, data, length) == 0) {
        Packet_Data *dt1 = nullptr;

        if (get_data_pointer(&conn->send_array, &dt1, packet_num) == 1) {
            dt1->sent_time = current_time_monotonic(c->mono_time);
        }
    } else {
        conn->maximum_speed_reached = true;
        LOGGER_DEBUG(c->log, "send_data_packet failed (packet_num = %ld)", (long)packet_num);
    }

    return packet_num;
}

/**
 * @brief Get the lowest 2 bytes from the nonce and convert
 *   them to host byte format before returning them.
 */
non_null()
static uint16_t get_nonce_uint16(const uint8_t *nonce)
{
    uint16_t num;
    memcpy(&num, nonce + (CRYPTO_NONCE_SIZE - sizeof(uint16_t)), sizeof(uint16_t));
    return net_ntohs(num);
}

#define DATA_NUM_THRESHOLD 21845

/** @brief Handle a data packet.
 * Decrypt packet of length and put it into data.
 * data must be at least MAX_DATA_DATA_PACKET_SIZE big.
 *
 * @retval -1 on failure.
 * @return length of data on success.
 */
non_null()
static int handle_data_packet(const Net_Crypto *c, int crypt_connection_id, uint8_t *data, const uint8_t *packet,
                              uint16_t length)
{
    const uint16_t crypto_packet_overhead = 1 + sizeof(uint16_t) + CRYPTO_MAC_SIZE;

    if (length <= crypto_packet_overhead || length > MAX_CRYPTO_PACKET_SIZE) {
        return -1;
    }

    Crypto_Connection *conn = get_crypto_connection(c, crypt_connection_id);

    if (conn == nullptr) {
        return -1;
    }

    uint8_t nonce[CRYPTO_NONCE_SIZE];
    memcpy(nonce, conn->recv_nonce, CRYPTO_NONCE_SIZE);
    const uint16_t num_cur_nonce = get_nonce_uint16(nonce);
    uint16_t num;
    net_unpack_u16(packet + 1, &num);
    const uint16_t diff = num - num_cur_nonce;
    increment_nonce_number(nonce, diff);
    const int len = decrypt_data_symmetric(conn->shared_key, nonce, packet + 1 + sizeof(uint16_t),
                                           length - (1 + sizeof(uint16_t)), data);

    if ((unsigned int)len != length - crypto_packet_overhead) {
        return -1;
    }

    if (diff > DATA_NUM_THRESHOLD * 2) {
        increment_nonce_number(conn->recv_nonce, DATA_NUM_THRESHOLD);
    }

    return len;
}

/** @brief Send a request packet.
 *
 * @retval -1 on failure.
 * @retval 0 on success.
 */
non_null()
static int send_request_packet(Net_Crypto *c, int crypt_connection_id)
{
    const Crypto_Connection *conn = get_crypto_connection(c, crypt_connection_id);

    if (conn == nullptr) {
        return -1;
    }

    uint8_t data[MAX_CRYPTO_DATA_SIZE];
    const int len = generate_request_packet(data, sizeof(data), &conn->recv_array);

    if (len == -1) {
        return -1;
    }

    return send_data_packet_helper(c, crypt_connection_id, conn->recv_array.buffer_start, conn->send_array.buffer_end, data,
                                   len);
}

/** @brief Send up to max num previously requested data packets.
 *
 * @retval -1 on failure.
 * @return number of packets sent on success.
 */
non_null()
static int send_requested_packets(Net_Crypto *c, int crypt_connection_id, uint32_t max_num)
{
    if (max_num == 0) {
        return -1;
    }

    const Crypto_Connection *conn = get_crypto_connection(c, crypt_connection_id);

    if (conn == nullptr) {
        return -1;
    }

    const uint64_t temp_time = current_time_monotonic(c->mono_time);
    const uint32_t array_size = num_packets_array(&conn->send_array);
    uint32_t num_sent = 0;

    for (uint32_t i = 0; i < array_size; ++i) {
        Packet_Data *dt;
        const uint32_t packet_num = i + conn->send_array.buffer_start;
        const int ret = get_data_pointer(&conn->send_array, &dt, packet_num);

        if (ret == -1) {
            return -1;
        }

        if (ret == 0) {
            continue;
        }

        if (dt->sent_time != 0) {
            continue;
        }

        if (send_data_packet_helper(c, crypt_connection_id, conn->recv_array.buffer_start, packet_num, dt->data,
                                    dt->length) == 0) {
            dt->sent_time = temp_time;
            ++num_sent;
        }

        if (num_sent >= max_num) {
            break;
        }
    }

    return num_sent;
}


/** @brief Add a new temp packet to send repeatedly.
 *
 * @retval -1 on failure.
 * @retval 0 on success.
 */
non_null()
static int new_temp_packet(const Net_Crypto *c, int crypt_connection_id, const uint8_t *packet, uint16_t length)
{
    if (length == 0 || length > MAX_CRYPTO_PACKET_SIZE) {
        return -1;
    }

    Crypto_Connection *conn = get_crypto_connection(c, crypt_connection_id);

    if (conn == nullptr) {
        return -1;
    }

    uint8_t *temp_packet = (uint8_t *)malloc(length);

    if (temp_packet == nullptr) {
        return -1;
    }

    if (conn->temp_packet != nullptr) {
        free(conn->temp_packet);
    }

    memcpy(temp_packet, packet, length);
    conn->temp_packet = temp_packet;
    conn->temp_packet_length = length;
    conn->temp_packet_sent_time = 0;
    conn->temp_packet_num_sent = 0;
    return 0;
}

/** @brief Clear the temp packet.
 *
 * @retval -1 on failure.
 * @retval 0 on success.
 */
non_null()
static int clear_temp_packet(const Net_Crypto *c, int crypt_connection_id)
{
    Crypto_Connection *conn = get_crypto_connection(c, crypt_connection_id);

    if (conn == nullptr) {
        return -1;
    }

    if (conn->temp_packet != nullptr) {
        free(conn->temp_packet);
    }

    conn->temp_packet = nullptr;
    conn->temp_packet_length = 0;
    conn->temp_packet_sent_time = 0;
    conn->temp_packet_num_sent = 0;
    return 0;
}


/** @brief Send the temp packet.
 *
 * @retval -1 on failure.
 * @retval 0 on success.
 */
non_null()
static int send_temp_packet(Net_Crypto *c, int crypt_connection_id)
{
    Crypto_Connection *conn = get_crypto_connection(c, crypt_connection_id);

    if (conn == nullptr) {
        return -1;
    }

    if (conn->temp_packet == nullptr) {
        return -1;
    }

    if (send_packet_to(c, crypt_connection_id, conn->temp_packet, conn->temp_packet_length) != 0) {
        return -1;
    }

    conn->temp_packet_sent_time = current_time_monotonic(c->mono_time);
    ++conn->temp_packet_num_sent;
    return 0;
}

/** @brief Create a handshake packet and set it as a temp packet.
 * @param cookie must be COOKIE_LENGTH.
 *
 * @retval -1 on failure.
 * @retval 0 on success.
 */
non_null()
static int create_send_handshake(Net_Crypto *c, int crypt_connection_id, const uint8_t *cookie,
                                 const uint8_t *dht_public_key)
{
    const Crypto_Connection *conn = get_crypto_connection(c, crypt_connection_id);

    if (conn == nullptr) {
        return -1;
    }

    uint8_t handshake_packet[HANDSHAKE_PACKET_LENGTH];

    if (create_crypto_handshake(c, handshake_packet, cookie, conn->sent_nonce, conn->sessionpublic_key,
                                conn->public_key, dht_public_key) != sizeof(handshake_packet)) {
        return -1;
    }

    if (new_temp_packet(c, crypt_connection_id, handshake_packet, sizeof(handshake_packet)) != 0) {
        return -1;
    }

    send_temp_packet(c, crypt_connection_id);
    return 0;
}

/** @brief Send a kill packet.
 *
 * @retval -1 on failure.
 * @retval 0 on success.
 */
non_null()
static int send_kill_packet(Net_Crypto *c, int crypt_connection_id)
{
    const Crypto_Connection *conn = get_crypto_connection(c, crypt_connection_id);

    if (conn == nullptr) {
        return -1;
    }

    uint8_t kill_packet = PACKET_ID_KILL;
    return send_data_packet_helper(c, crypt_connection_id, conn->recv_array.buffer_start, conn->send_array.buffer_end,
                                   &kill_packet, sizeof(kill_packet));
}

non_null(1) nullable(3)
static void connection_kill(Net_Crypto *c, int crypt_connection_id, void *userdata)
{
    const Crypto_Connection *conn = get_crypto_connection(c, crypt_connection_id);

    if (conn == nullptr) {
        return;
    }

    if (conn->connection_status_callback != nullptr) {
        conn->connection_status_callback(conn->connection_status_callback_object, conn->connection_status_callback_id,
                                         false, userdata);
    }

    crypto_kill(c, crypt_connection_id);
}

/** @brief Handle a received data packet.
 *
 * @retval -1 on failure.
 * @retval 0 on success.
 */
non_null(1, 3) nullable(6)
static int handle_data_packet_core(Net_Crypto *c, int crypt_connection_id, const uint8_t *packet, uint16_t length,
                                   bool udp, void *userdata)
{
    if (length > MAX_CRYPTO_PACKET_SIZE || length <= CRYPTO_DATA_PACKET_MIN_SIZE) {
        return -1;
    }

    Crypto_Connection *conn = get_crypto_connection(c, crypt_connection_id);

    if (conn == nullptr) {
        return -1;
    }

    uint8_t data[MAX_DATA_DATA_PACKET_SIZE];
    const int len = handle_data_packet(c, crypt_connection_id, data, packet, length);

    if (len <= (int)(sizeof(uint32_t) * 2)) {
        return -1;
    }

    uint32_t buffer_start;
    uint32_t num;
    memcpy(&buffer_start, data, sizeof(uint32_t));
    memcpy(&num, data + sizeof(uint32_t), sizeof(uint32_t));
    buffer_start = net_ntohl(buffer_start);
    num = net_ntohl(num);

    uint64_t rtt_calc_time = 0;

    if (buffer_start != conn->send_array.buffer_start) {
        Packet_Data *packet_time;

        if (get_data_pointer(&conn->send_array, &packet_time, conn->send_array.buffer_start) == 1) {
            rtt_calc_time = packet_time->sent_time;
        }

        if (clear_buffer_until(&conn->send_array, buffer_start) != 0) {
            return -1;
        }
    }

    const uint8_t *real_data = data + (sizeof(uint32_t) * 2);
    uint16_t real_length = len - (sizeof(uint32_t) * 2);

    while (real_data[0] == PACKET_ID_PADDING) { /* Remove Padding */
        ++real_data;
        --real_length;

        if (real_length == 0) {
            return -1;
        }
    }

    if (real_data[0] == PACKET_ID_KILL) {
        connection_kill(c, crypt_connection_id, userdata);
        return 0;
    }

    if (conn->status == CRYPTO_CONN_NOT_CONFIRMED) {
        clear_temp_packet(c, crypt_connection_id);
        conn->status = CRYPTO_CONN_ESTABLISHED;

        if (conn->connection_status_callback != nullptr) {
            conn->connection_status_callback(conn->connection_status_callback_object, conn->connection_status_callback_id,
                                             true, userdata);
        }
    }

    if (real_data[0] == PACKET_ID_REQUEST) {
        uint64_t rtt_time;

        if (udp) {
            rtt_time = conn->rtt_time;
        } else {
            rtt_time = DEFAULT_TCP_PING_CONNECTION;
        }

        const int requested = handle_request_packet(c->mono_time, &conn->send_array,
                              real_data, real_length,
                              &rtt_calc_time, rtt_time);

        if (requested == -1) {
            return -1;
        }

        set_buffer_end(&conn->recv_array, num);
    } else if (real_data[0] >= PACKET_ID_RANGE_LOSSLESS_START && real_data[0] <= PACKET_ID_RANGE_LOSSLESS_END) {
        Packet_Data dt = {0};
        dt.length = real_length;
        memcpy(dt.data, real_data, real_length);

        if (add_data_to_buffer(&conn->recv_array, num, &dt) != 0) {
            return -1;
        }

        while (true) {
            const int ret = read_data_beg_buffer(&conn->recv_array, &dt);

            if (ret == -1) {
                break;
            }

            if (conn->connection_data_callback != nullptr) {
                conn->connection_data_callback(conn->connection_data_callback_object, conn->connection_data_callback_id, dt.data,
                                               dt.length, userdata);
            }

            /* conn might get killed in callback. */
            conn = get_crypto_connection(c, crypt_connection_id);

            if (conn == nullptr) {
                return -1;
            }
        }

        /* Packet counter. */
        ++conn->packet_counter;
    } else if (real_data[0] >= PACKET_ID_RANGE_LOSSY_START && real_data[0] <= PACKET_ID_RANGE_LOSSY_END) {

        set_buffer_end(&conn->recv_array, num);

        if (conn->connection_lossy_data_callback != nullptr) {
            conn->connection_lossy_data_callback(conn->connection_lossy_data_callback_object,
                                                 conn->connection_lossy_data_callback_id, real_data, real_length, userdata);
        }
    } else {
        return -1;
    }

    if (rtt_calc_time != 0) {
        uint64_t rtt_time = current_time_monotonic(c->mono_time) - rtt_calc_time;

        if (rtt_time < conn->rtt_time) {
            conn->rtt_time = rtt_time;
        }
    }

    return 0;
}

non_null()
static int handle_packet_cookie_response(Net_Crypto *c, int crypt_connection_id, const uint8_t *packet, uint16_t length)
{
    Crypto_Connection *conn = get_crypto_connection(c, crypt_connection_id);

    if (conn == nullptr) {
        return -1;
    }

    if (conn->status != CRYPTO_CONN_COOKIE_REQUESTING) {
        return -1;
    }

    uint8_t cookie[COOKIE_LENGTH];
    uint64_t number;

    if (handle_cookie_response(cookie, &number, packet, length, conn->shared_key) != sizeof(cookie)) {
        return -1;
    }

    if (number != conn->cookie_request_number) {
        return -1;
    }

    if (create_send_handshake(c, crypt_connection_id, cookie, conn->dht_public_key) != 0) {
        return -1;
    }

    conn->status = CRYPTO_CONN_HANDSHAKE_SENT;
    return 0;
}

non_null(1, 3) nullable(5)
static int handle_packet_crypto_hs(Net_Crypto *c, int crypt_connection_id, const uint8_t *packet, uint16_t length,
                                   void *userdata)
{
    Crypto_Connection *conn = get_crypto_connection(c, crypt_connection_id);

    if (conn == nullptr) {
        return -1;
    }

    if (conn->status != CRYPTO_CONN_COOKIE_REQUESTING
            && conn->status != CRYPTO_CONN_HANDSHAKE_SENT
            && conn->status != CRYPTO_CONN_NOT_CONFIRMED) {
        return -1;
    }

    uint8_t peer_real_pk[CRYPTO_PUBLIC_KEY_SIZE];
    uint8_t dht_public_key[CRYPTO_PUBLIC_KEY_SIZE];
    uint8_t cookie[COOKIE_LENGTH];

    if (!handle_crypto_handshake(c, conn->recv_nonce, conn->peersessionpublic_key, peer_real_pk, dht_public_key, cookie,
                                 packet, length, conn->public_key)) {
        return -1;
    }

    if (pk_equal(dht_public_key, conn->dht_public_key)) {
        encrypt_precompute(conn->peersessionpublic_key, conn->sessionsecret_key, conn->shared_key);

        if (conn->status == CRYPTO_CONN_COOKIE_REQUESTING) {
            if (create_send_handshake(c, crypt_connection_id, cookie, dht_public_key) != 0) {
                return -1;
            }
        }

        conn->status = CRYPTO_CONN_NOT_CONFIRMED;
    } else {
        if (conn->dht_pk_callback != nullptr) {
            conn->dht_pk_callback(conn->dht_pk_callback_object, conn->dht_pk_callback_number, dht_public_key, userdata);
        }
    }

    return 0;
}

non_null(1, 3) nullable(6)
static int handle_packet_crypto_data(Net_Crypto *c, int crypt_connection_id, const uint8_t *packet, uint16_t length,
                                     bool udp, void *userdata)
{
    const Crypto_Connection *conn = get_crypto_connection(c, crypt_connection_id);

    if (conn == nullptr) {
        return -1;
    }

    if (conn->status != CRYPTO_CONN_NOT_CONFIRMED && conn->status != CRYPTO_CONN_ESTABLISHED) {
        return -1;
    }

    return handle_data_packet_core(c, crypt_connection_id, packet, length, udp, userdata);
}

/** @brief Handle a packet that was received for the connection.
 *
 * @retval -1 on failure.
 * @retval 0 on success.
 */
non_null(1, 3) nullable(6)
static int handle_packet_connection(Net_Crypto *c, int crypt_connection_id, const uint8_t *packet, uint16_t length,
                                    bool udp, void *userdata)
{
    if (length == 0 || length > MAX_CRYPTO_PACKET_SIZE) {
        return -1;
    }

    switch (packet[0]) {
        case NET_PACKET_COOKIE_RESPONSE:
            return handle_packet_cookie_response(c, crypt_connection_id, packet, length);

        case NET_PACKET_CRYPTO_HS:
            return handle_packet_crypto_hs(c, crypt_connection_id, packet, length, userdata);

        case NET_PACKET_CRYPTO_DATA:
            return handle_packet_crypto_data(c, crypt_connection_id, packet, length, udp, userdata);

        default:
            return -1;
    }
}

/** @brief Set the size of the friend list to numfriends.
 *
 * @retval -1 if realloc fails.
 * @retval 0 if it succeeds.
 */
non_null()
static int realloc_cryptoconnection(Net_Crypto *c, uint32_t num)
{
    if (num == 0) {
        free(c->crypto_connections);
        c->crypto_connections = nullptr;
        return 0;
    }

    Crypto_Connection *newcrypto_connections = (Crypto_Connection *)realloc(c->crypto_connections,
            num * sizeof(Crypto_Connection));

    if (newcrypto_connections == nullptr) {
        return -1;
    }

    c->crypto_connections = newcrypto_connections;
    return 0;
}


/** @brief Create a new empty crypto connection.
 *
 * @retval -1 on failure.
 * @return connection id on success.
 */
non_null()
static int create_crypto_connection(Net_Crypto *c)
{
    int id = -1;

    for (uint32_t i = 0; i < c->crypto_connections_length; ++i) {
        if (c->crypto_connections[i].status == CRYPTO_CONN_FREE) {
            id = i;
            break;
        }
    }

    if (id == -1) {
        if (realloc_cryptoconnection(c, c->crypto_connections_length + 1) == 0) {
            id = c->crypto_connections_length;
            ++c->crypto_connections_length;
            c->crypto_connections[id] = empty_crypto_connection;
        }
    }

    if (id != -1) {
        // Memsetting float/double to 0 is non-portable, so we explicitly set them to 0
        c->crypto_connections[id].packet_recv_rate = 0;
        c->crypto_connections[id].packet_send_rate = 0;
        c->crypto_connections[id].last_packets_left_rem = 0;
        c->crypto_connections[id].packet_send_rate_requested = 0;
        c->crypto_connections[id].last_packets_left_requested_rem = 0;
        c->crypto_connections[id].status = CRYPTO_CONN_NO_CONNECTION;
    }

    return id;
}

/** @brief Wipe a crypto connection.
 *
 * @retval -1 on failure.
 * @retval 0 on success.
 */
non_null()
static int wipe_crypto_connection(Net_Crypto *c, int crypt_connection_id)
{
    if ((uint32_t)crypt_connection_id >= c->crypto_connections_length) {
        return -1;
    }

    if (c->crypto_connections == nullptr) {
        return -1;
    }

    const Crypto_Conn_State status = c->crypto_connections[crypt_connection_id].status;

    if (status == CRYPTO_CONN_FREE) {
        return -1;
    }

    uint32_t i;

    crypto_memzero(&c->crypto_connections[crypt_connection_id], sizeof(Crypto_Connection));

    /* check if we can resize the connections array */
    for (i = c->crypto_connections_length; i != 0; --i) {
        if (c->crypto_connections[i - 1].status != CRYPTO_CONN_FREE) {
            break;
        }
    }

    if (c->crypto_connections_length != i) {
        c->crypto_connections_length = i;
        realloc_cryptoconnection(c, c->crypto_connections_length);
    }

    return 0;
}

/** @brief Get crypto connection id from public key of peer.
 *
 * @retval -1 if there are no connections like we are looking for.
 * @return id if it found it.
 */
non_null()
static int getcryptconnection_id(const Net_Crypto *c, const uint8_t *public_key)
{
    for (uint32_t i = 0; i < c->crypto_connections_length; ++i) {
        if (!crypt_connection_id_is_valid(c, i)) {
            continue;
        }

        if (pk_equal(public_key, c->crypto_connections[i].public_key)) {
            return i;
        }
    }

    return -1;
}

/** @brief Add a source to the crypto connection.
 * This is to be used only when we have received a packet from that source.
 *
 * @retval -1 on failure.
 * @retval 0 if source was a direct UDP connection.
 * @return positive number on success.
 */
non_null()
static int crypto_connection_add_source(Net_Crypto *c, int crypt_connection_id, const IP_Port *source)
{
    Crypto_Connection *conn = get_crypto_connection(c, crypt_connection_id);

    if (conn == nullptr) {
        return -1;
    }

    if (net_family_is_ipv4(source->ip.family) || net_family_is_ipv6(source->ip.family)) {
        if (add_ip_port_connection(c, crypt_connection_id, source) != 0) {
            return -1;
        }

        if (net_family_is_ipv4(source->ip.family)) {
            conn->direct_lastrecv_timev4 = mono_time_get(c->mono_time);
        } else {
            conn->direct_lastrecv_timev6 = mono_time_get(c->mono_time);
        }

        return 0;
    }

    unsigned int tcp_connections_number;

    if (ip_port_to_tcp_connections_number(source, &tcp_connections_number)) {
        if (add_tcp_number_relay_connection(c->tcp_c, conn->connection_number_tcp, tcp_connections_number) == 0) {
            return 1;
        }
    }

    return -1;
}


/** @brief Set function to be called when someone requests a new connection to us.
 *
 * The set function should return -1 on failure and 0 on success.
 *
 * n_c is only valid for the duration of the function call.
 */
void new_connection_handler(Net_Crypto *c, new_connection_cb *new_connection_callback, void *object)
{
    c->new_connection_callback = new_connection_callback;
    c->new_connection_callback_object = object;
}

/** @brief Handle a handshake packet by someone who wants to initiate a new connection with us.
 * This calls the callback set by `new_connection_handler()` if the handshake is ok.
 *
 * @retval -1 on failure.
 * @retval 0 on success.
 */
non_null(1, 2, 3) nullable(5)
static int handle_new_connection_handshake(Net_Crypto *c, const IP_Port *source, const uint8_t *data, uint16_t length,
        void *userdata)
{
    New_Connection n_c;
    n_c.cookie = (uint8_t *)malloc(COOKIE_LENGTH);

    if (n_c.cookie == nullptr) {
        return -1;
    }

    n_c.source = *source;
    n_c.cookie_length = COOKIE_LENGTH;

    if (!handle_crypto_handshake(c, n_c.recv_nonce, n_c.peersessionpublic_key, n_c.public_key, n_c.dht_public_key,
                                 n_c.cookie, data, length, nullptr)) {
        free(n_c.cookie);
        return -1;
    }

    const int crypt_connection_id = getcryptconnection_id(c, n_c.public_key);

    if (crypt_connection_id != -1) {
        Crypto_Connection *conn = get_crypto_connection(c, crypt_connection_id);

        if (conn == nullptr) {
            return -1;
        }

        if (!pk_equal(n_c.dht_public_key, conn->dht_public_key)) {
            connection_kill(c, crypt_connection_id, userdata);
        } else {
            if (conn->status != CRYPTO_CONN_COOKIE_REQUESTING && conn->status != CRYPTO_CONN_HANDSHAKE_SENT) {
                free(n_c.cookie);
                return -1;
            }

            memcpy(conn->recv_nonce, n_c.recv_nonce, CRYPTO_NONCE_SIZE);
            memcpy(conn->peersessionpublic_key, n_c.peersessionpublic_key, CRYPTO_PUBLIC_KEY_SIZE);
            encrypt_precompute(conn->peersessionpublic_key, conn->sessionsecret_key, conn->shared_key);

            crypto_connection_add_source(c, crypt_connection_id, source);

            if (create_send_handshake(c, crypt_connection_id, n_c.cookie, n_c.dht_public_key) != 0) {
                free(n_c.cookie);
                return -1;
            }

            conn->status = CRYPTO_CONN_NOT_CONFIRMED;
            free(n_c.cookie);
            return 0;
        }
    }

    const int ret = c->new_connection_callback(c->new_connection_callback_object, &n_c);
    free(n_c.cookie);
    return ret;
}

/** @brief Accept a crypto connection.
 *
 * return -1 on failure.
 * return connection id on success.
 */
int accept_crypto_connection(Net_Crypto *c, const New_Connection *n_c)
{
    if (getcryptconnection_id(c, n_c->public_key) != -1) {
        return -1;
    }

    const int crypt_connection_id = create_crypto_connection(c);

    if (crypt_connection_id == -1) {
        LOGGER_ERROR(c->log, "Could not create new crypto connection");
        return -1;
    }

    Crypto_Connection *conn = &c->crypto_connections[crypt_connection_id];

    if (n_c->cookie_length != COOKIE_LENGTH) {
        wipe_crypto_connection(c, crypt_connection_id);
        return -1;
    }

    const int connection_number_tcp = new_tcp_connection_to(c->tcp_c, n_c->dht_public_key, crypt_connection_id);

    if (connection_number_tcp == -1) {
        wipe_crypto_connection(c, crypt_connection_id);
        return -1;
    }

    conn->connection_number_tcp = connection_number_tcp;
    memcpy(conn->public_key, n_c->public_key, CRYPTO_PUBLIC_KEY_SIZE);
    memcpy(conn->recv_nonce, n_c->recv_nonce, CRYPTO_NONCE_SIZE);
    memcpy(conn->peersessionpublic_key, n_c->peersessionpublic_key, CRYPTO_PUBLIC_KEY_SIZE);
    random_nonce(c->rng, conn->sent_nonce);
    crypto_new_keypair(c->rng, conn->sessionpublic_key, conn->sessionsecret_key);
    encrypt_precompute(conn->peersessionpublic_key, conn->sessionsecret_key, conn->shared_key);
    conn->status = CRYPTO_CONN_NOT_CONFIRMED;

    if (create_send_handshake(c, crypt_connection_id, n_c->cookie, n_c->dht_public_key) != 0) {
        kill_tcp_connection_to(c->tcp_c, conn->connection_number_tcp);
        wipe_crypto_connection(c, crypt_connection_id);
        return -1;
    }

    memcpy(conn->dht_public_key, n_c->dht_public_key, CRYPTO_PUBLIC_KEY_SIZE);
    conn->packet_send_rate = CRYPTO_PACKET_MIN_RATE;
    conn->packet_send_rate_requested = CRYPTO_PACKET_MIN_RATE;
    conn->packets_left = CRYPTO_MIN_QUEUE_LENGTH;
    conn->rtt_time = DEFAULT_PING_CONNECTION;
    crypto_connection_add_source(c, crypt_connection_id, &n_c->source);
    return crypt_connection_id;
}

/** @brief Create a crypto connection.
 * If one to that real public key already exists, return it.
 *
 * return -1 on failure.
 * return connection id on success.
 */
int new_crypto_connection(Net_Crypto *c, const uint8_t *real_public_key, const uint8_t *dht_public_key)
{
    int crypt_connection_id = getcryptconnection_id(c, real_public_key);

    if (crypt_connection_id != -1) {
        return crypt_connection_id;
    }

    crypt_connection_id = create_crypto_connection(c);

    if (crypt_connection_id == -1) {
        return -1;
    }

    Crypto_Connection *conn = &c->crypto_connections[crypt_connection_id];

    const int connection_number_tcp = new_tcp_connection_to(c->tcp_c, dht_public_key, crypt_connection_id);

    if (connection_number_tcp == -1) {
        wipe_crypto_connection(c, crypt_connection_id);
        return -1;
    }

    conn->connection_number_tcp = connection_number_tcp;
    memcpy(conn->public_key, real_public_key, CRYPTO_PUBLIC_KEY_SIZE);
    random_nonce(c->rng, conn->sent_nonce);
    crypto_new_keypair(c->rng, conn->sessionpublic_key, conn->sessionsecret_key);
    conn->status = CRYPTO_CONN_COOKIE_REQUESTING;
    conn->packet_send_rate = CRYPTO_PACKET_MIN_RATE;
    conn->packet_send_rate_requested = CRYPTO_PACKET_MIN_RATE;
    conn->packets_left = CRYPTO_MIN_QUEUE_LENGTH;
    conn->rtt_time = DEFAULT_PING_CONNECTION;
    memcpy(conn->dht_public_key, dht_public_key, CRYPTO_PUBLIC_KEY_SIZE);

    conn->cookie_request_number = random_u64(c->rng);
    uint8_t cookie_request[COOKIE_REQUEST_LENGTH];

    if (create_cookie_request(c, cookie_request, conn->dht_public_key, conn->cookie_request_number,
                              conn->shared_key) != sizeof(cookie_request)
            || new_temp_packet(c, crypt_connection_id, cookie_request, sizeof(cookie_request)) != 0) {
        kill_tcp_connection_to(c->tcp_c, conn->connection_number_tcp);
        wipe_crypto_connection(c, crypt_connection_id);
        return -1;
    }

    return crypt_connection_id;
}

/** @brief Set the direct ip of the crypto connection.
 *
 * Connected is 0 if we are not sure we are connected to that person, 1 if we are sure.
 *
 * return -1 on failure.
 * return 0 on success.
 */
int set_direct_ip_port(Net_Crypto *c, int crypt_connection_id, const IP_Port *ip_port, bool connected)
{
    Crypto_Connection *conn = get_crypto_connection(c, crypt_connection_id);

    if (conn == nullptr) {
        return -1;
    }

    if (add_ip_port_connection(c, crypt_connection_id, ip_port) != 0) {
        return -1;
    }

    const uint64_t direct_lastrecv_time = connected ? mono_time_get(c->mono_time) : 0;

    if (net_family_is_ipv4(ip_port->ip.family)) {
        conn->direct_lastrecv_timev4 = direct_lastrecv_time;
    } else {
        conn->direct_lastrecv_timev6 = direct_lastrecv_time;
    }

    return 0;
}


non_null(1, 3) nullable(5)
static int tcp_data_callback(void *object, int crypt_connection_id, const uint8_t *data, uint16_t length,
                             void *userdata)
{
    Net_Crypto *c = (Net_Crypto *)object;

    if (length == 0 || length > MAX_CRYPTO_PACKET_SIZE) {
        return -1;
    }

    const Crypto_Connection *conn = get_crypto_connection(c, crypt_connection_id);

    if (conn == nullptr) {
        return -1;
    }

    if (data[0] == NET_PACKET_COOKIE_REQUEST) {
        return tcp_handle_cookie_request(c, conn->connection_number_tcp, data, length);
    }

    const int ret = handle_packet_connection(c, crypt_connection_id, data, length, false, userdata);

    if (ret != 0) {
        return -1;
    }

    // TODO(irungentoo): detect and kill bad TCP connections.
    return 0;
}

non_null(1, 2, 4) nullable(6)
static int tcp_oob_callback(void *object, const uint8_t *public_key, unsigned int tcp_connections_number,
                            const uint8_t *data, uint16_t length, void *userdata)
{
    Net_Crypto *c = (Net_Crypto *)object;

    if (length == 0 || length > MAX_CRYPTO_PACKET_SIZE) {
        return -1;
    }

    if (data[0] == NET_PACKET_COOKIE_REQUEST) {
        return tcp_oob_handle_cookie_request(c, tcp_connections_number, public_key, data, length);
    }

    if (data[0] == NET_PACKET_CRYPTO_HS) {
        IP_Port source = tcp_connections_number_to_ip_port(tcp_connections_number);

        if (handle_new_connection_handshake(c, &source, data, length, userdata) != 0) {
            return -1;
        }

        return 0;
    }

    return -1;
}

/** @brief Add a tcp relay, associating it to a crypt_connection_id.
 *
 * return 0 if it was added.
 * return -1 if it wasn't.
 */
int add_tcp_relay_peer(Net_Crypto *c, int crypt_connection_id, const IP_Port *ip_port, const uint8_t *public_key)
{
    const Crypto_Connection *conn = get_crypto_connection(c, crypt_connection_id);

    if (conn == nullptr) {
        return -1;
    }

    return add_tcp_relay_connection(c->tcp_c, conn->connection_number_tcp, ip_port, public_key);
}

/** @brief Add a tcp relay to the array.
 *
 * return 0 if it was added.
 * return -1 if it wasn't.
 */
int add_tcp_relay(Net_Crypto *c, const IP_Port *ip_port, const uint8_t *public_key)
{
    return add_tcp_relay_global(c->tcp_c, ip_port, public_key);
}

/** @brief Return a random TCP connection number for use in send_tcp_onion_request.
 *
 * TODO(irungentoo): This number is just the index of an array that the elements can
 * change without warning.
 *
 * return TCP connection number on success.
 * return -1 on failure.
 */
int get_random_tcp_con_number(Net_Crypto *c)
{
    return get_random_tcp_onion_conn_number(c->tcp_c);
}

/** @brief Put IP_Port of a random onion TCP connection in ip_port.
 *
 * return true on success.
 * return false on failure.
 */
bool get_random_tcp_conn_ip_port(Net_Crypto *c, IP_Port *ip_port)
{
    return tcp_get_random_conn_ip_port(c->tcp_c, ip_port);
}

/** @brief Send an onion packet via the TCP relay corresponding to tcp_connections_number.
 *
 * return 0 on success.
 * return -1 on failure.
 */
int send_tcp_onion_request(Net_Crypto *c, unsigned int tcp_connections_number, const uint8_t *data, uint16_t length)
{
    return tcp_send_onion_request(c->tcp_c, tcp_connections_number, data, length);
}

/**
 * Send a forward request to the TCP relay with IP_Port tcp_forwarder,
 * requesting to forward data via a chain of dht nodes starting with dht_node.
 * A chain_length of 0 means that dht_node is the final destination of data.
 *
 * return 0 on success.
 * return -1 on failure.
 */
int send_tcp_forward_request(const Logger *logger, Net_Crypto *c, const IP_Port *tcp_forwarder, const IP_Port *dht_node,
                             const uint8_t *chain_keys, uint16_t chain_length,
                             const uint8_t *data, uint16_t data_length)
{
    return tcp_send_forward_request(logger, c->tcp_c, tcp_forwarder, dht_node,
                                    chain_keys, chain_length, data, data_length);
}

/** @brief Copy a maximum of num random TCP relays we are connected to to tcp_relays.
 *
 * NOTE that the family of the copied ip ports will be set to TCP_INET or TCP_INET6.
 *
 * return number of relays copied to tcp_relays on success.
 * return 0 on failure.
 */
unsigned int copy_connected_tcp_relays(Net_Crypto *c, Node_format *tcp_relays, uint16_t num)
{
    if (num == 0) {
        return 0;
    }

    return tcp_copy_connected_relays(c->tcp_c, tcp_relays, num);
}

non_null()
char *udp_copy_all_connected(IP_Port conn_ip_port, char *connections_report_string, uint16_t max_num, uint32_t* num)
{
    if (max_num == 0) {
        return 0;
    }

    char *p = connections_report_string;
    uint32_t copied = 0;

    // HINT: we have an established UDP connection
    if (!net_family_is_unspec(conn_ip_port.ip.family)) {
        if (net_family_is_ipv4(conn_ip_port.ip.family)) {
            char ipv4[20];
            memset(ipv4, 0, 20);
            snprintf(ipv4, 16, "%d.%d.%d.%d",
                conn_ip_port.ip.ip.v4.uint8[0],
                conn_ip_port.ip.ip.v4.uint8[1],
                conn_ip_port.ip.ip.v4.uint8[2],
                conn_ip_port.ip.ip.v4.uint8[3]
            );
            p += snprintf(p, 60, "port=%5d ip=%s\n", net_ntohs(conn_ip_port.port), ipv4);
        } else if (net_family_is_ipv6(conn_ip_port.ip.family)) {
            char ipv6[401];
            memset(ipv6, 0, 401);
            bool res = ip_parse_addr(&conn_ip_port.ip, ipv6, 400);
            if (!res) {
                snprintf(ipv6, 16, "<error in ipv6>");
            }
            p += snprintf(p, 60, "port=%5d ip=%s\n", net_ntohs(conn_ip_port.port), ipv6);
        }

        ++copied;
    }

    *num = *num + copied;
    return p;
}

void copy_friend_ip_port(Net_Crypto *c, const int crypt_conn_id, char *report_string, bool direct_connected)
{
    if (report_string == nullptr) {
        return;
    }

    char *p = report_string;

    if (direct_connected) {
        const IP_Port conn_ip_port = return_ip_port_connection(c, crypt_conn_id);

        if (!net_family_is_unspec(conn_ip_port.ip.family)) {
            if (net_family_is_ipv4(conn_ip_port.ip.family)) {
                char ipv4[20];
                memset(ipv4, 0, 20);
                snprintf(ipv4, 16, "%d.%d.%d.%d",
                    conn_ip_port.ip.ip.v4.uint8[0],
                    conn_ip_port.ip.ip.v4.uint8[1],
                    conn_ip_port.ip.ip.v4.uint8[2],
                    conn_ip_port.ip.ip.v4.uint8[3]
                );
                p += snprintf(p, 60, "%s %5d\n", ipv4, net_ntohs(conn_ip_port.port));
            } else if (net_family_is_ipv6(conn_ip_port.ip.family)) {
                char ipv6[401];
                memset(ipv6, 0, 401);
                bool res = ip_parse_addr(&conn_ip_port.ip, ipv6, 400);
                if (!res) {
                    snprintf(ipv6, 16, "<error in ipv6>");
                }
                p += snprintf(p, 60, "%s %5d\n", ipv6, net_ntohs(conn_ip_port.port));
            }
        }

    } else {
        // get tcp connections
        Crypto_Connection *conn = get_crypto_connection(c, crypt_conn_id);
        if (conn == nullptr) {
            return;
        }
        unsigned int conn_num_tcp = conn->connection_number_tcp;
        const TCP_Connection_to *con_to = get_connection(c->tcp_c, conn_num_tcp);
        if (con_to == nullptr) {
            return;
        }

        for (uint32_t i = 0; i < MAX_FRIEND_TCP_CONNECTIONS; ++i) {
            uint32_t tcp_con_num = con_to->connections[i].tcp_connection;
            const uint8_t status = con_to->connections[i].status;
            const uint8_t connection_id = con_to->connections[i].connection_id;

            if (tcp_con_num > 0 && status == TCP_CONNECTIONS_STATUS_ONLINE) {
                tcp_con_num -= 1;
                TCP_con *tcp_con = get_tcp_connection(c->tcp_c, tcp_con_num);
                if (tcp_con == nullptr) {
                    continue;
                }

                const IP_Port conn_ip_port = tcp_con_ip_port(tcp_con->connection);

                if (!net_family_is_unspec(conn_ip_port.ip.family)) {
                    if (net_family_is_ipv4(conn_ip_port.ip.family)) {
                        char ipv4[20];
                        memset(ipv4, 0, 20);
                        snprintf(ipv4, 16, "%d.%d.%d.%d",
                            conn_ip_port.ip.ip.v4.uint8[0],
                            conn_ip_port.ip.ip.v4.uint8[1],
                            conn_ip_port.ip.ip.v4.uint8[2],
                            conn_ip_port.ip.ip.v4.uint8[3]
                        );
                        p += snprintf(p, 60, "%s %5d\n", ipv4, net_ntohs(conn_ip_port.port));
                    } else if (net_family_is_ipv6(conn_ip_port.ip.family)) {
                        char ipv6[401];
                        memset(ipv6, 0, 401);
                        bool res = ip_parse_addr(&conn_ip_port.ip, ipv6, 400);
                        if (!res) {
                            snprintf(ipv6, 16, "<error in ipv6>");
                        }
                        p += snprintf(p, 60, "%s %5d\n", ipv6, net_ntohs(conn_ip_port.port));
                    }
                }
            }
        }

    }
}

non_null()
char *copy_all_udp_connections(Net_Crypto *c, char *connections_report_string, uint16_t max_num, uint32_t* num)
{
    if (max_num == 0) {
        return 0;
    }

    char *p = connections_report_string;
    uint32_t copied = 0;
    for (uint32_t i = 0; i < c->crypto_connections_length; ++i) {
        const Crypto_Connection *conn = get_crypto_connection(c, i);

        if (conn == nullptr) {
            continue;
        }

        if (conn->status < CRYPTO_CONN_COOKIE_REQUESTING) {
            continue;
        }

        bool direct_connected = false;

        if (!crypto_connection_status(c, i, &direct_connected, nullptr)) {
            continue;
        }

        // HINT: we have an established UDP connection
        const IP_Port conn_ip_port = return_ip_port_connection(c, i);
        if (!net_family_is_unspec(conn_ip_port.ip.family)) {
            if (net_family_is_ipv4(conn_ip_port.ip.family)) {
                char ipv4[20];
                memset(ipv4, 0, 20);
                snprintf(ipv4, 16, "%d.%d.%d.%d",
                    conn_ip_port.ip.ip.v4.uint8[0],
                    conn_ip_port.ip.ip.v4.uint8[1],
                    conn_ip_port.ip.ip.v4.uint8[2],
                    conn_ip_port.ip.ip.v4.uint8[3]
                );
                p += snprintf(p, 60, "port=%5d ip=%s\n", net_ntohs(conn_ip_port.port), ipv4);
            } else if (net_family_is_ipv6(conn_ip_port.ip.family)) {
                char ipv6[401];
                memset(ipv6, 0, 401);
                bool res = ip_parse_addr(&conn_ip_port.ip, ipv6, 400);
                if (!res) {
                    snprintf(ipv6, 16, "<error in ipv6>");
                }
                p += snprintf(p, 60, "port=%5d ip=%s\n", net_ntohs(conn_ip_port.port), ipv6);
            }

            ++copied;
        }
    }

    *num = *num + copied;
    return p;
}


non_null()
char *copy_all_connected_relays(Net_Crypto *c, char* relays_report_string, uint16_t max_num, uint32_t* num)
{
    if (max_num == 0) {
        return 0;
    }

    return tcp_copy_all_connected_relays(c->tcp_c, relays_report_string, max_num, num);
}

uint32_t copy_connected_tcp_relays_index(Net_Crypto *c, Node_format *tcp_relays, uint16_t num, uint32_t idx)
{
    if (num == 0) {
        return 0;
    }

    return tcp_copy_connected_relays_index(c->tcp_c, tcp_relays, num, idx);
}

non_null()
static void do_tcp(Net_Crypto *c, void *userdata)
{
    do_tcp_connections(c->log, c->tcp_c, userdata);

    for (uint32_t i = 0; i < c->crypto_connections_length; ++i) {
        const Crypto_Connection *conn = get_crypto_connection(c, i);

        if (conn == nullptr) {
            continue;
        }

        if (conn->status != CRYPTO_CONN_ESTABLISHED) {
            continue;
        }

        bool direct_connected = false;

        if (!crypto_connection_status(c, i, &direct_connected, nullptr)) {
            continue;
        }

        set_tcp_connection_to_status(c->tcp_c, conn->connection_number_tcp, !direct_connected);
    }
}

/** @brief Set function to be called when connection with crypt_connection_id goes connects/disconnects.
 *
 * The set function should return -1 on failure and 0 on success.
 * Note that if this function is set, the connection will clear itself on disconnect.
 * Object and id will be passed to this function untouched.
 * status is 1 if the connection is going online, 0 if it is going offline.
 *
 * return -1 on failure.
 * return 0 on success.
 */
int connection_status_handler(const Net_Crypto *c, int crypt_connection_id,
                              connection_status_cb *connection_status_callback, void *object, int id)
{
    Crypto_Connection *conn = get_crypto_connection(c, crypt_connection_id);

    if (conn == nullptr) {
        return -1;
    }

    conn->connection_status_callback = connection_status_callback;
    conn->connection_status_callback_object = object;
    conn->connection_status_callback_id = id;
    return 0;
}

/** @brief Set function to be called when connection with crypt_connection_id receives a lossless data packet of length.
 *
 * The set function should return -1 on failure and 0 on success.
 * Object and id will be passed to this function untouched.
 *
 * return -1 on failure.
 * return 0 on success.
 */
int connection_data_handler(const Net_Crypto *c, int crypt_connection_id,
                            connection_data_cb *connection_data_callback, void *object, int id)
{
    Crypto_Connection *conn = get_crypto_connection(c, crypt_connection_id);

    if (conn == nullptr) {
        return -1;
    }

    conn->connection_data_callback = connection_data_callback;
    conn->connection_data_callback_object = object;
    conn->connection_data_callback_id = id;
    return 0;
}

/** @brief Set function to be called when connection with crypt_connection_id receives a lossy data packet of length.
 *
 * The set function should return -1 on failure and 0 on success.
 * Object and id will be passed to this function untouched.
 *
 * return -1 on failure.
 * return 0 on success.
 */
int connection_lossy_data_handler(const Net_Crypto *c, int crypt_connection_id,
                                  connection_lossy_data_cb *connection_lossy_data_callback,
                                  void *object, int id)
{
    Crypto_Connection *conn = get_crypto_connection(c, crypt_connection_id);

    if (conn == nullptr) {
        return -1;
    }

    conn->connection_lossy_data_callback = connection_lossy_data_callback;
    conn->connection_lossy_data_callback_object = object;
    conn->connection_lossy_data_callback_id = id;
    return 0;
}


/** @brief Set the function for this friend that will be callbacked with object and number if
 * the friend sends us a different dht public key than we have associated to him.
 *
 * If this function is called, the connection should be recreated with the new public key.
 *
 * object and number will be passed as argument to this function.
 *
 * return -1 on failure.
 * return 0 on success.
 */
int nc_dht_pk_callback(const Net_Crypto *c, int crypt_connection_id, dht_pk_cb *function, void *object, uint32_t number)
{
    Crypto_Connection *conn = get_crypto_connection(c, crypt_connection_id);

    if (conn == nullptr) {
        return -1;
    }

    conn->dht_pk_callback = function;
    conn->dht_pk_callback_object = object;
    conn->dht_pk_callback_number = number;
    return 0;
}

/** @brief Get the crypto connection id from the ip_port.
 *
 * return -1 on failure.
 * return connection id on success.
 */
non_null()
static int crypto_id_ip_port(const Net_Crypto *c, const IP_Port *ip_port)
{
    return bs_list_find(&c->ip_port_list, (const uint8_t *)ip_port);
}

#define CRYPTO_MIN_PACKET_SIZE (1 + sizeof(uint16_t) + CRYPTO_MAC_SIZE)

/** @brief Handle raw UDP packets coming directly from the socket.
 *
 * Handles:
 * Cookie response packets.
 * Crypto handshake packets.
 * Crypto data packets.
 *
 */
non_null(1, 2, 3) nullable(5)
static int udp_handle_packet(void *object, const IP_Port *source, const uint8_t *packet, uint16_t length,
                             void *userdata)
{
    Net_Crypto *c = (Net_Crypto *)object;

    if (length <= CRYPTO_MIN_PACKET_SIZE || length > MAX_CRYPTO_PACKET_SIZE) {
        return 1;
    }

    const int crypt_connection_id = crypto_id_ip_port(c, source);

    if (crypt_connection_id == -1) {
        if (packet[0] != NET_PACKET_CRYPTO_HS) {
            return 1;
        }

        if (handle_new_connection_handshake(c, source, packet, length, userdata) != 0) {
            return 1;
        }

        return 0;
    }

    if (handle_packet_connection(c, crypt_connection_id, packet, length, true, userdata) != 0) {
        return 1;
    }

    Crypto_Connection *conn = get_crypto_connection(c, crypt_connection_id);

    if (conn == nullptr) {
        return -1;
    }

    if (net_family_is_ipv4(source->ip.family)) {
        conn->direct_lastrecv_timev4 = mono_time_get(c->mono_time);
    } else {
        conn->direct_lastrecv_timev6 = mono_time_get(c->mono_time);
    }

    return 0;
}

/** @brief The dT for the average packet receiving rate calculations.
 * Also used as the
 */
#define PACKET_COUNTER_AVERAGE_INTERVAL 50

/** @brief Ratio of recv queue size / recv packet rate (in seconds) times
 * the number of ms between request packets to send at that ratio
 */
#define REQUEST_PACKETS_COMPARE_CONSTANT (0.125 * 100.0)

/** @brief Timeout for increasing speed after congestion event (in ms). */
#define CONGESTION_EVENT_TIMEOUT 1000

/**
 * If the send queue is SEND_QUEUE_RATIO times larger than the
 * calculated link speed the packet send speed will be reduced
 * by a value depending on this number.
 */
#define SEND_QUEUE_RATIO 2.0

non_null()
static void send_crypto_packets(Net_Crypto *c)
{
    const uint64_t temp_time = current_time_monotonic(c->mono_time);
    double total_send_rate = 0;
    uint32_t peak_request_packet_interval = -1;

    for (uint32_t i = 0; i < c->crypto_connections_length; ++i) {
        Crypto_Connection *conn = get_crypto_connection(c, i);

        if (conn == nullptr) {
            continue;
        }

        if ((CRYPTO_SEND_PACKET_INTERVAL + conn->temp_packet_sent_time) < temp_time) {
            send_temp_packet(c, i);
        }

        if ((conn->status == CRYPTO_CONN_NOT_CONFIRMED || conn->status == CRYPTO_CONN_ESTABLISHED)
                && (CRYPTO_SEND_PACKET_INTERVAL + conn->last_request_packet_sent) < temp_time) {
            if (send_request_packet(c, i) == 0) {
                conn->last_request_packet_sent = temp_time;
            }
        }

        if (conn->status == CRYPTO_CONN_ESTABLISHED) {
            if (conn->packet_recv_rate > CRYPTO_PACKET_MIN_RATE) {
                double request_packet_interval = REQUEST_PACKETS_COMPARE_CONSTANT / ((num_packets_array(
                                                     &conn->recv_array) + 1.0) / (conn->packet_recv_rate + 1.0));

                const double request_packet_interval2 = ((CRYPTO_PACKET_MIN_RATE / conn->packet_recv_rate) *
                                                        (double)CRYPTO_SEND_PACKET_INTERVAL) + (double)PACKET_COUNTER_AVERAGE_INTERVAL;

                if (request_packet_interval2 < request_packet_interval) {
                    request_packet_interval = request_packet_interval2;
                }

                if (request_packet_interval < PACKET_COUNTER_AVERAGE_INTERVAL) {
                    request_packet_interval = PACKET_COUNTER_AVERAGE_INTERVAL;
                }

                if (request_packet_interval > CRYPTO_SEND_PACKET_INTERVAL) {
                    request_packet_interval = CRYPTO_SEND_PACKET_INTERVAL;
                }

                if (temp_time - conn->last_request_packet_sent > (uint64_t)request_packet_interval) {
                    if (send_request_packet(c, i) == 0) {
                        conn->last_request_packet_sent = temp_time;
                    }
                }

                if (request_packet_interval < peak_request_packet_interval) {
                    peak_request_packet_interval = request_packet_interval;
                }
            }

            if ((PACKET_COUNTER_AVERAGE_INTERVAL + conn->packet_counter_set) < temp_time) {
                const double dt = (double)(temp_time - conn->packet_counter_set);

                conn->packet_recv_rate = (double)conn->packet_counter / (dt / 1000.0);
                conn->packet_counter = 0;
                conn->packet_counter_set = temp_time;

                const uint32_t packets_sent = conn->packets_sent;
                conn->packets_sent = 0;

                const uint32_t packets_resent = conn->packets_resent;
                conn->packets_resent = 0;

                /* conjestion control
                 *  calculate a new value of conn->packet_send_rate based on some data
                 */

                const unsigned int pos = conn->last_sendqueue_counter % CONGESTION_QUEUE_ARRAY_SIZE;
                conn->last_sendqueue_size[pos] = num_packets_array(&conn->send_array);

                long signed int sum = 0;
                sum = (long signed int)conn->last_sendqueue_size[pos] -
                      (long signed int)conn->last_sendqueue_size[(pos + 1) % CONGESTION_QUEUE_ARRAY_SIZE];

                const unsigned int n_p_pos = conn->last_sendqueue_counter % CONGESTION_LAST_SENT_ARRAY_SIZE;
                conn->last_num_packets_sent[n_p_pos] = packets_sent;
                conn->last_num_packets_resent[n_p_pos] = packets_resent;

                conn->last_sendqueue_counter = (conn->last_sendqueue_counter + 1) %
                                               (CONGESTION_QUEUE_ARRAY_SIZE * CONGESTION_LAST_SENT_ARRAY_SIZE);

                bool direct_connected = false;
                /* return value can be ignored since the `if` above ensures the connection is established */
                crypto_connection_status(c, i, &direct_connected, nullptr);

                /* When switching from TCP to UDP, don't change the packet send rate for CONGESTION_EVENT_TIMEOUT ms. */
                if (!(direct_connected && conn->last_tcp_sent + CONGESTION_EVENT_TIMEOUT > temp_time)) {
                    long signed int total_sent = 0;
                    long signed int total_resent = 0;

                    // TODO(irungentoo): use real delay
                    unsigned int delay = (unsigned int)(((double)conn->rtt_time / PACKET_COUNTER_AVERAGE_INTERVAL) + 0.5);
                    const unsigned int packets_set_rem_array = CONGESTION_LAST_SENT_ARRAY_SIZE - CONGESTION_QUEUE_ARRAY_SIZE;

                    if (delay > packets_set_rem_array) {
                        delay = packets_set_rem_array;
                    }

                    for (unsigned j = 0; j < CONGESTION_QUEUE_ARRAY_SIZE; ++j) {
                        const unsigned int ind = (j + (packets_set_rem_array  - delay) + n_p_pos) % CONGESTION_LAST_SENT_ARRAY_SIZE;
                        total_sent += conn->last_num_packets_sent[ind];
                        total_resent += conn->last_num_packets_resent[ind];
                    }

                    if (sum > 0) {
                        total_sent -= sum;
                    } else {
                        if (total_resent > -sum) {
                            total_resent = -sum;
                        }
                    }

                    /* if queue is too big only allow resending packets. */
                    const uint32_t npackets = num_packets_array(&conn->send_array);
                    double min_speed = 1000.0 * (((double)total_sent) / ((double)CONGESTION_QUEUE_ARRAY_SIZE *
                                                 PACKET_COUNTER_AVERAGE_INTERVAL));

                    const double min_speed_request = 1000.0 * (((double)(total_sent + total_resent)) / (
                                                         (double)CONGESTION_QUEUE_ARRAY_SIZE * PACKET_COUNTER_AVERAGE_INTERVAL));

                    if (min_speed < CRYPTO_PACKET_MIN_RATE) {
                        min_speed = CRYPTO_PACKET_MIN_RATE;
                    }

                    const double send_array_ratio = (double)npackets / min_speed;

                    // TODO(irungentoo): Improve formula?
                    if (send_array_ratio > SEND_QUEUE_RATIO && CRYPTO_MIN_QUEUE_LENGTH < npackets) {
                        conn->packet_send_rate = min_speed * (1.0 / (send_array_ratio / SEND_QUEUE_RATIO));
                    } else if (conn->last_congestion_event + CONGESTION_EVENT_TIMEOUT < temp_time) {
                        conn->packet_send_rate = min_speed * 1.2;
                    } else {
                        conn->packet_send_rate = min_speed * 0.9;
                    }

                    conn->packet_send_rate_requested = min_speed_request * 1.2;

                    if (conn->packet_send_rate < CRYPTO_PACKET_MIN_RATE) {
                        conn->packet_send_rate = CRYPTO_PACKET_MIN_RATE;
                    }

                    if (conn->packet_send_rate_requested < conn->packet_send_rate) {
                        conn->packet_send_rate_requested = conn->packet_send_rate;
                    }
                }
            }

            if (conn->last_packets_left_set == 0 || conn->last_packets_left_requested_set == 0) {
                conn->last_packets_left_requested_set = temp_time;
                conn->last_packets_left_set = temp_time;
                conn->packets_left_requested = CRYPTO_MIN_QUEUE_LENGTH;
                conn->packets_left = CRYPTO_MIN_QUEUE_LENGTH;
            } else {
                if (((uint64_t)((1000.0 / conn->packet_send_rate) + 0.5) + conn->last_packets_left_set) <= temp_time) {
                    double n_packets = conn->packet_send_rate * (((double)(temp_time - conn->last_packets_left_set)) / 1000.0);
                    n_packets += conn->last_packets_left_rem;

                    const uint32_t num_packets = n_packets;
                    const double rem = n_packets - (double)num_packets;

                    if (conn->packets_left > num_packets * 4 + CRYPTO_MIN_QUEUE_LENGTH) {
                        conn->packets_left = num_packets * 4 + CRYPTO_MIN_QUEUE_LENGTH;
                    } else {
                        conn->packets_left += num_packets;
                    }

                    conn->last_packets_left_set = temp_time;
                    conn->last_packets_left_rem = rem;
                }

                if (((uint64_t)((1000.0 / conn->packet_send_rate_requested) + 0.5) + conn->last_packets_left_requested_set) <=
                        temp_time) {
                    double n_packets = conn->packet_send_rate_requested * (((double)(temp_time - conn->last_packets_left_requested_set)) /
                                       1000.0);
                    n_packets += conn->last_packets_left_requested_rem;

                    uint32_t num_packets = n_packets;
                    double rem = n_packets - (double)num_packets;
                    conn->packets_left_requested = num_packets;

                    conn->last_packets_left_requested_set = temp_time;
                    conn->last_packets_left_requested_rem = rem;
                }

                if (conn->packets_left > conn->packets_left_requested) {
                    conn->packets_left_requested = conn->packets_left;
                }
            }

            const int ret = send_requested_packets(c, i, conn->packets_left_requested);

            if (ret != -1) {
                conn->packets_left_requested -= ret;
                conn->packets_resent += ret;

                if ((unsigned int)ret < conn->packets_left) {
                    conn->packets_left -= ret;
                } else {
                    conn->last_congestion_event = temp_time;
                    conn->packets_left = 0;
                }
            }

            if (conn->packet_send_rate > CRYPTO_PACKET_MIN_RATE * 1.5) {
                total_send_rate += conn->packet_send_rate;
            }
        }
    }

    c->current_sleep_time = -1;
    uint32_t sleep_time = peak_request_packet_interval;

    if (c->current_sleep_time > sleep_time) {
        c->current_sleep_time = sleep_time;
    }

    if (total_send_rate > CRYPTO_PACKET_MIN_RATE) {
        sleep_time = 1000.0 / total_send_rate;

        if (c->current_sleep_time > sleep_time) {
            c->current_sleep_time = sleep_time + 1;
        }
    }

    sleep_time = CRYPTO_SEND_PACKET_INTERVAL;

    if (c->current_sleep_time > sleep_time) {
        c->current_sleep_time = sleep_time;
    }
}

/**
 * @retval 1 if max speed was reached for this connection (no more data can be physically through the pipe).
 * @retval 0 if it wasn't reached.
 */
bool max_speed_reached(Net_Crypto *c, int crypt_connection_id)
{
    return reset_max_speed_reached(c, crypt_connection_id) != 0;
}

/**
 * @return the number of packet slots left in the sendbuffer.
 * @retval 0 if failure.
 */
uint32_t crypto_num_free_sendqueue_slots(const Net_Crypto *c, int crypt_connection_id)
{
    const Crypto_Connection *conn = get_crypto_connection(c, crypt_connection_id);

    if (conn == nullptr) {
        return 0;
    }

    const uint32_t max_packets = CRYPTO_PACKET_BUFFER_SIZE - num_packets_array(&conn->send_array);

    if (conn->packets_left < max_packets) {
        return conn->packets_left;
    }

    return max_packets;
}

/** @brief Sends a lossless cryptopacket.
 *
 * return -1 if data could not be put in packet queue.
 * return positive packet number if data was put into the queue.
 *
 * The first byte of data must be in the PACKET_ID_RANGE_LOSSLESS.
 *
 * congestion_control: should congestion control apply to this packet?
 */
int64_t write_cryptpacket(Net_Crypto *c, int crypt_connection_id, const uint8_t *data, uint16_t length,
                          bool congestion_control)
{
    if (length == 0) {
        // We need at least a packet id.
        LOGGER_ERROR(c->log, "rejecting empty packet for crypto connection %d", crypt_connection_id);
        return -1;
    }

    if (data[0] < PACKET_ID_RANGE_LOSSLESS_START || data[0] > PACKET_ID_RANGE_LOSSLESS_END) {
        LOGGER_ERROR(c->log, "rejecting lossless packet with out-of-range id %d", data[0]);
        return -1;
    }

    Crypto_Connection *conn = get_crypto_connection(c, crypt_connection_id);

    if (conn == nullptr) {
        LOGGER_WARNING(c->log, "invalid crypt connection id %d", crypt_connection_id);
        return -1;
    }

    if (conn->status != CRYPTO_CONN_ESTABLISHED) {
        LOGGER_WARNING(c->log, "attempted to send packet to non-established connection %d", crypt_connection_id);
        return -1;
    }

    if (congestion_control && conn->packets_left == 0) {
        LOGGER_ERROR(c->log, "congestion control: rejecting packet of length %d on crypt connection %d", length,
                     crypt_connection_id);
        return -1;
    }

    const int64_t ret = send_lossless_packet(c, crypt_connection_id, data, length, congestion_control);

    if (ret == -1) {
        return -1;
    }

    if (congestion_control) {
        --conn->packets_left;
        --conn->packets_left_requested;
        ++conn->packets_sent;
    }

    return ret;
}

/** @brief Check if packet_number was received by the other side.
 *
 * packet_number must be a valid packet number of a packet sent on this connection.
 *
 * return -1 on failure.
 * return 0 on success.
 *
 * Note: The condition `buffer_end - buffer_start < packet_number - buffer_start` is
 * a trick which handles situations `buffer_end >= buffer_start` and
 * `buffer_end < buffer_start` (when buffer_end overflowed) both correctly.
 *
 * It CANNOT be simplified to `packet_number < buffer_start`, as it will fail
 * when `buffer_end < buffer_start`.
 */
int cryptpacket_received(const Net_Crypto *c, int crypt_connection_id, uint32_t packet_number)
{
    const Crypto_Connection *conn = get_crypto_connection(c, crypt_connection_id);

    if (conn == nullptr) {
        return -1;
    }

    const uint32_t num = num_packets_array(&conn->send_array);
    const uint32_t num1 = packet_number - conn->send_array.buffer_start;

    if (num >= num1) {
        return -1;
    }

    return 0;
}

/** @brief Sends a lossy cryptopacket.
 *
 * return -1 on failure.
 * return 0 on success.
 *
 * The first byte of data must be in the PACKET_ID_RANGE_LOSSY.
 */
int send_lossy_cryptpacket(Net_Crypto *c, int crypt_connection_id, const uint8_t *data, uint16_t length)
{
    if (length == 0 || length > MAX_CRYPTO_DATA_SIZE) {
        return -1;
    }

    if (data[0] < PACKET_ID_RANGE_LOSSY_START || data[0] > PACKET_ID_RANGE_LOSSY_END) {
        return -1;
    }

    Crypto_Connection *conn = get_crypto_connection(c, crypt_connection_id);

    int ret = -1;

    if (conn != nullptr) {
        const uint32_t buffer_start = conn->recv_array.buffer_start;
        const uint32_t buffer_end = conn->send_array.buffer_end;
        ret = send_data_packet_helper(c, crypt_connection_id, buffer_start, buffer_end, data, length);
    }

    return ret;
}

/** @brief Kill a crypto connection.
 *
 * return -1 on failure.
 * return 0 on success.
 */
int crypto_kill(Net_Crypto *c, int crypt_connection_id)
{
    Crypto_Connection *conn = get_crypto_connection(c, crypt_connection_id);

    int ret = -1;

    if (conn != nullptr) {
        if (conn->status == CRYPTO_CONN_ESTABLISHED) {
            send_kill_packet(c, crypt_connection_id);
        }

        kill_tcp_connection_to(c->tcp_c, conn->connection_number_tcp);

        bs_list_remove(&c->ip_port_list, (uint8_t *)&conn->ip_portv4, crypt_connection_id);
        bs_list_remove(&c->ip_port_list, (uint8_t *)&conn->ip_portv6, crypt_connection_id);
        clear_temp_packet(c, crypt_connection_id);
        clear_buffer(&conn->send_array);
        clear_buffer(&conn->recv_array);
        ret = wipe_crypto_connection(c, crypt_connection_id);
    }

    return ret;
}

bool crypto_connection_status(const Net_Crypto *c, int crypt_connection_id, bool *direct_connected,
                              uint32_t *online_tcp_relays)
{
    const Crypto_Connection *conn = get_crypto_connection(c, crypt_connection_id);

    if (conn == nullptr) {
        return false;
    }

    if (direct_connected != nullptr) {
        *direct_connected = false;

        const uint64_t current_time = mono_time_get(c->mono_time);

        if ((UDP_DIRECT_TIMEOUT + conn->direct_lastrecv_timev4) > current_time) {
            *direct_connected = true;
        } else if ((UDP_DIRECT_TIMEOUT + conn->direct_lastrecv_timev6) > current_time) {
            *direct_connected = true;
        }
    }

    if (online_tcp_relays != nullptr) {
        *online_tcp_relays = tcp_connection_to_online_tcp_relays(c->tcp_c, conn->connection_number_tcp);
    }

    return true;
}

void new_keys(Net_Crypto *c)
{
    crypto_new_keypair(c->rng, c->self_public_key, c->self_secret_key);
}

/** @brief Save the public and private keys to the keys array.
 * Length must be CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_SECRET_KEY_SIZE.
 *
 * TODO(irungentoo): Save only secret key.
 */
void save_keys(const Net_Crypto *c, uint8_t *keys)
{
    memcpy(keys, c->self_public_key, CRYPTO_PUBLIC_KEY_SIZE);
    memcpy(keys + CRYPTO_PUBLIC_KEY_SIZE, c->self_secret_key, CRYPTO_SECRET_KEY_SIZE);
}

/** @brief Load the secret key.
 * Length must be CRYPTO_SECRET_KEY_SIZE.
 */
void load_secret_key(Net_Crypto *c, const uint8_t *sk)
{
    memcpy(c->self_secret_key, sk, CRYPTO_SECRET_KEY_SIZE);
    crypto_derive_public_key(c->self_public_key, c->self_secret_key);
}

/** @brief Create new instance of Net_Crypto.
 * Sets all the global connection variables to their default values.
 */
Net_Crypto *new_net_crypto(const Logger *log, const Random *rng, const Network *ns, Mono_Time *mono_time, DHT *dht, const TCP_Proxy_Info *proxy_info)
{
    if (dht == nullptr) {
        return nullptr;
    }

    Net_Crypto *temp = (Net_Crypto *)calloc(1, sizeof(Net_Crypto));

    if (temp == nullptr) {
        return nullptr;
    }

    temp->log = log;
    temp->rng = rng;
    temp->mono_time = mono_time;
    temp->ns = ns;

    temp->tcp_c = new_tcp_connections(log, rng, ns, mono_time, dht_get_self_secret_key(dht), proxy_info);

    if (temp->tcp_c == nullptr) {
        free(temp);
        return nullptr;
    }

    set_packet_tcp_connection_callback(temp->tcp_c, &tcp_data_callback, temp);
    set_oob_packet_tcp_connection_callback(temp->tcp_c, &tcp_oob_callback, temp);

    temp->dht = dht;

    new_keys(temp);
    new_symmetric_key(rng, temp->secret_symmetric_key);

    temp->current_sleep_time = CRYPTO_SEND_PACKET_INTERVAL;

    networking_registerhandler(dht_get_net(dht), NET_PACKET_COOKIE_REQUEST, &udp_handle_cookie_request, temp);
    networking_registerhandler(dht_get_net(dht), NET_PACKET_COOKIE_RESPONSE, &udp_handle_packet, temp);
    networking_registerhandler(dht_get_net(dht), NET_PACKET_CRYPTO_HS, &udp_handle_packet, temp);
    networking_registerhandler(dht_get_net(dht), NET_PACKET_CRYPTO_DATA, &udp_handle_packet, temp);

    bs_list_init(&temp->ip_port_list, sizeof(IP_Port), 8);

    return temp;
}

non_null(1) nullable(2)
static void kill_timedout(Net_Crypto *c, void *userdata)
{
    for (uint32_t i = 0; i < c->crypto_connections_length; ++i) {
        const Crypto_Connection *conn = get_crypto_connection(c, i);

        if (conn == nullptr) {
            continue;
        }

        if (conn->status == CRYPTO_CONN_COOKIE_REQUESTING || conn->status == CRYPTO_CONN_HANDSHAKE_SENT
                || conn->status == CRYPTO_CONN_NOT_CONFIRMED) {
            if (conn->temp_packet_num_sent < MAX_NUM_SENDPACKET_TRIES) {
                continue;
            }

            connection_kill(c, i, userdata);
        }

#if 0

        if (conn->status == CRYPTO_CONN_ESTABLISHED) {
            // TODO(irungentoo): add a timeout here?
            /* do_timeout_here(); */
        }

#endif
    }
}

/** return the optimal interval in ms for running do_net_crypto. */
uint32_t crypto_run_interval(const Net_Crypto *c)
{
    return c->current_sleep_time;
}

/** Main loop. */
void do_net_crypto(Net_Crypto *c, void *userdata)
{
    kill_timedout(c, userdata);
    do_tcp(c, userdata);
    send_crypto_packets(c);
}

void kill_net_crypto(Net_Crypto *c)
{
    if (c == nullptr) {
        return;
    }

    for (uint32_t i = 0; i < c->crypto_connections_length; ++i) {
        crypto_kill(c, i);
    }

    kill_tcp_connections(c->tcp_c);
    bs_list_free(&c->ip_port_list);
    networking_registerhandler(dht_get_net(c->dht), NET_PACKET_COOKIE_REQUEST, nullptr, nullptr);
    networking_registerhandler(dht_get_net(c->dht), NET_PACKET_COOKIE_RESPONSE, nullptr, nullptr);
    networking_registerhandler(dht_get_net(c->dht), NET_PACKET_CRYPTO_HS, nullptr, nullptr);
    networking_registerhandler(dht_get_net(c->dht), NET_PACKET_CRYPTO_DATA, nullptr, nullptr);
    crypto_memzero(c, sizeof(Net_Crypto));
    free(c);
}
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2018 The TokTok team.
 * Copyright © 2013 Tox project.
 */

/**
 * Functions for the core networking.
 */

#ifdef __APPLE__
#define _DARWIN_C_SOURCE
#endif

// For Solaris.
#ifdef __sun
#define __EXTENSIONS__ 1
#endif

// For Linux (and some BSDs).
#ifndef _XOPEN_SOURCE
#define _XOPEN_SOURCE 700
#endif

#if defined(_WIN32) && _WIN32_WINNT >= _WIN32_WINNT_WINXP
#undef _WIN32_WINNT
#define _WIN32_WINNT  0x501
#endif

#if !defined(OS_WIN32) && (defined(_WIN32) || defined(__WIN32__) || defined(WIN32))
#define OS_WIN32
#endif

#if defined(OS_WIN32) && !defined(WINVER)
// Windows XP
#define WINVER 0x0501
#endif


#ifdef PLAN9
#include <u.h> // Plan 9 requires this is imported first
// Comment line here to avoid reordering by source code formatters.
#include <libc.h>
#endif

#ifdef OS_WIN32 // Put win32 includes here
// The mingw32/64 Windows library warns about including winsock2.h after
// windows.h even though with the above it's a valid thing to do. So, to make
// mingw32 headers happy, we include winsock2.h first.
#include <winsock2.h>
// Comment line here to avoid reordering by source code formatters.
#include <windows.h>
#include <ws2tcpip.h>
#endif

#ifdef __APPLE__
#include <mach/clock.h>
#include <mach/mach.h>
#endif

#if !defined(OS_WIN32)
#include <arpa/inet.h>
#include <errno.h>
#include <fcntl.h>
#include <netdb.h>
#include <netinet/in.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <sys/types.h>
#include <unistd.h>

#ifdef __sun
#include <stropts.h>
#include <sys/filio.h>
#endif

#else
#ifndef IPV6_V6ONLY
#define IPV6_V6ONLY 27
#endif
#endif

#include <assert.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifndef VANILLA_NACL
// Used for sodium_init()
#include <sodium.h>
#endif


// Disable MSG_NOSIGNAL on systems not supporting it, e.g. Windows, FreeBSD
#if !defined(MSG_NOSIGNAL)
#define MSG_NOSIGNAL 0
#endif

#ifndef IPV6_ADD_MEMBERSHIP
#ifdef IPV6_JOIN_GROUP
#define IPV6_ADD_MEMBERSHIP IPV6_JOIN_GROUP
#endif
#endif

static_assert(sizeof(IP4) == SIZE_IP4, "IP4 size must be 4");

// TODO(iphydf): Stop relying on this. We memcpy this struct (and IP4 above)
// into packets but really should be serialising it properly.
static_assert(sizeof(IP6) == SIZE_IP6, "IP6 size must be 16");

#if !defined(OS_WIN32)

static bool should_ignore_recv_error(int err)
{
    return err == EWOULDBLOCK;
}

static bool should_ignore_connect_error(int err)
{
    return err == EWOULDBLOCK || err == EINPROGRESS;
}

non_null()
static const char *inet_ntop4(const struct in_addr *addr, char *buf, size_t bufsize)
{
    return inet_ntop(AF_INET, addr, buf, bufsize);
}

non_null()
static const char *inet_ntop6(const struct in6_addr *addr, char *buf, size_t bufsize)
{
    return inet_ntop(AF_INET6, addr, buf, bufsize);
}

non_null()
static int inet_pton4(const char *addrString, struct in_addr *addrbuf)
{
    return inet_pton(AF_INET, addrString, addrbuf);
}

non_null()
static int inet_pton6(const char *addrString, struct in6_addr *addrbuf)
{
    return inet_pton(AF_INET6, addrString, addrbuf);
}

#else
#ifndef IPV6_V6ONLY
#define IPV6_V6ONLY 27
#endif

static bool should_ignore_recv_error(int err)
{
    // We ignore WSAECONNRESET as Windows helpfully* sends that error if a
    // previously sent UDP packet wasn't delivered.
    return err == WSAEWOULDBLOCK || err == WSAECONNRESET;
}

static bool should_ignore_connect_error(int err)
{
    return err == WSAEWOULDBLOCK || err == WSAEINPROGRESS;
}

non_null()
static const char *inet_ntop4(const struct in_addr *addr, char *buf, size_t bufsize)
{
    struct sockaddr_in saddr = {0};

    saddr.sin_family = AF_INET;
    saddr.sin_addr = *addr;

    DWORD len = bufsize;

    if (WSAAddressToString((LPSOCKADDR)&saddr, sizeof(saddr), nullptr, buf, &len)) {
        return nullptr;
    }

    return buf;
}

non_null()
static const char *inet_ntop6(const struct in6_addr *addr, char *buf, size_t bufsize)
{
    struct sockaddr_in6 saddr = {0};

    saddr.sin6_family = AF_INET6;
    saddr.sin6_addr = *addr;

    DWORD len = bufsize;

    if (WSAAddressToString((LPSOCKADDR)&saddr, sizeof(saddr), nullptr, buf, &len)) {
        return nullptr;
    }

    return buf;
}

non_null()
static int inet_pton4(const char *addrString, struct in_addr *addrbuf)
{
    struct sockaddr_in saddr = {0};

    INT len = sizeof(saddr);

    if (WSAStringToAddress((LPTSTR)addrString, AF_INET, nullptr, (LPSOCKADDR)&saddr, &len)) {
        return 0;
    }

    *addrbuf = saddr.sin_addr;

    return 1;
}

non_null()
static int inet_pton6(const char *addrString, struct in6_addr *addrbuf)
{
    struct sockaddr_in6 saddr = {0};

    INT len = sizeof(saddr);

    if (WSAStringToAddress((LPTSTR)addrString, AF_INET6, nullptr, (LPSOCKADDR)&saddr, &len)) {
        return 0;
    }

    *addrbuf = saddr.sin6_addr;

    return 1;
}

#endif

static_assert(TOX_INET6_ADDRSTRLEN >= INET6_ADDRSTRLEN,
              "TOX_INET6_ADDRSTRLEN should be greater or equal to INET6_ADDRSTRLEN (#INET6_ADDRSTRLEN)");
static_assert(TOX_INET_ADDRSTRLEN >= INET_ADDRSTRLEN,
              "TOX_INET_ADDRSTRLEN should be greater or equal to INET_ADDRSTRLEN (#INET_ADDRSTRLEN)");

static int make_proto(int proto)
{
    switch (proto) {
        case TOX_PROTO_TCP:
            return IPPROTO_TCP;

        case TOX_PROTO_UDP:
            return IPPROTO_UDP;

        default:
            return proto;
    }
}

static int make_socktype(int type)
{
    switch (type) {
        case TOX_SOCK_STREAM:
            return SOCK_STREAM;

        case TOX_SOCK_DGRAM:
            return SOCK_DGRAM;

        default:
            return type;
    }
}

static int make_family(Family tox_family)
{
    switch (tox_family.value) {
        case TOX_AF_INET:
            return AF_INET;

        case TOX_AF_INET6:
            return AF_INET6;

        case TOX_AF_UNSPEC:
            return AF_UNSPEC;

        default:
            return tox_family.value;
    }
}

static const Family family_unspec = {TOX_AF_UNSPEC};
static const Family family_ipv4 = {TOX_AF_INET};
static const Family family_ipv6 = {TOX_AF_INET6};
static const Family family_tcp_server = {TCP_SERVER_FAMILY};
static const Family family_tcp_client = {TCP_CLIENT_FAMILY};
static const Family family_tcp_ipv4 = {TCP_INET};
static const Family family_tcp_ipv6 = {TCP_INET6};
static const Family family_tox_tcp_ipv4 = {TOX_TCP_INET};
static const Family family_tox_tcp_ipv6 = {TOX_TCP_INET6};

static const Family *make_tox_family(int family)
{
    switch (family) {
        case AF_INET:
            return &family_ipv4;

        case AF_INET6:
            return &family_ipv6;

        case AF_UNSPEC:
            return &family_unspec;

        default:
            return nullptr;
    }
}

non_null()
static void get_ip4(IP4 *result, const struct in_addr *addr)
{
    static_assert(sizeof(result->uint32) == sizeof(addr->s_addr),
                  "Tox and operating system don't agree on size of IPv4 addresses");
    result->uint32 = addr->s_addr;
}

non_null()
static void get_ip6(IP6 *result, const struct in6_addr *addr)
{
    static_assert(sizeof(result->uint8) == sizeof(addr->s6_addr),
                  "Tox and operating system don't agree on size of IPv6 addresses");
    memcpy(result->uint8, addr->s6_addr, sizeof(result->uint8));
}

non_null()
static void fill_addr4(const IP4 *ip, struct in_addr *addr)
{
    addr->s_addr = ip->uint32;
}

non_null()
static void fill_addr6(const IP6 *ip, struct in6_addr *addr)
{
    memcpy(addr->s6_addr, ip->uint8, sizeof(ip->uint8));
}

#if !defined(INADDR_LOOPBACK)
#define INADDR_LOOPBACK 0x7f000001
#endif

static const IP empty_ip = {{0}};
const IP_Port empty_ip_port = {{{0}}};

const IP4 ip4_broadcast = { INADDR_BROADCAST };
const IP6 ip6_broadcast = {
    { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff }
};

IP4 get_ip4_loopback(void)
{
    IP4 loopback;
    loopback.uint32 = htonl(INADDR_LOOPBACK);
    return loopback;
}

IP6 get_ip6_loopback(void)
{
    IP6 loopback;
#ifdef ESP_PLATFORM
    loopback = empty_ip_port.ip.ip.v6;
    loopback.uint8[15] = 1;
#else
    get_ip6(&loopback, &in6addr_loopback);
#endif
    return loopback;
}

#ifndef OS_WIN32
#define INVALID_SOCKET (-1)
#endif

const Socket net_invalid_socket = { (int)INVALID_SOCKET };

Family net_family_unspec(void)
{
    return family_unspec;
}

Family net_family_ipv4(void)
{
    return family_ipv4;
}

Family net_family_ipv6(void)
{
    return family_ipv6;
}

Family net_family_tcp_server(void)
{
    return family_tcp_server;
}

Family net_family_tcp_client(void)
{
    return family_tcp_client;
}

Family net_family_tcp_ipv4(void)
{
    return family_tcp_ipv4;
}

Family net_family_tcp_ipv6(void)
{
    return family_tcp_ipv6;
}

Family net_family_tox_tcp_ipv4(void)
{
    return family_tox_tcp_ipv4;
}

Family net_family_tox_tcp_ipv6(void)
{
    return family_tox_tcp_ipv6;
}

bool net_family_is_unspec(Family family)
{
    return family.value == family_unspec.value;
}

bool net_family_is_ipv4(Family family)
{
    return family.value == family_ipv4.value;
}

bool net_family_is_ipv6(Family family)
{
    return family.value == family_ipv6.value;
}

bool net_family_is_tcp_server(Family family)
{
    return family.value == family_tcp_server.value;
}

bool net_family_is_tcp_client(Family family)
{
    return family.value == family_tcp_client.value;
}

bool net_family_is_tcp_ipv4(Family family)
{
    return family.value == family_tcp_ipv4.value;
}

bool net_family_is_tcp_ipv6(Family family)
{
    return family.value == family_tcp_ipv6.value;
}

bool net_family_is_tox_tcp_ipv4(Family family)
{
    return family.value == family_tox_tcp_ipv4.value;
}

bool net_family_is_tox_tcp_ipv6(Family family)
{
    return family.value == family_tox_tcp_ipv6.value;
}

bool sock_valid(Socket sock)
{
    return sock.sock != net_invalid_socket.sock;
}

struct Network_Addr {
    struct sockaddr_storage addr;
    size_t size;
};

non_null()
static int sys_close(void *obj, int sock)
{
#if defined(OS_WIN32)
    return closesocket(sock);
#else  // !OS_WIN32
    return close(sock);
#endif
}

non_null()
static int sys_accept(void *obj, int sock)
{
    return accept(sock, nullptr, nullptr);
}

non_null()
static int sys_bind(void *obj, int sock, const Network_Addr *addr)
{
    return bind(sock, (const struct sockaddr *)&addr->addr, addr->size);
}

non_null()
static int sys_listen(void *obj, int sock, int backlog)
{
    return listen(sock, backlog);
}

non_null()
static int sys_recvbuf(void *obj, int sock)
{
#ifdef OS_WIN32
    u_long count = 0;
    ioctlsocket(sock, FIONREAD, &count);
#else
    int count = 0;
    ioctl(sock, FIONREAD, &count);
#endif

    return count;
}

non_null()
static int sys_recv(void *obj, int sock, uint8_t *buf, size_t len)
{
    return recv(sock, (char *)buf, len, MSG_NOSIGNAL);
}

non_null()
static int sys_send(void *obj, int sock, const uint8_t *buf, size_t len)
{
    return send(sock, (const char *)buf, len, MSG_NOSIGNAL);
}

non_null()
static int sys_sendto(void *obj, int sock, const uint8_t *buf, size_t len, const Network_Addr *addr) {
    return sendto(sock, (const char *)buf, len, 0, (const struct sockaddr *)&addr->addr, addr->size);
}

non_null()
static int sys_recvfrom(void *obj, int sock, uint8_t *buf, size_t len, Network_Addr *addr) {
    socklen_t size = addr->size;
    const int ret = recvfrom(sock, (char *)buf, len, 0, (struct sockaddr *)&addr->addr, &size);
    addr->size = size;
    return ret;
}

non_null()
static int sys_socket(void *obj, int domain, int type, int proto)
{
    return (int)socket(domain, type, proto);
}

non_null()
static int sys_socket_nonblock(void *obj, int sock, bool nonblock)
{
#ifdef OS_WIN32
    u_long mode = nonblock ? 1 : 0;
    return ioctlsocket(sock, FIONBIO, &mode);
#else
    return fcntl(sock, F_SETFL, O_NONBLOCK, nonblock ? 1 : 0);
#endif /* OS_WIN32 */
}

non_null()
static int sys_getsockopt(void *obj, int sock, int level, int optname, void *optval, size_t *optlen)
{
    socklen_t len = *optlen;
    const int ret = getsockopt(sock, level, optname, optval, &len);
    *optlen = len;
    return ret;
}

non_null()
static int sys_setsockopt(void *obj, int sock, int level, int optname, const void *optval, size_t optlen)
{
    return setsockopt(sock, level, optname, optval, optlen);
}

static const Network_Funcs system_network_funcs = {
    sys_close,
    sys_accept,
    sys_bind,
    sys_listen,
    sys_recvbuf,
    sys_recv,
    sys_recvfrom,
    sys_send,
    sys_sendto,
    sys_socket,
    sys_socket_nonblock,
    sys_getsockopt,
    sys_setsockopt,
};
static const Network system_network_obj = {&system_network_funcs};

const Network *system_network(void)
{
#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
    if ((true)) {
        return nullptr;
    }
#endif
#ifdef OS_WIN32
    WSADATA wsaData;

    if (WSAStartup(MAKEWORD(2, 2), &wsaData) != NO_ERROR) {
        return nullptr;
    }
#endif
    return &system_network_obj;
}

#if 0
/* TODO(iphydf): Call this from functions that use `system_network()`. */
void system_network_deinit(const Network *ns)
{
#ifdef OS_WIN32
    WSACleanup();
#endif
}
#endif

non_null()
static int net_setsockopt(const Network *ns, Socket sock, int level, int optname, const void *optval, size_t optlen)
{
    return ns->funcs->setsockopt(ns->obj, sock.sock, level, optname, optval, optlen);
}

non_null()
static int net_getsockopt(const Network *ns, Socket sock, int level, int optname, void *optval, size_t *optlen)
{
    return ns->funcs->getsockopt(ns->obj, sock.sock, level, optname, optval, optlen);
}

non_null()
static uint32_t data_0(uint16_t buflen, const uint8_t *buffer)
{
    uint32_t data = 0;

    if (buflen > 4) {
        net_unpack_u32(buffer + 1, &data);
    }

    return data;
}
non_null()
static uint32_t data_1(uint16_t buflen, const uint8_t *buffer)
{
    uint32_t data = 0;

    if (buflen > 8) {
        net_unpack_u32(buffer + 5, &data);
    }

    return data;
}

static const char *net_packet_type_name(Net_Packet_Type type)
{
    switch (type) {
        case NET_PACKET_PING_REQUEST:
            return "PING_REQUEST";

        case NET_PACKET_PING_RESPONSE:
            return "PING_RESPONSE";

        case NET_PACKET_GET_NODES:
            return "GET_NODES";

        case NET_PACKET_SEND_NODES_IPV6:
            return "SEND_NODES_IPV6";

        case NET_PACKET_COOKIE_REQUEST:
            return "COOKIE_REQUEST";

        case NET_PACKET_COOKIE_RESPONSE:
            return "COOKIE_RESPONSE";

        case NET_PACKET_CRYPTO_HS:
            return "CRYPTO_HS";

        case NET_PACKET_CRYPTO_DATA:
            return "CRYPTO_DATA";

        case NET_PACKET_CRYPTO:
            return "CRYPTO";

        case NET_PACKET_GC_HANDSHAKE:
            return "GC_HANDSHAKE";

        case NET_PACKET_GC_LOSSLESS:
            return "GC_LOSSLESS";

        case NET_PACKET_GC_LOSSY:
            return "GC_LOSSY";

        case NET_PACKET_LAN_DISCOVERY:
            return "LAN_DISCOVERY";

        case NET_PACKET_ONION_SEND_INITIAL:
            return "ONION_SEND_INITIAL";

        case NET_PACKET_ONION_SEND_1:
            return "ONION_SEND_1";

        case NET_PACKET_ONION_SEND_2:
            return "ONION_SEND_2";

        case NET_PACKET_ANNOUNCE_REQUEST_OLD:
            return "ANNOUNCE_REQUEST_OLD";

        case NET_PACKET_ANNOUNCE_RESPONSE_OLD:
            return "ANNOUNCE_RESPONSE_OLD";

        case NET_PACKET_ONION_DATA_REQUEST:
            return "ONION_DATA_REQUEST";

        case NET_PACKET_ONION_DATA_RESPONSE:
            return "ONION_DATA_RESPONSE";

        case NET_PACKET_ANNOUNCE_REQUEST:
            return "ANNOUNCE_REQUEST";

        case NET_PACKET_ANNOUNCE_RESPONSE:
            return "ANNOUNCE_RESPONSE";

        case NET_PACKET_ONION_RECV_3:
            return "ONION_RECV_3";

        case NET_PACKET_ONION_RECV_2:
            return "ONION_RECV_2";

        case NET_PACKET_ONION_RECV_1:
            return "ONION_RECV_1";

        case NET_PACKET_FORWARD_REQUEST:
            return "FORWARD_REQUEST";

        case NET_PACKET_FORWARDING:
            return "FORWARDING";

        case NET_PACKET_FORWARD_REPLY:
            return "FORWARD_REPLY";

        case NET_PACKET_DATA_SEARCH_REQUEST:
            return "DATA_SEARCH_REQUEST";

        case NET_PACKET_DATA_SEARCH_RESPONSE:
            return "DATA_SEARCH_RESPONSE";

        case NET_PACKET_DATA_RETRIEVE_REQUEST:
            return "DATA_RETRIEVE_REQUEST";

        case NET_PACKET_DATA_RETRIEVE_RESPONSE:
            return "DATA_RETRIEVE_RESPONSE";

        case NET_PACKET_STORE_ANNOUNCE_REQUEST:
            return "STORE_ANNOUNCE_REQUEST";

        case NET_PACKET_STORE_ANNOUNCE_RESPONSE:
            return "STORE_ANNOUNCE_RESPONSE";

        case BOOTSTRAP_INFO_PACKET_ID:
            return "BOOTSTRAP_INFO";

        case NET_PACKET_MAX:
            return "MAX";
    }

    return "<unknown>";
}

non_null()
static void loglogdata(const Logger *log, const char *message, const uint8_t *buffer,
                       uint16_t buflen, const IP_Port *ip_port, long res)
{
    if (res < 0) { /* Windows doesn't necessarily know `%zu` */
        Ip_Ntoa ip_str;
        const int error = net_error();
        char *strerror = net_new_strerror(error);
        LOGGER_TRACE(log, "[%02x = %-20s] %s %3u%c %s:%u (%u: %s) | %08x%08x...%02x",
                     buffer[0], net_packet_type_name((Net_Packet_Type)buffer[0]), message,
                     min_u16(buflen, 999), 'E',
                     net_ip_ntoa(&ip_port->ip, &ip_str), net_ntohs(ip_port->port), error,
                     strerror, data_0(buflen, buffer), data_1(buflen, buffer), buffer[buflen - 1]);
        net_kill_strerror(strerror);
    } else if ((res > 0) && ((size_t)res <= buflen)) {
        Ip_Ntoa ip_str;
        LOGGER_TRACE(log, "[%02x = %-20s] %s %3u%c %s:%u (%u: %s) | %08x%08x...%02x",
                     buffer[0], net_packet_type_name((Net_Packet_Type)buffer[0]), message,
                     min_u16(res, 999), (size_t)res < buflen ? '<' : '=',
                     net_ip_ntoa(&ip_port->ip, &ip_str), net_ntohs(ip_port->port), 0, "OK",
                     data_0(buflen, buffer), data_1(buflen, buffer), buffer[buflen - 1]);
    } else { /* empty or overwrite */
        Ip_Ntoa ip_str;
        LOGGER_TRACE(log, "[%02x = %-20s] %s %lu%c%u %s:%u (%u: %s) | %08x%08x...%02x",
                     buffer[0], net_packet_type_name((Net_Packet_Type)buffer[0]), message,
                     res, res == 0 ? '!' : '>', buflen,
                     net_ip_ntoa(&ip_port->ip, &ip_str), net_ntohs(ip_port->port), 0, "OK",
                     data_0(buflen, buffer), data_1(buflen, buffer), buffer[buflen - 1]);
    }
}

int net_send(const Network *ns, const Logger *log,
             Socket sock, const uint8_t *buf, size_t len, const IP_Port *ip_port)
{
    const int res = ns->funcs->send(ns->obj, sock.sock, buf, len);
    loglogdata(log, "T=>", buf, len, ip_port, res);
    return res;
}

non_null()
static int net_sendto(
        const Network *ns,
        Socket sock, const uint8_t *buf, size_t len, const Network_Addr *addr, const IP_Port *ip_port)
{
    return ns->funcs->sendto(ns->obj, sock.sock, buf, len, addr);
}

int net_recv(const Network *ns, const Logger *log,
             Socket sock, uint8_t *buf, size_t len, const IP_Port *ip_port)
{
    const int res = ns->funcs->recv(ns->obj, sock.sock, buf, len);
    loglogdata(log, "=>T", buf, len, ip_port, res);
    return res;
}

non_null()
static int net_recvfrom(const Network *ns,
                        Socket sock, uint8_t *buf, size_t len, Network_Addr *addr)
{
    return ns->funcs->recvfrom(ns->obj, sock.sock, buf, len, addr);
}

int net_listen(const Network *ns, Socket sock, int backlog)
{
    return ns->funcs->listen(ns->obj, sock.sock, backlog);
}

non_null()
static int net_bind(const Network *ns, Socket sock, const Network_Addr *addr)
{
    return ns->funcs->bind(ns->obj, sock.sock, addr);
}

Socket net_accept(const Network *ns, Socket sock)
{
    const Socket newsock = {ns->funcs->accept(ns->obj, sock.sock)};
    return newsock;
}

/** Close the socket. */
void kill_sock(const Network *ns, Socket sock)
{
    ns->funcs->close(ns->obj, sock.sock);
}

bool set_socket_nonblock(const Network *ns, Socket sock)
{
    return ns->funcs->socket_nonblock(ns->obj, sock.sock, true) == 0;
}

bool set_socket_nosigpipe(const Network *ns, Socket sock)
{
#if defined(__APPLE__)
    int set = 1;
    return net_setsockopt(ns, sock, SOL_SOCKET, SO_NOSIGPIPE, &set, sizeof(int)) == 0;
#else
    return true;
#endif
}

bool set_socket_reuseaddr(const Network *ns, Socket sock)
{
    int set = 1;
    return net_setsockopt(ns, sock, SOL_SOCKET, SO_REUSEADDR, &set, sizeof(set)) == 0;
}

bool set_socket_dualstack(const Network *ns, Socket sock)
{
    int ipv6only = 0;
    size_t optsize = sizeof(ipv6only);
    const int res = net_getsockopt(ns, sock, IPPROTO_IPV6, IPV6_V6ONLY, &ipv6only, &optsize);

    if ((res == 0) && (ipv6only == 0)) {
        return true;
    }

    ipv6only = 0;
    return net_setsockopt(ns, sock, IPPROTO_IPV6, IPV6_V6ONLY, &ipv6only, sizeof(ipv6only)) == 0;
}


typedef struct Packet_Handler {
    packet_handler_cb *function;
    void *object;
} Packet_Handler;

struct Networking_Core {
    const Logger *log;
    Packet_Handler packethandlers[256];
    const Network *ns;

    Family family;
    uint16_t port;
    /* Our UDP socket. */
    Socket sock;
};

Family net_family(const Networking_Core *net)
{
    return net->family;
}

uint16_t net_port(const Networking_Core *net)
{
    return net->port;
}

/* Basic network functions:
 */

int send_packet(const Networking_Core *net, const IP_Port *ip_port, Packet packet)
{
    IP_Port ipp_copy = *ip_port;

    if (net_family_is_unspec(ip_port->ip.family)) {
        // TODO(iphydf): Make this an error. Currently this fails sometimes when
        // called from DHT.c:do_ping_and_sendnode_requests.
        return -1;
    }

    if (net_family_is_unspec(net->family)) { /* Socket not initialized */
        // TODO(iphydf): Make this an error. Currently, the onion client calls
        // this via DHT getnodes.
        LOGGER_WARNING(net->log, "attempted to send message of length %u on uninitialised socket", packet.length);
        return -1;
    }

    /* socket TOX_AF_INET, but target IP NOT: can't send */
    if (net_family_is_ipv4(net->family) && !net_family_is_ipv4(ipp_copy.ip.family)) {
        // TODO(iphydf): Make this an error. Occasionally we try to send to an
        // all-zero ip_port.
        LOGGER_DEBUG(net->log, "attempted to send message with network family %d (probably IPv6) on IPv4 socket",
                       ipp_copy.ip.family.value);
        return -1;
    }

    if (net_family_is_ipv4(ipp_copy.ip.family) && net_family_is_ipv6(net->family)) {
        /* must convert to IPV4-in-IPV6 address */
        IP6 ip6;

        /* there should be a macro for this in a standards compliant
         * environment, not found */
        ip6.uint32[0] = 0;
        ip6.uint32[1] = 0;
        ip6.uint32[2] = net_htonl(0xFFFF);
        ip6.uint32[3] = ipp_copy.ip.ip.v4.uint32;

        ipp_copy.ip.family = net_family_ipv6();
        ipp_copy.ip.ip.v6 = ip6;
    }

    Network_Addr addr;

    if (net_family_is_ipv4(ipp_copy.ip.family)) {
        struct sockaddr_in *const addr4 = (struct sockaddr_in *)&addr.addr;

        addr.size = sizeof(struct sockaddr_in);
        addr4->sin_family = AF_INET;
        addr4->sin_port = ipp_copy.port;
        fill_addr4(&ipp_copy.ip.ip.v4, &addr4->sin_addr);
    } else if (net_family_is_ipv6(ipp_copy.ip.family)) {
        struct sockaddr_in6 *const addr6 = (struct sockaddr_in6 *)&addr.addr;

        addr.size = sizeof(struct sockaddr_in6);
        addr6->sin6_family = AF_INET6;
        addr6->sin6_port = ipp_copy.port;
        fill_addr6(&ipp_copy.ip.ip.v6, &addr6->sin6_addr);

        addr6->sin6_flowinfo = 0;
        addr6->sin6_scope_id = 0;
    } else {
        LOGGER_ERROR(net->log, "unknown address type: %d", ipp_copy.ip.family.value);
        return -1;
    }

    const long res = net_sendto(net->ns, net->sock, packet.data, packet.length, &addr, &ipp_copy);
    loglogdata(net->log, "O=>", packet.data, packet.length, ip_port, res);

    assert(res <= INT_MAX);
    return (int)res;
}

/**
 * Function to send packet(data) of length length to ip_port.
 *
 * @deprecated Use send_packet instead.
 */
int sendpacket(const Networking_Core *net, const IP_Port *ip_port, const uint8_t *data, uint16_t length)
{
    const Packet packet = {data, length};
    return send_packet(net, ip_port, packet);
}

/** @brief Function to receive data
 * ip and port of sender is put into ip_port.
 * Packet data is put into data.
 * Packet length is put into length.
 */
non_null()
static int receivepacket(const Network *ns, const Logger *log, Socket sock, IP_Port *ip_port, uint8_t *data, uint32_t *length)
{
    memset(ip_port, 0, sizeof(IP_Port));
    Network_Addr addr = {{0}};
    addr.size = sizeof(addr.addr);
    *length = 0;

    const int fail_or_len = net_recvfrom(ns, sock, data, MAX_UDP_PACKET_SIZE, &addr);

    if (fail_or_len < 0) {
        const int error = net_error();

        if (!should_ignore_recv_error(error)) {
            char *strerror = net_new_strerror(error);
            LOGGER_ERROR(log, "unexpected error reading from socket: %u, %s", error, strerror);
            net_kill_strerror(strerror);
        }

        return -1; /* Nothing received. */
    }

    *length = (uint32_t)fail_or_len;

    if (addr.addr.ss_family == AF_INET) {
        const struct sockaddr_in *addr_in = (const struct sockaddr_in *)&addr.addr;

        const Family *const family = make_tox_family(addr_in->sin_family);
        assert(family != nullptr);

        if (family == nullptr) {
            return -1;
        }

        ip_port->ip.family = *family;
        get_ip4(&ip_port->ip.ip.v4, &addr_in->sin_addr);
        ip_port->port = addr_in->sin_port;
    } else if (addr.addr.ss_family == AF_INET6) {
        const struct sockaddr_in6 *addr_in6 = (const struct sockaddr_in6 *)&addr.addr;
        const Family *const family = make_tox_family(addr_in6->sin6_family);
        assert(family != nullptr);

        if (family == nullptr) {
            return -1;
        }

        ip_port->ip.family = *family;
        get_ip6(&ip_port->ip.ip.v6, &addr_in6->sin6_addr);
        ip_port->port = addr_in6->sin6_port;

        if (ipv6_ipv4_in_v6(&ip_port->ip.ip.v6)) {
            ip_port->ip.family = net_family_ipv4();
            ip_port->ip.ip.v4.uint32 = ip_port->ip.ip.v6.uint32[3];
        }
    } else {
        return -1;
    }

    loglogdata(log, "=>O", data, MAX_UDP_PACKET_SIZE, ip_port, *length);

    return 0;
}

void networking_registerhandler(Networking_Core *net, uint8_t byte, packet_handler_cb *cb, void *object)
{
    net->packethandlers[byte].function = cb;
    net->packethandlers[byte].object = object;
}

void networking_poll(const Networking_Core *net, void *userdata)
{
    if (net_family_is_unspec(net->family)) {
        /* Socket not initialized */
        return;
    }

    IP_Port ip_port;
    uint8_t data[MAX_UDP_PACKET_SIZE] = {0};
    uint32_t length;

    while (receivepacket(net->ns, net->log, net->sock, &ip_port, data, &length) != -1) {
        if (length < 1) {
            continue;
        }

        const Packet_Handler *const handler = &net->packethandlers[data[0]];

        if (handler->function == nullptr) {
            // TODO(https://github.com/TokTok/c-toxcore/issues/1115): Make this
            // a warning or error again.
            LOGGER_DEBUG(net->log, "[%02u] -- Packet has no handler", data[0]);
            continue;
        }

        handler->function(handler->object, &ip_port, data, length, userdata);
    }
}

/** @brief Initialize networking.
 * Bind to ip and port.
 * ip must be in network order EX: 127.0.0.1 = (7F000001).
 * port is in host byte order (this means don't worry about it).
 *
 * @return Networking_Core object if no problems
 * @retval NULL if there are problems.
 *
 * If error is non NULL it is set to 0 if no issues, 1 if socket related error, 2 if other.
 */
Networking_Core *new_networking_ex(
        const Logger *log, const Network *ns, const IP *ip,
        uint16_t port_from, uint16_t port_to, unsigned int *error)
{
    /* If both from and to are 0, use default port range
     * If one is 0 and the other is non-0, use the non-0 value as only port
     * If from > to, swap
     */
    if (port_from == 0 && port_to == 0) {
        port_from = TOX_PORTRANGE_FROM;
        port_to = TOX_PORTRANGE_TO;
    } else if (port_from == 0 && port_to != 0) {
        port_from = port_to;
    } else if (port_from != 0 && port_to == 0) {
        port_to = port_from;
    } else if (port_from > port_to) {
        const uint16_t temp_port = port_from;
        port_from = port_to;
        port_to = temp_port;
    }

    if (error != nullptr) {
        *error = 2;
    }

    /* maybe check for invalid IPs like 224+.x.y.z? if there is any IP set ever */
    if (!net_family_is_ipv4(ip->family) && !net_family_is_ipv6(ip->family)) {
        LOGGER_ERROR(log, "invalid address family: %u", ip->family.value);
        return nullptr;
    }

    Networking_Core *temp = (Networking_Core *)calloc(1, sizeof(Networking_Core));

    if (temp == nullptr) {
        return nullptr;
    }

    temp->ns = ns;
    temp->log = log;
    temp->family = ip->family;
    temp->port = 0;

    /* Initialize our socket. */
    /* add log message what we're creating */
    temp->sock = net_socket(ns, temp->family, TOX_SOCK_DGRAM, TOX_PROTO_UDP);

    /* Check for socket error. */
    if (!sock_valid(temp->sock)) {
        const int neterror = net_error();
        char *strerror = net_new_strerror(neterror);
        LOGGER_ERROR(log, "failed to get a socket?! %d, %s", neterror, strerror);
        net_kill_strerror(strerror);
        free(temp);

        if (error != nullptr) {
            *error = 1;
        }

        return nullptr;
    }

    /* Functions to increase the size of the send and receive UDP buffers.
     */
    int n = 1024 * 1024 * 2;

#if !(defined(__NetBSD__))
    if (net_setsockopt(ns, temp->sock, SOL_SOCKET, SO_RCVBUF, &n, sizeof(n)) != 0) {
        LOGGER_ERROR(log, "failed to set socket option %d", SO_RCVBUF);
    }

    if (net_setsockopt(ns, temp->sock, SOL_SOCKET, SO_SNDBUF, &n, sizeof(n)) != 0) {
        LOGGER_ERROR(log, "failed to set socket option %d", SO_SNDBUF);
    }
#endif

    /* Enable broadcast on socket */
    int broadcast = 1;

    if (net_setsockopt(ns, temp->sock, SOL_SOCKET, SO_BROADCAST, &broadcast, sizeof(broadcast)) != 0) {
        LOGGER_ERROR(log, "failed to set socket option %d", SO_BROADCAST);
    }

    /* iOS UDP sockets are weird and apparently can SIGPIPE */
    if (!set_socket_nosigpipe(ns, temp->sock)) {
        kill_networking(temp);

        if (error != nullptr) {
            *error = 1;
        }

        return nullptr;
    }

    /* Set socket nonblocking. */
    if (!set_socket_nonblock(ns, temp->sock)) {
        kill_networking(temp);

        if (error != nullptr) {
            *error = 1;
        }

        return nullptr;
    }

    /* Bind our socket to port PORT and the given IP address (usually 0.0.0.0 or ::) */
    uint16_t *portptr = nullptr;
    Network_Addr addr;

    memset(&addr.addr, 0, sizeof(struct sockaddr_storage));

    if (net_family_is_ipv4(temp->family)) {
        struct sockaddr_in *addr4 = (struct sockaddr_in *)&addr.addr;

        addr.size = sizeof(struct sockaddr_in);
        addr4->sin_family = AF_INET;
        addr4->sin_port = 0;
        fill_addr4(&ip->ip.v4, &addr4->sin_addr);

        portptr = &addr4->sin_port;
    } else if (net_family_is_ipv6(temp->family)) {
        struct sockaddr_in6 *addr6 = (struct sockaddr_in6 *)&addr.addr;

        addr.size = sizeof(struct sockaddr_in6);
        addr6->sin6_family = AF_INET6;
        addr6->sin6_port = 0;
        fill_addr6(&ip->ip.v6, &addr6->sin6_addr);

        addr6->sin6_flowinfo = 0;
        addr6->sin6_scope_id = 0;

        portptr = &addr6->sin6_port;
    } else {
        free(temp);
        return nullptr;
    }

    if (net_family_is_ipv6(ip->family)) {
        const bool is_dualstack = set_socket_dualstack(ns, temp->sock);

        if (is_dualstack) {
            LOGGER_TRACE(log, "Dual-stack socket: enabled");
        } else {
            LOGGER_ERROR(log, "Dual-stack socket failed to enable, won't be able to receive from/send to IPv4 addresses");
        }

#ifndef ESP_PLATFORM
        /* multicast local nodes */
        struct ipv6_mreq mreq;
        memset(&mreq, 0, sizeof(mreq));
        mreq.ipv6mr_multiaddr.s6_addr[ 0] = 0xFF;
        mreq.ipv6mr_multiaddr.s6_addr[ 1] = 0x02;
        mreq.ipv6mr_multiaddr.s6_addr[15] = 0x01;
        mreq.ipv6mr_interface = 0;

        const int res = net_setsockopt(ns, temp->sock, IPPROTO_IPV6, IPV6_ADD_MEMBERSHIP, &mreq, sizeof(mreq));

        int neterror = net_error();
        char *strerror = net_new_strerror(neterror);

        if (res < 0) {
            LOGGER_INFO(log, "Failed to activate local multicast membership in FF02::1. (%d, %s)", neterror, strerror);
        } else {
            LOGGER_TRACE(log, "Local multicast group joined successfully. (%d, %s)", neterror, strerror);
        }

        net_kill_strerror(strerror);
#endif
    }

    /* A hanging program or a different user might block the standard port.
     * As long as it isn't a parameter coming from the commandline,
     * try a few ports after it, to see if we can find a "free" one.
     *
     * If we go on without binding, the first sendto() automatically binds to
     * a free port chosen by the system (i.e. anything from 1024 to 65535).
     *
     * Returning NULL after bind fails has both advantages and disadvantages:
     * advantage:
     *   we can rely on getting the port in the range 33445..33450, which
     *   enables us to tell joe user to open their firewall to a small range
     *
     * disadvantage:
     *   some clients might not test return of tox_new(), blindly assuming that
     *   it worked ok (which it did previously without a successful bind)
     */
    uint16_t port_to_try = port_from;
    *portptr = net_htons(port_to_try);

    for (uint16_t tries = port_from; tries <= port_to; ++tries) {
        const int res = net_bind(ns, temp->sock, &addr);

        if (res == 0) {
            temp->port = *portptr;

            Ip_Ntoa ip_str;
            LOGGER_DEBUG(log, "Bound successfully to %s:%u", net_ip_ntoa(ip, &ip_str),
                         net_ntohs(temp->port));

            /* errno isn't reset on success, only set on failure, the failed
             * binds with parallel clients yield a -EPERM to the outside if
             * errno isn't cleared here */
            if (tries > 0) {
                errno = 0;
            }

            if (error != nullptr) {
                *error = 0;
            }

            return temp;
        }

        ++port_to_try;

        if (port_to_try > port_to) {
            port_to_try = port_from;
        }

        *portptr = net_htons(port_to_try);
    }

    Ip_Ntoa ip_str;
    int neterror = net_error();
    char *strerror = net_new_strerror(neterror);
    LOGGER_ERROR(log, "failed to bind socket: %d, %s IP: %s port_from: %u port_to: %u", neterror, strerror,
                 net_ip_ntoa(ip, &ip_str), port_from, port_to);
    net_kill_strerror(strerror);
    kill_networking(temp);

    if (error != nullptr) {
        *error = 1;
    }

    return nullptr;
}

Networking_Core *new_networking_no_udp(const Logger *log, const Network *ns)
{
    /* this is the easiest way to completely disable UDP without changing too much code. */
    Networking_Core *net = (Networking_Core *)calloc(1, sizeof(Networking_Core));

    if (net == nullptr) {
        return nullptr;
    }

    net->ns = ns;
    net->log = log;

    return net;
}

/** Function to cleanup networking stuff (doesn't do much right now). */
void kill_networking(Networking_Core *net)
{
    if (net == nullptr) {
        return;
    }

    if (!net_family_is_unspec(net->family)) {
        /* Socket is initialized, so we close it. */
        kill_sock(net->ns, net->sock);
    }

    free(net);
}


bool ip_equal(const IP *a, const IP *b)
{
    if (a == nullptr || b == nullptr) {
        return false;
    }

    /* same family */
    if (a->family.value == b->family.value) {
        if (net_family_is_ipv4(a->family) || net_family_is_tcp_ipv4(a->family)) {
            struct in_addr addr_a;
            struct in_addr addr_b;
            fill_addr4(&a->ip.v4, &addr_a);
            fill_addr4(&b->ip.v4, &addr_b);
            return addr_a.s_addr == addr_b.s_addr;
        }

        if (net_family_is_ipv6(a->family) || net_family_is_tcp_ipv6(a->family)) {
            return a->ip.v6.uint64[0] == b->ip.v6.uint64[0] &&
                   a->ip.v6.uint64[1] == b->ip.v6.uint64[1];
        }

        return false;
    }

    /* different family: check on the IPv6 one if it is the IPv4 one embedded */
    if (net_family_is_ipv4(a->family) && net_family_is_ipv6(b->family)) {
        if (ipv6_ipv4_in_v6(&b->ip.v6)) {
            struct in_addr addr_a;
            fill_addr4(&a->ip.v4, &addr_a);
            return addr_a.s_addr == b->ip.v6.uint32[3];
        }
    } else if (net_family_is_ipv6(a->family) && net_family_is_ipv4(b->family)) {
        if (ipv6_ipv4_in_v6(&a->ip.v6)) {
            struct in_addr addr_b;
            fill_addr4(&b->ip.v4, &addr_b);
            return a->ip.v6.uint32[3] == addr_b.s_addr;
        }
    }

    return false;
}

bool ipport_equal(const IP_Port *a, const IP_Port *b)
{
    if (a == nullptr || b == nullptr) {
        return false;
    }

    if (a->port == 0 || (a->port != b->port)) {
        return false;
    }

    return ip_equal(&a->ip, &b->ip);
}

/** nulls out ip */
void ip_reset(IP *ip)
{
    if (ip == nullptr) {
        return;
    }

    *ip = empty_ip;
}

/** nulls out ip_port */
void ipport_reset(IP_Port *ipport)
{
    if (ipport == nullptr) {
        return;
    }

    *ipport = empty_ip_port;
}

/** nulls out ip, sets family according to flag */
void ip_init(IP *ip, bool ipv6enabled)
{
    if (ip == nullptr) {
        return;
    }

    *ip = empty_ip;
    ip->family = ipv6enabled ? net_family_ipv6() : net_family_ipv4();
}

/** checks if ip is valid */
bool ip_isset(const IP *ip)
{
    if (ip == nullptr) {
        return false;
    }

    return !net_family_is_unspec(ip->family);
}

/** checks if ip is valid */
bool ipport_isset(const IP_Port *ipport)
{
    if (ipport == nullptr) {
        return false;
    }

    if (ipport->port == 0) {
        return false;
    }

    return ip_isset(&ipport->ip);
}

/** copies an ip structure (careful about direction) */
void ip_copy(IP *target, const IP *source)
{
    if (source == nullptr || target == nullptr) {
        return;
    }

    *target = *source;
}

/** copies an ip_port structure (careful about direction) */
void ipport_copy(IP_Port *target, const IP_Port *source)
{
    if (source == nullptr || target == nullptr) {
        return;
    }

    *target = *source;
}

/** @brief Converts IP into a string.
 *
 * Writes error message into the buffer on error.
 *
 * @param ip_str contains a buffer of the required size.
 *
 * @return Pointer to the buffer inside `ip_str` containing the IP string.
 */
const char *net_ip_ntoa(const IP *ip, Ip_Ntoa *ip_str)
{
    assert(ip_str != nullptr);

    if (ip == nullptr) {
        snprintf(ip_str->buf, sizeof(ip_str->buf), "(IP invalid: NULL)");
        return ip_str->buf;
    }

    if (!ip_parse_addr(ip, ip_str->buf, sizeof(ip_str->buf))) {
        snprintf(ip_str->buf, sizeof(ip_str->buf), "(IP invalid, family %u)", ip->family.value);
        return ip_str->buf;
    }

    /* brute force protection against lacking termination */
    ip_str->buf[sizeof(ip_str->buf) - 1] = '\0';
    return ip_str->buf;
}

bool ip_parse_addr(const IP *ip, char *address, size_t length)
{
    if (address == nullptr || ip == nullptr) {
        return false;
    }

    if (net_family_is_ipv4(ip->family)) {
        struct in_addr addr;
        assert(make_family(ip->family) == AF_INET);
        fill_addr4(&ip->ip.v4, &addr);
        return inet_ntop4(&addr, address, length) != nullptr;
    }

    if (net_family_is_ipv6(ip->family)) {
        struct in6_addr addr;
        assert(make_family(ip->family) == AF_INET6);
        fill_addr6(&ip->ip.v6, &addr);
        return inet_ntop6(&addr, address, length) != nullptr;
    }

    return false;
}

bool addr_parse_ip(const char *address, IP *to)
{
    if (address == nullptr || to == nullptr) {
        return false;
    }

    struct in_addr addr4;

    if (inet_pton4(address, &addr4) == 1) {
        to->family = net_family_ipv4();
        get_ip4(&to->ip.v4, &addr4);
        return true;
    }

    struct in6_addr addr6;

    if (inet_pton6(address, &addr6) == 1) {
        to->family = net_family_ipv6();
        get_ip6(&to->ip.v6, &addr6);
        return true;
    }

    return false;
}

/** addr_resolve return values */
#define TOX_ADDR_RESOLVE_INET  1
#define TOX_ADDR_RESOLVE_INET6 2

/**
 * Uses getaddrinfo to resolve an address into an IP address.
 *
 * Uses the first IPv4/IPv6 addresses returned by getaddrinfo.
 *
 * @param address a hostname (or something parseable to an IP address)
 * @param to to.family MUST be initialized, either set to a specific IP version
 *   (TOX_AF_INET/TOX_AF_INET6) or to the unspecified TOX_AF_UNSPEC (0), if both
 *   IP versions are acceptable
 * @param extra can be NULL and is only set in special circumstances, see returns
 *
 * Returns in `*to` a valid IPAny (v4/v6),
 * prefers v6 if `ip.family` was TOX_AF_UNSPEC and both available
 * Returns in `*extra` an IPv4 address, if family was TOX_AF_UNSPEC and `*to` is TOX_AF_INET6
 *
 * @return 0 on failure, `TOX_ADDR_RESOLVE_*` on success.
 */
non_null(1, 2, 3) nullable(4)
static int addr_resolve(const Network *ns, const char *address, IP *to, IP *extra)
{
#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
    if ((true)) {
        return 0;
    }
#endif

    if (address == nullptr || to == nullptr) {
        return 0;
    }

    const Family tox_family = to->family;
    const int family = make_family(tox_family);

    struct addrinfo hints;
    memset(&hints, 0, sizeof(hints));
    hints.ai_family   = family;
    hints.ai_socktype = SOCK_DGRAM; // type of socket Tox uses.

    struct addrinfo *server = nullptr;

    const int rc = getaddrinfo(address, nullptr, &hints, &server);

    // Lookup failed.
    if (rc != 0) {
        return 0;
    }

    IP ip4;
    ip_init(&ip4, false); // ipv6enabled = false
    IP ip6;
    ip_init(&ip6, true); // ipv6enabled = true

    int result = 0;
    bool done = false;

    for (struct addrinfo *walker = server; walker != nullptr && !done; walker = walker->ai_next) {
        switch (walker->ai_family) {
            case AF_INET: {
                if (walker->ai_family == family) { /* AF_INET requested, done */
                    const struct sockaddr_in *addr = (const struct sockaddr_in *)(const void *)walker->ai_addr;
                    get_ip4(&to->ip.v4, &addr->sin_addr);
                    result = TOX_ADDR_RESOLVE_INET;
                    done = true;
                } else if ((result & TOX_ADDR_RESOLVE_INET) == 0) { /* AF_UNSPEC requested, store away */
                    const struct sockaddr_in *addr = (const struct sockaddr_in *)(const void *)walker->ai_addr;
                    get_ip4(&ip4.ip.v4, &addr->sin_addr);
                    result |= TOX_ADDR_RESOLVE_INET;
                }

                break; /* switch */
            }

            case AF_INET6: {
                if (walker->ai_family == family) { /* AF_INET6 requested, done */
                    if (walker->ai_addrlen == sizeof(struct sockaddr_in6)) {
                        const struct sockaddr_in6 *addr = (const struct sockaddr_in6 *)(void *)walker->ai_addr;
                        get_ip6(&to->ip.v6, &addr->sin6_addr);
                        result = TOX_ADDR_RESOLVE_INET6;
                        done = true;
                    }
                } else if ((result & TOX_ADDR_RESOLVE_INET6) == 0) { /* AF_UNSPEC requested, store away */
                    if (walker->ai_addrlen == sizeof(struct sockaddr_in6)) {
                        const struct sockaddr_in6 *addr = (const struct sockaddr_in6 *)(void *)walker->ai_addr;
                        get_ip6(&ip6.ip.v6, &addr->sin6_addr);
                        result |= TOX_ADDR_RESOLVE_INET6;
                    }
                }

                break; /* switch */
            }
        }
    }

    if (family == AF_UNSPEC) {
        if ((result & TOX_ADDR_RESOLVE_INET6) != 0) {
            ip_copy(to, &ip6);

            if ((result & TOX_ADDR_RESOLVE_INET) != 0 && (extra != nullptr)) {
                ip_copy(extra, &ip4);
            }
        } else if ((result & TOX_ADDR_RESOLVE_INET) != 0) {
            ip_copy(to, &ip4);
        } else {
            result = 0;
        }
    }

    freeaddrinfo(server);
    return result;
}

bool addr_resolve_or_parse_ip(const Network *ns, const char *address, IP *to, IP *extra)
{
    if (addr_resolve(ns, address, to, extra) == 0) {
        if (!addr_parse_ip(address, to)) {
            return false;
        }
    }

    return true;
}

bool net_connect(const Logger *log, Socket sock, const IP_Port *ip_port)
{
    struct sockaddr_storage addr = {0};
    size_t addrsize;

    if (net_family_is_ipv4(ip_port->ip.family)) {
        struct sockaddr_in *addr4 = (struct sockaddr_in *)&addr;

        addrsize = sizeof(struct sockaddr_in);
        addr4->sin_family = AF_INET;
        fill_addr4(&ip_port->ip.ip.v4, &addr4->sin_addr);
        addr4->sin_port = ip_port->port;
    } else if (net_family_is_ipv6(ip_port->ip.family)) {
        struct sockaddr_in6 *addr6 = (struct sockaddr_in6 *)&addr;

        addrsize = sizeof(struct sockaddr_in6);
        addr6->sin6_family = AF_INET6;
        fill_addr6(&ip_port->ip.ip.v6, &addr6->sin6_addr);
        addr6->sin6_port = ip_port->port;
    } else {
        Ip_Ntoa ip_str;
        LOGGER_ERROR(log, "cannot connect to %s:%d which is neither IPv4 nor IPv6",
                     net_ip_ntoa(&ip_port->ip, &ip_str), net_ntohs(ip_port->port));
        return false;
    }

#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
    if ((true)) {
        return true;
    }
#endif

    Ip_Ntoa ip_str;
    LOGGER_DEBUG(log, "connecting socket %d to %s:%d",
                 (int)sock.sock, net_ip_ntoa(&ip_port->ip, &ip_str), net_ntohs(ip_port->port));
    errno = 0;

    if (connect(sock.sock, (struct sockaddr *)&addr, addrsize) == -1) {
        const int error = net_error();

        // Non-blocking socket: "Operation in progress" means it's connecting.
        if (!should_ignore_connect_error(error)) {
            char *net_strerror = net_new_strerror(error);
            LOGGER_ERROR(log, "failed to connect to %s:%d: %d (%s)",
                         net_ip_ntoa(&ip_port->ip, &ip_str), net_ntohs(ip_port->port), error, net_strerror);
            net_kill_strerror(net_strerror);
            return false;
        }
    }

    return true;
}

int32_t net_getipport(const char *node, IP_Port **res, int tox_type)
{
    // Try parsing as IP address first.
    IP_Port parsed = {{{0}}};
    // Initialise to nullptr. In error paths, at least we initialise the out
    // parameter.
    *res = nullptr;

    if (addr_parse_ip(node, &parsed.ip)) {
        IP_Port *tmp = (IP_Port *)calloc(1, sizeof(IP_Port));

        if (tmp == nullptr) {
            return -1;
        }

        tmp[0] = parsed;
        *res = tmp;
        return 1;
    }

#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
    if ((true)) {
        *res = (IP_Port *)calloc(1, sizeof(IP_Port));
        assert(*res != nullptr);
        IP_Port *ip_port = *res;
        ip_port->ip.ip.v4.uint32 = net_htonl(0x7F000003); // 127.0.0.3
        ip_port->ip.family = *make_tox_family(AF_INET);

        return 1;
    }
#endif

    // It's not an IP address, so now we try doing a DNS lookup.
    struct addrinfo *infos;
    const int ret = getaddrinfo(node, nullptr, nullptr, &infos);

    if (ret != 0) {
        return -1;
    }

    // Used to avoid calloc parameter overflow
    const size_t max_count = min_u64(SIZE_MAX, INT32_MAX) / sizeof(IP_Port);
    const int type = make_socktype(tox_type);
    size_t count = 0;

    for (struct addrinfo *cur = infos; count < max_count && cur != nullptr; cur = cur->ai_next) {
        if (cur->ai_socktype && type > 0 && cur->ai_socktype != type) {
            continue;
        }

        if (cur->ai_family != AF_INET && cur->ai_family != AF_INET6) {
            continue;
        }

        ++count;
    }

    assert(count <= max_count);

    if (count == 0) {
        freeaddrinfo(infos);
        return 0;
    }

    *res = (IP_Port *)calloc(count, sizeof(IP_Port));

    if (*res == nullptr) {
        freeaddrinfo(infos);
        return -1;
    }

    IP_Port *ip_port = *res;

    for (struct addrinfo *cur = infos; cur != nullptr; cur = cur->ai_next) {
        if (cur->ai_socktype && type > 0 && cur->ai_socktype != type) {
            continue;
        }

        if (cur->ai_family == AF_INET) {
            const struct sockaddr_in *addr = (const struct sockaddr_in *)(const void *)cur->ai_addr;
            memcpy(&ip_port->ip.ip.v4, &addr->sin_addr, sizeof(IP4));
        } else if (cur->ai_family == AF_INET6) {
            const struct sockaddr_in6 *addr = (const struct sockaddr_in6 *)(const void *)cur->ai_addr;
            memcpy(&ip_port->ip.ip.v6, &addr->sin6_addr, sizeof(IP6));
        } else {
            continue;
        }

        const Family *const family = make_tox_family(cur->ai_family);
        assert(family != nullptr);

        if (family == nullptr) {
            freeaddrinfo(infos);
            return -1;
        }

        ip_port->ip.family = *family;

        ++ip_port;
    }

    freeaddrinfo(infos);

    return count;
}

void net_freeipport(IP_Port *ip_ports)
{
    free(ip_ports);
}

bool bind_to_port(const Network *ns, Socket sock, Family family, uint16_t port)
{
    Network_Addr addr = {{0}};

    if (net_family_is_ipv4(family)) {
        struct sockaddr_in *addr4 = (struct sockaddr_in *)&addr.addr;

        addr.size = sizeof(struct sockaddr_in);
        addr4->sin_family = AF_INET;
        addr4->sin_port = net_htons(port);
    } else if (net_family_is_ipv6(family)) {
        struct sockaddr_in6 *addr6 = (struct sockaddr_in6 *)&addr.addr;

        addr.size = sizeof(struct sockaddr_in6);
        addr6->sin6_family = AF_INET6;
        addr6->sin6_port = net_htons(port);
    } else {
        return false;
    }

    return net_bind(ns, sock, &addr) == 0;
}

Socket net_socket(const Network *ns, Family domain, int type, int protocol)
{
    const int platform_domain = make_family(domain);
    const int platform_type = make_socktype(type);
    const int platform_prot = make_proto(protocol);
    const Socket sock = {ns->funcs->socket(ns->obj, platform_domain, platform_type, platform_prot)};
    return sock;
}

uint16_t net_socket_data_recv_buffer(const Network *ns, Socket sock)
{
    const int count = ns->funcs->recvbuf(ns->obj, sock.sock);
    return (uint16_t)max_s32(0, min_s32(count, UINT16_MAX));
}

uint32_t net_htonl(uint32_t hostlong)
{
    return htonl(hostlong);
}

uint16_t net_htons(uint16_t hostshort)
{
    return htons(hostshort);
}

uint32_t net_ntohl(uint32_t hostlong)
{
    return ntohl(hostlong);
}

uint16_t net_ntohs(uint16_t hostshort)
{
    return ntohs(hostshort);
}

size_t net_pack_bool(uint8_t *bytes, bool v)
{
    bytes[0] = v ? 1 : 0;
    return 1;
}

size_t net_pack_u16(uint8_t *bytes, uint16_t v)
{
    bytes[0] = (v >> 8) & 0xff;
    bytes[1] = v & 0xff;
    return sizeof(v);
}

size_t net_pack_u32(uint8_t *bytes, uint32_t v)
{
    uint8_t *p = bytes;
    p += net_pack_u16(p, (v >> 16) & 0xffff);
    p += net_pack_u16(p, v & 0xffff);
    return p - bytes;
}

size_t net_pack_u64(uint8_t *bytes, uint64_t v)
{
    uint8_t *p = bytes;
    p += net_pack_u32(p, (v >> 32) & 0xffffffff);
    p += net_pack_u32(p, v & 0xffffffff);
    return p - bytes;
}

size_t net_unpack_bool(const uint8_t *bytes, bool *v)
{
    *v = bytes[0] != 0;
    return 1;
}

size_t net_unpack_u16(const uint8_t *bytes, uint16_t *v)
{
    const uint8_t hi = bytes[0];
    const uint8_t lo = bytes[1];
    *v = ((uint16_t)hi << 8) | lo;
    return sizeof(*v);
}

size_t net_unpack_u32(const uint8_t *bytes, uint32_t *v)
{
    const uint8_t *p = bytes;
    uint16_t hi;
    uint16_t lo;
    p += net_unpack_u16(p, &hi);
    p += net_unpack_u16(p, &lo);
    *v = ((uint32_t)hi << 16) | lo;
    return p - bytes;
}

size_t net_unpack_u64(const uint8_t *bytes, uint64_t *v)
{
    const uint8_t *p = bytes;
    uint32_t hi;
    uint32_t lo;
    p += net_unpack_u32(p, &hi);
    p += net_unpack_u32(p, &lo);
    *v = ((uint64_t)hi << 32) | lo;
    return p - bytes;
}

bool ipv6_ipv4_in_v6(const IP6 *a)
{
    return a->uint64[0] == 0 && a->uint32[2] == net_htonl(0xffff);
}

int net_error(void)
{
#if defined(_WIN32) || defined(__WIN32__) || defined(WIN32)
    return WSAGetLastError();
#else
    return errno;
#endif
}

#if defined(_WIN32) || defined(__WIN32__) || defined(WIN32)
char *net_new_strerror(int error)
{
    char *str = nullptr;
    // Windows API is weird. The 5th function arg is of char* type, but we
    // have to pass char** so that it could assign new memory block to our
    // pointer, so we have to cast our char** to char* for the compilation
    // not to fail (otherwise it would fail to find a variant of this function
    // accepting char** as the 5th arg) and Windows inside casts it back
    // to char** to do the assignment. So no, this cast you see here, although
    // it looks weird, is not a mistake.
    FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, nullptr,
                   error, 0, (char *)&str, 0, nullptr);
    return str;
}
#else
#ifdef _GNU_SOURCE
non_null()
static const char *net_strerror_r(int error, char *tmp, size_t tmp_size)
{
    const char *retstr = strerror_r(error, tmp, tmp_size);

    if (errno != 0) {
        snprintf(tmp, tmp_size, "error %d (strerror_r failed with errno %d)", error, errno);
    }

    return retstr;
}
#else
non_null()
static const char *net_strerror_r(int error, char *tmp, size_t tmp_size)
{
    const int fmt_error = strerror_r(error, tmp, tmp_size);

    if (fmt_error != 0) {
        snprintf(tmp, tmp_size, "error %d (strerror_r failed with error %d, errno %d)", error, fmt_error, errno);
    }

    return tmp;
}
#endif
char *net_new_strerror(int error)
{
    char tmp[256];

    errno = 0;

    const char *retstr = net_strerror_r(error, tmp, sizeof(tmp));
    const size_t retstr_len = strlen(retstr);

    char *str = (char *)malloc(retstr_len + 1);

    if (str == nullptr) {
        return nullptr;
    }

    memcpy(str, retstr, retstr_len + 1);

    return str;
}
#endif

void net_kill_strerror(char *strerror)
{
#if defined(_WIN32) || defined(__WIN32__) || defined(WIN32)
    LocalFree((char *)strerror);
#else
    free(strerror);
#endif
}
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2018 The TokTok team.
 * Copyright © 2013 Tox project.
 */

/**
 * Implementation of the announce part of docs/Prevent_Tracking.txt
 */

#include <assert.h>
#include <stdlib.h>
#include <string.h>


#define PING_ID_TIMEOUT ONION_ANNOUNCE_TIMEOUT

#define ANNOUNCE_REQUEST_MIN_SIZE_RECV (ONION_ANNOUNCE_REQUEST_MIN_SIZE + ONION_RETURN_3)
#define ANNOUNCE_REQUEST_MAX_SIZE_RECV (ONION_ANNOUNCE_REQUEST_MAX_SIZE + ONION_RETURN_3)

/* TODO(Jfreegman): DEPRECATE */
#define ANNOUNCE_REQUEST_SIZE_RECV (ONION_ANNOUNCE_REQUEST_SIZE + ONION_RETURN_3)

#define DATA_REQUEST_MIN_SIZE ONION_DATA_REQUEST_MIN_SIZE
#define DATA_REQUEST_MIN_SIZE_RECV (DATA_REQUEST_MIN_SIZE + ONION_RETURN_3)

#define ONION_MINIMAL_SIZE (ONION_PING_ID_SIZE + CRYPTO_PUBLIC_KEY_SIZE * 2 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH)

/* Settings for the shared key cache */
#define MAX_KEYS_PER_SLOT 4
#define KEYS_TIMEOUT 600

static_assert(ONION_PING_ID_SIZE == CRYPTO_PUBLIC_KEY_SIZE,
              "announce response packets assume that ONION_PING_ID_SIZE is equal to CRYPTO_PUBLIC_KEY_SIZE");

typedef struct Onion_Announce_Entry {
    uint8_t public_key[CRYPTO_PUBLIC_KEY_SIZE];
    IP_Port ret_ip_port;
    uint8_t ret[ONION_RETURN_3];
    uint8_t data_public_key[CRYPTO_PUBLIC_KEY_SIZE];
    uint64_t announce_time;
} Onion_Announce_Entry;

struct Onion_Announce {
    const Logger *log;
    const Mono_Time *mono_time;
    const Random *rng;
    DHT     *dht;
    Networking_Core *net;
    Onion_Announce_Entry entries[ONION_ANNOUNCE_MAX_ENTRIES];
    uint8_t hmac_key[CRYPTO_HMAC_KEY_SIZE];

    Shared_Key_Cache *shared_keys_recv;

    uint16_t extra_data_max_size;
    pack_extra_data_cb *extra_data_callback;
    void *extra_data_object;
};

void onion_announce_extra_data_callback(Onion_Announce *onion_a, uint16_t extra_data_max_size,
                                        pack_extra_data_cb *extra_data_callback, void *extra_data_object)
{
    onion_a->extra_data_max_size = extra_data_max_size;
    onion_a->extra_data_callback = extra_data_callback;
    onion_a->extra_data_object = extra_data_object;
}

uint8_t *onion_announce_entry_public_key(Onion_Announce *onion_a, uint32_t entry)
{
    return onion_a->entries[entry].public_key;
}

void onion_announce_entry_set_time(Onion_Announce *onion_a, uint32_t entry, uint64_t announce_time)
{
    onion_a->entries[entry].announce_time = announce_time;
}

/** @brief Create an onion announce request packet in packet of max_packet_length.
 *
 * Recommended value for max_packet_length is ONION_ANNOUNCE_REQUEST_MIN_SIZE.
 *
 * dest_client_id is the public key of the node the packet will be sent to.
 * public_key and secret_key is the kepair which will be used to encrypt the request.
 * ping_id is the ping id that will be sent in the request.
 * client_id is the client id of the node we are searching for.
 * data_public_key is the public key we want others to encrypt their data packets with.
 * sendback_data is the data of ONION_ANNOUNCE_SENDBACK_DATA_LENGTH length that we expect to
 * receive back in the response.
 *
 * return -1 on failure.
 * return packet length on success.
 */
int create_announce_request(const Random *rng, uint8_t *packet, uint16_t max_packet_length, const uint8_t *dest_client_id,
                            const uint8_t *public_key, const uint8_t *secret_key, const uint8_t *ping_id, const uint8_t *client_id,
                            const uint8_t *data_public_key, uint64_t sendback_data)
{
    if (max_packet_length < ONION_ANNOUNCE_REQUEST_MIN_SIZE) {
        return -1;
    }

    uint8_t plain[ONION_PING_ID_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_PUBLIC_KEY_SIZE +
                                     ONION_ANNOUNCE_SENDBACK_DATA_LENGTH];
    memcpy(plain, ping_id, ONION_PING_ID_SIZE);
    memcpy(plain + ONION_PING_ID_SIZE, client_id, CRYPTO_PUBLIC_KEY_SIZE);
    memcpy(plain + ONION_PING_ID_SIZE + CRYPTO_PUBLIC_KEY_SIZE, data_public_key, CRYPTO_PUBLIC_KEY_SIZE);
    memcpy(plain + ONION_PING_ID_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_PUBLIC_KEY_SIZE, &sendback_data,
           sizeof(sendback_data));

    packet[0] = NET_PACKET_ANNOUNCE_REQUEST_OLD;
    random_nonce(rng, packet + 1);

    const int len = encrypt_data(dest_client_id, secret_key, packet + 1, plain, sizeof(plain),
                                 packet + 1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE);

    if ((uint32_t)len + 1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE != ONION_ANNOUNCE_REQUEST_MIN_SIZE) {
        return -1;
    }

    memcpy(packet + 1 + CRYPTO_NONCE_SIZE, public_key, CRYPTO_PUBLIC_KEY_SIZE);

    return ONION_ANNOUNCE_REQUEST_MIN_SIZE;
}

/** @brief Create an onion data request packet in packet of max_packet_length.
 *
 * Recommended value for max_packet_length is ONION_ANNOUNCE_REQUEST_SIZE.
 *
 * public_key is the real public key of the node which we want to send the data of length length to.
 * encrypt_public_key is the public key used to encrypt the data packet.
 *
 * nonce is the nonce to encrypt this packet with
 *
 * return -1 on failure.
 * return 0 on success.
 */
int create_data_request(const Random *rng, uint8_t *packet, uint16_t max_packet_length, const uint8_t *public_key,
                        const uint8_t *encrypt_public_key, const uint8_t *nonce, const uint8_t *data, uint16_t length)
{
    if (DATA_REQUEST_MIN_SIZE + length > max_packet_length) {
        return -1;
    }

    if (DATA_REQUEST_MIN_SIZE + length > ONION_MAX_DATA_SIZE) {
        return -1;
    }

    packet[0] = NET_PACKET_ONION_DATA_REQUEST;
    memcpy(packet + 1, public_key, CRYPTO_PUBLIC_KEY_SIZE);
    memcpy(packet + 1 + CRYPTO_PUBLIC_KEY_SIZE, nonce, CRYPTO_NONCE_SIZE);

    uint8_t random_public_key[CRYPTO_PUBLIC_KEY_SIZE];
    uint8_t random_secret_key[CRYPTO_SECRET_KEY_SIZE];
    crypto_new_keypair(rng, random_public_key, random_secret_key);

    memcpy(packet + 1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE, random_public_key, CRYPTO_PUBLIC_KEY_SIZE);

    const int len = encrypt_data(encrypt_public_key, random_secret_key, packet + 1 + CRYPTO_PUBLIC_KEY_SIZE, data, length,
                                 packet + 1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE);

    if (1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + len != DATA_REQUEST_MIN_SIZE +
            length) {
        return -1;
    }

    return DATA_REQUEST_MIN_SIZE + length;
}

/** @brief Create and send an onion announce request packet.
 *
 * path is the path the request will take before it is sent to dest.
 *
 * public_key and secret_key is the kepair which will be used to encrypt the request.
 * ping_id is the ping id that will be sent in the request.
 * client_id is the client id of the node we are searching for.
 * data_public_key is the public key we want others to encrypt their data packets with.
 * sendback_data is the data of ONION_ANNOUNCE_SENDBACK_DATA_LENGTH length that we expect to
 * receive back in the response.
 *
 * return -1 on failure.
 * return 0 on success.
 */
int send_announce_request(const Networking_Core *net, const Random *rng,
                          const Onion_Path *path, const Node_format *dest,
                          const uint8_t *public_key, const uint8_t *secret_key,
                          const uint8_t *ping_id, const uint8_t *client_id,
                          const uint8_t *data_public_key, uint64_t sendback_data)
{
    uint8_t request[ONION_ANNOUNCE_REQUEST_MIN_SIZE];
    int len = create_announce_request(rng, request, sizeof(request), dest->public_key, public_key, secret_key, ping_id,
                                      client_id, data_public_key, sendback_data);

    if (len != sizeof(request)) {
        return -1;
    }

    uint8_t packet[ONION_MAX_PACKET_SIZE];
    len = create_onion_packet(rng, packet, sizeof(packet), path, &dest->ip_port, request, sizeof(request));

    if (len == -1) {
        return -1;
    }

    if (sendpacket(net, &path->ip_port1, packet, len) != len) {
        return -1;
    }

    return 0;
}

/** @brief Create and send an onion data request packet.
 *
 * path is the path the request will take before it is sent to dest.
 * (if dest knows the person with the public_key they should
 * send the packet to that person in the form of a response)
 *
 * public_key is the real public key of the node which we want to send the data of length length to.
 * encrypt_public_key is the public key used to encrypt the data packet.
 *
 * nonce is the nonce to encrypt this packet with
 *
 * The maximum length of data is MAX_DATA_REQUEST_SIZE.
 *
 * return -1 on failure.
 * return 0 on success.
 */
int send_data_request(const Networking_Core *net, const Random *rng, const Onion_Path *path, const IP_Port *dest,
                      const uint8_t *public_key, const uint8_t *encrypt_public_key, const uint8_t *nonce,
                      const uint8_t *data, uint16_t length)
{
    uint8_t request[ONION_MAX_DATA_SIZE];
    int len = create_data_request(rng, request, sizeof(request), public_key, encrypt_public_key, nonce, data, length);

    if (len == -1) {
        return -1;
    }

    uint8_t packet[ONION_MAX_PACKET_SIZE];
    len = create_onion_packet(rng, packet, sizeof(packet), path, dest, request, len);

    if (len == -1) {
        return -1;
    }

    if (sendpacket(net, &path->ip_port1, packet, len) != len) {
        return -1;
    }

    return 0;
}

/** @brief check if public key is in entries list
 *
 * return -1 if no
 * return position in list if yes
 */
non_null()
static int in_entries(const Onion_Announce *onion_a, const uint8_t *public_key)
{
    for (unsigned int i = 0; i < ONION_ANNOUNCE_MAX_ENTRIES; ++i) {
        if (!mono_time_is_timeout(onion_a->mono_time, onion_a->entries[i].announce_time, ONION_ANNOUNCE_TIMEOUT)
                && pk_equal(onion_a->entries[i].public_key, public_key)) {
            return i;
        }
    }

    return -1;
}

typedef struct Cmp_Data {
    const Mono_Time *mono_time;
    const uint8_t *base_public_key;
    Onion_Announce_Entry entry;
} Cmp_Data;

non_null()
static int cmp_entry(const void *a, const void *b)
{
    const Cmp_Data *cmp1 = (const Cmp_Data *)a;
    const Cmp_Data *cmp2 = (const Cmp_Data *)b;
    const Onion_Announce_Entry entry1 = cmp1->entry;
    const Onion_Announce_Entry entry2 = cmp2->entry;
    const uint8_t *cmp_public_key = cmp1->base_public_key;

    const bool t1 = mono_time_is_timeout(cmp1->mono_time, entry1.announce_time, ONION_ANNOUNCE_TIMEOUT);
    const bool t2 = mono_time_is_timeout(cmp1->mono_time, entry2.announce_time, ONION_ANNOUNCE_TIMEOUT);

    if (t1 && t2) {
        return 0;
    }

    if (t1) {
        return -1;
    }

    if (t2) {
        return 1;
    }

    const int closest = id_closest(cmp_public_key, entry1.public_key, entry2.public_key);

    if (closest == 1) {
        return 1;
    }

    if (closest == 2) {
        return -1;
    }

    return 0;
}

non_null()
static void sort_onion_announce_list(Onion_Announce_Entry *list, unsigned int length, const Mono_Time *mono_time,
                                     const uint8_t *comp_public_key)
{
    // Pass comp_public_key to qsort with each Client_data entry, so the
    // comparison function can use it as the base of comparison.
    Cmp_Data *cmp_list = (Cmp_Data *)calloc(length, sizeof(Cmp_Data));

    if (cmp_list == nullptr) {
        return;
    }

    for (uint32_t i = 0; i < length; ++i) {
        cmp_list[i].mono_time = mono_time;
        cmp_list[i].base_public_key = comp_public_key;
        cmp_list[i].entry = list[i];
    }

    qsort(cmp_list, length, sizeof(Cmp_Data), cmp_entry);

    for (uint32_t i = 0; i < length; ++i) {
        list[i] = cmp_list[i].entry;
    }

    free(cmp_list);
}

/** @brief add entry to entries list
 *
 * return -1 if failure
 * return position if added
 */
non_null()
static int add_to_entries(Onion_Announce *onion_a, const IP_Port *ret_ip_port, const uint8_t *public_key,
                          const uint8_t *data_public_key, const uint8_t *ret)
{
    int pos = in_entries(onion_a, public_key);

    if (pos == -1) {
        for (unsigned i = 0; i < ONION_ANNOUNCE_MAX_ENTRIES; ++i) {
            if (mono_time_is_timeout(onion_a->mono_time, onion_a->entries[i].announce_time, ONION_ANNOUNCE_TIMEOUT)) {
                pos = i;
            }
        }
    }

    if (pos == -1) {
        if (id_closest(dht_get_self_public_key(onion_a->dht), public_key, onion_a->entries[0].public_key) == 1) {
            pos = 0;
        }
    }

    if (pos == -1) {
        return -1;
    }

    memcpy(onion_a->entries[pos].public_key, public_key, CRYPTO_PUBLIC_KEY_SIZE);
    onion_a->entries[pos].ret_ip_port = *ret_ip_port;
    memcpy(onion_a->entries[pos].ret, ret, ONION_RETURN_3);
    memcpy(onion_a->entries[pos].data_public_key, data_public_key, CRYPTO_PUBLIC_KEY_SIZE);
    onion_a->entries[pos].announce_time = mono_time_get(onion_a->mono_time);

    sort_onion_announce_list(onion_a->entries, ONION_ANNOUNCE_MAX_ENTRIES, onion_a->mono_time,
                             dht_get_self_public_key(onion_a->dht));
    return in_entries(onion_a, public_key);
}

non_null()
static void make_announce_payload_helper(const Onion_Announce *onion_a, const uint8_t *ping_id,
        uint8_t *response, int index, const uint8_t *packet_public_key, const uint8_t *data_public_key)
{
    if (index < 0) {
        response[0] = 0;
        memcpy(response + 1, ping_id, ONION_PING_ID_SIZE);
        return;
    }

    if (pk_equal(onion_a->entries[index].public_key, packet_public_key)) {
        if (!pk_equal(onion_a->entries[index].data_public_key, data_public_key)) {
            response[0] = 0;
            memcpy(response + 1, ping_id, ONION_PING_ID_SIZE);
        } else {
            response[0] = 2;
            memcpy(response + 1, ping_id, ONION_PING_ID_SIZE);
        }
    } else {
        response[0] = 1;
        memcpy(response + 1, onion_a->entries[index].data_public_key, CRYPTO_PUBLIC_KEY_SIZE);
    }
}

/** @brief Handle an onion announce request, possibly with extra data for group chats.
 *
 * @param onion_a The announce object.
 * @param source Requester IP/Port.
 * @param packet Encrypted incoming packet.
 * @param length Length of incoming packet.
 * @param response_packet_id Packet ID to use for the onion announce response.
 * @param plain_size Expected size of the decrypted packet. This function returns an error if the
 *   actual decrypted size is not exactly equal to this number.
 * @param want_node_count If true, the packed nodes in the response are preceded by the number of
 *   nodes sent in the packet. This is necessary if you want to send extra data after the nodes.
 * @param max_extra_size Amount of memory to allocate in the outgoing packet to be filled by the
 *   extra data callback.
 * @param pack_extra_data_callback Callback that may write extra data into the packet.
 *
 * @retval 1 on failure.
 * @retval 0 on success.
 */
non_null(1, 2, 3) nullable(9)
static int handle_announce_request_common(
    Onion_Announce *onion_a, const IP_Port *source, const uint8_t *packet, uint16_t length,
    uint8_t response_packet_id, uint16_t plain_size, bool want_node_count, uint16_t max_extra_size,
    pack_extra_data_cb *pack_extra_data_callback)
{
    const uint8_t *packet_public_key = packet + 1 + CRYPTO_NONCE_SIZE;
    const uint8_t *shared_key = shared_key_cache_lookup(onion_a->shared_keys_recv, packet_public_key);

    if (shared_key == nullptr) {
        /* Error looking up/deriving the shared key */
        return 1;
    }

    uint8_t *plain = (uint8_t *)malloc(plain_size);

    if (plain == nullptr) {
        return 1;
    }

    const int decrypted_len = decrypt_data_symmetric(shared_key, packet + 1,
                              packet + 1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE, plain_size + CRYPTO_MAC_SIZE, plain);

    if ((uint32_t)decrypted_len != plain_size) {
        free(plain);
        return 1;
    }

    const uint16_t ping_id_data_len = CRYPTO_PUBLIC_KEY_SIZE + sizeof(*source);
    uint8_t ping_id_data[CRYPTO_PUBLIC_KEY_SIZE + sizeof(*source)];
    memcpy(ping_id_data, packet_public_key, CRYPTO_PUBLIC_KEY_SIZE);
    memcpy(ping_id_data + CRYPTO_PUBLIC_KEY_SIZE, source, sizeof(*source));

    const uint8_t *data_public_key = plain + ONION_PING_ID_SIZE + CRYPTO_PUBLIC_KEY_SIZE;

    int index;

    if (check_timed_auth(onion_a->mono_time, PING_ID_TIMEOUT, onion_a->hmac_key,
                         ping_id_data, ping_id_data_len, plain)) {
        index = add_to_entries(onion_a, source, packet_public_key, data_public_key,
                               packet + (length - ONION_RETURN_3));
    } else {
        index = in_entries(onion_a, plain + ONION_PING_ID_SIZE);
    }

    /* Respond with a announce response packet */
    Node_format nodes_list[MAX_SENT_NODES];
    const unsigned int num_nodes =
        get_close_nodes(onion_a->dht, plain + ONION_PING_ID_SIZE, nodes_list, net_family_unspec(), ip_is_lan(&source->ip), false);

    assert(num_nodes <= UINT8_MAX);

    uint8_t nonce[CRYPTO_NONCE_SIZE];
    random_nonce(onion_a->rng, nonce);

    const uint16_t nodes_offset = 1 + ONION_PING_ID_SIZE + (want_node_count ? 1 : 0);
    const uint16_t response_size = nodes_offset
                                   + MAX_SENT_NODES * PACKED_NODE_SIZE_IP6
                                   + max_extra_size;
    uint8_t *response = (uint8_t *)malloc(response_size);

    if (response == nullptr) {
        free(plain);
        return 1;
    }

    uint8_t ping_id[TIMED_AUTH_SIZE];
    generate_timed_auth(onion_a->mono_time, PING_ID_TIMEOUT, onion_a->hmac_key,
                        ping_id_data, ping_id_data_len, ping_id);

    make_announce_payload_helper(onion_a, ping_id, response, index, packet_public_key, data_public_key);

    int nodes_length = 0;

    if (num_nodes != 0) {
        nodes_length = pack_nodes(onion_a->log, response + nodes_offset, sizeof(nodes_list), nodes_list,
                                  (uint16_t)num_nodes);

        if (nodes_length <= 0) {
            LOGGER_WARNING(onion_a->log, "Failed to pack nodes");
            free(response);
            free(plain);
            return 1;
        }
    }

    uint16_t offset = nodes_offset + nodes_length;

    if (want_node_count) {
        response[1 + ONION_PING_ID_SIZE] = (uint8_t)num_nodes;
    }

    const int extra_size = pack_extra_data_callback == nullptr ? 0
                           : pack_extra_data_callback(onion_a->extra_data_object,
                                   onion_a->log, onion_a->mono_time, num_nodes,
                                   plain + ONION_MINIMAL_SIZE, length - ANNOUNCE_REQUEST_MIN_SIZE_RECV,
                                   response, response_size, offset);

    if (extra_size == -1) {
        free(response);
        free(plain);
        return 1;
    }

    offset += extra_size;

    uint8_t data[ONION_ANNOUNCE_RESPONSE_MAX_SIZE];
    const int len = encrypt_data_symmetric(shared_key, nonce, response, offset,
                                           data + 1 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_NONCE_SIZE);

    if (len != offset + CRYPTO_MAC_SIZE) {
        LOGGER_ERROR(onion_a->log, "Failed to encrypt announce response");
        free(response);
        free(plain);
        return 1;
    }

    data[0] = response_packet_id;
    memcpy(data + 1, plain + ONION_PING_ID_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_PUBLIC_KEY_SIZE,
           ONION_ANNOUNCE_SENDBACK_DATA_LENGTH);
    memcpy(data + 1 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH, nonce, CRYPTO_NONCE_SIZE);

    if (send_onion_response(onion_a->net, source, data,
                            1 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_NONCE_SIZE + len,
                            packet + (length - ONION_RETURN_3)) == -1) {
        free(response);
        free(plain);
        return 1;
    }

    free(response);
    free(plain);
    return 0;
}

non_null()
static int handle_gca_announce_request(Onion_Announce *onion_a, const IP_Port *source, const uint8_t *packet,
                                       uint16_t length)
{
    if (length > ANNOUNCE_REQUEST_MAX_SIZE_RECV || length <= ANNOUNCE_REQUEST_MIN_SIZE_RECV) {
        return 1;
    }

    if (onion_a->extra_data_callback == nullptr) {
        return 1;
    }

    return handle_announce_request_common(onion_a, source, packet, length, NET_PACKET_ANNOUNCE_RESPONSE,
                                          ONION_MINIMAL_SIZE + length - ANNOUNCE_REQUEST_MIN_SIZE_RECV,
                                          true, onion_a->extra_data_max_size, onion_a->extra_data_callback);
}

non_null(1, 2, 3) nullable(5)
static int handle_announce_request(void *object, const IP_Port *source, const uint8_t *packet, uint16_t length,
                                   void *userdata)
{
    Onion_Announce *onion_a = (Onion_Announce *)object;

    if (length != ANNOUNCE_REQUEST_MIN_SIZE_RECV) {
        return handle_gca_announce_request(onion_a, source, packet, length);
    }

    return handle_announce_request_common(onion_a, source, packet, length, NET_PACKET_ANNOUNCE_RESPONSE,
                                          ONION_PING_ID_SIZE + CRYPTO_PUBLIC_KEY_SIZE * 2 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH,
                                          true, 0, nullptr);
}

/* TODO(Jfreegman): DEPRECATE */
non_null(1, 2, 3) nullable(5)
static int handle_announce_request_old(void *object, const IP_Port *source, const uint8_t *packet, uint16_t length,
                                       void *userdata)
{
    Onion_Announce *onion_a = (Onion_Announce *)object;

    if (length != ANNOUNCE_REQUEST_SIZE_RECV) {
        return 1;
    }

    return handle_announce_request_common(onion_a, source, packet, length, NET_PACKET_ANNOUNCE_RESPONSE_OLD,
                                          ONION_PING_ID_SIZE + CRYPTO_PUBLIC_KEY_SIZE * 2 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH,
                                          false, 0, nullptr);
}

non_null()
static int handle_data_request(void *object, const IP_Port *source, const uint8_t *packet, uint16_t length,
                               void *userdata)
{
    const Onion_Announce *onion_a = (const Onion_Announce *)object;

    if (length <= DATA_REQUEST_MIN_SIZE_RECV) {
        return 1;
    }

    if (length > ONION_MAX_PACKET_SIZE) {
        return 1;
    }

    const int index = in_entries(onion_a, packet + 1);

    if (index == -1) {
        return 1;
    }

    VLA(uint8_t, data, length - (CRYPTO_PUBLIC_KEY_SIZE + ONION_RETURN_3));
    data[0] = NET_PACKET_ONION_DATA_RESPONSE;
    memcpy(data + 1, packet + 1 + CRYPTO_PUBLIC_KEY_SIZE, length - (1 + CRYPTO_PUBLIC_KEY_SIZE + ONION_RETURN_3));

    if (send_onion_response(onion_a->net, &onion_a->entries[index].ret_ip_port, data, SIZEOF_VLA(data),
                            onion_a->entries[index].ret) == -1) {
        return 1;
    }

    return 0;
}

Onion_Announce *new_onion_announce(const Logger *log, const Random *rng, const Mono_Time *mono_time, DHT *dht)
{
    if (dht == nullptr) {
        return nullptr;
    }

    Onion_Announce *onion_a = (Onion_Announce *)calloc(1, sizeof(Onion_Announce));

    if (onion_a == nullptr) {
        return nullptr;
    }

    onion_a->log = log;
    onion_a->rng = rng;
    onion_a->mono_time = mono_time;
    onion_a->dht = dht;
    onion_a->net = dht_get_net(dht);
    onion_a->extra_data_max_size = 0;
    onion_a->extra_data_callback = nullptr;
    onion_a->extra_data_object = nullptr;
    new_hmac_key(rng, onion_a->hmac_key);

    onion_a->shared_keys_recv = shared_key_cache_new(mono_time, dht_get_self_secret_key(dht), KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
    if (onion_a->shared_keys_recv == nullptr) {
        kill_onion_announce(onion_a);
        return nullptr;
    }

    networking_registerhandler(onion_a->net, NET_PACKET_ANNOUNCE_REQUEST, &handle_announce_request, onion_a);
    networking_registerhandler(onion_a->net, NET_PACKET_ANNOUNCE_REQUEST_OLD, &handle_announce_request_old, onion_a);
    networking_registerhandler(onion_a->net, NET_PACKET_ONION_DATA_REQUEST, &handle_data_request, onion_a);

    return onion_a;
}

void kill_onion_announce(Onion_Announce *onion_a)
{
    if (onion_a == nullptr) {
        return;
    }

    networking_registerhandler(onion_a->net, NET_PACKET_ANNOUNCE_REQUEST, nullptr, nullptr);
    networking_registerhandler(onion_a->net, NET_PACKET_ANNOUNCE_REQUEST_OLD, nullptr, nullptr);
    networking_registerhandler(onion_a->net, NET_PACKET_ONION_DATA_REQUEST, nullptr, nullptr);

    crypto_memzero(onion_a->hmac_key, CRYPTO_HMAC_KEY_SIZE);
    shared_key_cache_free(onion_a->shared_keys_recv);

    free(onion_a);
}
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2018 The TokTok team.
 * Copyright © 2013 Tox project.
 */

/**
 * Implementation of the onion part of docs/Prevent_Tracking.txt
 */

#include <assert.h>
#include <stdlib.h>
#include <string.h>


#define RETURN_1 ONION_RETURN_1
#define RETURN_2 ONION_RETURN_2
#define RETURN_3 ONION_RETURN_3

#define SEND_BASE ONION_SEND_BASE
#define SEND_3 ONION_SEND_3
#define SEND_2 ONION_SEND_2
#define SEND_1 ONION_SEND_1

#define KEY_REFRESH_INTERVAL (2 * 60 * 60)


// Settings for the shared key cache
#define MAX_KEYS_PER_SLOT 4
#define KEYS_TIMEOUT 600

/** Change symmetric keys every 2 hours to make paths expire eventually. */
non_null()
static void change_symmetric_key(Onion *onion)
{
    if (mono_time_is_timeout(onion->mono_time, onion->timestamp, KEY_REFRESH_INTERVAL)) {
        new_symmetric_key(onion->rng, onion->secret_symmetric_key);
        onion->timestamp = mono_time_get(onion->mono_time);
    }
}

/** packing and unpacking functions */
non_null()
static void ip_pack(uint8_t *data, const IP *source)
{
    data[0] = source->family.value;

    if (net_family_is_ipv4(source->family) || net_family_is_tox_tcp_ipv4(source->family)) {
        memset(data + 1, 0, SIZE_IP6);
        memcpy(data + 1, source->ip.v4.uint8, SIZE_IP4);
    } else {
        memcpy(data + 1, source->ip.v6.uint8, SIZE_IP6);
    }
}

/** return 0 on success, -1 on failure. */
non_null()
static int ip_unpack(IP *target, const uint8_t *data, unsigned int data_size, bool disable_family_check)
{
    if (data_size < (1 + SIZE_IP6)) {
        return -1;
    }

    // TODO(iphydf): Validate input.
    target->family.value = data[0];

    if (net_family_is_ipv4(target->family) || net_family_is_tox_tcp_ipv4(target->family)) {
        memcpy(target->ip.v4.uint8, data + 1, SIZE_IP4);
    } else {
        memcpy(target->ip.v6.uint8, data + 1, SIZE_IP6);
    }

    const bool valid = disable_family_check ||
                 net_family_is_ipv4(target->family) ||
                 net_family_is_ipv6(target->family);

    return valid ? 0 : -1;
}

non_null()
static void ipport_pack(uint8_t *data, const IP_Port *source)
{
    ip_pack(data, &source->ip);
    memcpy(data + SIZE_IP, &source->port, SIZE_PORT);
}

/** return 0 on success, -1 on failure. */
non_null()
static int ipport_unpack(IP_Port *target, const uint8_t *data, unsigned int data_size, bool disable_family_check)
{
    if (data_size < (SIZE_IP + SIZE_PORT)) {
        return -1;
    }

    if (ip_unpack(&target->ip, data, data_size, disable_family_check) == -1) {
        return -1;
    }

    memcpy(&target->port, data + SIZE_IP, SIZE_PORT);
    return 0;
}


/** @brief Create a new onion path.
 *
 * Create a new onion path out of nodes (nodes is a list of ONION_PATH_LENGTH nodes)
 *
 * new_path must be an empty memory location of at least Onion_Path size.
 *
 * return -1 on failure.
 * return 0 on success.
 */
int create_onion_path(const Random *rng, const DHT *dht, Onion_Path *new_path, const Node_format *nodes)
{
    if (new_path == nullptr || nodes == nullptr) {
        return -1;
    }

    encrypt_precompute(nodes[0].public_key, dht_get_self_secret_key(dht), new_path->shared_key1);
    memcpy(new_path->public_key1, dht_get_self_public_key(dht), CRYPTO_PUBLIC_KEY_SIZE);

    uint8_t random_public_key[CRYPTO_PUBLIC_KEY_SIZE];
    uint8_t random_secret_key[CRYPTO_SECRET_KEY_SIZE];

    crypto_new_keypair(rng, random_public_key, random_secret_key);
    encrypt_precompute(nodes[1].public_key, random_secret_key, new_path->shared_key2);
    memcpy(new_path->public_key2, random_public_key, CRYPTO_PUBLIC_KEY_SIZE);

    crypto_new_keypair(rng, random_public_key, random_secret_key);
    encrypt_precompute(nodes[2].public_key, random_secret_key, new_path->shared_key3);
    memcpy(new_path->public_key3, random_public_key, CRYPTO_PUBLIC_KEY_SIZE);

    crypto_memzero(random_secret_key, sizeof(random_secret_key));

    new_path->ip_port1 = nodes[0].ip_port;
    new_path->ip_port2 = nodes[1].ip_port;
    new_path->ip_port3 = nodes[2].ip_port;

    memcpy(new_path->node_public_key1, nodes[0].public_key, CRYPTO_PUBLIC_KEY_SIZE);
    memcpy(new_path->node_public_key2, nodes[1].public_key, CRYPTO_PUBLIC_KEY_SIZE);
    memcpy(new_path->node_public_key3, nodes[2].public_key, CRYPTO_PUBLIC_KEY_SIZE);

    return 0;
}

/** @brief Dump nodes in onion path to nodes of length num_nodes.
 *
 * return -1 on failure.
 * return 0 on success.
 */
int onion_path_to_nodes(Node_format *nodes, unsigned int num_nodes, const Onion_Path *path)
{
    if (num_nodes < ONION_PATH_LENGTH) {
        return -1;
    }

    nodes[0].ip_port = path->ip_port1;
    nodes[1].ip_port = path->ip_port2;
    nodes[2].ip_port = path->ip_port3;

    memcpy(nodes[0].public_key, path->node_public_key1, CRYPTO_PUBLIC_KEY_SIZE);
    memcpy(nodes[1].public_key, path->node_public_key2, CRYPTO_PUBLIC_KEY_SIZE);
    memcpy(nodes[2].public_key, path->node_public_key3, CRYPTO_PUBLIC_KEY_SIZE);
    return 0;
}

/** @brief Create a onion packet.
 *
 * Use Onion_Path path to create packet for data of length to dest.
 * Maximum length of data is ONION_MAX_DATA_SIZE.
 * packet should be at least ONION_MAX_PACKET_SIZE big.
 *
 * return -1 on failure.
 * return length of created packet on success.
 */
int create_onion_packet(const Random *rng, uint8_t *packet, uint16_t max_packet_length,
                        const Onion_Path *path, const IP_Port *dest,
                        const uint8_t *data, uint16_t length)
{
    if (1 + length + SEND_1 > max_packet_length || length == 0) {
        return -1;
    }

    VLA(uint8_t, step1, SIZE_IPPORT + length);

    ipport_pack(step1, dest);
    memcpy(step1 + SIZE_IPPORT, data, length);

    uint8_t nonce[CRYPTO_NONCE_SIZE];
    random_nonce(rng, nonce);

    VLA(uint8_t, step2, SIZE_IPPORT + SEND_BASE + length);
    ipport_pack(step2, &path->ip_port3);
    memcpy(step2 + SIZE_IPPORT, path->public_key3, CRYPTO_PUBLIC_KEY_SIZE);

    int len = encrypt_data_symmetric(path->shared_key3, nonce, step1, SIZEOF_VLA(step1),
                                     step2 + SIZE_IPPORT + CRYPTO_PUBLIC_KEY_SIZE);

    if (len != SIZE_IPPORT + length + CRYPTO_MAC_SIZE) {
        return -1;
    }

    VLA(uint8_t, step3, SIZE_IPPORT + SEND_BASE * 2 + length);
    ipport_pack(step3, &path->ip_port2);
    memcpy(step3 + SIZE_IPPORT, path->public_key2, CRYPTO_PUBLIC_KEY_SIZE);
    len = encrypt_data_symmetric(path->shared_key2, nonce, step2, SIZEOF_VLA(step2),
                                 step3 + SIZE_IPPORT + CRYPTO_PUBLIC_KEY_SIZE);

    if (len != SIZE_IPPORT + SEND_BASE + length + CRYPTO_MAC_SIZE) {
        return -1;
    }

    packet[0] = NET_PACKET_ONION_SEND_INITIAL;
    memcpy(packet + 1, nonce, CRYPTO_NONCE_SIZE);
    memcpy(packet + 1 + CRYPTO_NONCE_SIZE, path->public_key1, CRYPTO_PUBLIC_KEY_SIZE);

    len = encrypt_data_symmetric(path->shared_key1, nonce, step3, SIZEOF_VLA(step3),
                                 packet + 1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE);

    if (len != SIZE_IPPORT + SEND_BASE * 2 + length + CRYPTO_MAC_SIZE) {
        return -1;
    }

    return 1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + len;
}

/** @brief Create a onion packet to be sent over tcp.
 *
 * Use Onion_Path path to create packet for data of length to dest.
 * Maximum length of data is ONION_MAX_DATA_SIZE.
 * packet should be at least ONION_MAX_PACKET_SIZE big.
 *
 * return -1 on failure.
 * return length of created packet on success.
 */
int create_onion_packet_tcp(const Random *rng, uint8_t *packet, uint16_t max_packet_length,
                            const Onion_Path *path, const IP_Port *dest,
                            const uint8_t *data, uint16_t length)
{
    if (CRYPTO_NONCE_SIZE + SIZE_IPPORT + SEND_BASE * 2 + length > max_packet_length || length == 0) {
        return -1;
    }

    VLA(uint8_t, step1, SIZE_IPPORT + length);

    ipport_pack(step1, dest);
    memcpy(step1 + SIZE_IPPORT, data, length);

    uint8_t nonce[CRYPTO_NONCE_SIZE];
    random_nonce(rng, nonce);

    VLA(uint8_t, step2, SIZE_IPPORT + SEND_BASE + length);
    ipport_pack(step2, &path->ip_port3);
    memcpy(step2 + SIZE_IPPORT, path->public_key3, CRYPTO_PUBLIC_KEY_SIZE);

    int len = encrypt_data_symmetric(path->shared_key3, nonce, step1, SIZEOF_VLA(step1),
                                     step2 + SIZE_IPPORT + CRYPTO_PUBLIC_KEY_SIZE);

    if (len != SIZE_IPPORT + length + CRYPTO_MAC_SIZE) {
        return -1;
    }

    ipport_pack(packet + CRYPTO_NONCE_SIZE, &path->ip_port2);
    memcpy(packet + CRYPTO_NONCE_SIZE + SIZE_IPPORT, path->public_key2, CRYPTO_PUBLIC_KEY_SIZE);
    len = encrypt_data_symmetric(path->shared_key2, nonce, step2, SIZEOF_VLA(step2),
                                 packet + CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_PUBLIC_KEY_SIZE);

    if (len != SIZE_IPPORT + SEND_BASE + length + CRYPTO_MAC_SIZE) {
        return -1;
    }

    memcpy(packet, nonce, CRYPTO_NONCE_SIZE);

    return CRYPTO_NONCE_SIZE + SIZE_IPPORT + CRYPTO_PUBLIC_KEY_SIZE + len;
}

/** @brief Create and send a onion response sent initially to dest with.
 * Maximum length of data is ONION_RESPONSE_MAX_DATA_SIZE.
 *
 * return -1 on failure.
 * return 0 on success.
 */
int send_onion_response(const Networking_Core *net, const IP_Port *dest, const uint8_t *data, uint16_t length,
                        const uint8_t *ret)
{
    if (length > ONION_RESPONSE_MAX_DATA_SIZE || length == 0) {
        return -1;
    }

    VLA(uint8_t, packet, 1 + RETURN_3 + length);
    packet[0] = NET_PACKET_ONION_RECV_3;
    memcpy(packet + 1, ret, RETURN_3);
    memcpy(packet + 1 + RETURN_3, data, length);

    if ((uint32_t)sendpacket(net, dest, packet, SIZEOF_VLA(packet)) != SIZEOF_VLA(packet)) {
        return -1;
    }

    return 0;
}

non_null()
static int handle_send_initial(void *object, const IP_Port *source, const uint8_t *packet, uint16_t length,
                               void *userdata)
{
    Onion *onion = (Onion *)object;

    if (length > ONION_MAX_PACKET_SIZE) {
        return 1;
    }

    if (length <= 1 + SEND_1) {
        return 1;
    }

    change_symmetric_key(onion);

    uint8_t plain[ONION_MAX_PACKET_SIZE];
    const uint8_t *public_key = packet + 1 + CRYPTO_NONCE_SIZE;
    const uint8_t *shared_key = shared_key_cache_lookup(onion->shared_keys_1, public_key);

    if (shared_key == nullptr) {
        /* Error looking up/deriving the shared key */
        return 1;
    }

    const int len = decrypt_data_symmetric(shared_key, packet + 1, packet + 1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE,
                                     length - (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE), plain);

    if (len != length - (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_MAC_SIZE)) {
        return 1;
    }

    return onion_send_1(onion, plain, len, source, packet + 1);
}

int onion_send_1(const Onion *onion, const uint8_t *plain, uint16_t len, const IP_Port *source, const uint8_t *nonce)
{
    if (len > ONION_MAX_PACKET_SIZE + SIZE_IPPORT - (1 + CRYPTO_NONCE_SIZE + ONION_RETURN_1)) {
        return 1;
    }

    if (len <= SIZE_IPPORT + SEND_BASE * 2) {
        return 1;
    }

    IP_Port send_to;

    if (ipport_unpack(&send_to, plain, len, false) == -1) {
        return 1;
    }

    uint8_t ip_port[SIZE_IPPORT];
    ipport_pack(ip_port, source);

    uint8_t data[ONION_MAX_PACKET_SIZE] = {0};
    data[0] = NET_PACKET_ONION_SEND_1;
    memcpy(data + 1, nonce, CRYPTO_NONCE_SIZE);
    memcpy(data + 1 + CRYPTO_NONCE_SIZE, plain + SIZE_IPPORT, len - SIZE_IPPORT);
    uint16_t data_len = 1 + CRYPTO_NONCE_SIZE + (len - SIZE_IPPORT);
    uint8_t *ret_part = data + data_len;
    random_nonce(onion->rng, ret_part);
    len = encrypt_data_symmetric(onion->secret_symmetric_key, ret_part, ip_port, SIZE_IPPORT,
                                 ret_part + CRYPTO_NONCE_SIZE);

    if (len != SIZE_IPPORT + CRYPTO_MAC_SIZE) {
        return 1;
    }

    data_len += CRYPTO_NONCE_SIZE + len;

    if ((uint32_t)sendpacket(onion->net, &send_to, data, data_len) != data_len) {
        return 1;
    }

    return 0;
}

non_null()
static int handle_send_1(void *object, const IP_Port *source, const uint8_t *packet, uint16_t length, void *userdata)
{
    Onion *onion = (Onion *)object;

    if (length > ONION_MAX_PACKET_SIZE) {
        return 1;
    }

    if (length <= 1 + SEND_2) {
        return 1;
    }

    change_symmetric_key(onion);

    uint8_t plain[ONION_MAX_PACKET_SIZE];
    const uint8_t *public_key = packet + 1 + CRYPTO_NONCE_SIZE;
    const uint8_t *shared_key = shared_key_cache_lookup(onion->shared_keys_2, public_key);

    if (shared_key == nullptr) {
        /* Error looking up/deriving the shared key */
        return 1;
    }

    int len = decrypt_data_symmetric(shared_key, packet + 1, packet + 1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE,
                                     length - (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + RETURN_1), plain);

    if (len != length - (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + RETURN_1 + CRYPTO_MAC_SIZE)) {
        return 1;
    }

    IP_Port send_to;

    if (ipport_unpack(&send_to, plain, len, false) == -1) {
        return 1;
    }

    uint8_t data[ONION_MAX_PACKET_SIZE] = {0};
    data[0] = NET_PACKET_ONION_SEND_2;
    memcpy(data + 1, packet + 1, CRYPTO_NONCE_SIZE);
    memcpy(data + 1 + CRYPTO_NONCE_SIZE, plain + SIZE_IPPORT, len - SIZE_IPPORT);
    uint16_t data_len = 1 + CRYPTO_NONCE_SIZE + (len - SIZE_IPPORT);
    uint8_t *ret_part = data + data_len;
    random_nonce(onion->rng, ret_part);
    uint8_t ret_data[RETURN_1 + SIZE_IPPORT];
    ipport_pack(ret_data, source);
    memcpy(ret_data + SIZE_IPPORT, packet + (length - RETURN_1), RETURN_1);
    len = encrypt_data_symmetric(onion->secret_symmetric_key, ret_part, ret_data, sizeof(ret_data),
                                 ret_part + CRYPTO_NONCE_SIZE);

    if (len != RETURN_2 - CRYPTO_NONCE_SIZE) {
        return 1;
    }

    data_len += CRYPTO_NONCE_SIZE + len;

    if ((uint32_t)sendpacket(onion->net, &send_to, data, data_len) != data_len) {
        return 1;
    }

    return 0;
}

non_null()
static int handle_send_2(void *object, const IP_Port *source, const uint8_t *packet, uint16_t length, void *userdata)
{
    Onion *onion = (Onion *)object;

    if (length > ONION_MAX_PACKET_SIZE) {
        return 1;
    }

    if (length <= 1 + SEND_3) {
        return 1;
    }

    change_symmetric_key(onion);

    uint8_t plain[ONION_MAX_PACKET_SIZE];
    const uint8_t *public_key = packet + 1 + CRYPTO_NONCE_SIZE;
    const uint8_t *shared_key = shared_key_cache_lookup(onion->shared_keys_3, public_key);

    if (shared_key == nullptr) {
        /* Error looking up/deriving the shared key */
        return 1;
    }

    int len = decrypt_data_symmetric(shared_key, packet + 1, packet + 1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE,
                                     length - (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + RETURN_2), plain);

    if (len != length - (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE + RETURN_2 + CRYPTO_MAC_SIZE)) {
        return 1;
    }

    assert(len > SIZE_IPPORT);

    const uint8_t packet_id = plain[SIZE_IPPORT];

    if (packet_id != NET_PACKET_ANNOUNCE_REQUEST && packet_id != NET_PACKET_ANNOUNCE_REQUEST_OLD &&
            packet_id != NET_PACKET_ONION_DATA_REQUEST) {
        return 1;
    }

    IP_Port send_to;

    if (ipport_unpack(&send_to, plain, len, false) == -1) {
        return 1;
    }

    uint8_t data[ONION_MAX_PACKET_SIZE] = {0};
    memcpy(data, plain + SIZE_IPPORT, len - SIZE_IPPORT);
    uint16_t data_len = len - SIZE_IPPORT;
    uint8_t *ret_part = data + (len - SIZE_IPPORT);
    random_nonce(onion->rng, ret_part);
    uint8_t ret_data[RETURN_2 + SIZE_IPPORT];
    ipport_pack(ret_data, source);
    memcpy(ret_data + SIZE_IPPORT, packet + (length - RETURN_2), RETURN_2);
    len = encrypt_data_symmetric(onion->secret_symmetric_key, ret_part, ret_data, sizeof(ret_data),
                                 ret_part + CRYPTO_NONCE_SIZE);

    if (len != RETURN_3 - CRYPTO_NONCE_SIZE) {
        return 1;
    }

    data_len += RETURN_3;

    if ((uint32_t)sendpacket(onion->net, &send_to, data, data_len) != data_len) {
        return 1;
    }

    return 0;
}


non_null()
static int handle_recv_3(void *object, const IP_Port *source, const uint8_t *packet, uint16_t length, void *userdata)
{
    Onion *onion = (Onion *)object;

    if (length > ONION_MAX_PACKET_SIZE) {
        return 1;
    }

    if (length <= 1 + RETURN_3) {
        return 1;
    }

    const uint8_t packet_id = packet[1 + RETURN_3];

    if (packet_id != NET_PACKET_ANNOUNCE_RESPONSE && packet_id != NET_PACKET_ANNOUNCE_RESPONSE_OLD &&
            packet_id != NET_PACKET_ONION_DATA_RESPONSE) {
        return 1;
    }

    change_symmetric_key(onion);

    uint8_t plain[SIZE_IPPORT + RETURN_2];
    const int len = decrypt_data_symmetric(onion->secret_symmetric_key, packet + 1, packet + 1 + CRYPTO_NONCE_SIZE,
                                     SIZE_IPPORT + RETURN_2 + CRYPTO_MAC_SIZE, plain);

    if ((uint32_t)len != sizeof(plain)) {
        return 1;
    }

    IP_Port send_to;

    if (ipport_unpack(&send_to, plain, len, false) == -1) {
        return 1;
    }

    uint8_t data[ONION_MAX_PACKET_SIZE] = {0};
    data[0] = NET_PACKET_ONION_RECV_2;
    memcpy(data + 1, plain + SIZE_IPPORT, RETURN_2);
    memcpy(data + 1 + RETURN_2, packet + 1 + RETURN_3, length - (1 + RETURN_3));
    const uint16_t data_len = 1 + RETURN_2 + (length - (1 + RETURN_3));

    if ((uint32_t)sendpacket(onion->net, &send_to, data, data_len) != data_len) {
        return 1;
    }

    return 0;
}

non_null()
static int handle_recv_2(void *object, const IP_Port *source, const uint8_t *packet, uint16_t length, void *userdata)
{
    Onion *onion = (Onion *)object;

    if (length > ONION_MAX_PACKET_SIZE) {
        return 1;
    }

    if (length <= 1 + RETURN_2) {
        return 1;
    }

    const uint8_t packet_id = packet[1 + RETURN_2];

    if (packet_id != NET_PACKET_ANNOUNCE_RESPONSE && packet_id != NET_PACKET_ANNOUNCE_RESPONSE_OLD &&
            packet_id != NET_PACKET_ONION_DATA_RESPONSE) {
        return 1;
    }

    change_symmetric_key(onion);

    uint8_t plain[SIZE_IPPORT + RETURN_1];
    const int len = decrypt_data_symmetric(onion->secret_symmetric_key, packet + 1, packet + 1 + CRYPTO_NONCE_SIZE,
                                     SIZE_IPPORT + RETURN_1 + CRYPTO_MAC_SIZE, plain);

    if ((uint32_t)len != sizeof(plain)) {
        return 1;
    }

    IP_Port send_to;

    if (ipport_unpack(&send_to, plain, len, false) == -1) {
        return 1;
    }

    uint8_t data[ONION_MAX_PACKET_SIZE] = {0};
    data[0] = NET_PACKET_ONION_RECV_1;
    memcpy(data + 1, plain + SIZE_IPPORT, RETURN_1);
    memcpy(data + 1 + RETURN_1, packet + 1 + RETURN_2, length - (1 + RETURN_2));
    const uint16_t data_len = 1 + RETURN_1 + (length - (1 + RETURN_2));

    if ((uint32_t)sendpacket(onion->net, &send_to, data, data_len) != data_len) {
        return 1;
    }

    return 0;
}

non_null()
static int handle_recv_1(void *object, const IP_Port *source, const uint8_t *packet, uint16_t length, void *userdata)
{
    Onion *onion = (Onion *)object;

    if (length > ONION_MAX_PACKET_SIZE) {
        return 1;
    }

    if (length <= 1 + RETURN_1) {
        return 1;
    }

    const uint8_t packet_id = packet[1 + RETURN_1];

    if (packet_id != NET_PACKET_ANNOUNCE_RESPONSE && packet_id != NET_PACKET_ANNOUNCE_RESPONSE_OLD &&
            packet_id != NET_PACKET_ONION_DATA_RESPONSE) {
        return 1;
    }

    change_symmetric_key(onion);

    uint8_t plain[SIZE_IPPORT];
    const int len = decrypt_data_symmetric(onion->secret_symmetric_key, packet + 1, packet + 1 + CRYPTO_NONCE_SIZE,
                                     SIZE_IPPORT + CRYPTO_MAC_SIZE, plain);

    if ((uint32_t)len != SIZE_IPPORT) {
        return 1;
    }

    IP_Port send_to;

    if (ipport_unpack(&send_to, plain, len, true) == -1) {
        return 1;
    }

    const uint16_t data_len = length - (1 + RETURN_1);

    if (onion->recv_1_function != nullptr &&
            !net_family_is_ipv4(send_to.ip.family) &&
            !net_family_is_ipv6(send_to.ip.family)) {
        return onion->recv_1_function(onion->callback_object, &send_to, packet + (1 + RETURN_1), data_len);
    }

    if ((uint32_t)sendpacket(onion->net, &send_to, packet + (1 + RETURN_1), data_len) != data_len) {
        return 1;
    }

    return 0;
}

void set_callback_handle_recv_1(Onion *onion, onion_recv_1_cb *function, void *object)
{
    onion->recv_1_function = function;
    onion->callback_object = object;
}

Onion *new_onion(const Logger *log, const Mono_Time *mono_time, const Random *rng, DHT *dht)
{
    if (dht == nullptr) {
        return nullptr;
    }

    Onion *onion = (Onion *)calloc(1, sizeof(Onion));

    if (onion == nullptr) {
        return nullptr;
    }

    onion->log = log;
    onion->dht = dht;
    onion->net = dht_get_net(dht);
    onion->mono_time = mono_time;
    onion->rng = rng;
    new_symmetric_key(rng, onion->secret_symmetric_key);
    onion->timestamp = mono_time_get(onion->mono_time);

    const uint8_t *secret_key = dht_get_self_secret_key(dht);
    onion->shared_keys_1 = shared_key_cache_new(mono_time, secret_key, KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
    onion->shared_keys_2 = shared_key_cache_new(mono_time, secret_key, KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);
    onion->shared_keys_3 = shared_key_cache_new(mono_time, secret_key, KEYS_TIMEOUT, MAX_KEYS_PER_SLOT);

    if (onion->shared_keys_1 == nullptr ||
        onion->shared_keys_2 == nullptr ||
        onion->shared_keys_3 == nullptr) {
        kill_onion(onion);
        return nullptr;
    }


    networking_registerhandler(onion->net, NET_PACKET_ONION_SEND_INITIAL, &handle_send_initial, onion);
    networking_registerhandler(onion->net, NET_PACKET_ONION_SEND_1, &handle_send_1, onion);
    networking_registerhandler(onion->net, NET_PACKET_ONION_SEND_2, &handle_send_2, onion);

    networking_registerhandler(onion->net, NET_PACKET_ONION_RECV_3, &handle_recv_3, onion);
    networking_registerhandler(onion->net, NET_PACKET_ONION_RECV_2, &handle_recv_2, onion);
    networking_registerhandler(onion->net, NET_PACKET_ONION_RECV_1, &handle_recv_1, onion);

    return onion;
}

void kill_onion(Onion *onion)
{
    if (onion == nullptr) {
        return;
    }

    networking_registerhandler(onion->net, NET_PACKET_ONION_SEND_INITIAL, nullptr, nullptr);
    networking_registerhandler(onion->net, NET_PACKET_ONION_SEND_1, nullptr, nullptr);
    networking_registerhandler(onion->net, NET_PACKET_ONION_SEND_2, nullptr, nullptr);

    networking_registerhandler(onion->net, NET_PACKET_ONION_RECV_3, nullptr, nullptr);
    networking_registerhandler(onion->net, NET_PACKET_ONION_RECV_2, nullptr, nullptr);
    networking_registerhandler(onion->net, NET_PACKET_ONION_RECV_1, nullptr, nullptr);

    crypto_memzero(onion->secret_symmetric_key, sizeof(onion->secret_symmetric_key));

    shared_key_cache_free(onion->shared_keys_1);
    shared_key_cache_free(onion->shared_keys_2);
    shared_key_cache_free(onion->shared_keys_3);

    free(onion);
}
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2018 The TokTok team.
 * Copyright © 2013 Tox project.
 */

/**
 * Implementation of the client part of docs/Prevent_Tracking.txt (The part that
 * uses the onion stuff to connect to the friend)
 */

#include <assert.h>
#include <stdlib.h>
#include <string.h>


/** @brief defines for the array size and timeout for onion announce packets. */
#define ANNOUNCE_ARRAY_SIZE 256
#define ANNOUNCE_TIMEOUT 10

typedef struct Onion_Node {
    uint8_t     public_key[CRYPTO_PUBLIC_KEY_SIZE];
    IP_Port     ip_port;
    uint8_t     ping_id[ONION_PING_ID_SIZE];
    uint8_t     data_public_key[CRYPTO_PUBLIC_KEY_SIZE];
    uint8_t     is_stored;  // Tribool.

    uint64_t    added_time;

    uint64_t    timestamp;

    uint64_t    last_pinged;

    uint8_t     pings_since_last_response;

    uint32_t    path_used;
} Onion_Node;

typedef struct Onion_Client_Paths {
    Onion_Path paths[NUMBER_ONION_PATHS];
    uint64_t last_path_success[NUMBER_ONION_PATHS];
    uint64_t last_path_used[NUMBER_ONION_PATHS];
    uint64_t path_creation_time[NUMBER_ONION_PATHS];
    /* number of times used without success. */
    unsigned int last_path_used_times[NUMBER_ONION_PATHS];
} Onion_Client_Paths;

typedef struct Last_Pinged {
    uint8_t     public_key[CRYPTO_PUBLIC_KEY_SIZE];
    uint64_t    timestamp;
} Last_Pinged;

struct Onion_Friend {
    bool is_valid;
    bool is_online;

    bool know_dht_public_key;
    uint8_t dht_public_key[CRYPTO_PUBLIC_KEY_SIZE];
    uint8_t real_public_key[CRYPTO_PUBLIC_KEY_SIZE];

    Onion_Node clients_list[MAX_ONION_CLIENTS];
    uint8_t temp_public_key[CRYPTO_PUBLIC_KEY_SIZE];
    uint8_t temp_secret_key[CRYPTO_SECRET_KEY_SIZE];

    uint64_t last_dht_pk_onion_sent;
    uint64_t last_dht_pk_dht_sent;

    uint64_t last_noreplay;

    uint64_t last_populated;  // the last time we had a fully populated client nodes list
    uint64_t time_last_pinged; // the last time we pinged this friend with any node

    uint32_t run_count;
    uint32_t pings;  // how many sucessful pings we've made for this friend

    Last_Pinged last_pinged[MAX_STORED_PINGED_NODES];
    uint8_t last_pinged_index;

    recv_tcp_relay_cb *tcp_relay_node_callback;
    void *tcp_relay_node_callback_object;
    uint32_t tcp_relay_node_callback_number;

    onion_dht_pk_cb *dht_pk_callback;
    void *dht_pk_callback_object;
    uint32_t dht_pk_callback_number;

    uint8_t  gc_data[GCA_MAX_DATA_LENGTH];
    uint8_t  gc_public_key[ENC_PUBLIC_KEY_SIZE];
    uint16_t gc_data_length;
    bool     is_groupchat;
};

static const Onion_Friend empty_onion_friend = {false};

typedef struct Onion_Data_Handler {
    oniondata_handler_cb *function;
    void *object;
} Onion_Data_Handler;

struct Onion_Client {
    const Mono_Time *mono_time;
    const Logger *logger;
    const Random *rng;

    DHT     *dht;
    Net_Crypto *c;
    Networking_Core *net;
    Onion_Friend    *friends_list;
    uint16_t       num_friends;

    Onion_Node clients_announce_list[MAX_ONION_CLIENTS_ANNOUNCE];
    uint64_t last_announce;

    Onion_Client_Paths onion_paths_self;
    Onion_Client_Paths onion_paths_friends;

    uint8_t secret_symmetric_key[CRYPTO_SYMMETRIC_KEY_SIZE];
    uint64_t last_run;
    uint64_t first_run;
    uint64_t last_time_connected;

    uint8_t temp_public_key[CRYPTO_PUBLIC_KEY_SIZE];
    uint8_t temp_secret_key[CRYPTO_SECRET_KEY_SIZE];

    Last_Pinged last_pinged[MAX_STORED_PINGED_NODES];

    Node_format path_nodes[MAX_PATH_NODES];
    uint16_t path_nodes_index;

    Node_format path_nodes_bs[MAX_PATH_NODES];
    uint16_t path_nodes_index_bs;

    Ping_Array *announce_ping_array;
    uint8_t last_pinged_index;
    Onion_Data_Handler onion_data_handlers[256];

    uint64_t last_packet_recv;
    uint64_t last_populated;  // the last time we had a fully populated path nodes list

    unsigned int onion_connected;
    bool udp_connected;
    bool udp_connected_lan_only_is_ok;

    onion_group_announce_cb *group_announce_response;
    void *group_announce_response_user_data;
};

uint16_t onion_get_friend_count(const Onion_Client *const onion_c)
{
    return onion_c->num_friends;
}

Onion_Friend *onion_get_friend(const Onion_Client *const onion_c, uint16_t friend_num)
{
    return &onion_c->friends_list[friend_num];
}

const uint8_t *onion_friend_get_gc_public_key(const Onion_Friend *const onion_friend)
{
    return onion_friend->gc_public_key;
}

const uint8_t *onion_friend_get_gc_public_key_num(const Onion_Client *const onion_c, uint32_t num)
{
    return onion_c->friends_list[num].gc_public_key;
}

void onion_friend_set_gc_public_key(Onion_Friend *const onion_friend, const uint8_t *public_key)
{
    memcpy(onion_friend->gc_public_key, public_key, ENC_PUBLIC_KEY_SIZE);
}

void onion_friend_set_gc_data(Onion_Friend *const onion_friend, const uint8_t *gc_data, uint16_t gc_data_length)
{
    if (gc_data_length > 0 && gc_data != nullptr) {
        memcpy(onion_friend->gc_data, gc_data, gc_data_length);
    }

    onion_friend->gc_data_length = gc_data_length;
    onion_friend->is_groupchat = true;
}

bool onion_friend_is_groupchat(const Onion_Friend *const onion_friend)
{
    return onion_friend->is_groupchat;
}

DHT *onion_get_dht(const Onion_Client *onion_c)
{
    return onion_c->dht;
}

Net_Crypto *onion_get_net_crypto(const Onion_Client *onion_c)
{
    return onion_c->c;
}

/** @brief Add a node to the path_nodes bootstrap array.
 *
 * If a node with the given public key was already in the bootstrap array, this function has no
 * effect and returns successfully. There is currently no way to update the IP/port for a bootstrap
 * node, so if it changes, the Onion_Client must be recreated.
 *
 * @param onion_c The onion client object.
 * @param ip_port IP/port for the bootstrap node.
 * @param public_key DHT public key for the bootstrap node.
 *
 * @retval false on failure
 * @retval true on success
 */
bool onion_add_bs_path_node(Onion_Client *onion_c, const IP_Port *ip_port, const uint8_t *public_key)
{
    if (!net_family_is_ipv4(ip_port->ip.family) && !net_family_is_ipv6(ip_port->ip.family)) {
        return false;
    }

    for (unsigned int i = 0; i < MAX_PATH_NODES; ++i) {
        if (pk_equal(public_key, onion_c->path_nodes_bs[i].public_key)) {
            return true;
        }
    }

    onion_c->path_nodes_bs[onion_c->path_nodes_index_bs % MAX_PATH_NODES].ip_port = *ip_port;
    memcpy(onion_c->path_nodes_bs[onion_c->path_nodes_index_bs % MAX_PATH_NODES].public_key, public_key,
           CRYPTO_PUBLIC_KEY_SIZE);

    const uint16_t last = onion_c->path_nodes_index_bs;
    ++onion_c->path_nodes_index_bs;

    if (onion_c->path_nodes_index_bs < last) {
        onion_c->path_nodes_index_bs = MAX_PATH_NODES + 1;
    }

    return true;
}

/** @brief Add a node to the path_nodes array.
 *
 * return -1 on failure
 * return 0 on success
 */
non_null()
static int onion_add_path_node(Onion_Client *onion_c, const IP_Port *ip_port, const uint8_t *public_key)
{
    if (!net_family_is_ipv4(ip_port->ip.family) && !net_family_is_ipv6(ip_port->ip.family)) {
        return -1;
    }

    for (unsigned int i = 0; i < MAX_PATH_NODES; ++i) {
        if (pk_equal(public_key, onion_c->path_nodes[i].public_key)) {
            return -1;
        }
    }

    onion_c->path_nodes[onion_c->path_nodes_index % MAX_PATH_NODES].ip_port = *ip_port;
    memcpy(onion_c->path_nodes[onion_c->path_nodes_index % MAX_PATH_NODES].public_key, public_key,
           CRYPTO_PUBLIC_KEY_SIZE);

    const uint16_t last = onion_c->path_nodes_index;
    ++onion_c->path_nodes_index;

    if (onion_c->path_nodes_index < last) {
        onion_c->path_nodes_index = MAX_PATH_NODES + 1;
    }

    return 0;
}

/** @brief Put up to max_num nodes in nodes.
 *
 * return the number of nodes.
 */
uint16_t onion_backup_nodes(const Onion_Client *onion_c, Node_format *nodes, uint16_t max_num)
{
    if (max_num == 0) {
        return 0;
    }

    const uint16_t num_nodes = min_u16(onion_c->path_nodes_index, MAX_PATH_NODES);
    uint16_t i = 0;

    while (i < max_num && i < num_nodes) {
        nodes[i] = onion_c->path_nodes[(onion_c->path_nodes_index - (1 + i)) % num_nodes];
        ++i;
    }

    for (uint16_t j = 0; i < max_num && j < MAX_PATH_NODES && j < onion_c->path_nodes_index_bs; ++j) {
        bool already_saved = false;

        for (uint16_t k = 0; k < num_nodes; ++k) {
            if (pk_equal(nodes[k].public_key, onion_c->path_nodes_bs[j].public_key)) {
                already_saved = true;
                break;
            }
        }

        if (!already_saved) {
            nodes[i] = onion_c->path_nodes_bs[j];
            ++i;
        }
    }

    return i;
}

/** @brief Put up to max_num random nodes in nodes.
 *
 * return the number of nodes.
 */
non_null()
static uint16_t random_nodes_path_onion(const Onion_Client *onion_c, Node_format *nodes, uint16_t max_num)
{
    if (max_num == 0) {
        return 0;
    }

    const uint16_t num_nodes = min_u16(onion_c->path_nodes_index, MAX_PATH_NODES);

    // if (dht_non_lan_connected(onion_c->dht)) {
    if (dht_isconnected(onion_c->dht)) {
        if (num_nodes == 0) {
            return 0;
        }

        for (unsigned int i = 0; i < max_num; ++i) {
            const uint32_t rand_idx = random_range_u32(onion_c->rng, num_nodes);
            nodes[i] = onion_c->path_nodes[rand_idx];
        }
    } else {
        const int random_tcp = get_random_tcp_con_number(onion_c->c);

        if (random_tcp == -1) {
            return 0;
        }

        if (num_nodes >= 2) {
            nodes[0] = empty_node_format;
            nodes[0].ip_port = tcp_connections_number_to_ip_port(random_tcp);

            for (unsigned int i = 1; i < max_num; ++i) {
                const uint32_t rand_idx = random_range_u32(onion_c->rng, num_nodes);
                nodes[i] = onion_c->path_nodes[rand_idx];
            }
        } else {
            const uint16_t num_nodes_bs = min_u16(onion_c->path_nodes_index_bs, MAX_PATH_NODES);

            if (num_nodes_bs == 0) {
                return 0;
            }

            nodes[0] = empty_node_format;
            nodes[0].ip_port = tcp_connections_number_to_ip_port(random_tcp);

            for (unsigned int i = 1; i < max_num; ++i) {
                const uint32_t rand_idx = random_range_u32(onion_c->rng, num_nodes_bs);
                nodes[i] = onion_c->path_nodes_bs[rand_idx];
            }
        }
    }

    return max_num;
}

/**
 * return -1 if nodes are suitable for creating a new path.
 * return path number of already existing similar path if one already exists.
 */
non_null()
static int is_path_used(const Mono_Time *mono_time, const Onion_Client_Paths *onion_paths, const Node_format *nodes)
{
    for (unsigned int i = 0; i < NUMBER_ONION_PATHS; ++i) {
        if (mono_time_is_timeout(mono_time, onion_paths->last_path_success[i], ONION_PATH_TIMEOUT)) {
            continue;
        }

        if (mono_time_is_timeout(mono_time, onion_paths->path_creation_time[i], ONION_PATH_MAX_LIFETIME)) {
            continue;
        }

        // TODO(irungentoo): do we really have to check it with the last node?
        if (ipport_equal(&onion_paths->paths[i].ip_port1, &nodes[ONION_PATH_LENGTH - 1].ip_port)) {
            return i;
        }
    }

    return -1;
}

/** is path timed out */
non_null()
static bool path_timed_out(const Mono_Time *mono_time, const Onion_Client_Paths *onion_paths, uint32_t pathnum)
{
    pathnum = pathnum % NUMBER_ONION_PATHS;

    const bool is_new = onion_paths->last_path_success[pathnum] == onion_paths->path_creation_time[pathnum];
    const uint64_t timeout = is_new ? ONION_PATH_FIRST_TIMEOUT : ONION_PATH_TIMEOUT;

    return (onion_paths->last_path_used_times[pathnum] >= ONION_PATH_MAX_NO_RESPONSE_USES
            && mono_time_is_timeout(mono_time, onion_paths->last_path_used[pathnum], timeout))
           || mono_time_is_timeout(mono_time, onion_paths->path_creation_time[pathnum], ONION_PATH_MAX_LIFETIME);
}

/** should node be considered to have timed out */
non_null()
static bool onion_node_timed_out(const Onion_Node *node, const Mono_Time *mono_time)
{
    return node->timestamp == 0
           || (node->pings_since_last_response >= ONION_NODE_MAX_PINGS
               && mono_time_is_timeout(mono_time, node->last_pinged, ONION_NODE_TIMEOUT));
}

/** @brief Create a new path or use an old suitable one (if pathnum is valid)
 * or a random one from onion_paths.
 *
 * return -1 on failure
 * return 0 on success
 *
 * TODO(irungentoo): Make this function better, it currently probably is
 * vulnerable to some attacks that could deanonimize us.
 */
non_null()
static int random_path(const Onion_Client *onion_c, Onion_Client_Paths *onion_paths, uint32_t pathnum, Onion_Path *path)
{
    if (pathnum == UINT32_MAX) {
        pathnum = random_range_u32(onion_c->rng, NUMBER_ONION_PATHS);
    } else {
        pathnum = pathnum % NUMBER_ONION_PATHS;
    }

    if (path_timed_out(onion_c->mono_time, onion_paths, pathnum)) {
        Node_format nodes[ONION_PATH_LENGTH];

        if (random_nodes_path_onion(onion_c, nodes, ONION_PATH_LENGTH) != ONION_PATH_LENGTH) {
            return -1;
        }

        const int n = is_path_used(onion_c->mono_time, onion_paths, nodes);

        if (n == -1) {
            if (create_onion_path(onion_c->rng, onion_c->dht, &onion_paths->paths[pathnum], nodes) == -1) {
                return -1;
            }

            onion_paths->path_creation_time[pathnum] = mono_time_get(onion_c->mono_time);
            onion_paths->last_path_success[pathnum] = onion_paths->path_creation_time[pathnum];
            onion_paths->last_path_used_times[pathnum] = ONION_PATH_MAX_NO_RESPONSE_USES / 2;

            uint32_t path_num = random_u32(onion_c->rng);
            path_num /= NUMBER_ONION_PATHS;
            path_num *= NUMBER_ONION_PATHS;
            path_num += pathnum;

            onion_paths->paths[pathnum].path_num = path_num;
        } else {
            pathnum = n;
        }
    }

    if (onion_paths->last_path_used_times[pathnum] < ONION_PATH_MAX_NO_RESPONSE_USES) {
        onion_paths->last_path_used[pathnum] = mono_time_get(onion_c->mono_time);
    }

    ++onion_paths->last_path_used_times[pathnum];
    *path = onion_paths->paths[pathnum];
    return 0;
}

/** Does path with path_num exist. */
non_null()
static bool path_exists(const Mono_Time *mono_time, const Onion_Client_Paths *onion_paths, uint32_t path_num)
{
    if (path_timed_out(mono_time, onion_paths, path_num)) {
        return false;
    }

    return onion_paths->paths[path_num % NUMBER_ONION_PATHS].path_num == path_num;
}

/** Set path timeouts, return the path number. */
non_null()
static uint32_t set_path_timeouts(Onion_Client *onion_c, uint32_t num, uint32_t path_num)
{
    if (num > onion_c->num_friends) {
        return -1;
    }

    Onion_Client_Paths *onion_paths;

    if (num == 0) {
        onion_paths = &onion_c->onion_paths_self;
    } else {
        onion_paths = &onion_c->onion_paths_friends;
    }

    if (onion_paths->paths[path_num % NUMBER_ONION_PATHS].path_num == path_num) {
        onion_paths->last_path_success[path_num % NUMBER_ONION_PATHS] = mono_time_get(onion_c->mono_time);
        onion_paths->last_path_used_times[path_num % NUMBER_ONION_PATHS] = 0;

        Node_format nodes[ONION_PATH_LENGTH];

        if (onion_path_to_nodes(nodes, ONION_PATH_LENGTH, &onion_paths->paths[path_num % NUMBER_ONION_PATHS]) == 0) {
            for (unsigned int i = 0; i < ONION_PATH_LENGTH; ++i) {
                onion_add_path_node(onion_c, &nodes[i].ip_port, nodes[i].public_key);
            }
        }

        return path_num;
    }

    return -1;
}

/** @brief Function to send onion packet via TCP and UDP.
 *
 * return -1 on failure.
 * return 0 on success.
 */
non_null()
static int send_onion_packet_tcp_udp(const Onion_Client *onion_c, const Onion_Path *path, const IP_Port *dest,
                                     const uint8_t *data, uint16_t length)
{
    if (net_family_is_ipv4(path->ip_port1.ip.family) || net_family_is_ipv6(path->ip_port1.ip.family)) {
        uint8_t packet[ONION_MAX_PACKET_SIZE];
        const int len = create_onion_packet(onion_c->rng, packet, sizeof(packet), path, dest, data, length);

        if (len == -1) {
            return -1;
        }

        if (sendpacket(onion_c->net, &path->ip_port1, packet, len) != len) {
            return -1;
        }

        return 0;
    }

    unsigned int tcp_connections_number;

    if (ip_port_to_tcp_connections_number(&path->ip_port1, &tcp_connections_number)) {
        uint8_t packet[ONION_MAX_PACKET_SIZE];
        const int len = create_onion_packet_tcp(onion_c->rng, packet, sizeof(packet), path, dest, data, length);

        if (len == -1) {
            return -1;
        }

        return send_tcp_onion_request(onion_c->c, tcp_connections_number, packet, len);
    }

    return -1;
}

/** @brief Creates a sendback for use in an announce request.
 *
 * num is 0 if we used our secret public key for the announce
 * num is 1 + friendnum if we use a temporary one.
 *
 * Public key is the key we will be sending it to.
 * ip_port is the ip_port of the node we will be sending
 * it to.
 *
 * sendback must be at least ONION_ANNOUNCE_SENDBACK_DATA_LENGTH big
 *
 * return -1 on failure
 * return 0 on success
 *
 */
non_null()
static int new_sendback(Onion_Client *onion_c, uint32_t num, const uint8_t *public_key, const IP_Port *ip_port,
                        uint32_t path_num, uint64_t *sendback)
{
    uint8_t data[sizeof(uint32_t) + CRYPTO_PUBLIC_KEY_SIZE + sizeof(IP_Port) + sizeof(uint32_t)];
    memcpy(data, &num, sizeof(uint32_t));
    memcpy(data + sizeof(uint32_t), public_key, CRYPTO_PUBLIC_KEY_SIZE);
    memcpy(data + sizeof(uint32_t) + CRYPTO_PUBLIC_KEY_SIZE, ip_port, sizeof(IP_Port));
    memcpy(data + sizeof(uint32_t) + CRYPTO_PUBLIC_KEY_SIZE + sizeof(IP_Port), &path_num, sizeof(uint32_t));
    *sendback = ping_array_add(onion_c->announce_ping_array, onion_c->mono_time, onion_c->rng, data, sizeof(data));

    if (*sendback == 0) {
        return -1;
    }

    return 0;
}

/** @brief Checks if the sendback is valid and returns the public key contained in it in ret_pubkey and the
 * ip contained in it in ret_ip_port
 *
 * sendback is the sendback ONION_ANNOUNCE_SENDBACK_DATA_LENGTH big
 * ret_pubkey must be at least CRYPTO_PUBLIC_KEY_SIZE big
 * ret_ip_port must be at least 1 big
 *
 * return -1 on failure
 * return num (see new_sendback(...)) on success
 */
non_null()
static uint32_t check_sendback(Onion_Client *onion_c, const uint8_t *sendback, uint8_t *ret_pubkey,
                               IP_Port *ret_ip_port, uint32_t *path_num)
{
    uint64_t sback;
    memcpy(&sback, sendback, sizeof(uint64_t));
    uint8_t data[sizeof(uint32_t) + CRYPTO_PUBLIC_KEY_SIZE + sizeof(IP_Port) + sizeof(uint32_t)];

    if (ping_array_check(onion_c->announce_ping_array, onion_c->mono_time, data, sizeof(data), sback) != sizeof(data)) {
        return -1;
    }

    memcpy(ret_pubkey, data + sizeof(uint32_t), CRYPTO_PUBLIC_KEY_SIZE);
    memcpy(ret_ip_port, data + sizeof(uint32_t) + CRYPTO_PUBLIC_KEY_SIZE, sizeof(IP_Port));
    memcpy(path_num, data + sizeof(uint32_t) + CRYPTO_PUBLIC_KEY_SIZE + sizeof(IP_Port), sizeof(uint32_t));

    uint32_t num;
    memcpy(&num, data, sizeof(uint32_t));
    return num;
}

non_null(1, 3, 4) nullable(5)
static int client_send_announce_request(Onion_Client *onion_c, uint32_t num, const IP_Port *dest,
                                        const uint8_t *dest_pubkey, const uint8_t *ping_id, uint32_t pathnum)
{
    if (num > onion_c->num_friends) {
        return -1;
    }

    uint64_t sendback;
    Onion_Path path;

    if (num == 0) {
        if (random_path(onion_c, &onion_c->onion_paths_self, pathnum, &path) == -1) {
            return -1;
        }
    } else {
        if (random_path(onion_c, &onion_c->onion_paths_friends, pathnum, &path) == -1) {
            return -1;
        }
    }

    if (new_sendback(onion_c, num, dest_pubkey, dest, path.path_num, &sendback) == -1) {
        return -1;
    }

    uint8_t zero_ping_id[ONION_PING_ID_SIZE] = {0};

    if (ping_id == nullptr) {
        ping_id = zero_ping_id;
    }

    uint8_t request[ONION_ANNOUNCE_REQUEST_MAX_SIZE];
    int len;

    if (num == 0) {
        len = create_announce_request(
                  onion_c->rng, request, sizeof(request), dest_pubkey, nc_get_self_public_key(onion_c->c),
                  nc_get_self_secret_key(onion_c->c), ping_id, nc_get_self_public_key(onion_c->c),
                  onion_c->temp_public_key, sendback);
    } else {
        Onion_Friend *onion_friend = &onion_c->friends_list[num - 1];

        if (onion_friend->gc_data_length == 0) { // contact is a friend
            len = create_announce_request(
                      onion_c->rng, request, sizeof(request), dest_pubkey, onion_friend->temp_public_key,
                      onion_friend->temp_secret_key, ping_id, onion_friend->real_public_key,
                      zero_ping_id, sendback);
        } else { // contact is a gc
#ifndef VANILLA_NACL
            onion_friend->is_groupchat = true;

            len = create_gca_announce_request(
                      onion_c->rng, request, sizeof(request), dest_pubkey, onion_friend->temp_public_key,
                      onion_friend->temp_secret_key, ping_id, onion_friend->real_public_key,
                      zero_ping_id, sendback, onion_friend->gc_data,
                      onion_friend->gc_data_length);
#else
            return -1;
#endif  // VANILLA_NACL
        }
    }

    if (len == -1) {
        return -1;
    }

    return send_onion_packet_tcp_udp(onion_c, &path, dest, request, len);
}

typedef struct Onion_Client_Cmp_Data {
    const Mono_Time *mono_time;
    const uint8_t *base_public_key;
    Onion_Node entry;
} Onion_Client_Cmp_Data;

non_null()
static int onion_client_cmp_entry(const void *a, const void *b)
{
    const Onion_Client_Cmp_Data *cmp1 = (const Onion_Client_Cmp_Data *)a;
    const Onion_Client_Cmp_Data *cmp2 = (const Onion_Client_Cmp_Data *)b;
    const Onion_Node entry1 = cmp1->entry;
    const Onion_Node entry2 = cmp2->entry;
    const uint8_t *cmp_public_key = cmp1->base_public_key;

    const bool t1 = onion_node_timed_out(&entry1, cmp1->mono_time);
    const bool t2 = onion_node_timed_out(&entry2, cmp2->mono_time);

    if (t1 && t2) {
        return 0;
    }

    if (t1) {
        return -1;
    }

    if (t2) {
        return 1;
    }

    const int closest = id_closest(cmp_public_key, entry1.public_key, entry2.public_key);

    if (closest == 1) {
        return 1;
    }

    if (closest == 2) {
        return -1;
    }

    return 0;
}

non_null()
static void sort_onion_node_list(Onion_Node *list, unsigned int length, const Mono_Time *mono_time,
                                 const uint8_t *comp_public_key)
{
    // Pass comp_public_key to qsort with each Client_data entry, so the
    // comparison function can use it as the base of comparison.
    Onion_Client_Cmp_Data *cmp_list = (Onion_Client_Cmp_Data *)calloc(length, sizeof(Onion_Client_Cmp_Data));

    if (cmp_list == nullptr) {
        return;
    }

    for (uint32_t i = 0; i < length; ++i) {
        cmp_list[i].mono_time = mono_time;
        cmp_list[i].base_public_key = comp_public_key;
        cmp_list[i].entry = list[i];
    }

    qsort(cmp_list, length, sizeof(Onion_Client_Cmp_Data), onion_client_cmp_entry);

    for (uint32_t i = 0; i < length; ++i) {
        list[i] = cmp_list[i].entry;
    }

    free(cmp_list);
}

non_null()
static int client_add_to_list(Onion_Client *onion_c, uint32_t num, const uint8_t *public_key, const IP_Port *ip_port,
                              uint8_t is_stored, const uint8_t *pingid_or_key, uint32_t path_used)
{
    if (num > onion_c->num_friends) {
        return -1;
    }

    Onion_Node *node_list = nullptr;
    const uint8_t *reference_id = nullptr;
    unsigned int list_length;

    if (num == 0) {
        node_list = onion_c->clients_announce_list;
        reference_id = nc_get_self_public_key(onion_c->c);
        list_length = MAX_ONION_CLIENTS_ANNOUNCE;

        if (is_stored == 1 && !pk_equal(pingid_or_key, onion_c->temp_public_key)) {
            is_stored = 0;
        }
    } else {
        if (is_stored >= 2) {
            return -1;
        }

        node_list = onion_c->friends_list[num - 1].clients_list;
        reference_id = onion_c->friends_list[num - 1].real_public_key;
        list_length = MAX_ONION_CLIENTS;
    }

    sort_onion_node_list(node_list, list_length, onion_c->mono_time, reference_id);

    int index = -1;
    bool stored = false;

    if (onion_node_timed_out(&node_list[0], onion_c->mono_time)
            || id_closest(reference_id, node_list[0].public_key, public_key) == 2) {
        index = 0;
    }

    for (unsigned int i = 0; i < list_length; ++i) {
        if (pk_equal(node_list[i].public_key, public_key)) {
            index = i;
            stored = true;
            break;
        }
    }

    if (index == -1) {
        return 0;
    }

    memcpy(node_list[index].public_key, public_key, CRYPTO_PUBLIC_KEY_SIZE);
    node_list[index].ip_port = *ip_port;

    // TODO(irungentoo): remove this and find a better source of nodes to use for paths.
    onion_add_path_node(onion_c, ip_port, public_key);

    if (is_stored == 1) {
        memcpy(node_list[index].data_public_key, pingid_or_key, CRYPTO_PUBLIC_KEY_SIZE);
    } else {
        memcpy(node_list[index].ping_id, pingid_or_key, ONION_PING_ID_SIZE);
    }

    node_list[index].is_stored = is_stored;
    node_list[index].timestamp = mono_time_get(onion_c->mono_time);
    node_list[index].pings_since_last_response = 0;

    if (!stored) {
        node_list[index].last_pinged = 0;
        node_list[index].added_time = mono_time_get(onion_c->mono_time);
    }

    node_list[index].path_used = path_used;
    return 0;
}

non_null()
static bool good_to_ping(const Mono_Time *mono_time, Last_Pinged *last_pinged, uint8_t *last_pinged_index,
                         const uint8_t *public_key)
{
    for (unsigned int i = 0; i < MAX_STORED_PINGED_NODES; ++i) {
        if (!mono_time_is_timeout(mono_time, last_pinged[i].timestamp, MIN_NODE_PING_TIME)) {
            if (pk_equal(last_pinged[i].public_key, public_key)) {
                return false;
            }
        }
    }

    memcpy(last_pinged[*last_pinged_index % MAX_STORED_PINGED_NODES].public_key, public_key, CRYPTO_PUBLIC_KEY_SIZE);
    last_pinged[*last_pinged_index % MAX_STORED_PINGED_NODES].timestamp = mono_time_get(mono_time);
    ++*last_pinged_index;
    return true;
}

non_null()
static int client_ping_nodes(Onion_Client *onion_c, uint32_t num, const Node_format *nodes, uint16_t num_nodes,
                             const IP_Port *source)
{
    if (num > onion_c->num_friends) {
        return -1;
    }

    if (num_nodes == 0) {
        return 0;
    }

    const Onion_Node *node_list = nullptr;
    const uint8_t *reference_id = nullptr;
    unsigned int list_length;

    Last_Pinged *last_pinged = nullptr;
    uint8_t *last_pinged_index = nullptr;

    if (num == 0) {
        node_list = onion_c->clients_announce_list;
        reference_id = nc_get_self_public_key(onion_c->c);
        list_length = MAX_ONION_CLIENTS_ANNOUNCE;
        last_pinged = onion_c->last_pinged;
        last_pinged_index = &onion_c->last_pinged_index;
    } else {
        node_list = onion_c->friends_list[num - 1].clients_list;
        reference_id = onion_c->friends_list[num - 1].real_public_key;
        list_length = MAX_ONION_CLIENTS;
        last_pinged = onion_c->friends_list[num - 1].last_pinged;
        last_pinged_index = &onion_c->friends_list[num - 1].last_pinged_index;
    }

    const bool lan_ips_accepted = ip_is_lan(&source->ip);

    for (uint32_t i = 0; i < num_nodes; ++i) {
        if (!lan_ips_accepted) {
            if (ip_is_lan(&nodes[i].ip_port.ip)) {
                continue;
            }
        }

        if (onion_node_timed_out(&node_list[0], onion_c->mono_time)
                || id_closest(reference_id, node_list[0].public_key, nodes[i].public_key) == 2
                || onion_node_timed_out(&node_list[1], onion_c->mono_time)
                || id_closest(reference_id, node_list[1].public_key, nodes[i].public_key) == 2) {
            uint32_t j;

            /* check if node is already in list. */
            for (j = 0; j < list_length; ++j) {
                if (pk_equal(node_list[j].public_key, nodes[i].public_key)) {
                    break;
                }
            }

            if (j == list_length && good_to_ping(onion_c->mono_time, last_pinged, last_pinged_index, nodes[i].public_key)) {
                client_send_announce_request(onion_c, num, &nodes[i].ip_port, nodes[i].public_key, nullptr, -1);
            }
        }
    }

    return 0;
}

non_null()
static bool handle_group_announce_response(Onion_Client *onion_c, uint32_t num, const uint8_t *plain, size_t plain_size)
{
    if (onion_c->group_announce_response == nullptr) {
        return true;
    }

    return onion_c->group_announce_response(onion_c, num, plain, plain_size, onion_c->group_announce_response_user_data);
}

non_null(1, 2, 3) nullable(5)
static int handle_announce_response(void *object, const IP_Port *source, const uint8_t *packet, uint16_t length,
                                    void *userdata)
{
    Onion_Client *onion_c = (Onion_Client *)object;

    if (length < ONION_ANNOUNCE_RESPONSE_MIN_SIZE || length > ONION_ANNOUNCE_RESPONSE_MAX_SIZE) {
        return 1;
    }

    uint8_t public_key[CRYPTO_PUBLIC_KEY_SIZE];
    IP_Port ip_port;
    uint32_t path_num;
    const uint32_t num = check_sendback(onion_c, packet + 1, public_key, &ip_port, &path_num);

    if (num > onion_c->num_friends) {
        return 1;
    }

    uint8_t plain[1 + ONION_PING_ID_SIZE + ONION_ANNOUNCE_RESPONSE_MAX_SIZE - ONION_ANNOUNCE_RESPONSE_MIN_SIZE];
    const int plain_size = 1 + ONION_PING_ID_SIZE + length - ONION_ANNOUNCE_RESPONSE_MIN_SIZE;
    int len;

    if (num == 0) {
        len = decrypt_data(public_key, nc_get_self_secret_key(onion_c->c),
                           packet + 1 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH,
                           packet + 1 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_NONCE_SIZE,
                           length - (1 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_NONCE_SIZE), plain);
    } else {
        if (!onion_c->friends_list[num - 1].is_valid) {
            return 1;
        }

        len = decrypt_data(public_key, onion_c->friends_list[num - 1].temp_secret_key,
                           packet + 1 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH,
                           packet + 1 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_NONCE_SIZE,
                           length - (1 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_NONCE_SIZE), plain);
    }

    if ((uint32_t)len != plain_size) {
        return 1;
    }

    const uint32_t path_used = set_path_timeouts(onion_c, num, path_num);

    if (client_add_to_list(onion_c, num, public_key, &ip_port, plain[0], plain + 1, path_used) == -1) {
        return 1;
    }

    uint16_t len_nodes = 0;
    const uint8_t nodes_count = plain[1 + ONION_PING_ID_SIZE];

    if (nodes_count > 0) {
        if (nodes_count > MAX_SENT_NODES) {
            return 1;
        }

        Node_format nodes[MAX_SENT_NODES];
        const int num_nodes = unpack_nodes(nodes, nodes_count, &len_nodes, plain + 2 + ONION_PING_ID_SIZE,
                                           plain_size - 2 - ONION_PING_ID_SIZE, false);

        if (num_nodes < 0) {
            return 1;
        }

        if (client_ping_nodes(onion_c, num, nodes, num_nodes, source) == -1) {
            return 1;
        }
    }

    if (len_nodes + 1 < length - ONION_ANNOUNCE_RESPONSE_MIN_SIZE) {
        const uint16_t offset = 2 + ONION_PING_ID_SIZE + len_nodes;

        if (plain_size < offset) {
            return 1;
        }

        if (!handle_group_announce_response(onion_c, num, plain + offset, plain_size - offset)) {
            return 1;
        }
    }

    // TODO(irungentoo): LAN vs non LAN ips?, if we are connected only to LAN, are we offline?
    onion_c->last_packet_recv = mono_time_get(onion_c->mono_time);

    return 0;
}

/* TODO(jfreegman): DEPRECATE */
non_null(1, 2, 3) nullable(5)
static int handle_announce_response_old(void *object, const IP_Port *source, const uint8_t *packet, uint16_t length,
                                        void *userdata)
{
    Onion_Client *onion_c = (Onion_Client *)object;

    if (length < ONION_ANNOUNCE_RESPONSE_MIN_SIZE || length > ONION_ANNOUNCE_RESPONSE_MAX_SIZE) {
        return 1;
    }

    const uint16_t len_nodes = length - ONION_ANNOUNCE_RESPONSE_MIN_SIZE;

    uint8_t public_key[CRYPTO_PUBLIC_KEY_SIZE];
    IP_Port ip_port;
    uint32_t path_num;
    const uint32_t num = check_sendback(onion_c, packet + 1, public_key, &ip_port, &path_num);

    if (num > onion_c->num_friends) {
        return 1;
    }

    VLA(uint8_t, plain, 1 + ONION_PING_ID_SIZE + len_nodes);
    int len;

    if (num == 0) {
        len = decrypt_data(public_key, nc_get_self_secret_key(onion_c->c),
                           packet + 1 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH,
                           packet + 1 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_NONCE_SIZE,
                           length - (1 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_NONCE_SIZE), plain);
    } else {
        if (!onion_c->friends_list[num - 1].is_valid) {
            return 1;
        }

        len = decrypt_data(public_key, onion_c->friends_list[num - 1].temp_secret_key,
                           packet + 1 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH,
                           packet + 1 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_NONCE_SIZE,
                           length - (1 + ONION_ANNOUNCE_SENDBACK_DATA_LENGTH + CRYPTO_NONCE_SIZE), plain);
    }

    if ((uint32_t)len != SIZEOF_VLA(plain)) {
        return 1;
    }

    const uint32_t path_used = set_path_timeouts(onion_c, num, path_num);

    if (client_add_to_list(onion_c, num, public_key, &ip_port, plain[0], plain + 1, path_used) == -1) {
        return 1;
    }

    if (len_nodes != 0) {
        Node_format nodes[MAX_SENT_NODES];
        const int num_nodes = unpack_nodes(nodes, MAX_SENT_NODES, nullptr, plain + 1 + ONION_PING_ID_SIZE, len_nodes, false);

        if (num_nodes <= 0) {
            return 1;
        }

        if (client_ping_nodes(onion_c, num, nodes, num_nodes, source) == -1) {
            return 1;
        }
    }

    // TODO(irungentoo): LAN vs non LAN ips?, if we are connected only to LAN, are we offline?
    onion_c->last_packet_recv = mono_time_get(onion_c->mono_time);
    return 0;
}

#define DATA_IN_RESPONSE_MIN_SIZE ONION_DATA_IN_RESPONSE_MIN_SIZE

non_null()
static int handle_data_response(void *object, const IP_Port *source, const uint8_t *packet, uint16_t length,
                                void *userdata)
{
    Onion_Client *onion_c = (Onion_Client *)object;

    if (length <= (ONION_DATA_RESPONSE_MIN_SIZE + DATA_IN_RESPONSE_MIN_SIZE)) {
        return 1;
    }

    if (length > MAX_DATA_REQUEST_SIZE) {
        return 1;
    }

    VLA(uint8_t, temp_plain, length - ONION_DATA_RESPONSE_MIN_SIZE);
    int len = decrypt_data(packet + 1 + CRYPTO_NONCE_SIZE, onion_c->temp_secret_key, packet + 1,
                           packet + 1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE,
                           length - (1 + CRYPTO_NONCE_SIZE + CRYPTO_PUBLIC_KEY_SIZE), temp_plain);

    if ((uint32_t)len != SIZEOF_VLA(temp_plain)) {
        return 1;
    }

    VLA(uint8_t, plain, SIZEOF_VLA(temp_plain) - DATA_IN_RESPONSE_MIN_SIZE);
    len = decrypt_data(temp_plain, nc_get_self_secret_key(onion_c->c),
                       packet + 1, temp_plain + CRYPTO_PUBLIC_KEY_SIZE,
                       SIZEOF_VLA(temp_plain) - CRYPTO_PUBLIC_KEY_SIZE, plain);

    if ((uint32_t)len != SIZEOF_VLA(plain)) {
        return 1;
    }

    if (onion_c->onion_data_handlers[plain[0]].function == nullptr) {
        return 1;
    }

    return onion_c->onion_data_handlers[plain[0]].function(onion_c->onion_data_handlers[plain[0]].object, temp_plain, plain,
            SIZEOF_VLA(plain), userdata);
}

#define DHTPK_DATA_MIN_LENGTH (1 + sizeof(uint64_t) + CRYPTO_PUBLIC_KEY_SIZE)
#define DHTPK_DATA_MAX_LENGTH (DHTPK_DATA_MIN_LENGTH + sizeof(Node_format)*MAX_SENT_NODES)
non_null(1, 2, 3) nullable(5)
static int handle_dhtpk_announce(void *object, const uint8_t *source_pubkey, const uint8_t *data, uint16_t length,
                                 void *userdata)
{
    Onion_Client *onion_c = (Onion_Client *)object;

    if (length < DHTPK_DATA_MIN_LENGTH) {
        return 1;
    }

    if (length > DHTPK_DATA_MAX_LENGTH) {
        return 1;
    }

    const int friend_num = onion_friend_num(onion_c, source_pubkey);

    if (friend_num == -1) {
        return 1;
    }

    uint64_t no_replay;
    net_unpack_u64(data + 1, &no_replay);

    if (no_replay <= onion_c->friends_list[friend_num].last_noreplay) {
        return 1;
    }

    onion_c->friends_list[friend_num].last_noreplay = no_replay;

    if (onion_c->friends_list[friend_num].dht_pk_callback != nullptr) {
        onion_c->friends_list[friend_num].dht_pk_callback(onion_c->friends_list[friend_num].dht_pk_callback_object,
                onion_c->friends_list[friend_num].dht_pk_callback_number, data + 1 + sizeof(uint64_t), userdata);
    }

    onion_set_friend_DHT_pubkey(onion_c, friend_num, data + 1 + sizeof(uint64_t));

    const uint16_t len_nodes = length - DHTPK_DATA_MIN_LENGTH;

    if (len_nodes != 0) {
        Node_format nodes[MAX_SENT_NODES];
        const int num_nodes = unpack_nodes(nodes, MAX_SENT_NODES, nullptr, data + 1 + sizeof(uint64_t) + CRYPTO_PUBLIC_KEY_SIZE,
                                           len_nodes, true);

        if (num_nodes <= 0) {
            return 1;
        }

        for (int i = 0; i < num_nodes; ++i) {
            const Family family = nodes[i].ip_port.ip.family;

            if (net_family_is_ipv4(family) || net_family_is_ipv6(family)) {
                dht_getnodes(onion_c->dht, &nodes[i].ip_port, nodes[i].public_key, onion_c->friends_list[friend_num].dht_public_key);
            } else if (net_family_is_tcp_ipv4(family) || net_family_is_tcp_ipv6(family)) {
                if (onion_c->friends_list[friend_num].tcp_relay_node_callback != nullptr) {
                    void *obj = onion_c->friends_list[friend_num].tcp_relay_node_callback_object;
                    const uint32_t number = onion_c->friends_list[friend_num].tcp_relay_node_callback_number;
                    onion_c->friends_list[friend_num].tcp_relay_node_callback(obj, number, &nodes[i].ip_port, nodes[i].public_key);
                }
            }
        }
    }

    return 0;
}

non_null()
static int handle_tcp_onion(void *object, const uint8_t *data, uint16_t length, void *userdata)
{
    if (length == 0) {
        return 1;
    }

    IP_Port ip_port = {{{0}}};
    ip_port.ip.family = net_family_tcp_server();

    if (data[0] == NET_PACKET_ANNOUNCE_RESPONSE) {
        return handle_announce_response(object, &ip_port, data, length, userdata);
    }

    if (data[0] == NET_PACKET_ANNOUNCE_RESPONSE_OLD) {
        return handle_announce_response_old(object, &ip_port, data, length, userdata);
    }

    if (data[0] == NET_PACKET_ONION_DATA_RESPONSE) {
        return handle_data_response(object, &ip_port, data, length, userdata);
    }

    return 1;
}

/** @brief Send data of length length to friendnum.
 * Maximum length of data is ONION_CLIENT_MAX_DATA_SIZE.
 * This data will be received by the friend using the Onion_Data_Handlers callbacks.
 *
 * Even if this function succeeds, the friend might not receive any data.
 *
 * return the number of packets sent on success
 * return -1 on failure.
 */
int send_onion_data(Onion_Client *onion_c, int friend_num, const uint8_t *data, uint16_t length)
{
    if ((uint32_t)friend_num >= onion_c->num_friends) {
        return -1;
    }

    if (length + DATA_IN_RESPONSE_MIN_SIZE > MAX_DATA_REQUEST_SIZE) {
        return -1;
    }

    if (length == 0) {
        return -1;
    }

    unsigned int good_nodes[MAX_ONION_CLIENTS];
    unsigned int num_good = 0;
    unsigned int num_nodes = 0;
    const Onion_Node *node_list = onion_c->friends_list[friend_num].clients_list;

    for (unsigned int i = 0; i < MAX_ONION_CLIENTS; ++i) {
        if (onion_node_timed_out(&node_list[i], onion_c->mono_time)) {
            continue;
        }

        ++num_nodes;

        if (node_list[i].is_stored != 0) {
            good_nodes[num_good] = i;
            ++num_good;
        }
    }

    if (num_good < (num_nodes - 1) / 4 + 1) {
        return -1;
    }

    uint8_t nonce[CRYPTO_NONCE_SIZE];
    random_nonce(onion_c->rng, nonce);

    VLA(uint8_t, packet, DATA_IN_RESPONSE_MIN_SIZE + length);
    memcpy(packet, nc_get_self_public_key(onion_c->c), CRYPTO_PUBLIC_KEY_SIZE);
    int len = encrypt_data(onion_c->friends_list[friend_num].real_public_key,
                           nc_get_self_secret_key(onion_c->c), nonce, data,
                           length, packet + CRYPTO_PUBLIC_KEY_SIZE);

    if ((uint32_t)len + CRYPTO_PUBLIC_KEY_SIZE != SIZEOF_VLA(packet)) {
        return -1;
    }

    unsigned int good = 0;

    for (unsigned int i = 0; i < num_good; ++i) {
        Onion_Path path;

        if (random_path(onion_c, &onion_c->onion_paths_friends, -1, &path) == -1) {
            continue;
        }

        uint8_t o_packet[ONION_MAX_PACKET_SIZE];
        len = create_data_request(
                  onion_c->rng, o_packet, sizeof(o_packet), onion_c->friends_list[friend_num].real_public_key,
                  node_list[good_nodes[i]].data_public_key, nonce, packet, SIZEOF_VLA(packet));

        if (len == -1) {
            continue;
        }

        if (send_onion_packet_tcp_udp(onion_c, &path, &node_list[good_nodes[i]].ip_port, o_packet, len) == 0) {
            ++good;
        }
    }

    return good;
}

/** @brief Try to send the dht public key via the DHT instead of onion
 *
 * Even if this function succeeds, the friend might not receive any data.
 *
 * return the number of packets sent on success
 * return -1 on failure.
 */
non_null()
static int send_dht_dhtpk(const Onion_Client *onion_c, int friend_num, const uint8_t *data, uint16_t length)
{
    if ((uint32_t)friend_num >= onion_c->num_friends) {
        return -1;
    }

    if (!onion_c->friends_list[friend_num].know_dht_public_key) {
        return -1;
    }

    uint8_t nonce[CRYPTO_NONCE_SIZE];
    random_nonce(onion_c->rng, nonce);

    VLA(uint8_t, temp, DATA_IN_RESPONSE_MIN_SIZE + CRYPTO_NONCE_SIZE + length);
    memcpy(temp, nc_get_self_public_key(onion_c->c), CRYPTO_PUBLIC_KEY_SIZE);
    memcpy(temp + CRYPTO_PUBLIC_KEY_SIZE, nonce, CRYPTO_NONCE_SIZE);
    int len = encrypt_data(onion_c->friends_list[friend_num].real_public_key,
                           nc_get_self_secret_key(onion_c->c), nonce, data,
                           length, temp + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE);

    if ((uint32_t)len + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE != SIZEOF_VLA(temp)) {
        return -1;
    }

    uint8_t packet_data[MAX_CRYPTO_REQUEST_SIZE];
    len = create_request(
              onion_c->rng, dht_get_self_public_key(onion_c->dht), dht_get_self_secret_key(onion_c->dht), packet_data,
              onion_c->friends_list[friend_num].dht_public_key, temp, SIZEOF_VLA(temp), CRYPTO_PACKET_DHTPK);
    assert(len <= UINT16_MAX);
    const Packet packet = {packet_data, (uint16_t)len};

    if (len == -1) {
        return -1;
    }

    return route_to_friend(onion_c->dht, onion_c->friends_list[friend_num].dht_public_key, &packet);
}

non_null()
static int handle_dht_dhtpk(void *object, const IP_Port *source, const uint8_t *source_pubkey, const uint8_t *packet,
                            uint16_t length, void *userdata)
{
    Onion_Client *onion_c = (Onion_Client *)object;

    if (length < DHTPK_DATA_MIN_LENGTH + DATA_IN_RESPONSE_MIN_SIZE + CRYPTO_NONCE_SIZE) {
        return 1;
    }

    if (length > DHTPK_DATA_MAX_LENGTH + DATA_IN_RESPONSE_MIN_SIZE + CRYPTO_NONCE_SIZE) {
        return 1;
    }

    uint8_t plain[DHTPK_DATA_MAX_LENGTH];
    const int len = decrypt_data(packet, nc_get_self_secret_key(onion_c->c),
                                 packet + CRYPTO_PUBLIC_KEY_SIZE,
                                 packet + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE,
                                 length - (CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE), plain);

    if (len != length - (DATA_IN_RESPONSE_MIN_SIZE + CRYPTO_NONCE_SIZE)) {
        return 1;
    }

    if (!pk_equal(source_pubkey, plain + 1 + sizeof(uint64_t))) {
        return 1;
    }

    return handle_dhtpk_announce(onion_c, packet, plain, len, userdata);
}
/** @brief Send the packets to tell our friends what our DHT public key is.
 *
 * if onion_dht_both is 0, use only the onion to send the packet.
 * if it is 1, use only the dht.
 * if it is something else, use both.
 *
 * return the number of packets sent on success
 * return -1 on failure.
 */
non_null()
static int send_dhtpk_announce(Onion_Client *onion_c, uint16_t friend_num, uint8_t onion_dht_both)
{
    if (friend_num >= onion_c->num_friends) {
        return -1;
    }

    uint8_t data[DHTPK_DATA_MAX_LENGTH];
    data[0] = ONION_DATA_DHTPK;
    const uint64_t no_replay = mono_time_get(onion_c->mono_time);
    net_pack_u64(data + 1, no_replay);
    memcpy(data + 1 + sizeof(uint64_t), dht_get_self_public_key(onion_c->dht), CRYPTO_PUBLIC_KEY_SIZE);
    Node_format nodes[MAX_SENT_NODES];
    const uint16_t num_relays = copy_connected_tcp_relays(onion_c->c, nodes, MAX_SENT_NODES / 2);
    uint16_t num_nodes = closelist_nodes(onion_c->dht, &nodes[num_relays], MAX_SENT_NODES - num_relays);
    num_nodes += num_relays;
    int nodes_len = 0;

    if (num_nodes != 0) {
        nodes_len = pack_nodes(onion_c->logger, data + DHTPK_DATA_MIN_LENGTH, DHTPK_DATA_MAX_LENGTH - DHTPK_DATA_MIN_LENGTH,
                               nodes, num_nodes);

        if (nodes_len <= 0) {
            return -1;
        }
    }

    int num1 = -1;
    int num2 = -1;

    if (onion_dht_both != 1) {
        num1 = send_onion_data(onion_c, friend_num, data, DHTPK_DATA_MIN_LENGTH + nodes_len);
    }

    if (onion_dht_both != 0) {
        num2 = send_dht_dhtpk(onion_c, friend_num, data, DHTPK_DATA_MIN_LENGTH + nodes_len);
    }

    if (num1 == -1) {
        return num2;
    }

    if (num2 == -1) {
        return num1;
    }

    return num1 + num2;
}

/** @brief Get the friend_num of a friend.
 *
 * return -1 on failure.
 * return friend number on success.
 */
int onion_friend_num(const Onion_Client *onion_c, const uint8_t *public_key)
{
    for (unsigned int i = 0; i < onion_c->num_friends; ++i) {
        if (!onion_c->friends_list[i].is_valid) {
            continue;
        }

        if (pk_equal(public_key, onion_c->friends_list[i].real_public_key)) {
            return i;
        }
    }

    return -1;
}

/** @brief Set the size of the friend list to num.
 *
 * @retval -1 if realloc fails.
 * @retval 0 if it succeeds.
 */
non_null()
static int realloc_onion_friends(Onion_Client *onion_c, uint32_t num)
{
    if (num == 0) {
        free(onion_c->friends_list);
        onion_c->friends_list = nullptr;
        return 0;
    }

    Onion_Friend *newonion_friends = (Onion_Friend *)realloc(onion_c->friends_list, num * sizeof(Onion_Friend));

    if (newonion_friends == nullptr) {
        return -1;
    }

    onion_c->friends_list = newonion_friends;
    return 0;
}

/** @brief Add a friend who we want to connect to.
 *
 * return -1 on failure.
 * return the friend number on success or if the friend was already added.
 */
int onion_addfriend(Onion_Client *onion_c, const uint8_t *public_key)
{
    const int num = onion_friend_num(onion_c, public_key);

    if (num != -1) {
        return num;
    }

    unsigned int index = -1;

    for (unsigned int i = 0; i < onion_c->num_friends; ++i) {
        if (!onion_c->friends_list[i].is_valid) {
            index = i;
            break;
        }
    }

    if (index == (uint32_t) -1) {
        if (realloc_onion_friends(onion_c, onion_c->num_friends + 1) == -1) {
            return -1;
        }

        index = onion_c->num_friends;
        onion_c->friends_list[onion_c->num_friends] = empty_onion_friend;
        ++onion_c->num_friends;
    }

    onion_c->friends_list[index].is_valid = true;
    memcpy(onion_c->friends_list[index].real_public_key, public_key, CRYPTO_PUBLIC_KEY_SIZE);
    crypto_new_keypair(onion_c->rng, onion_c->friends_list[index].temp_public_key,
                       onion_c->friends_list[index].temp_secret_key);
    return index;
}

/** @brief Delete a friend.
 *
 * return -1 on failure.
 * return the deleted friend number on success.
 */
int onion_delfriend(Onion_Client *onion_c, int friend_num)
{
    if ((uint32_t)friend_num >= onion_c->num_friends) {
        return -1;
    }

#if 0

    if (onion_c->friends_list[friend_num].know_dht_public_key) {
        dht_delfriend(onion_c->dht, onion_c->friends_list[friend_num].dht_public_key, 0);
    }

#endif

    crypto_memzero(&onion_c->friends_list[friend_num], sizeof(Onion_Friend));
    unsigned int i;

    for (i = onion_c->num_friends; i != 0; --i) {
        if (onion_c->friends_list[i - 1].is_valid) {
            break;
        }
    }

    if (onion_c->num_friends != i) {
        onion_c->num_friends = i;
        realloc_onion_friends(onion_c, onion_c->num_friends);
    }

    return friend_num;
}

/** @brief Set the function for this friend that will be callbacked with object and number
 * when that friend gives us one of the TCP relays they are connected to.
 *
 * object and number will be passed as argument to this function.
 *
 * return -1 on failure.
 * return 0 on success.
 */
int recv_tcp_relay_handler(Onion_Client *onion_c, int friend_num,
                           recv_tcp_relay_cb *callback, void *object, uint32_t number)
{
    if ((uint32_t)friend_num >= onion_c->num_friends) {
        return -1;
    }

    onion_c->friends_list[friend_num].tcp_relay_node_callback = callback;
    onion_c->friends_list[friend_num].tcp_relay_node_callback_object = object;
    onion_c->friends_list[friend_num].tcp_relay_node_callback_number = number;
    return 0;
}

/** @brief Set the function for this friend that will be callbacked with object and number
 * when that friend gives us their DHT temporary public key.
 *
 * object and number will be passed as argument to this function.
 *
 * return -1 on failure.
 * return 0 on success.
 */
int onion_dht_pk_callback(Onion_Client *onion_c, int friend_num,
                          onion_dht_pk_cb *function, void *object, uint32_t number)
{
    if ((uint32_t)friend_num >= onion_c->num_friends) {
        return -1;
    }

    onion_c->friends_list[friend_num].dht_pk_callback = function;
    onion_c->friends_list[friend_num].dht_pk_callback_object = object;
    onion_c->friends_list[friend_num].dht_pk_callback_number = number;
    return 0;
}

/** @brief Set a friend's DHT public key.
 *
 * return -1 on failure.
 * return 0 on success.
 */
int onion_set_friend_DHT_pubkey(Onion_Client *onion_c, int friend_num, const uint8_t *dht_key)
{
    if ((uint32_t)friend_num >= onion_c->num_friends) {
        return -1;
    }

    if (!onion_c->friends_list[friend_num].is_valid) {
        return -1;
    }

    if (onion_c->friends_list[friend_num].know_dht_public_key) {
        if (pk_equal(dht_key, onion_c->friends_list[friend_num].dht_public_key)) {
            return -1;
        }
    }

    onion_c->friends_list[friend_num].know_dht_public_key = true;
    memcpy(onion_c->friends_list[friend_num].dht_public_key, dht_key, CRYPTO_PUBLIC_KEY_SIZE);

    return 0;
}

/** @brief Copy friends DHT public key into dht_key.
 *
 * return 0 on failure (no key copied).
 * return 1 on success (key copied).
 */
unsigned int onion_getfriend_DHT_pubkey(const Onion_Client *onion_c, int friend_num, uint8_t *dht_key)
{
    if ((uint32_t)friend_num >= onion_c->num_friends) {
        return 0;
    }

    if (!onion_c->friends_list[friend_num].is_valid) {
        return 0;
    }

    if (!onion_c->friends_list[friend_num].know_dht_public_key) {
        return 0;
    }

    memcpy(dht_key, onion_c->friends_list[friend_num].dht_public_key, CRYPTO_PUBLIC_KEY_SIZE);
    return 1;
}

/** @brief Get the ip of friend friendnum and put it in ip_port
 *
 * @retval -1 if public_key does NOT refer to a friend
 * @retval  0 if public_key refers to a friend and we failed to find the friend (yet)
 * @retval  1 if public_key refers to a friend and we found them
 */
int onion_getfriendip(const Onion_Client *onion_c, int friend_num, IP_Port *ip_port)
{
    uint8_t dht_public_key[CRYPTO_PUBLIC_KEY_SIZE];

    if (onion_getfriend_DHT_pubkey(onion_c, friend_num, dht_public_key) == 0) {
        return -1;
    }

    return dht_getfriendip(onion_c->dht, dht_public_key, ip_port);
}


/** @brief Set if friend is online or not.
 *
 * NOTE: This function is there and should be used so that we don't send
 * useless packets to the friend if they are online.
 *
 * return -1 on failure.
 * return 0 on success.
 */
int onion_set_friend_online(Onion_Client *onion_c, int friend_num, bool is_online)
{
    if ((uint32_t)friend_num >= onion_c->num_friends) {
        return -1;
    }

    onion_c->friends_list[friend_num].is_online = is_online;

    /* This should prevent some clock related issues */
    if (!is_online) {
        onion_c->friends_list[friend_num].last_noreplay = 0;
        onion_c->friends_list[friend_num].run_count = 0;
    }

    return 0;
}

non_null()
static void populate_path_nodes(Onion_Client *onion_c)
{
    Node_format node_list[MAX_FRIEND_CLIENTS];

    const unsigned int num_nodes = randfriends_nodes(onion_c->dht, node_list, MAX_FRIEND_CLIENTS);

    for (unsigned int i = 0; i < num_nodes; ++i) {
        onion_add_path_node(onion_c, &node_list[i].ip_port, node_list[i].public_key);
    }
}

/* How often we ping new friends per node */
#define ANNOUNCE_FRIEND_NEW_INTERVAL 3

/* How long we consider a friend new based on the value of their run_count */
#define ANNOUNCE_FRIEND_RUN_COUNT_BEGINNING 5

/* How often we try to re-populate the nodes lists if we don't meet a minimum threshhold of nodes */
#define ANNOUNCE_POPULATE_TIMEOUT (60 * 10)

/* The max time between lookup requests for a friend per node */
#define ANNOUNCE_FRIEND_MAX_INTERVAL (60 * 60)

/* Max exponent when calculating the announce request interval */
#define MAX_RUN_COUNT_EXPONENT 12

non_null()
static void do_friend(Onion_Client *onion_c, uint16_t friendnum)
{
    if (friendnum >= onion_c->num_friends) {
        return;
    }

    Onion_Friend *o_friend = &onion_c->friends_list[friendnum];

    if (!o_friend->is_valid) {
        return;
    }

    uint32_t interval;
    const uint64_t tm = mono_time_get(onion_c->mono_time);
    const bool friend_is_new = o_friend->run_count <= ANNOUNCE_FRIEND_RUN_COUNT_BEGINNING;

    if (!friend_is_new) {
        // how often we ping a node for a friend depends on how many times we've already tried.
        // the interval increases exponentially, as the longer a friend has been offline, the less
        // likely the case is that they're online and failed to find us
        const uint32_t c = 1 << min_u32(MAX_RUN_COUNT_EXPONENT, o_friend->run_count - 2);
        interval = min_u32(c, ANNOUNCE_FRIEND_MAX_INTERVAL);
    } else {
        interval = ANNOUNCE_FRIEND_NEW_INTERVAL;
    }

    if (o_friend->is_online) {
        return;
    }

    assert(interval >= ANNOUNCE_FRIEND_NEW_INTERVAL); // an int overflow would be devastating

    /* send packets to friend telling them our DHT public key. */
    if (mono_time_is_timeout(onion_c->mono_time, onion_c->friends_list[friendnum].last_dht_pk_onion_sent,
                             ONION_DHTPK_SEND_INTERVAL)) {
        if (send_dhtpk_announce(onion_c, friendnum, 0) >= 1) {
            onion_c->friends_list[friendnum].last_dht_pk_onion_sent = tm;
        }
    }

    if (mono_time_is_timeout(onion_c->mono_time, onion_c->friends_list[friendnum].last_dht_pk_dht_sent,
                             DHT_DHTPK_SEND_INTERVAL)) {
        if (send_dhtpk_announce(onion_c, friendnum, 1) >= 1) {
            onion_c->friends_list[friendnum].last_dht_pk_dht_sent = tm;
        }
    }

    uint16_t count = 0;  // number of alive path nodes

    Onion_Node *node_list = o_friend->clients_list;

    for (unsigned i = 0; i < MAX_ONION_CLIENTS; ++i) {
        if (onion_node_timed_out(&node_list[i], onion_c->mono_time)) {
            continue;
        }

        ++count;

        // we don't want new nodes to be pinged immediately
        if (node_list[i].last_pinged == 0) {
            node_list[i].last_pinged = tm;
            continue;
        }

        // node hasn't responded in a while so we skip it
        if (node_list[i].pings_since_last_response >= ONION_NODE_MAX_PINGS) {
            continue;
        }

        // space requests out between nodes
        if (!mono_time_is_timeout(onion_c->mono_time, o_friend->time_last_pinged, interval / (MAX_ONION_CLIENTS / 2))) {
            continue;
        }

        if (!mono_time_is_timeout(onion_c->mono_time, node_list[i].last_pinged, interval)) {
            continue;
        }

        if (client_send_announce_request(onion_c, friendnum + 1, &node_list[i].ip_port,
                                         node_list[i].public_key, nullptr, -1) == 0) {
            node_list[i].last_pinged = tm;
            o_friend->time_last_pinged = tm;
            ++node_list[i].pings_since_last_response;
            ++o_friend->pings;

            if (o_friend->pings % (MAX_ONION_CLIENTS / 2) == 0) {
                ++o_friend->run_count;
            }
        }
    }

    if (count == MAX_ONION_CLIENTS) {
        if (!friend_is_new) {
            o_friend->last_populated = tm;
        }

        return;
    }

    // check if path nodes list for this friend needs to be repopulated
    if (count <= MAX_ONION_CLIENTS / 2
            || mono_time_is_timeout(onion_c->mono_time, o_friend->last_populated, ANNOUNCE_POPULATE_TIMEOUT)) {
        const uint16_t num_nodes = min_u16(onion_c->path_nodes_index, MAX_PATH_NODES);
        const uint16_t n = min_u16(num_nodes, MAX_PATH_NODES / 4);

        if (n == 0) {
            return;
        }

        o_friend->last_populated = tm;

        for (uint16_t i = 0; i < n; ++i) {
            const uint32_t num = random_range_u32(onion_c->rng, num_nodes);
            client_send_announce_request(onion_c, friendnum + 1, &onion_c->path_nodes[num].ip_port,
                                         onion_c->path_nodes[num].public_key, nullptr, -1);
        }
    }
}


/** Function to call when onion data packet with contents beginning with byte is received. */
void oniondata_registerhandler(Onion_Client *onion_c, uint8_t byte, oniondata_handler_cb *cb, void *object)
{
    onion_c->onion_data_handlers[byte].function = cb;
    onion_c->onion_data_handlers[byte].object = object;
}

void onion_group_announce_register(Onion_Client *onion_c, onion_group_announce_cb *func, void *user_data)
{
    onion_c->group_announce_response = func;
    onion_c->group_announce_response_user_data = user_data;
}

#define ANNOUNCE_INTERVAL_NOT_ANNOUNCED 3
#define ANNOUNCE_INTERVAL_ANNOUNCED ONION_NODE_PING_INTERVAL

#define TIME_TO_STABLE (ONION_NODE_PING_INTERVAL * 6)
#define ANNOUNCE_INTERVAL_STABLE (ONION_NODE_PING_INTERVAL * 8)

non_null()
static void do_announce(Onion_Client *onion_c)
{
    unsigned int count = 0;
    Onion_Node *node_list = onion_c->clients_announce_list;

    for (unsigned int i = 0; i < MAX_ONION_CLIENTS_ANNOUNCE; ++i) {
        if (onion_node_timed_out(&node_list[i], onion_c->mono_time)) {
            continue;
        }

        ++count;

        /* Don't announce ourselves the first time this is run to new peers */
        if (node_list[i].last_pinged == 0) {
            node_list[i].last_pinged = 1;
            continue;
        }

        if (node_list[i].pings_since_last_response >= ONION_NODE_MAX_PINGS) {
            continue;
        }


        unsigned int interval = ANNOUNCE_INTERVAL_NOT_ANNOUNCED;

        if (node_list[i].is_stored != 0
                && path_exists(onion_c->mono_time, &onion_c->onion_paths_self, node_list[i].path_used)) {
            interval = ANNOUNCE_INTERVAL_ANNOUNCED;

            const uint32_t pathnum = node_list[i].path_used % NUMBER_ONION_PATHS;

            /* A node/path is considered "stable", and can be pinged less
             * aggressively, if it has survived for at least TIME_TO_STABLE
             * and the latest packets sent to it are not timing out.
             */
            if (mono_time_is_timeout(onion_c->mono_time, node_list[i].added_time, TIME_TO_STABLE)
                    && !(node_list[i].pings_since_last_response > 0
                         && mono_time_is_timeout(onion_c->mono_time, node_list[i].last_pinged, ONION_NODE_TIMEOUT))
                    && mono_time_is_timeout(onion_c->mono_time, onion_c->onion_paths_self.path_creation_time[pathnum], TIME_TO_STABLE)
                    && !(onion_c->onion_paths_self.last_path_used_times[pathnum] > 0
                         && mono_time_is_timeout(onion_c->mono_time, onion_c->onion_paths_self.last_path_used[pathnum], ONION_PATH_TIMEOUT))) {
                interval = ANNOUNCE_INTERVAL_STABLE;
            }
        }

        if (mono_time_is_timeout(onion_c->mono_time, node_list[i].last_pinged, interval)
                || mono_time_is_timeout(onion_c->mono_time, onion_c->last_announce, ONION_NODE_PING_INTERVAL)) {
            uint32_t path_to_use = node_list[i].path_used;

            if (node_list[i].pings_since_last_response == ONION_NODE_MAX_PINGS - 1
                    && mono_time_is_timeout(onion_c->mono_time, node_list[i].added_time, TIME_TO_STABLE)) {
                /* Last chance for a long-lived node - try a random path */
                path_to_use = -1;
            }

            if (client_send_announce_request(onion_c, 0, &node_list[i].ip_port, node_list[i].public_key,
                                             node_list[i].ping_id, path_to_use) == 0) {
                node_list[i].last_pinged = mono_time_get(onion_c->mono_time);
                ++node_list[i].pings_since_last_response;
                onion_c->last_announce = mono_time_get(onion_c->mono_time);
            }
        }
    }

    if (count == MAX_ONION_CLIENTS_ANNOUNCE) {
        onion_c->last_populated = mono_time_get(onion_c->mono_time);
        return;
    }

    // check if list needs to be re-populated
    if (count <= MAX_ONION_CLIENTS_ANNOUNCE / 2
            || mono_time_is_timeout(onion_c->mono_time, onion_c->last_populated, ANNOUNCE_POPULATE_TIMEOUT)) {
        uint16_t num_nodes;
        const Node_format *path_nodes;

        if (onion_c->path_nodes_index == 0) {
            num_nodes = min_u16(onion_c->path_nodes_index_bs, MAX_PATH_NODES);
            path_nodes = onion_c->path_nodes_bs;
        } else {
            num_nodes = min_u16(onion_c->path_nodes_index, MAX_PATH_NODES);
            path_nodes = onion_c->path_nodes;
        }

        if (num_nodes == 0) {
            return;
        }

        for (unsigned int i = 0; i < (MAX_ONION_CLIENTS_ANNOUNCE / 2); ++i) {
            const uint32_t num = random_range_u32(onion_c->rng, num_nodes);
            client_send_announce_request(onion_c, 0, &path_nodes[num].ip_port, path_nodes[num].public_key, nullptr, -1);
        }
    }
}

/**
 * @retval false if we are not connected to the network.
 * @retval true if we are.
 */
non_null()
static bool onion_isconnected(Onion_Client *onion_c)
{
    unsigned int num = 0;
    unsigned int announced = 0;

    if (mono_time_is_timeout(onion_c->mono_time, onion_c->last_packet_recv, ONION_OFFLINE_TIMEOUT)) {
        onion_c->last_populated = 0;
        return false;
    }

    if (onion_c->path_nodes_index == 0) {
        onion_c->last_populated = 0;
        return false;
    }

    for (unsigned int i = 0; i < MAX_ONION_CLIENTS_ANNOUNCE; ++i) {
        if (!onion_node_timed_out(&onion_c->clients_announce_list[i], onion_c->mono_time)) {
            ++num;

            if (onion_c->clients_announce_list[i].is_stored != 0) {
                ++announced;
            }
        }
    }

    unsigned int pnodes = onion_c->path_nodes_index;

    if (pnodes > MAX_ONION_CLIENTS_ANNOUNCE) {
        pnodes = MAX_ONION_CLIENTS_ANNOUNCE;
    }

    /* Consider ourselves online if we are announced to half or more nodes
     * we are connected to */
    if (num != 0 && announced != 0) {
        if ((num / 2) <= announced && (pnodes / 2) <= num) {
            return true;
        }
    }

    onion_c->last_populated = 0;

    return false;
}

non_null()
static void reset_friend_run_counts(Onion_Client *onion_c)
{
    for (uint16_t i = 0; i < onion_c->num_friends; ++i) {
        Onion_Friend *o_friend = &onion_c->friends_list[i];

        if (o_friend->is_valid) {
            o_friend->run_count = 0;
        }
    }
}

#define ONION_CONNECTION_SECONDS 3
#define ONION_CONNECTED_TIMEOUT 10

Onion_Connection_Status onion_connection_status(const Onion_Client *onion_c, bool lan_only_is_online)
{
    if (onion_c->onion_connected >= ONION_CONNECTION_SECONDS) {
        if (lan_only_is_online) {
            if (onion_c->udp_connected_lan_only_is_ok) {
                return ONION_CONNECTION_STATUS_UDP;
            }
        } else {
            if (onion_c->udp_connected) {
                return ONION_CONNECTION_STATUS_UDP;
            }
        }
        return ONION_CONNECTION_STATUS_TCP;
    }

    return ONION_CONNECTION_STATUS_NONE;
}

void do_onion_client(Onion_Client *onion_c)
{
    if (onion_c->last_run == mono_time_get(onion_c->mono_time)) {
        return;
    }

    if (mono_time_is_timeout(onion_c->mono_time, onion_c->first_run, ONION_CONNECTION_SECONDS)) {
        populate_path_nodes(onion_c);
        do_announce(onion_c);
    }

    if (onion_isconnected(onion_c)) {
        if (mono_time_is_timeout(onion_c->mono_time, onion_c->last_time_connected, ONION_CONNECTED_TIMEOUT)) {
            reset_friend_run_counts(onion_c);
        }

        onion_c->last_time_connected = mono_time_get(onion_c->mono_time);

        if (onion_c->onion_connected < ONION_CONNECTION_SECONDS * 2) {
            ++onion_c->onion_connected;
        }
    } else {
        if (onion_c->onion_connected != 0) {
            --onion_c->onion_connected;
        }
    }

    onion_c->udp_connected = dht_non_lan_connected(onion_c->dht);
    onion_c->udp_connected_lan_only_is_ok = dht_isconnected(onion_c->dht);

    if (mono_time_is_timeout(onion_c->mono_time, onion_c->first_run, ONION_CONNECTION_SECONDS * 2)) {
        set_tcp_onion_status(nc_get_tcp_c(onion_c->c), !onion_c->udp_connected);
    }

    if (onion_connection_status(onion_c, false) != ONION_CONNECTION_STATUS_NONE) {
        for (unsigned i = 0; i < onion_c->num_friends; ++i) {
            do_friend(onion_c, i);
        }
    }

    if (onion_c->last_run == 0) {
        onion_c->first_run = mono_time_get(onion_c->mono_time);
    }

    onion_c->last_run = mono_time_get(onion_c->mono_time);
}

Onion_Client *new_onion_client(const Logger *logger, const Random *rng, const Mono_Time *mono_time, Net_Crypto *c)
{
    if (c == nullptr) {
        return nullptr;
    }

    Onion_Client *onion_c = (Onion_Client *)calloc(1, sizeof(Onion_Client));

    if (onion_c == nullptr) {
        return nullptr;
    }

    onion_c->announce_ping_array = ping_array_new(ANNOUNCE_ARRAY_SIZE, ANNOUNCE_TIMEOUT);

    if (onion_c->announce_ping_array == nullptr) {
        free(onion_c);
        return nullptr;
    }

    onion_c->mono_time = mono_time;
    onion_c->logger = logger;
    onion_c->rng = rng;
    onion_c->dht = nc_get_dht(c);
    onion_c->net = dht_get_net(onion_c->dht);
    onion_c->c = c;
    new_symmetric_key(rng, onion_c->secret_symmetric_key);
    crypto_new_keypair(rng, onion_c->temp_public_key, onion_c->temp_secret_key);
    networking_registerhandler(onion_c->net, NET_PACKET_ANNOUNCE_RESPONSE, &handle_announce_response, onion_c);
    networking_registerhandler(onion_c->net, NET_PACKET_ANNOUNCE_RESPONSE_OLD, &handle_announce_response_old, onion_c);
    networking_registerhandler(onion_c->net, NET_PACKET_ONION_DATA_RESPONSE, &handle_data_response, onion_c);
    oniondata_registerhandler(onion_c, ONION_DATA_DHTPK, &handle_dhtpk_announce, onion_c);
    cryptopacket_registerhandler(onion_c->dht, CRYPTO_PACKET_DHTPK, &handle_dht_dhtpk, onion_c);
    set_onion_packet_tcp_connection_callback(nc_get_tcp_c(onion_c->c), &handle_tcp_onion, onion_c);

    return onion_c;
}

void kill_onion_client(Onion_Client *onion_c)
{
    if (onion_c == nullptr) {
        return;
    }

    ping_array_kill(onion_c->announce_ping_array);
    realloc_onion_friends(onion_c, 0);
    networking_registerhandler(onion_c->net, NET_PACKET_ANNOUNCE_RESPONSE, nullptr, nullptr);
    networking_registerhandler(onion_c->net, NET_PACKET_ANNOUNCE_RESPONSE_OLD, nullptr, nullptr);
    networking_registerhandler(onion_c->net, NET_PACKET_ONION_DATA_RESPONSE, nullptr, nullptr);
    oniondata_registerhandler(onion_c, ONION_DATA_DHTPK, nullptr, nullptr);
    cryptopacket_registerhandler(onion_c->dht, CRYPTO_PACKET_DHTPK, nullptr, nullptr);
    set_onion_packet_tcp_connection_callback(nc_get_tcp_c(onion_c->c), nullptr, nullptr);
    crypto_memzero(onion_c, sizeof(Onion_Client));
    free(onion_c);
}
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2018 The TokTok team.
 * Copyright © 2014 Tox project.
 */

/**
 * Implementation of an efficient array to store that we pinged something.
 */

#include <stdlib.h>
#include <string.h>


typedef struct Ping_Array_Entry {
    uint8_t *data;
    uint32_t length;
    uint64_t ping_time;
    uint64_t ping_id;
} Ping_Array_Entry;

struct Ping_Array {
    Ping_Array_Entry *entries;

    uint32_t last_deleted; /* number representing the next entry to be deleted. */
    uint32_t last_added;   /* number representing the last entry to be added. */
    uint32_t total_size;   /* The length of entries */
    uint32_t timeout;      /* The timeout after which entries are cleared. */
};

Ping_Array *ping_array_new(uint32_t size, uint32_t timeout)
{
    if (size == 0 || timeout == 0) {
        return nullptr;
    }

    if ((size & (size - 1)) != 0) {
        // Not a power of 2.
        return nullptr;
    }

    Ping_Array *const empty_array = (Ping_Array *)calloc(1, sizeof(Ping_Array));

    if (empty_array == nullptr) {
        return nullptr;
    }

    empty_array->entries = (Ping_Array_Entry *)calloc(size, sizeof(Ping_Array_Entry));

    if (empty_array->entries == nullptr) {
        free(empty_array);
        return nullptr;
    }

    empty_array->last_deleted = 0;
    empty_array->last_added = 0;
    empty_array->total_size = size;
    empty_array->timeout = timeout;
    return empty_array;
}

non_null()
static void clear_entry(Ping_Array *array, uint32_t index)
{
    const Ping_Array_Entry empty = {nullptr};
    free(array->entries[index].data);
    array->entries[index] = empty;
}

void ping_array_kill(Ping_Array *array)
{
    if (array == nullptr) {
        return;
    }

    while (array->last_deleted != array->last_added) {
        const uint32_t index = array->last_deleted % array->total_size;
        clear_entry(array, index);
        ++array->last_deleted;
    }

    free(array->entries);
    free(array);
}

/** Clear timed out entries. */
non_null()
static void ping_array_clear_timedout(Ping_Array *array, const Mono_Time *mono_time)
{
    while (array->last_deleted != array->last_added) {
        const uint32_t index = array->last_deleted % array->total_size;

        if (!mono_time_is_timeout(mono_time, array->entries[index].ping_time, array->timeout)) {
            break;
        }

        clear_entry(array, index);
        ++array->last_deleted;
    }
}

uint64_t ping_array_add(Ping_Array *array, const Mono_Time *mono_time, const Random *rng,
                        const uint8_t *data, uint32_t length)
{
    ping_array_clear_timedout(array, mono_time);
    const uint32_t index = array->last_added % array->total_size;

    if (array->entries[index].data != nullptr) {
        array->last_deleted = array->last_added - array->total_size;
        clear_entry(array, index);
    }

    array->entries[index].data = (uint8_t *)malloc(length);

    if (array->entries[index].data == nullptr) {
        return 0;
    }

    memcpy(array->entries[index].data, data, length);
    array->entries[index].length = length;
    array->entries[index].ping_time = mono_time_get(mono_time);
    ++array->last_added;
    uint64_t ping_id = random_u64(rng);
    ping_id /= array->total_size;
    ping_id *= array->total_size;
    ping_id += index;

    if (ping_id == 0) {
        ping_id += array->total_size;
    }

    array->entries[index].ping_id = ping_id;
    return ping_id;
}

int32_t ping_array_check(Ping_Array *array, const Mono_Time *mono_time, uint8_t *data,
                         size_t length, uint64_t ping_id)
{
    if (ping_id == 0) {
        return -1;
    }

    const uint32_t index = ping_id % array->total_size;

    if (array->entries[index].ping_id != ping_id) {
        return -1;
    }

    if (mono_time_is_timeout(mono_time, array->entries[index].ping_time, array->timeout)) {
        return -1;
    }

    if (array->entries[index].length > length) {
        return -1;
    }

    // TODO(iphydf): This can't happen? If it indeed can't, turn it into an assert.
    if (array->entries[index].data == nullptr) {
        return -1;
    }

    memcpy(data, array->entries[index].data, array->entries[index].length);
    const uint32_t len = array->entries[index].length;
    clear_entry(array, index);
    return len;
}
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2018 The TokTok team.
 * Copyright © 2013 Tox project.
 * Copyright © 2013 plutooo
 */

/**
 * Buffered pinging using cyclic arrays.
 */

#include <stdlib.h>
#include <string.h>


#define PING_NUM_MAX 512

/** Maximum newly announced nodes to ping per TIME_TO_PING seconds. */
#define MAX_TO_PING 32

/** Ping newly announced nodes to ping per TIME_TO_PING seconds*/
#define TIME_TO_PING 2


struct Ping {
    const Mono_Time *mono_time;
    const Random *rng;
    DHT *dht;

    Ping_Array  *ping_array;
    Node_format to_ping[MAX_TO_PING];
    uint64_t    last_to_ping;
};


#define PING_PLAIN_SIZE (1 + sizeof(uint64_t))
#define DHT_PING_SIZE (1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + PING_PLAIN_SIZE + CRYPTO_MAC_SIZE)
#define PING_DATA_SIZE (CRYPTO_PUBLIC_KEY_SIZE + sizeof(IP_Port))

void ping_send_request(Ping *ping, const IP_Port *ipp, const uint8_t *public_key)
{
    uint8_t   pk[DHT_PING_SIZE];
    int       rc;
    uint64_t  ping_id;

    if (pk_equal(public_key, dht_get_self_public_key(ping->dht))) {
        return;
    }


    // generate key to encrypt ping_id with recipient privkey
    const uint8_t *shared_key = dht_get_shared_key_sent(ping->dht, public_key);
    // Generate random ping_id.
    uint8_t data[PING_DATA_SIZE];
    pk_copy(data, public_key);
    memcpy(data + CRYPTO_PUBLIC_KEY_SIZE, ipp, sizeof(IP_Port));
    ping_id = ping_array_add(ping->ping_array, ping->mono_time, ping->rng, data, sizeof(data));

    if (ping_id == 0) {
        return;
    }

    uint8_t ping_plain[PING_PLAIN_SIZE];
    ping_plain[0] = NET_PACKET_PING_REQUEST;
    memcpy(ping_plain + 1, &ping_id, sizeof(ping_id));

    pk[0] = NET_PACKET_PING_REQUEST;
    pk_copy(pk + 1, dht_get_self_public_key(ping->dht));     // Our pubkey
    random_nonce(ping->rng, pk + 1 + CRYPTO_PUBLIC_KEY_SIZE); // Generate new nonce


    rc = encrypt_data_symmetric(shared_key,
                                pk + 1 + CRYPTO_PUBLIC_KEY_SIZE,
                                ping_plain, sizeof(ping_plain),
                                pk + 1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE);

    if (rc != PING_PLAIN_SIZE + CRYPTO_MAC_SIZE) {
        return;
    }

    // We never check this return value and failures in sendpacket are already logged
    sendpacket(dht_get_net(ping->dht), ipp, pk, sizeof(pk));
}

non_null()
static int ping_send_response(const Ping *ping, const IP_Port *ipp, const uint8_t *public_key,
                              uint64_t ping_id, const uint8_t *shared_encryption_key)
{
    uint8_t pk[DHT_PING_SIZE];

    if (pk_equal(public_key, dht_get_self_public_key(ping->dht))) {
        return 1;
    }

    uint8_t ping_plain[PING_PLAIN_SIZE];
    ping_plain[0] = NET_PACKET_PING_RESPONSE;
    memcpy(ping_plain + 1, &ping_id, sizeof(ping_id));

    pk[0] = NET_PACKET_PING_RESPONSE;
    pk_copy(pk + 1, dht_get_self_public_key(ping->dht));     // Our pubkey
    random_nonce(ping->rng, pk + 1 + CRYPTO_PUBLIC_KEY_SIZE); // Generate new nonce

    // Encrypt ping_id using recipient privkey
    const int rc = encrypt_data_symmetric(shared_encryption_key,
                                          pk + 1 + CRYPTO_PUBLIC_KEY_SIZE,
                                          ping_plain, sizeof(ping_plain),
                                          pk + 1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE);

    if (rc != PING_PLAIN_SIZE + CRYPTO_MAC_SIZE) {
        return 1;
    }

    return sendpacket(dht_get_net(ping->dht), ipp, pk, sizeof(pk));
}

non_null()
static int handle_ping_request(void *object, const IP_Port *source, const uint8_t *packet, uint16_t length,
                               void *userdata)
{
    DHT *dht = (DHT *)object;

    if (length != DHT_PING_SIZE) {
        return 1;
    }

    Ping *ping = dht_get_ping(dht);

    if (pk_equal(packet + 1, dht_get_self_public_key(ping->dht))) {
        return 1;
    }

    const uint8_t *shared_key = dht_get_shared_key_recv(dht, packet + 1);

    uint8_t ping_plain[PING_PLAIN_SIZE];

    // Decrypt ping_id
    const int rc = decrypt_data_symmetric(shared_key,
                                          packet + 1 + CRYPTO_PUBLIC_KEY_SIZE,
                                          packet + 1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE,
                                          PING_PLAIN_SIZE + CRYPTO_MAC_SIZE,
                                          ping_plain);

    if (rc != sizeof(ping_plain)) {
        return 1;
    }

    if (ping_plain[0] != NET_PACKET_PING_REQUEST) {
        return 1;
    }

    uint64_t ping_id;
    memcpy(&ping_id, ping_plain + 1, sizeof(ping_id));
    // Send response
    ping_send_response(ping, source, packet + 1, ping_id, shared_key);
    ping_add(ping, packet + 1, source);

    return 0;
}

non_null()
static int handle_ping_response(void *object, const IP_Port *source, const uint8_t *packet, uint16_t length,
                                void *userdata)
{
    DHT      *dht = (DHT *)object;
    int       rc;

    if (length != DHT_PING_SIZE) {
        return 1;
    }

    Ping *ping = dht_get_ping(dht);

    if (pk_equal(packet + 1, dht_get_self_public_key(ping->dht))) {
        return 1;
    }

    // generate key to encrypt ping_id with recipient privkey
    const uint8_t *shared_key = dht_get_shared_key_sent(ping->dht, packet + 1);

    uint8_t ping_plain[PING_PLAIN_SIZE];
    // Decrypt ping_id
    rc = decrypt_data_symmetric(shared_key,
                                packet + 1 + CRYPTO_PUBLIC_KEY_SIZE,
                                packet + 1 + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE,
                                PING_PLAIN_SIZE + CRYPTO_MAC_SIZE,
                                ping_plain);

    if (rc != sizeof(ping_plain)) {
        return 1;
    }

    if (ping_plain[0] != NET_PACKET_PING_RESPONSE) {
        return 1;
    }

    uint64_t   ping_id;
    memcpy(&ping_id, ping_plain + 1, sizeof(ping_id));
    uint8_t data[PING_DATA_SIZE];

    if (ping_array_check(ping->ping_array, ping->mono_time, data, sizeof(data), ping_id) != sizeof(data)) {
        return 1;
    }

    if (!pk_equal(packet + 1, data)) {
        return 1;
    }

    IP_Port ipp;
    memcpy(&ipp, data + CRYPTO_PUBLIC_KEY_SIZE, sizeof(IP_Port));

    if (!ipport_equal(&ipp, source)) {
        return 1;
    }

    addto_lists(dht, source, packet + 1);
    return 0;
}

/** @brief Check if public_key with ip_port is in the list.
 *
 * return true if it is.
 * return false if it isn't.
 */
non_null()
static bool in_list(const Client_data *list, uint16_t length, const Mono_Time *mono_time, const uint8_t *public_key,
                    const IP_Port *ip_port)
{
    for (unsigned int i = 0; i < length; ++i) {
        if (pk_equal(list[i].public_key, public_key)) {
            const IPPTsPng *ipptp;

            if (net_family_is_ipv4(ip_port->ip.family)) {
                ipptp = &list[i].assoc4;
            } else {
                ipptp = &list[i].assoc6;
            }

            if (!mono_time_is_timeout(mono_time, ipptp->timestamp, BAD_NODE_TIMEOUT)
                    && ipport_equal(&ipptp->ip_port, ip_port)) {
                return true;
            }
        }
    }

    return false;
}

/** @brief Add nodes to the to_ping list.
 * All nodes in this list are pinged every TIME_TO_PING seconds
 * and are then removed from the list.
 * If the list is full the nodes farthest from our public_key are replaced.
 * The purpose of this list is to enable quick integration of new nodes into the
 * network while preventing amplification attacks.
 *
 * @retval 0 if node was added.
 * @retval -1 if node was not added.
 */
int32_t ping_add(Ping *ping, const uint8_t *public_key, const IP_Port *ip_port)
{
    if (!ip_isset(&ip_port->ip)) {
        return -1;
    }

    if (!node_addable_to_close_list(ping->dht, public_key, ip_port)) {
        return -1;
    }

    if (in_list(dht_get_close_clientlist(ping->dht), LCLIENT_LIST, ping->mono_time, public_key, ip_port)) {
        return -1;
    }

    IP_Port temp;

    if (dht_getfriendip(ping->dht, public_key, &temp) == 0) {
        ping_send_request(ping, ip_port, public_key);
        return -1;
    }

    for (unsigned int i = 0; i < MAX_TO_PING; ++i) {
        if (!ip_isset(&ping->to_ping[i].ip_port.ip)) {
            memcpy(ping->to_ping[i].public_key, public_key, CRYPTO_PUBLIC_KEY_SIZE);
            ipport_copy(&ping->to_ping[i].ip_port, ip_port);
            return 0;
        }

        if (pk_equal(ping->to_ping[i].public_key, public_key)) {
            return -1;
        }
    }

    if (add_to_list(ping->to_ping, MAX_TO_PING, public_key, ip_port, dht_get_self_public_key(ping->dht))) {
        return 0;
    }

    return -1;
}


/** @brief Ping all the valid nodes in the to_ping list every TIME_TO_PING seconds.
 * This function must be run at least once every TIME_TO_PING seconds.
 */
void ping_iterate(Ping *ping)
{
    if (!mono_time_is_timeout(ping->mono_time, ping->last_to_ping, TIME_TO_PING)) {
        return;
    }

    if (!ip_isset(&ping->to_ping[0].ip_port.ip)) {
        return;
    }

    unsigned int i;

    for (i = 0; i < MAX_TO_PING; ++i) {
        if (!ip_isset(&ping->to_ping[i].ip_port.ip)) {
            break;
        }

        if (!node_addable_to_close_list(ping->dht, ping->to_ping[i].public_key, &ping->to_ping[i].ip_port)) {
            continue;
        }

        ping_send_request(ping, &ping->to_ping[i].ip_port, ping->to_ping[i].public_key);
        ip_reset(&ping->to_ping[i].ip_port.ip);
    }

    if (i != 0) {
        ping->last_to_ping = mono_time_get(ping->mono_time);
    }
}


Ping *ping_new(const Mono_Time *mono_time, const Random *rng, DHT *dht)
{
    Ping *ping = (Ping *)calloc(1, sizeof(Ping));

    if (ping == nullptr) {
        return nullptr;
    }

    ping->ping_array = ping_array_new(PING_NUM_MAX, PING_TIMEOUT);

    if (ping->ping_array == nullptr) {
        free(ping);
        return nullptr;
    }

    ping->mono_time = mono_time;
    ping->rng = rng;
    ping->dht = dht;
    networking_registerhandler(dht_get_net(ping->dht), NET_PACKET_PING_REQUEST, &handle_ping_request, dht);
    networking_registerhandler(dht_get_net(ping->dht), NET_PACKET_PING_RESPONSE, &handle_ping_response, dht);

    return ping;
}

void ping_kill(Ping *ping)
{
    if (ping == nullptr) {
        return;
    }

    networking_registerhandler(dht_get_net(ping->dht), NET_PACKET_PING_REQUEST, nullptr, nullptr);
    networking_registerhandler(dht_get_net(ping->dht), NET_PACKET_PING_RESPONSE, nullptr, nullptr);
    ping_array_kill(ping->ping_array);

    free(ping);
}
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2022 The TokTok team.
 */


#include <assert.h>
#include <stdint.h>
#include <stdlib.h>     // calloc(...)
#include <string.h>     // memcpy(...)


typedef struct Shared_Key {
    uint8_t public_key[CRYPTO_PUBLIC_KEY_SIZE];
    uint8_t shared_key[CRYPTO_SHARED_KEY_SIZE];
    uint64_t time_last_requested;
} Shared_Key;

struct Shared_Key_Cache {
    Shared_Key *keys;
    const uint8_t* self_secret_key;
    uint64_t timeout; /** After this time (in seconds), a key is erased on the next housekeeping cycle */
    const Mono_Time *time;
    uint8_t keys_per_slot;
};

non_null()
static bool shared_key_is_empty(const Shared_Key *k) {
    assert(k != nullptr);
    /*
     * Since time can never be 0, we use that to determine if a key slot is empty.
     * Additionally this allows us to use crypto_memzero and leave the slot in a valid state.
     */
    return k->time_last_requested == 0;
}

non_null()
static void shared_key_set_empty(Shared_Key *k) {
    crypto_memzero(k, sizeof (Shared_Key));
    assert(shared_key_is_empty(k));
}

Shared_Key_Cache *shared_key_cache_new(const Mono_Time *time, const uint8_t *self_secret_key, uint64_t timeout, uint8_t keys_per_slot)
{
    if (time == nullptr || self_secret_key == nullptr || timeout == 0 || keys_per_slot == 0) {
        return nullptr;
    }

    // Time must not be zero, since we use that as special value for empty slots
    if (mono_time_get(time) == 0) {
        // Fail loudly in debug environments
        assert(false);
        return nullptr;
    }

    Shared_Key_Cache *res = (Shared_Key_Cache *)calloc(1, sizeof (Shared_Key_Cache));
    if (res == nullptr) {
        return nullptr;
    }

    res->self_secret_key = self_secret_key;
    res->time = time;
    res->keys_per_slot = keys_per_slot;
    // We take one byte from the public key for each bucket and store keys_per_slot elements there
    const size_t cache_size = 256 * keys_per_slot;
    res->keys = (Shared_Key *)calloc(cache_size, sizeof (Shared_Key));

    if (res->keys == nullptr) {
        free(res);
        return nullptr;
    }

    crypto_memlock(res->keys, cache_size * sizeof (Shared_Key));

    return res;
}

void shared_key_cache_free(Shared_Key_Cache *cache)
{
    if (cache == nullptr) {
        return;
    }

    const size_t cache_size = 256 * cache->keys_per_slot;
    // Don't leave key material in memory
    crypto_memzero(cache->keys, cache_size * sizeof (Shared_Key));
    crypto_memunlock(cache->keys, cache_size * sizeof (Shared_Key));
    free(cache->keys);
    free(cache);
}

/* NOTE: On each lookup housekeeping is performed to evict keys that did timeout. */
const uint8_t *shared_key_cache_lookup(Shared_Key_Cache *cache, const uint8_t public_key[CRYPTO_PUBLIC_KEY_SIZE])
{
    // caching the time is not necessary, but calls to mono_time_get(...) are not free
    const uint64_t cur_time = mono_time_get(cache->time);
    // We can't use the first and last bytes because they are masked in curve25519. Selected 8 for good alignment.
    const uint8_t bucket_idx = public_key[8];
    Shared_Key* bucket_start = &cache->keys[bucket_idx*cache->keys_per_slot];

    const uint8_t* found = nullptr;

    // Perform lookup
    for(size_t i = 0; i < cache->keys_per_slot; ++i) {
        if (shared_key_is_empty(&bucket_start[i])) {
            continue;
        }

        if (pk_equal(public_key, bucket_start[i].public_key)) {
            found = bucket_start[i].shared_key;
            bucket_start[i].time_last_requested = cur_time;
            break;
        }
    }

    // Perform housekeeping for this bucket
    for (size_t i = 0; i < cache->keys_per_slot; ++i) {
        if (shared_key_is_empty(&bucket_start[i])) {
            continue;
        }

        const bool timed_out = (bucket_start[i].time_last_requested + cache->timeout) < cur_time;
        if (timed_out) {
            shared_key_set_empty(&bucket_start[i]);
        }
    }

    if (found == nullptr) {
        // Insert into cache

        uint64_t oldest_timestamp = UINT64_MAX;
        size_t oldest_index = 0;

        /*
         *  Find least recently used entry, unused entries are prioritised,
         *  because their time_last_requested field is zeroed.
         */
        for (size_t i = 0; i < cache->keys_per_slot; ++i) {
            if (bucket_start[i].time_last_requested < oldest_timestamp) {
                oldest_timestamp = bucket_start[i].time_last_requested;
                oldest_index = i;
            }
        }

        // Compute the shared key for the cache
        if (encrypt_precompute(public_key, cache->self_secret_key, bucket_start[oldest_index].shared_key) != 0) {
            // Don't put anything in the cache on error
            return nullptr;
        }

        // update cache entry
        memcpy(bucket_start[oldest_index].public_key, public_key, CRYPTO_PUBLIC_KEY_SIZE);
        bucket_start[oldest_index].time_last_requested = cur_time;
        found = bucket_start[oldest_index].shared_key;
    }

    return found;
}
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2020 The TokTok team.
 * Copyright © 2014 Tox project.
 */

#include <string.h>


/** state load/save */
int state_load(const Logger *log, state_load_cb *state_load_callback, void *outer,
               const uint8_t *data, uint32_t length, uint16_t cookie_inner)
{
    if (state_load_callback == nullptr || data == nullptr) {
        LOGGER_ERROR(log, "state_load() called with invalid args.");
        return -1;
    }


    const uint32_t size_head = sizeof(uint32_t) * 2;

    while (length >= size_head) {
        uint32_t length_sub;
        lendian_bytes_to_host32(&length_sub, data);

        uint32_t cookie_type;
        lendian_bytes_to_host32(&cookie_type, data + sizeof(uint32_t));

        data += size_head;
        length -= size_head;

        if (length < length_sub) {
            /* file truncated */
            LOGGER_ERROR(log, "state file too short: %u < %u", length, length_sub);
            return -1;
        }

        if (lendian_to_host16(cookie_type >> 16) != cookie_inner) {
            /* something is not matching up in a bad way, give up */
            LOGGER_ERROR(log, "state file garbled: %04x != %04x", cookie_type >> 16, cookie_inner);
            return -1;
        }

        const uint16_t type = lendian_to_host16(cookie_type & 0xFFFF);

        switch (state_load_callback(outer, data, length_sub, type)) {
            case STATE_LOAD_STATUS_CONTINUE: {
                data += length_sub;
                length -= length_sub;
                break;
            }

            case STATE_LOAD_STATUS_ERROR: {
                LOGGER_ERROR(log, "Error occcured in state file (type: 0x%02x).", type);
                return -1;
            }

            case STATE_LOAD_STATUS_END: {
                return 0;
            }
        }
    }

    if (length != 0) {
        LOGGER_ERROR(log, "unparsed data in state file of length %u", length);
        return -1;
    }

    return 0;
}

uint8_t *state_write_section_header(uint8_t *data, uint16_t cookie_type, uint32_t len, uint32_t section_type)
{
    host_to_lendian_bytes32(data, len);
    data += sizeof(uint32_t);
    host_to_lendian_bytes32(data, (host_to_lendian16(cookie_type) << 16) | host_to_lendian16(section_type));
    data += sizeof(uint32_t);
    return data;
}

uint16_t lendian_to_host16(uint16_t lendian)
{
#ifdef WORDS_BIGENDIAN
    return (lendian << 8) | (lendian >> 8);
#else
    return lendian;
#endif
}

uint16_t host_to_lendian16(uint16_t host)
{
    return lendian_to_host16(host);
}

void host_to_lendian_bytes64(uint8_t *dest, uint64_t num)
{
#ifdef WORDS_BIGENDIAN
    num = ((num << 8) & 0xFF00FF00FF00FF00) | ((num >> 8) & 0xFF00FF00FF00FF);
    num = ((num << 16) & 0xFFFF0000FFFF0000) | ((num >> 16) & 0xFFFF0000FFFF);
    num = (num << 32) | (num >> 32);
#endif
    memcpy(dest, &num, sizeof(uint64_t));
}

void lendian_bytes_to_host64(uint64_t *dest, const uint8_t *lendian)
{
    uint64_t d;
    memcpy(&d, lendian, sizeof(uint64_t));
#ifdef WORDS_BIGENDIAN
    d = ((d << 8) & 0xFF00FF00FF00FF00) | ((d >> 8) & 0xFF00FF00FF00FF);
    d = ((d << 16) & 0xFFFF0000FFFF0000) | ((d >> 16) & 0xFFFF0000FFFF);
    d = (d << 32) | (d >> 32);
#endif
    *dest = d;
}

void host_to_lendian_bytes32(uint8_t *dest, uint32_t num)
{
#ifdef WORDS_BIGENDIAN
    num = ((num << 8) & 0xFF00FF00) | ((num >> 8) & 0xFF00FF);
    num = (num << 16) | (num >> 16);
#endif
    memcpy(dest, &num, sizeof(uint32_t));
}

void lendian_bytes_to_host32(uint32_t *dest, const uint8_t *lendian)
{
    uint32_t d;
    memcpy(&d, lendian, sizeof(uint32_t));
#ifdef WORDS_BIGENDIAN
    d = ((d << 8) & 0xFF00FF00) | ((d >> 8) & 0xFF00FF);
    d = (d << 16) | (d >> 16);
#endif
    *dest = d;
}

void host_to_lendian_bytes16(uint8_t *dest, uint16_t num)
{
#ifdef WORDS_BIGENDIAN
    num = (num << 8) | (num >> 8);
#endif
    memcpy(dest, &num, sizeof(uint16_t));
}

void lendian_bytes_to_host16(uint16_t *dest, const uint8_t *lendian)
{
    uint16_t d;
    memcpy(&d, lendian, sizeof(uint16_t));
#ifdef WORDS_BIGENDIAN
    d = (d << 8) | (d >> 8);
#endif
    *dest = d;
}
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2018 The TokTok team.
 * Copyright © 2014 Tox project.
 */

/**
 * Implementation of the TCP relay client part of Tox.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>


typedef struct TCP_Client_Conn {
    // TODO(iphydf): Add an enum for this.
    uint8_t status; /* 0 if not used, 1 if other is offline, 2 if other is online. */
    uint8_t public_key[CRYPTO_PUBLIC_KEY_SIZE];
    uint32_t number;
} TCP_Client_Conn;

struct TCP_Client_Connection {
    TCP_Connection con;
    TCP_Client_Status status;
    uint8_t self_public_key[CRYPTO_PUBLIC_KEY_SIZE]; /* our public key */
    uint8_t public_key[CRYPTO_PUBLIC_KEY_SIZE]; /* public key of the server */
    IP_Port ip_port; /* The ip and port of the server */
    TCP_Proxy_Info proxy_info;
    uint8_t recv_nonce[CRYPTO_NONCE_SIZE]; /* Nonce of received packets. */
    uint16_t next_packet_length;

    uint8_t temp_secret_key[CRYPTO_SECRET_KEY_SIZE];

    uint64_t kill_at;

    uint64_t last_pinged;
    uint64_t ping_id;

    uint64_t ping_response_id;
    uint64_t ping_request_id;

    TCP_Client_Conn connections[NUM_CLIENT_CONNECTIONS];
    tcp_routing_response_cb *response_callback;
    void *response_callback_object;
    tcp_routing_status_cb *status_callback;
    void *status_callback_object;
    tcp_routing_data_cb *data_callback;
    void *data_callback_object;
    tcp_oob_data_cb *oob_data_callback;
    void *oob_data_callback_object;

    tcp_onion_response_cb *onion_callback;
    void *onion_callback_object;

    forwarded_response_cb *forwarded_response_callback;
    void *forwarded_response_callback_object;

    /* Can be used by user. */
    void *custom_object;
    uint32_t custom_uint;
};

const uint8_t *tcp_con_public_key(const TCP_Client_Connection *con)
{
    return con->public_key;
}

IP_Port tcp_con_ip_port(const TCP_Client_Connection *con)
{
    return con->ip_port;
}

TCP_Client_Status tcp_con_status(const TCP_Client_Connection *con)
{
    return con->status;
}
void *tcp_con_custom_object(const TCP_Client_Connection *con)
{
    return con->custom_object;
}
uint32_t tcp_con_custom_uint(const TCP_Client_Connection *con)
{
    return con->custom_uint;
}
void tcp_con_set_custom_object(TCP_Client_Connection *con, void *object)
{
    con->custom_object = object;
}
void tcp_con_set_custom_uint(TCP_Client_Connection *con, uint32_t value)
{
    con->custom_uint = value;
}

/**
 * @retval true on success
 * @retval false on failure
 */
non_null()
static bool connect_sock_to(const Logger *logger, Socket sock, const IP_Port *ip_port, const TCP_Proxy_Info *proxy_info)
{
    if (proxy_info->proxy_type != TCP_PROXY_NONE) {
        return net_connect(logger, sock, &proxy_info->ip_port);
    } else {
        return net_connect(logger, sock, ip_port);
    }
}

/**
 * @retval 1 on success.
 * @retval 0 on failure.
 */
non_null()
static int proxy_http_generate_connection_request(TCP_Client_Connection *tcp_conn)
{
    char one[] = "CONNECT ";
    char two[] = " HTTP/1.1\nHost: ";
    char three[] = "\r\n\r\n";

    char ip[TOX_INET6_ADDRSTRLEN];

    if (!ip_parse_addr(&tcp_conn->ip_port.ip, ip, sizeof(ip))) {
        return 0;
    }

    const uint16_t port = net_ntohs(tcp_conn->ip_port.port);
    const int written = snprintf((char *)tcp_conn->con.last_packet, MAX_PACKET_SIZE, "%s%s:%hu%s%s:%hu%s", one, ip, port,
                                 two, ip, port, three);

    if (written < 0 || MAX_PACKET_SIZE < written) {
        return 0;
    }

    tcp_conn->con.last_packet_length = written;
    tcp_conn->con.last_packet_sent = 0;
    return 1;
}

/**
 * @retval 1 on success.
 * @retval 0 if no data received.
 * @retval -1 on failure (connection refused).
 */
non_null()
static int proxy_http_read_connection_response(const Logger *logger, const TCP_Client_Connection *tcp_conn)
{
    char success[] = "200";
    uint8_t data[16]; // draining works the best if the length is a power of 2

    const int ret = read_TCP_packet(logger, tcp_conn->con.ns, tcp_conn->con.sock, data, sizeof(data) - 1,
                                    &tcp_conn->con.ip_port);

    if (ret == -1) {
        return 0;
    }

    data[sizeof(data) - 1] = 0;

    if (strstr((const char *)data, success) != nullptr) {
        // drain all data
        uint16_t data_left = net_socket_data_recv_buffer(tcp_conn->con.ns, tcp_conn->con.sock);

        while (data_left > 0) {
            uint8_t temp_data[16];
            const uint16_t temp_data_size = min_u16(data_left, sizeof(temp_data));

            if (read_TCP_packet(logger, tcp_conn->con.ns, tcp_conn->con.sock, temp_data, temp_data_size,
                                &tcp_conn->con.ip_port) == -1) {
                LOGGER_ERROR(logger, "failed to drain TCP data (but ignoring failure)");
                return 1;
            }

            data_left -= temp_data_size;
        }

        return 1;
    }

    return -1;
}

#define TCP_SOCKS5_PROXY_HS_VERSION_SOCKS5 0x05
#define TCP_SOCKS5_PROXY_HS_COMM_ESTABLISH_REQUEST 0x01
#define TCP_SOCKS5_PROXY_HS_COMM_REQUEST_GRANTED 0x00
#define TCP_SOCKS5_PROXY_HS_AUTH_METHODS_SUPPORTED 0x01
#define TCP_SOCKS5_PROXY_HS_NO_AUTH 0x00
#define TCP_SOCKS5_PROXY_HS_RESERVED 0x00
#define TCP_SOCKS5_PROXY_HS_ADDR_TYPE_IPV4 0x01
#define TCP_SOCKS5_PROXY_HS_ADDR_TYPE_IPV6 0x04

non_null()
static void proxy_socks5_generate_greetings(TCP_Client_Connection *tcp_conn)
{
    tcp_conn->con.last_packet[0] = TCP_SOCKS5_PROXY_HS_VERSION_SOCKS5;
    tcp_conn->con.last_packet[1] = TCP_SOCKS5_PROXY_HS_AUTH_METHODS_SUPPORTED;
    tcp_conn->con.last_packet[2] = TCP_SOCKS5_PROXY_HS_NO_AUTH;

    tcp_conn->con.last_packet_length = 3;
    tcp_conn->con.last_packet_sent = 0;
}

/**
 * @retval 1 on success.
 * @retval 0 if no data received.
 * @retval -1 on failure (connection refused).
 */
non_null()
static int socks5_read_handshake_response(const Logger *logger, const TCP_Client_Connection *tcp_conn)
{
    uint8_t data[2];
    const int ret = read_TCP_packet(logger, tcp_conn->con.ns, tcp_conn->con.sock, data, sizeof(data), &tcp_conn->con.ip_port);

    if (ret == -1) {
        return 0;
    }

    if (data[0] == TCP_SOCKS5_PROXY_HS_VERSION_SOCKS5 && data[1] == TCP_SOCKS5_PROXY_HS_COMM_REQUEST_GRANTED) {
        return 1;
    }

    return -1;
}

non_null()
static void proxy_socks5_generate_connection_request(TCP_Client_Connection *tcp_conn)
{
    tcp_conn->con.last_packet[0] = TCP_SOCKS5_PROXY_HS_VERSION_SOCKS5;
    tcp_conn->con.last_packet[1] = TCP_SOCKS5_PROXY_HS_COMM_ESTABLISH_REQUEST;
    tcp_conn->con.last_packet[2] = TCP_SOCKS5_PROXY_HS_RESERVED;
    uint16_t length = 3;

    if (net_family_is_ipv4(tcp_conn->ip_port.ip.family)) {
        tcp_conn->con.last_packet[3] = TCP_SOCKS5_PROXY_HS_ADDR_TYPE_IPV4;
        ++length;
        memcpy(tcp_conn->con.last_packet + length, tcp_conn->ip_port.ip.ip.v4.uint8, sizeof(IP4));
        length += sizeof(IP4);
    } else {
        tcp_conn->con.last_packet[3] = TCP_SOCKS5_PROXY_HS_ADDR_TYPE_IPV6;
        ++length;
        memcpy(tcp_conn->con.last_packet + length, tcp_conn->ip_port.ip.ip.v6.uint8, sizeof(IP6));
        length += sizeof(IP6);
    }

    memcpy(tcp_conn->con.last_packet + length, &tcp_conn->ip_port.port, sizeof(uint16_t));
    length += sizeof(uint16_t);

    tcp_conn->con.last_packet_length = length;
    tcp_conn->con.last_packet_sent = 0;
}

/**
 * @retval 1 on success.
 * @retval 0 if no data received.
 * @retval -1 on failure (connection refused).
 */
non_null()
static int proxy_socks5_read_connection_response(const Logger *logger, const TCP_Client_Connection *tcp_conn)
{
    if (net_family_is_ipv4(tcp_conn->ip_port.ip.family)) {
        uint8_t data[4 + sizeof(IP4) + sizeof(uint16_t)];
        const int ret = read_TCP_packet(logger, tcp_conn->con.ns, tcp_conn->con.sock, data, sizeof(data), &tcp_conn->con.ip_port);

        if (ret == -1) {
            return 0;
        }

        if (data[0] == TCP_SOCKS5_PROXY_HS_VERSION_SOCKS5 && data[1] == TCP_SOCKS5_PROXY_HS_COMM_REQUEST_GRANTED) {
            return 1;
        }
    } else {
        uint8_t data[4 + sizeof(IP6) + sizeof(uint16_t)];
        int ret = read_TCP_packet(logger, tcp_conn->con.ns, tcp_conn->con.sock, data, sizeof(data), &tcp_conn->con.ip_port);

        if (ret == -1) {
            return 0;
        }

        if (data[0] == TCP_SOCKS5_PROXY_HS_VERSION_SOCKS5 && data[1] == TCP_SOCKS5_PROXY_HS_COMM_REQUEST_GRANTED) {
            return 1;
        }
    }

    return -1;
}

/**
 * @retval 0 on success.
 * @retval -1 on failure.
 */
non_null()
static int generate_handshake(TCP_Client_Connection *tcp_conn)
{
    uint8_t plain[CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE];
    crypto_new_keypair(tcp_conn->con.rng, plain, tcp_conn->temp_secret_key);
    random_nonce(tcp_conn->con.rng, tcp_conn->con.sent_nonce);
    memcpy(plain + CRYPTO_PUBLIC_KEY_SIZE, tcp_conn->con.sent_nonce, CRYPTO_NONCE_SIZE);
    memcpy(tcp_conn->con.last_packet, tcp_conn->self_public_key, CRYPTO_PUBLIC_KEY_SIZE);
    random_nonce(tcp_conn->con.rng, tcp_conn->con.last_packet + CRYPTO_PUBLIC_KEY_SIZE);
    const int len = encrypt_data_symmetric(tcp_conn->con.shared_key, tcp_conn->con.last_packet + CRYPTO_PUBLIC_KEY_SIZE, plain,
                                     sizeof(plain), tcp_conn->con.last_packet + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE);

    if (len != sizeof(plain) + CRYPTO_MAC_SIZE) {
        return -1;
    }

    tcp_conn->con.last_packet_length = CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE + sizeof(plain) + CRYPTO_MAC_SIZE;
    tcp_conn->con.last_packet_sent = 0;
    return 0;
}

/**
 * @param data must be of length TCP_SERVER_HANDSHAKE_SIZE
 *
 * @retval 0 on success.
 * @retval -1 on failure.
 */
non_null()
static int handle_handshake(TCP_Client_Connection *tcp_conn, const uint8_t *data)
{
    uint8_t plain[CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE];
    const int len = decrypt_data_symmetric(tcp_conn->con.shared_key, data, data + CRYPTO_NONCE_SIZE,
                                     TCP_SERVER_HANDSHAKE_SIZE - CRYPTO_NONCE_SIZE, plain);

    if (len != sizeof(plain)) {
        return -1;
    }

    memcpy(tcp_conn->recv_nonce, plain + CRYPTO_PUBLIC_KEY_SIZE, CRYPTO_NONCE_SIZE);
    encrypt_precompute(plain, tcp_conn->temp_secret_key, tcp_conn->con.shared_key);
    crypto_memzero(tcp_conn->temp_secret_key, CRYPTO_SECRET_KEY_SIZE);
    return 0;
}

/**
 * @retval 1 on success.
 * @retval 0 if could not send packet.
 * @retval -1 on failure (connection must be killed).
 */
int send_routing_request(const Logger *logger, TCP_Client_Connection *con, const uint8_t *public_key)
{
    uint8_t packet[1 + CRYPTO_PUBLIC_KEY_SIZE];
    packet[0] = TCP_PACKET_ROUTING_REQUEST;
    memcpy(packet + 1, public_key, CRYPTO_PUBLIC_KEY_SIZE);
    return write_packet_TCP_secure_connection(logger, &con->con, packet, sizeof(packet), true);
}

void routing_response_handler(TCP_Client_Connection *con, tcp_routing_response_cb *response_callback, void *object)
{
    con->response_callback = response_callback;
    con->response_callback_object = object;
}

void routing_status_handler(TCP_Client_Connection *con, tcp_routing_status_cb *status_callback, void *object)
{
    con->status_callback = status_callback;
    con->status_callback_object = object;
}

non_null() static int tcp_send_ping_response(const Logger *logger, TCP_Client_Connection *con);
non_null() static int tcp_send_ping_request(const Logger *logger, TCP_Client_Connection *con);

/**
 * @retval 1 on success.
 * @retval 0 if could not send packet.
 * @retval -1 on failure.
 */
int send_data(const Logger *logger, TCP_Client_Connection *con, uint8_t con_id, const uint8_t *data, uint16_t length)
{
    if (con_id >= NUM_CLIENT_CONNECTIONS) {
        return -1;
    }

    if (con->connections[con_id].status != 2) {
        return -1;
    }

    if (tcp_send_ping_response(logger, con) == 0 || tcp_send_ping_request(logger, con) == 0) {
        return 0;
    }

    VLA(uint8_t, packet, 1 + length);
    packet[0] = con_id + NUM_RESERVED_PORTS;
    memcpy(packet + 1, data, length);
    return write_packet_TCP_secure_connection(logger, &con->con, packet, SIZEOF_VLA(packet), false);
}

/**
 * @retval 1 on success.
 * @retval 0 if could not send packet.
 * @retval -1 on failure.
 */
int send_oob_packet(const Logger *logger, TCP_Client_Connection *con, const uint8_t *public_key, const uint8_t *data,
                    uint16_t length)
{
    if (length == 0 || length > TCP_MAX_OOB_DATA_LENGTH) {
        return -1;
    }

    VLA(uint8_t, packet, 1 + CRYPTO_PUBLIC_KEY_SIZE + length);
    packet[0] = TCP_PACKET_OOB_SEND;
    memcpy(packet + 1, public_key, CRYPTO_PUBLIC_KEY_SIZE);
    memcpy(packet + 1 + CRYPTO_PUBLIC_KEY_SIZE, data, length);
    return write_packet_TCP_secure_connection(logger, &con->con, packet, SIZEOF_VLA(packet), false);
}


/** @brief Set the number that will be used as an argument in the callbacks related to con_id.
 *
 * When not set by this function, the number is -1.
 *
 * return 0 on success.
 * return -1 on failure.
 */
int set_tcp_connection_number(TCP_Client_Connection *con, uint8_t con_id, uint32_t number)
{
    if (con_id >= NUM_CLIENT_CONNECTIONS) {
        return -1;
    }

    if (con->connections[con_id].status == 0) {
        return -1;
    }

    con->connections[con_id].number = number;
    return 0;
}

void routing_data_handler(TCP_Client_Connection *con, tcp_routing_data_cb *data_callback, void *object)
{
    con->data_callback = data_callback;
    con->data_callback_object = object;
}

void oob_data_handler(TCP_Client_Connection *con, tcp_oob_data_cb *oob_data_callback, void *object)
{
    con->oob_data_callback = oob_data_callback;
    con->oob_data_callback_object = object;
}

/**
 * @retval 1 on success.
 * @retval 0 if could not send packet.
 * @retval -1 on failure (connection must be killed).
 */
non_null()
static int client_send_disconnect_notification(const Logger *logger, TCP_Client_Connection *con, uint8_t id)
{
    uint8_t packet[1 + 1];
    packet[0] = TCP_PACKET_DISCONNECT_NOTIFICATION;
    packet[1] = id;
    return write_packet_TCP_secure_connection(logger, &con->con, packet, sizeof(packet), true);
}

/**
 * @retval 1 on success.
 * @retval 0 if could not send packet.
 * @retval -1 on failure (connection must be killed).
 */
static int tcp_send_ping_request(const Logger *logger, TCP_Client_Connection *con)
{
    if (con->ping_request_id == 0) {
        return 1;
    }

    uint8_t packet[1 + sizeof(uint64_t)];
    packet[0] = TCP_PACKET_PING;
    memcpy(packet + 1, &con->ping_request_id, sizeof(uint64_t));
    const int ret = write_packet_TCP_secure_connection(logger, &con->con, packet, sizeof(packet), true);

    if (ret == 1) {
        con->ping_request_id = 0;
    }

    return ret;
}

/**
 * @retval 1 on success.
 * @retval 0 if could not send packet.
 * @retval -1 on failure (connection must be killed).
 */
static int tcp_send_ping_response(const Logger *logger, TCP_Client_Connection *con)
{
    if (con->ping_response_id == 0) {
        return 1;
    }

    uint8_t packet[1 + sizeof(uint64_t)];
    packet[0] = TCP_PACKET_PONG;
    memcpy(packet + 1, &con->ping_response_id, sizeof(uint64_t));
    const int ret = write_packet_TCP_secure_connection(logger, &con->con, packet, sizeof(packet), true);

    if (ret == 1) {
        con->ping_response_id = 0;
    }

    return ret;
}

/**
 * @retval 1 on success.
 * @retval 0 if could not send packet.
 * @retval -1 on failure (connection must be killed).
 */
int send_disconnect_request(const Logger *logger, TCP_Client_Connection *con, uint8_t con_id)
{
    if (con_id >= NUM_CLIENT_CONNECTIONS) {
        return -1;
    }

    con->connections[con_id].status = 0;
    con->connections[con_id].number = 0;
    return client_send_disconnect_notification(logger, con, con_id + NUM_RESERVED_PORTS);
}

/**
 * @retval 1 on success.
 * @retval 0 if could not send packet.
 * @retval -1 on failure (connection must be killed).
 */
int send_onion_request(const Logger *logger, TCP_Client_Connection *con, const uint8_t *data, uint16_t length)
{
    VLA(uint8_t, packet, 1 + length);
    packet[0] = TCP_PACKET_ONION_REQUEST;
    memcpy(packet + 1, data, length);
    return write_packet_TCP_secure_connection(logger, &con->con, packet, SIZEOF_VLA(packet), false);
}

void onion_response_handler(TCP_Client_Connection *con, tcp_onion_response_cb *onion_callback, void *object)
{
    con->onion_callback = onion_callback;
    con->onion_callback_object = object;
}

/** @retval 1 on success.
 * @retval 0 if could not send packet.
 * @retval -1 on failure (connection must be killed).
 */
int send_forward_request_tcp(const Logger *logger, TCP_Client_Connection *con, const IP_Port *dest, const uint8_t *data, uint16_t length)
{
    if (length > MAX_FORWARD_DATA_SIZE) {
        return -1;
    }

    VLA(uint8_t, packet, 1 + MAX_PACKED_IPPORT_SIZE + length);
    packet[0] = TCP_PACKET_FORWARD_REQUEST;
    const int ipport_length = pack_ip_port(logger, packet + 1, MAX_PACKED_IPPORT_SIZE, dest);

    if (ipport_length == -1) {
        return 0;
    }

    memcpy(packet + 1 + ipport_length, data, length);
    return write_packet_TCP_secure_connection(logger, &con->con, packet, 1 + ipport_length + length, false);
}

void forwarding_handler(TCP_Client_Connection *con, forwarded_response_cb *forwarded_response_callback, void *object)
{
    con->forwarded_response_callback = forwarded_response_callback;
    con->forwarded_response_callback_object = object;
}

/** Create new TCP connection to ip_port/public_key */
TCP_Client_Connection *new_TCP_connection(
        const Logger *logger, const Mono_Time *mono_time, const Random *rng, const Network *ns, const IP_Port *ip_port,
        const uint8_t *public_key, const uint8_t *self_public_key, const uint8_t *self_secret_key,
        const TCP_Proxy_Info *proxy_info)
{
    if (!net_family_is_ipv4(ip_port->ip.family) && !net_family_is_ipv6(ip_port->ip.family)) {
        return nullptr;
    }

    const TCP_Proxy_Info default_proxyinfo = {{{{0}}}};

    if (proxy_info == nullptr) {
        proxy_info = &default_proxyinfo;
    }

    Family family = ip_port->ip.family;

    if (proxy_info->proxy_type != TCP_PROXY_NONE) {
        family = proxy_info->ip_port.ip.family;
    }

    const Socket sock = net_socket(ns, family, TOX_SOCK_STREAM, TOX_PROTO_TCP);

    if (!sock_valid(sock)) {
        return nullptr;
    }

    if (!set_socket_nosigpipe(ns, sock)) {
        kill_sock(ns, sock);
        return nullptr;
    }

    if (!(set_socket_nonblock(ns, sock) && connect_sock_to(logger, sock, ip_port, proxy_info))) {
        kill_sock(ns, sock);
        return nullptr;
    }

    TCP_Client_Connection *temp = (TCP_Client_Connection *)calloc(1, sizeof(TCP_Client_Connection));

    if (temp == nullptr) {
        kill_sock(ns, sock);
        return nullptr;
    }

    temp->con.ns = ns;
    temp->con.rng = rng;
    temp->con.sock = sock;
    temp->con.ip_port = *ip_port;
    memcpy(temp->public_key, public_key, CRYPTO_PUBLIC_KEY_SIZE);
    memcpy(temp->self_public_key, self_public_key, CRYPTO_PUBLIC_KEY_SIZE);
    encrypt_precompute(temp->public_key, self_secret_key, temp->con.shared_key);
    temp->ip_port = *ip_port;
    temp->proxy_info = *proxy_info;

    switch (proxy_info->proxy_type) {
        case TCP_PROXY_HTTP: {
            temp->status = TCP_CLIENT_PROXY_HTTP_CONNECTING;
            proxy_http_generate_connection_request(temp);
            break;
        }

        case TCP_PROXY_SOCKS5: {
            temp->status = TCP_CLIENT_PROXY_SOCKS5_CONNECTING;
            proxy_socks5_generate_greetings(temp);
            break;
        }

        case TCP_PROXY_NONE: {
            temp->status = TCP_CLIENT_CONNECTING;

            if (generate_handshake(temp) == -1) {
                kill_sock(ns, sock);
                free(temp);
                return nullptr;
            }

            break;
        }
    }

    temp->kill_at = mono_time_get(mono_time) + TCP_CONNECTION_TIMEOUT;

    return temp;
}

non_null()
static int handle_TCP_client_routing_response(TCP_Client_Connection *conn, const uint8_t *data, uint16_t length)
{
    if (length != 1 + 1 + CRYPTO_PUBLIC_KEY_SIZE) {
        return -1;
    }

    if (data[1] < NUM_RESERVED_PORTS) {
        return 0;
    }

    const uint8_t con_id = data[1] - NUM_RESERVED_PORTS;

    if (conn->connections[con_id].status != 0) {
        return 0;
    }

    conn->connections[con_id].status = 1;
    conn->connections[con_id].number = -1;
    memcpy(conn->connections[con_id].public_key, data + 2, CRYPTO_PUBLIC_KEY_SIZE);

    if (conn->response_callback != nullptr) {
        conn->response_callback(conn->response_callback_object, con_id, conn->connections[con_id].public_key);
    }

    return 0;
}

non_null()
static int handle_TCP_client_connection_notification(TCP_Client_Connection *conn, const uint8_t *data, uint16_t length)
{
    if (length != 1 + 1) {
        return -1;
    }

    if (data[1] < NUM_RESERVED_PORTS) {
        return -1;
    }

    const uint8_t con_id = data[1] - NUM_RESERVED_PORTS;

    if (conn->connections[con_id].status != 1) {
        return 0;
    }

    conn->connections[con_id].status = 2;

    if (conn->status_callback != nullptr) {
        conn->status_callback(conn->status_callback_object, conn->connections[con_id].number, con_id,
                              conn->connections[con_id].status);
    }

    return 0;
}

non_null()
static int handle_TCP_client_disconnect_notification(TCP_Client_Connection *conn, const uint8_t *data, uint16_t length)
{
    if (length != 1 + 1) {
        return -1;
    }

    if (data[1] < NUM_RESERVED_PORTS) {
        return -1;
    }

    const uint8_t con_id = data[1] - NUM_RESERVED_PORTS;

    if (conn->connections[con_id].status == 0) {
        return 0;
    }

    if (conn->connections[con_id].status != 2) {
        return 0;
    }

    conn->connections[con_id].status = 1;

    if (conn->status_callback != nullptr) {
        conn->status_callback(conn->status_callback_object, conn->connections[con_id].number, con_id,
                              conn->connections[con_id].status);
    }

    return 0;
}

non_null()
static int handle_TCP_client_ping(const Logger *logger, TCP_Client_Connection *conn, const uint8_t *data, uint16_t length)
{
    if (length != 1 + sizeof(uint64_t)) {
        return -1;
    }

    uint64_t ping_id;
    memcpy(&ping_id, data + 1, sizeof(uint64_t));
    conn->ping_response_id = ping_id;
    tcp_send_ping_response(logger, conn);
    return 0;
}

non_null()
static int handle_TCP_client_pong(TCP_Client_Connection *conn, const uint8_t *data, uint16_t length)
{
    if (length != 1 + sizeof(uint64_t)) {
        return -1;
    }

    uint64_t ping_id;
    memcpy(&ping_id, data + 1, sizeof(uint64_t));

    if (ping_id != 0) {
        if (ping_id == conn->ping_id) {
            conn->ping_id = 0;
        }

        return 0;
    }

    return -1;
}

non_null(1, 2) nullable(4)
static int handle_TCP_client_oob_recv(TCP_Client_Connection *conn, const uint8_t *data, uint16_t length, void *userdata)
{
    if (length <= 1 + CRYPTO_PUBLIC_KEY_SIZE) {
        return -1;
    }

    if (conn->oob_data_callback != nullptr) {
        conn->oob_data_callback(conn->oob_data_callback_object, data + 1, data + 1 + CRYPTO_PUBLIC_KEY_SIZE,
                                length - (1 + CRYPTO_PUBLIC_KEY_SIZE), userdata);
    }

    return 0;
}

/**
 * @retval 0 on success
 * @retval -1 on failure
 */
non_null(1, 2, 3) nullable(5)
static int handle_TCP_client_packet(const Logger *logger, TCP_Client_Connection *conn, const uint8_t *data,
                                    uint16_t length, void *userdata)
{
    if (length <= 1) {
        return -1;
    }

    switch (data[0]) {
        case TCP_PACKET_ROUTING_RESPONSE:
            return handle_TCP_client_routing_response(conn, data, length);

        case TCP_PACKET_CONNECTION_NOTIFICATION:
            return handle_TCP_client_connection_notification(conn, data, length);

        case TCP_PACKET_DISCONNECT_NOTIFICATION:
            return handle_TCP_client_disconnect_notification(conn, data, length);

        case TCP_PACKET_PING:
            return handle_TCP_client_ping(logger, conn, data, length);

        case TCP_PACKET_PONG:
            return handle_TCP_client_pong(conn, data, length);

        case TCP_PACKET_OOB_RECV:
            return handle_TCP_client_oob_recv(conn, data, length, userdata);

        case TCP_PACKET_ONION_RESPONSE: {
            if (conn->onion_callback != nullptr) {
                conn->onion_callback(conn->onion_callback_object, data + 1, length - 1, userdata);
            }
            return 0;
        }

        case TCP_PACKET_FORWARDING: {
            if (conn->forwarded_response_callback != nullptr) {
                conn->forwarded_response_callback(conn->forwarded_response_callback_object, data + 1, length - 1, userdata);
            }
            return 0;
        }

        default: {
            if (data[0] < NUM_RESERVED_PORTS) {
                return -1;
            }

            const uint8_t con_id = data[0] - NUM_RESERVED_PORTS;

            if (conn->data_callback != nullptr) {
                conn->data_callback(conn->data_callback_object, conn->connections[con_id].number, con_id, data + 1, length - 1,
                                    userdata);
            }
        }
    }

    return 0;
}

non_null(1, 2) nullable(3)
static bool tcp_process_packet(const Logger *logger, TCP_Client_Connection *conn, void *userdata)
{
    uint8_t packet[MAX_PACKET_SIZE];
    const int len = read_packet_TCP_secure_connection(logger, conn->con.ns, conn->con.sock, &conn->next_packet_length, conn->con.shared_key, conn->recv_nonce, packet, sizeof(packet), &conn->ip_port);

    if (len == 0) {
        return false;
    }

    if (len == -1) {
        conn->status = TCP_CLIENT_DISCONNECTED;
        return false;
    }

    if (handle_TCP_client_packet(logger, conn, packet, len, userdata) == -1) {
        conn->status = TCP_CLIENT_DISCONNECTED;
        return false;
    }

    return true;
}

non_null(1, 2, 3) nullable(4)
static int do_confirmed_TCP(const Logger *logger, TCP_Client_Connection *conn, const Mono_Time *mono_time,
                            void *userdata)
{
    send_pending_data(logger, &conn->con);
    tcp_send_ping_response(logger, conn);
    tcp_send_ping_request(logger, conn);

    if (mono_time_is_timeout(mono_time, conn->last_pinged, TCP_PING_FREQUENCY)) {
        uint64_t ping_id = random_u64(conn->con.rng);

        if (ping_id == 0) {
            ++ping_id;
        }

        conn->ping_request_id = ping_id;
        conn->ping_id = ping_id;
        tcp_send_ping_request(logger, conn);
        conn->last_pinged = mono_time_get(mono_time);
    }

    if (conn->ping_id != 0 && mono_time_is_timeout(mono_time, conn->last_pinged, TCP_PING_TIMEOUT)) {
        conn->status = TCP_CLIENT_DISCONNECTED;
        return 0;
    }

    while (tcp_process_packet(logger, conn, userdata)) {
        // Keep reading until error or out of data.
        continue;
    }

    return 0;
}

/** Run the TCP connection */
void do_TCP_connection(const Logger *logger, const Mono_Time *mono_time,
                       TCP_Client_Connection *tcp_connection, void *userdata)
{
    if (tcp_connection->status == TCP_CLIENT_DISCONNECTED) {
        return;
    }

    if (tcp_connection->status == TCP_CLIENT_PROXY_HTTP_CONNECTING) {
        if (send_pending_data(logger, &tcp_connection->con) == 0) {
            const int ret = proxy_http_read_connection_response(logger, tcp_connection);

            if (ret == -1) {
                tcp_connection->kill_at = 0;
                tcp_connection->status = TCP_CLIENT_DISCONNECTED;
            }

            if (ret == 1) {
                generate_handshake(tcp_connection);
                tcp_connection->status = TCP_CLIENT_CONNECTING;
            }
        }
    }

    if (tcp_connection->status == TCP_CLIENT_PROXY_SOCKS5_CONNECTING) {
        if (send_pending_data(logger, &tcp_connection->con) == 0) {
            int ret = socks5_read_handshake_response(logger, tcp_connection);

            if (ret == -1) {
                tcp_connection->kill_at = 0;
                tcp_connection->status = TCP_CLIENT_DISCONNECTED;
            }

            if (ret == 1) {
                proxy_socks5_generate_connection_request(tcp_connection);
                tcp_connection->status = TCP_CLIENT_PROXY_SOCKS5_UNCONFIRMED;
            }
        }
    }

    if (tcp_connection->status == TCP_CLIENT_PROXY_SOCKS5_UNCONFIRMED) {
        if (send_pending_data(logger, &tcp_connection->con) == 0) {
            int ret = proxy_socks5_read_connection_response(logger, tcp_connection);

            if (ret == -1) {
                tcp_connection->kill_at = 0;
                tcp_connection->status = TCP_CLIENT_DISCONNECTED;
            }

            if (ret == 1) {
                generate_handshake(tcp_connection);
                tcp_connection->status = TCP_CLIENT_CONNECTING;
            }
        }
    }

    if (tcp_connection->status == TCP_CLIENT_CONNECTING) {
        if (send_pending_data(logger, &tcp_connection->con) == 0) {
            tcp_connection->status = TCP_CLIENT_UNCONFIRMED;
        }
    }

    if (tcp_connection->status == TCP_CLIENT_UNCONFIRMED) {
        uint8_t data[TCP_SERVER_HANDSHAKE_SIZE];
        const int len = read_TCP_packet(logger, tcp_connection->con.ns, tcp_connection->con.sock, data, sizeof(data), &tcp_connection->con.ip_port);

        if (sizeof(data) == len) {
            if (handle_handshake(tcp_connection, data) == 0) {
                tcp_connection->kill_at = UINT64_MAX;
                tcp_connection->status = TCP_CLIENT_CONFIRMED;
            } else {
                tcp_connection->kill_at = 0;
                tcp_connection->status = TCP_CLIENT_DISCONNECTED;
            }
        }
    }

    if (tcp_connection->status == TCP_CLIENT_CONFIRMED) {
        do_confirmed_TCP(logger, tcp_connection, mono_time, userdata);
    }

    if (tcp_connection->kill_at <= mono_time_get(mono_time)) {
        tcp_connection->status = TCP_CLIENT_DISCONNECTED;
    }
}

/** Kill the TCP connection */
void kill_TCP_connection(TCP_Client_Connection *tcp_connection)
{
    if (tcp_connection == nullptr) {
        return;
    }

    wipe_priority_list(tcp_connection->con.priority_queue_start);
    kill_sock(tcp_connection->con.ns, tcp_connection->con.sock);
    crypto_memzero(tcp_connection, sizeof(TCP_Client_Connection));
    free(tcp_connection);
}
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2018 The TokTok team.
 * Copyright © 2014 Tox project.
 */


#include <stdlib.h>
#include <string.h>


void wipe_priority_list(TCP_Priority_List *p)
{
    while (p != nullptr) {
        TCP_Priority_List *pp = p;
        p = p->next;
        free(pp->data);
        free(pp);
    }
}

/**
 * @retval 0 if pending data was sent completely
 * @retval -1 if it wasn't
 */
int send_pending_data_nonpriority(const Logger *logger, TCP_Connection *con)
{
    if (con->last_packet_length == 0) {
        return 0;
    }

    const uint16_t left = con->last_packet_length - con->last_packet_sent;
    const int len = net_send(con->ns, logger, con->sock, con->last_packet + con->last_packet_sent, left, &con->ip_port);

    if (len <= 0) {
        return -1;
    }

    if (len == left) {
        con->last_packet_length = 0;
        con->last_packet_sent = 0;
        return 0;
    }

    con->last_packet_sent += len;
    return -1;
}

/**
 * @retval 0 if pending data was sent completely
 * @retval -1 if it wasn't
 */
int send_pending_data(const Logger *logger, TCP_Connection *con)
{
    /* finish sending current non-priority packet */
    if (send_pending_data_nonpriority(logger, con) == -1) {
        return -1;
    }

    TCP_Priority_List *p = con->priority_queue_start;

    while (p != nullptr) {
        const uint16_t left = p->size - p->sent;
        const int len = net_send(con->ns, logger, con->sock, p->data + p->sent, left, &con->ip_port);

        if (len != left) {
            if (len > 0) {
                p->sent += len;
            }

            break;
        }

        TCP_Priority_List *pp = p;
        p = p->next;
        free(pp->data);
        free(pp);
    }

    con->priority_queue_start = p;

    if (p == nullptr) {
        con->priority_queue_end = nullptr;
        return 0;
    }

    return -1;
}

/**
 * @retval false on failure (only if calloc fails)
 * @retval true on success
 */
non_null()
static bool add_priority(TCP_Connection *con, const uint8_t *packet, uint16_t size, uint16_t sent)
{
    TCP_Priority_List *p = con->priority_queue_end;
    TCP_Priority_List *new_list = (TCP_Priority_List *)calloc(1, sizeof(TCP_Priority_List));

    if (new_list == nullptr) {
        return false;
    }

    new_list->next = nullptr;
    new_list->size = size;
    new_list->sent = sent;
    new_list->data = (uint8_t *)malloc(size);

    if (new_list->data == nullptr) {
        free(new_list);
        return false;
    }

    memcpy(new_list->data, packet, size);

    if (p != nullptr) {
        p->next = new_list;
    } else {
        con->priority_queue_start = new_list;
    }

    con->priority_queue_end = new_list;
    return true;
}

/**
 * @retval 1 on success.
 * @retval 0 if could not send packet.
 * @retval -1 on failure (connection must be killed).
 */
int write_packet_TCP_secure_connection(const Logger *logger, TCP_Connection *con, const uint8_t *data, uint16_t length,
                                       bool priority)
{
    if (length + CRYPTO_MAC_SIZE > MAX_PACKET_SIZE) {
        return -1;
    }

    bool sendpriority = true;

    if (send_pending_data(logger, con) == -1) {
        if (priority) {
            sendpriority = false;
        } else {
            return 0;
        }
    }

    VLA(uint8_t, packet, sizeof(uint16_t) + length + CRYPTO_MAC_SIZE);

    uint16_t c_length = net_htons(length + CRYPTO_MAC_SIZE);
    memcpy(packet, &c_length, sizeof(uint16_t));
    int len = encrypt_data_symmetric(con->shared_key, con->sent_nonce, data, length, packet + sizeof(uint16_t));

    if ((unsigned int)len != (SIZEOF_VLA(packet) - sizeof(uint16_t))) {
        return -1;
    }

    if (priority) {
        len = sendpriority ? net_send(con->ns, logger, con->sock, packet, SIZEOF_VLA(packet), &con->ip_port) : 0;

        if (len <= 0) {
            len = 0;
        }

        increment_nonce(con->sent_nonce);

        if ((unsigned int)len == SIZEOF_VLA(packet)) {
            return 1;
        }

        return add_priority(con, packet, SIZEOF_VLA(packet), len) ? 1 : 0;
    }

    len = net_send(con->ns, logger, con->sock, packet, SIZEOF_VLA(packet), &con->ip_port);

    if (len <= 0) {
        return 0;
    }

    increment_nonce(con->sent_nonce);

    if ((unsigned int)len == SIZEOF_VLA(packet)) {
        return 1;
    }

    memcpy(con->last_packet, packet, SIZEOF_VLA(packet));
    con->last_packet_length = SIZEOF_VLA(packet);
    con->last_packet_sent = len;
    return 1;
}

/** @brief Read length bytes from socket.
 *
 * return length on success
 * return -1 on failure/no data in buffer.
 */
int read_TCP_packet(const Logger *logger, const Network *ns, Socket sock, uint8_t *data, uint16_t length, const IP_Port *ip_port)
{
    const uint16_t count = net_socket_data_recv_buffer(ns, sock);

    if (count < length) {
        LOGGER_TRACE(logger, "recv buffer has %d bytes, but requested %d bytes", count, length);
        return -1;
    }

    const int len = net_recv(ns, logger, sock, data, length, ip_port);

    if (len != length) {
        LOGGER_ERROR(logger, "FAIL recv packet");
        return -1;
    }

    return len;
}

/** @brief Read the next two bytes in TCP stream then convert them to
 * length (host byte order).
 *
 * return length on success
 * return 0 if nothing has been read from socket.
 * return -1 on failure.
 */
non_null()
static uint16_t read_TCP_length(const Logger *logger, const Network *ns, Socket sock, const IP_Port *ip_port)
{
    const uint16_t count = net_socket_data_recv_buffer(ns, sock);

    if (count >= sizeof(uint16_t)) {
        uint8_t length_buf[sizeof(uint16_t)];
        const int len = net_recv(ns, logger, sock, length_buf, sizeof(length_buf), ip_port);

        if (len != sizeof(uint16_t)) {
            LOGGER_ERROR(logger, "FAIL recv packet");
            return 0;
        }

        uint16_t length;
        net_unpack_u16(length_buf, &length);

        if (length > MAX_PACKET_SIZE) {
            LOGGER_ERROR(logger, "TCP packet too large: %d > %d", length, MAX_PACKET_SIZE);
            return -1;
        }

        return length;
    }

    return 0;
}

/**
 * @return length of received packet on success.
 * @retval 0 if could not read any packet.
 * @retval -1 on failure (connection must be killed).
 */
int read_packet_TCP_secure_connection(
        const Logger *logger, const Network *ns, Socket sock, uint16_t *next_packet_length,
        const uint8_t *shared_key, uint8_t *recv_nonce, uint8_t *data,
        uint16_t max_len, const IP_Port *ip_port)
{
    if (*next_packet_length == 0) {
        const uint16_t len = read_TCP_length(logger, ns, sock, ip_port);

        if (len == (uint16_t) -1) {
            return -1;
        }

        if (len == 0) {
            return 0;
        }

        *next_packet_length = len;
    }

    if (max_len + CRYPTO_MAC_SIZE < *next_packet_length) {
        LOGGER_DEBUG(logger, "packet too large");
        return -1;
    }

    VLA(uint8_t, data_encrypted, *next_packet_length);
    const int len_packet = read_TCP_packet(logger, ns, sock, data_encrypted, *next_packet_length, ip_port);

    if (len_packet == -1) {
        return 0;
    }

    if (len_packet != *next_packet_length) {
        LOGGER_WARNING(logger, "invalid packet length: %d, expected %d", len_packet, *next_packet_length);
        return 0;
    }

    *next_packet_length = 0;

    const int len = decrypt_data_symmetric(shared_key, recv_nonce, data_encrypted, len_packet, data);

    if (len + CRYPTO_MAC_SIZE != len_packet) {
        LOGGER_ERROR(logger, "decrypted length %d does not match expected length %d", len + CRYPTO_MAC_SIZE, len_packet);
        return -1;
    }

    increment_nonce(recv_nonce);

    return len;
}
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2018 The TokTok team.
 * Copyright © 2015 Tox project.
 */

/**
 * Handles TCP relay connections between two Tox clients.
 */

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


struct TCP_Connections {
    const Logger *logger;
    const Random *rng;
    Mono_Time *mono_time;
    const Network *ns;
    DHT *dht;

    uint8_t self_public_key[CRYPTO_PUBLIC_KEY_SIZE];
    uint8_t self_secret_key[CRYPTO_SECRET_KEY_SIZE];

    TCP_Connection_to *connections;
    uint32_t connections_length; /* Length of connections array. */

    TCP_con *tcp_connections;
    uint32_t tcp_connections_length; /* Length of tcp_connections array. */

    tcp_data_cb *tcp_data_callback;
    void *tcp_data_callback_object;

    tcp_oob_cb *tcp_oob_callback;
    void *tcp_oob_callback_object;

    tcp_onion_cb *tcp_onion_callback;
    void *tcp_onion_callback_object;

    forwarded_response_cb *tcp_forwarded_response_callback;
    void *tcp_forwarded_response_callback_object;

    TCP_Proxy_Info proxy_info;

    bool onion_status;
    uint16_t onion_num_conns;
};


static const TCP_Connection_to empty_tcp_connection_to = {0};
static const TCP_con empty_tcp_con = {0};


const uint8_t *tcp_connections_public_key(const TCP_Connections *tcp_c)
{
    return tcp_c->self_public_key;
}


uint32_t tcp_connections_count(const TCP_Connections *tcp_c)
{
    return tcp_c->tcp_connections_length;
}

/** @brief Set the size of the array to num.
 *
 * @retval -1 if realloc fails.
 * @retval 0 if it succeeds.
 */
non_null()
static int realloc_TCP_Connection_to(TCP_Connection_to **array, size_t num)
{
    if (num == 0) {
        free(*array);
        *array = nullptr;
        return 0;
    }

    TCP_Connection_to *temp_pointer =
        (TCP_Connection_to *)realloc(*array, num * sizeof(TCP_Connection_to));

    if (temp_pointer == nullptr) {
        return -1;
    }

    *array = temp_pointer;

    return 0;
}

non_null()
static int realloc_TCP_con(TCP_con **array, size_t num)
{
    if (num == 0) {
        free(*array);
        *array = nullptr;
        return 0;
    }

    TCP_con *temp_pointer = (TCP_con *)realloc(*array, num * sizeof(TCP_con));

    if (temp_pointer == nullptr) {
        return -1;
    }

    *array = temp_pointer;

    return 0;
}


/**
 * Return true if the connections_number is valid.
 */
non_null()
static bool connections_number_is_valid(const TCP_Connections *tcp_c, int connections_number)
{
    if ((unsigned int)connections_number >= tcp_c->connections_length) {
        return false;
    }

    if (tcp_c->connections == nullptr) {
        return false;
    }

    return tcp_c->connections[connections_number].status != TCP_CONN_NONE;
}

/**
 * Return true if the tcp_connections_number is valid.
 */
non_null()
static bool tcp_connections_number_is_valid(const TCP_Connections *tcp_c, int tcp_connections_number)
{
    if ((uint32_t)tcp_connections_number >= tcp_c->tcp_connections_length) {
        return false;
    }

    if (tcp_c->tcp_connections == nullptr) {
        return false;
    }

    return tcp_c->tcp_connections[tcp_connections_number].status != TCP_CONN_NONE;
}

/** @brief Create a new empty connection.
 *
 * return -1 on failure.
 * return connections_number on success.
 */
non_null()
static int create_connection(TCP_Connections *tcp_c)
{
    for (uint32_t i = 0; i < tcp_c->connections_length; ++i) {
        if (tcp_c->connections[i].status == TCP_CONN_NONE) {
            return i;
        }
    }

    int id = -1;

    if (realloc_TCP_Connection_to(&tcp_c->connections, tcp_c->connections_length + 1) == 0) {
        id = tcp_c->connections_length;
        ++tcp_c->connections_length;
        tcp_c->connections[id] = empty_tcp_connection_to;
    }

    return id;
}

/** @brief Create a new empty tcp connection.
 *
 * return -1 on failure.
 * return tcp_connections_number on success.
 */
non_null()
static int create_tcp_connection(TCP_Connections *tcp_c)
{
    for (uint32_t i = 0; i < tcp_c->tcp_connections_length; ++i) {
        if (tcp_c->tcp_connections[i].status == TCP_CONN_NONE) {
            return i;
        }
    }

    int id = -1;

    if (realloc_TCP_con(&tcp_c->tcp_connections, tcp_c->tcp_connections_length + 1) == 0) {
        id = tcp_c->tcp_connections_length;
        ++tcp_c->tcp_connections_length;
        tcp_c->tcp_connections[id] = empty_tcp_con;
    }

    return id;
}

/** @brief Wipe a connection.
 *
 * return -1 on failure.
 * return 0 on success.
 */
non_null()
static int wipe_connection(TCP_Connections *tcp_c, int connections_number)
{
    if (!connections_number_is_valid(tcp_c, connections_number)) {
        return -1;
    }

    uint32_t i;
    tcp_c->connections[connections_number] = empty_tcp_connection_to;

    for (i = tcp_c->connections_length; i != 0; --i) {
        if (tcp_c->connections[i - 1].status != TCP_CONN_NONE) {
            break;
        }
    }

    if (tcp_c->connections_length != i) {
        tcp_c->connections_length = i;
        realloc_TCP_Connection_to(&tcp_c->connections, tcp_c->connections_length);
    }

    return 0;
}

/** @brief Wipe a connection.
 *
 * return -1 on failure.
 * return 0 on success.
 */
non_null()
static int wipe_tcp_connection(TCP_Connections *tcp_c, int tcp_connections_number)
{
    if (!tcp_connections_number_is_valid(tcp_c, tcp_connections_number)) {
        return -1;
    }

    tcp_c->tcp_connections[tcp_connections_number] = empty_tcp_con;

    uint32_t i;

    for (i = tcp_c->tcp_connections_length; i != 0; --i) {
        if (tcp_c->tcp_connections[i - 1].status != TCP_CONN_NONE) {
            break;
        }
    }

    if (tcp_c->tcp_connections_length != i) {
        tcp_c->tcp_connections_length = i;
        realloc_TCP_con(&tcp_c->tcp_connections, tcp_c->tcp_connections_length);
    }

    return 0;
}

non_null()
TCP_Connection_to *get_connection(const TCP_Connections *tcp_c, int connections_number)
{
    if (!connections_number_is_valid(tcp_c, connections_number)) {
        return nullptr;
    }

    return &tcp_c->connections[connections_number];
}

non_null()
TCP_con *get_tcp_connection(const TCP_Connections *tcp_c, int tcp_connections_number)
{
    if (!tcp_connections_number_is_valid(tcp_c, tcp_connections_number)) {
        return nullptr;
    }

    return &tcp_c->tcp_connections[tcp_connections_number];
}

uint32_t tcp_connected_relays_count(const TCP_Connections *tcp_c)
{
    uint32_t count = 0;

    for (uint32_t i = 0; i < tcp_connections_count(tcp_c); ++i) {
        const TCP_con *tcp_con = get_tcp_connection(tcp_c, i);

        if (tcp_con == nullptr) {
            continue;
        }

        if (tcp_con->status == TCP_CONN_CONNECTED) {
            ++count;
        }
    }

    return count;
}

/** @brief Send a packet to the TCP connection.
 *
 * return -1 on failure.
 * return 0 on success.
 */
int send_packet_tcp_connection(const TCP_Connections *tcp_c, int connections_number, const uint8_t *packet,
                               uint16_t length)
{
    const TCP_Connection_to *con_to = get_connection(tcp_c, connections_number);

    if (con_to == nullptr) {
        return -1;
    }

    // TODO(irungentoo): detect and kill bad relays.
    // TODO(irungentoo): thread safety?
    int ret = -1;

    bool limit_reached = false;

    for (uint32_t i = 0; i < MAX_FRIEND_TCP_CONNECTIONS; ++i) {
        uint32_t tcp_con_num = con_to->connections[i].tcp_connection;
        const uint8_t status = con_to->connections[i].status;
        const uint8_t connection_id = con_to->connections[i].connection_id;

        if (tcp_con_num > 0 && status == TCP_CONNECTIONS_STATUS_ONLINE) {
            tcp_con_num -= 1;
            TCP_con *tcp_con = get_tcp_connection(tcp_c, tcp_con_num);

            if (tcp_con == nullptr) {
                continue;
            }

            ret = send_data(tcp_c->logger, tcp_con->connection, connection_id, packet, length);

            if (ret == 0) {
                limit_reached = true;
            }

            if (ret == 1) {
                break;
            }
        }
    }

    if (ret == 1) {
        return 0;
    }

    if (limit_reached) {
        return -1;
    }

    bool sent_any = false;

    /* Send oob packets to all relays tied to the connection. */
    for (uint32_t i = 0; i < MAX_FRIEND_TCP_CONNECTIONS; ++i) {
        uint32_t tcp_con_num = con_to->connections[i].tcp_connection;
        const uint8_t status = con_to->connections[i].status;

        if (tcp_con_num > 0 && status == TCP_CONNECTIONS_STATUS_REGISTERED) {
            tcp_con_num -= 1;
            TCP_con *tcp_con = get_tcp_connection(tcp_c, tcp_con_num);

            if (tcp_con == nullptr) {
                continue;
            }

            if (send_oob_packet(tcp_c->logger, tcp_con->connection, con_to->public_key, packet, length) == 1) {
                sent_any = true;
            }
        }
    }

    return sent_any ? 0 : -1;
}

/** @brief Return a TCP connection number for use in send_tcp_onion_request.
 *
 * TODO(irungentoo): This number is just the index of an array that the elements
 * can change without warning.
 *
 * return TCP connection number on success.
 * return -1 on failure.
 */
int get_random_tcp_onion_conn_number(const TCP_Connections *tcp_c)
{
    const uint32_t r = random_u32(tcp_c->rng);

    for (uint32_t i = 0; i < tcp_c->tcp_connections_length; ++i) {
        const uint32_t index = (i + r) % tcp_c->tcp_connections_length;

        if (tcp_c->tcp_connections[index].onion && tcp_c->tcp_connections[index].status == TCP_CONN_CONNECTED) {
            return index;
        }
    }

    return -1;
}

/** @brief Return TCP connection number of active TCP connection with ip_port.
 *
 * return TCP connection number on success.
 * return -1 on failure.
 */
non_null()
static int get_conn_number_by_ip_port(TCP_Connections *tcp_c, const IP_Port *ip_port)
{
    for (uint32_t i = 0; i < tcp_c->tcp_connections_length; ++i) {
        const IP_Port conn_ip_port = tcp_con_ip_port(tcp_c->tcp_connections[i].connection);

        if (ipport_equal(ip_port, &conn_ip_port) &&
                tcp_c->tcp_connections[i].status == TCP_CONN_CONNECTED) {
            return i;
        }
    }

    return -1;
}

/** @brief Put IP_Port of a random onion TCP connection in ip_port.
 *
 * return true on success.
 * return false on failure.
 */
bool tcp_get_random_conn_ip_port(const TCP_Connections *tcp_c, IP_Port *ip_port)
{
    const int index = get_random_tcp_onion_conn_number(tcp_c);

    if (index == -1) {
        return false;
    }

    *ip_port = tcp_con_ip_port(tcp_c->tcp_connections[index].connection);
    return true;
}

/** @brief Send an onion packet via the TCP relay corresponding to tcp_connections_number.
 *
 * return 0 on success.
 * return -1 on failure.
 */
int tcp_send_onion_request(TCP_Connections *tcp_c, uint32_t tcp_connections_number, const uint8_t *data,
                           uint16_t length)
{
    if (tcp_connections_number >= tcp_c->tcp_connections_length) {
        return -1;
    }

    if (tcp_c->tcp_connections[tcp_connections_number].status == TCP_CONN_CONNECTED) {
        const int ret = send_onion_request(tcp_c->logger, tcp_c->tcp_connections[tcp_connections_number].connection, data,
                                           length);

        if (ret == 1) {
            return 0;
        }
    }

    return -1;
}

/* Send a forward request to the TCP relay with IP_Port tcp_forwarder,
 * requesting to forward data via a chain of dht nodes starting with dht_node.
 * A chain_length of 0 means that dht_node is the final destination of data.
 *
 * return 0 on success.
 * return -1 on failure.
 */
int tcp_send_forward_request(const Logger *logger, TCP_Connections *tcp_c, const IP_Port *tcp_forwarder,
                             const IP_Port *dht_node,
                             const uint8_t *chain_keys, uint16_t chain_length,
                             const uint8_t *data, uint16_t data_length)
{
    const int index = get_conn_number_by_ip_port(tcp_c, tcp_forwarder);

    if (index == -1) {
        return -1;
    }

    if (chain_length == 0) {
        return send_forward_request_tcp(logger, tcp_c->tcp_connections[index].connection, dht_node, data,
                                        data_length) == 1 ? 0 : -1;
    }

    const uint16_t len = forward_chain_packet_size(chain_length, data_length);
    VLA(uint8_t, packet, len);

    return create_forward_chain_packet(chain_keys, chain_length, data, data_length, packet)
           && send_forward_request_tcp(logger, tcp_c->tcp_connections[index].connection, dht_node, packet, len) == 1 ? 0 : -1;
}

/** @brief Send an oob packet via the TCP relay corresponding to tcp_connections_number.
 *
 * return 0 on success.
 * return -1 on failure.
 */
int tcp_send_oob_packet(const TCP_Connections *tcp_c, unsigned int tcp_connections_number,
                        const uint8_t *public_key, const uint8_t *packet, uint16_t length)
{
    TCP_con *tcp_con = get_tcp_connection(tcp_c, tcp_connections_number);

    if (tcp_con == nullptr) {
        return -1;
    }

    if (tcp_con->status != TCP_CONN_CONNECTED) {
        return -1;
    }

    const int ret = send_oob_packet(tcp_c->logger, tcp_con->connection, public_key, packet, length);

    if (ret == 1) {
        return 0;
    }

    return -1;
}

non_null()
static int find_tcp_connection_relay(const TCP_Connections *tcp_c, const uint8_t *relay_pk);

/** @brief Send an oob packet via the TCP relay corresponding to relay_pk.
 *
 * return 0 on success.
 * return -1 on failure.
 */
int tcp_send_oob_packet_using_relay(const TCP_Connections *tcp_c, const uint8_t *relay_pk, const uint8_t *public_key,
                                    const uint8_t *packet, uint16_t length)
{
    const int tcp_con_number = find_tcp_connection_relay(tcp_c, relay_pk);

    if (tcp_con_number < 0) {
        return -1;
    }

    return tcp_send_oob_packet(tcp_c, tcp_con_number, public_key, packet, length);
}

/** @brief Set the callback for TCP data packets. */
void set_packet_tcp_connection_callback(TCP_Connections *tcp_c, tcp_data_cb *tcp_data_callback, void *object)
{
    tcp_c->tcp_data_callback = tcp_data_callback;
    tcp_c->tcp_data_callback_object = object;
}

/** @brief Set the callback for TCP oob data packets. */
void set_oob_packet_tcp_connection_callback(TCP_Connections *tcp_c, tcp_oob_cb *tcp_oob_callback, void *object)
{
    tcp_c->tcp_oob_callback = tcp_oob_callback;
    tcp_c->tcp_oob_callback_object = object;
}

/** @brief Set the callback for TCP onion packets. */
void set_onion_packet_tcp_connection_callback(TCP_Connections *tcp_c, tcp_onion_cb *tcp_onion_callback, void *object)
{
    tcp_c->tcp_onion_callback = tcp_onion_callback;
    tcp_c->tcp_onion_callback_object = object;
}

/** @brief Set the callback for TCP forwarding packets. */
void set_forwarding_packet_tcp_connection_callback(TCP_Connections *tcp_c,
        forwarded_response_cb *tcp_forwarded_response_callback,
        void *object)
{
    tcp_c->tcp_forwarded_response_callback = tcp_forwarded_response_callback;
    tcp_c->tcp_forwarded_response_callback_object = object;
}

/** @brief Encode tcp_connections_number as a custom ip_port.
 *
 * return ip_port.
 */
IP_Port tcp_connections_number_to_ip_port(unsigned int tcp_connections_number)
{
    IP_Port ip_port = {{{0}}};
    ip_port.ip.family = net_family_tcp_server();
    ip_port.ip.ip.v6.uint32[0] = tcp_connections_number;
    return ip_port;
}

/** @brief Decode ip_port created by tcp_connections_number_to_ip_port to tcp_connections_number.
 *
 * return true on success.
 * return false if ip_port is invalid.
 */
bool ip_port_to_tcp_connections_number(const IP_Port *ip_port, unsigned int *tcp_connections_number)
{
    *tcp_connections_number = ip_port->ip.ip.v6.uint32[0];
    return net_family_is_tcp_server(ip_port->ip.family);
}

/** @brief Find the TCP connection with public_key.
 *
 * return connections_number on success.
 * return -1 on failure.
 */
non_null()
static int find_tcp_connection_to(const TCP_Connections *tcp_c, const uint8_t *public_key)
{
    for (uint32_t i = 0; i < tcp_c->connections_length; ++i) {
        const TCP_Connection_to *con_to = get_connection(tcp_c, i);

        if (con_to != nullptr) {
            if (pk_equal(con_to->public_key, public_key)) {
                return i;
            }
        }
    }

    return -1;
}

/** @brief Find the TCP connection to a relay with relay_pk.
 *
 * return connections_number on success.
 * return -1 on failure.
 */
static int find_tcp_connection_relay(const TCP_Connections *tcp_c, const uint8_t *relay_pk)
{
    for (uint32_t i = 0; i < tcp_c->tcp_connections_length; ++i) {
        const TCP_con *tcp_con = get_tcp_connection(tcp_c, i);

        if (tcp_con != nullptr) {
            if (tcp_con->status == TCP_CONN_SLEEPING) {
                if (pk_equal(tcp_con->relay_pk, relay_pk)) {
                    return i;
                }
            } else {
                if (pk_equal(tcp_con_public_key(tcp_con->connection), relay_pk)) {
                    return i;
                }
            }
        }
    }

    return -1;
}

bool tcp_relay_is_valid(const TCP_Connections *tcp_c, const uint8_t *relay_pk)
{
    return find_tcp_connection_relay(tcp_c, relay_pk) != -1;
}

/** @brief Create a new TCP connection to public_key.
 *
 * public_key must be the counterpart to the secret key that the other peer used with `new_tcp_connections()`.
 *
 * id is the id in the callbacks for that connection.
 *
 * return connections_number on success.
 * return -1 on failure.
 */
int new_tcp_connection_to(TCP_Connections *tcp_c, const uint8_t *public_key, int id)
{
    if (find_tcp_connection_to(tcp_c, public_key) != -1) {
        return -1;
    }

    const int connections_number = create_connection(tcp_c);

    if (connections_number == -1) {
        return -1;
    }

    TCP_Connection_to *con_to = &tcp_c->connections[connections_number];

    con_to->status = TCP_CONN_VALID;
    memcpy(con_to->public_key, public_key, CRYPTO_PUBLIC_KEY_SIZE);
    con_to->id = id;

    return connections_number;
}

/**
 * @retval 0 on success.
 * @retval -1 on failure.
 */
int kill_tcp_connection_to(TCP_Connections *tcp_c, int connections_number)
{
    const TCP_Connection_to *con_to = get_connection(tcp_c, connections_number);

    if (con_to == nullptr) {
        return -1;
    }

    for (uint32_t i = 0; i < MAX_FRIEND_TCP_CONNECTIONS; ++i) {
        if (con_to->connections[i].tcp_connection > 0) {
            const unsigned int tcp_connections_number = con_to->connections[i].tcp_connection - 1;
            TCP_con *tcp_con = get_tcp_connection(tcp_c, tcp_connections_number);

            if (tcp_con == nullptr) {
                continue;
            }

            if (tcp_con->status == TCP_CONN_CONNECTED) {
                send_disconnect_request(tcp_c->logger, tcp_con->connection, con_to->connections[i].connection_id);
            }

            if (con_to->connections[i].status == TCP_CONNECTIONS_STATUS_ONLINE) {
                --tcp_con->lock_count;

                if (con_to->status == TCP_CONN_SLEEPING) {
                    --tcp_con->sleep_count;
                }
            }
        }
    }

    return wipe_connection(tcp_c, connections_number);
}

/** @brief Set connection status.
 *
 * status of 1 means we are using the connection.
 * status of 0 means we are not using it.
 *
 * Unused tcp connections will be disconnected from but kept in case they are needed.
 *
 * return 0 on success.
 * return -1 on failure.
 */
int set_tcp_connection_to_status(const TCP_Connections *tcp_c, int connections_number, bool status)
{
    TCP_Connection_to *con_to = get_connection(tcp_c, connections_number);

    if (con_to == nullptr) {
        return -1;
    }

    if (status) {
        /* Connection is unsleeping. */
        if (con_to->status != TCP_CONN_SLEEPING) {
            return -1;
        }

        for (uint32_t i = 0; i < MAX_FRIEND_TCP_CONNECTIONS; ++i) {
            if (con_to->connections[i].tcp_connection > 0) {
                const unsigned int tcp_connections_number = con_to->connections[i].tcp_connection - 1;
                TCP_con *tcp_con = get_tcp_connection(tcp_c, tcp_connections_number);

                if (tcp_con == nullptr) {
                    continue;
                }

                if (tcp_con->status == TCP_CONN_SLEEPING) {
                    tcp_con->unsleep = 1;
                }
            }
        }

        con_to->status = TCP_CONN_VALID;
        return 0;
    }

    /* Connection is going to sleep. */
    if (con_to->status != TCP_CONN_VALID) {
        return -1;
    }

    for (uint32_t i = 0; i < MAX_FRIEND_TCP_CONNECTIONS; ++i) {
        if (con_to->connections[i].tcp_connection > 0) {
            unsigned int tcp_connections_number = con_to->connections[i].tcp_connection - 1;
            TCP_con *tcp_con = get_tcp_connection(tcp_c, tcp_connections_number);

            if (tcp_con == nullptr) {
                continue;
            }

            if (con_to->connections[i].status == TCP_CONNECTIONS_STATUS_ONLINE) {
                ++tcp_con->sleep_count;
            }
        }
    }

    con_to->status = TCP_CONN_SLEEPING;
    return 0;
}

non_null()
static bool tcp_connection_in_conn(const TCP_Connection_to *con_to, unsigned int tcp_connections_number)
{
    for (uint32_t i = 0; i < MAX_FRIEND_TCP_CONNECTIONS; ++i) {
        if (con_to->connections[i].tcp_connection == (tcp_connections_number + 1)) {
            return true;
        }
    }

    return false;
}

/**
 * @return index on success.
 * @retval -1 on failure.
 */
non_null()
static int add_tcp_connection_to_conn(TCP_Connection_to *con_to, unsigned int tcp_connections_number)
{
    if (tcp_connection_in_conn(con_to, tcp_connections_number)) {
        return -1;
    }

    for (uint32_t i = 0; i < MAX_FRIEND_TCP_CONNECTIONS; ++i) {
        if (con_to->connections[i].tcp_connection == 0) {
            con_to->connections[i].tcp_connection = tcp_connections_number + 1;
            con_to->connections[i].status = TCP_CONNECTIONS_STATUS_NONE;
            con_to->connections[i].connection_id = 0;
            return i;
        }
    }

    return -1;
}

/**
 * @return index on success.
 * @retval -1 on failure.
 */
non_null()
static int rm_tcp_connection_from_conn(TCP_Connection_to *con_to, unsigned int tcp_connections_number)
{
    for (uint32_t i = 0; i < MAX_FRIEND_TCP_CONNECTIONS; ++i) {
        if (con_to->connections[i].tcp_connection == (tcp_connections_number + 1)) {
            con_to->connections[i].tcp_connection = 0;
            con_to->connections[i].status = TCP_CONNECTIONS_STATUS_NONE;
            con_to->connections[i].connection_id = 0;
            return i;
        }
    }

    return -1;
}

/**
 * @return number of online connections on success.
 * @retval -1 on failure.
 */
non_null()
static uint32_t online_tcp_connection_from_conn(const TCP_Connection_to *con_to)
{
    uint32_t count = 0;

    for (uint32_t i = 0; i < MAX_FRIEND_TCP_CONNECTIONS; ++i) {
        if (con_to->connections[i].tcp_connection > 0) {
            if (con_to->connections[i].status == TCP_CONNECTIONS_STATUS_ONLINE) {
                ++count;
            }
        }
    }

    return count;
}

/**
 * @return index on success.
 * @retval -1 on failure.
 */
non_null()
static int set_tcp_connection_status(TCP_Connection_to *con_to, unsigned int tcp_connections_number,
                                     uint8_t status,
                                     uint8_t connection_id)
{
    for (uint32_t i = 0; i < MAX_FRIEND_TCP_CONNECTIONS; ++i) {
        if (con_to->connections[i].tcp_connection == (tcp_connections_number + 1)) {

            if (con_to->connections[i].status == status) {
                return -1;
            }

            con_to->connections[i].status = status;
            con_to->connections[i].connection_id = connection_id;
            return i;
        }
    }

    return -1;
}

/** @brief Kill a TCP relay connection.
 *
 * return 0 on success.
 * return -1 on failure.
 */
int kill_tcp_relay_connection(TCP_Connections *tcp_c, int tcp_connections_number)
{
    TCP_con *tcp_con = get_tcp_connection(tcp_c, tcp_connections_number);

    if (tcp_con == nullptr) {
        return -1;
    }

    for (uint32_t i = 0; i < tcp_c->connections_length; ++i) {
        TCP_Connection_to *con_to = get_connection(tcp_c, i);

        if (con_to != nullptr) {
            rm_tcp_connection_from_conn(con_to, tcp_connections_number);
        }
    }

    if (tcp_con->onion) {
        --tcp_c->onion_num_conns;
    }

    kill_TCP_connection(tcp_con->connection);

    return wipe_tcp_connection(tcp_c, tcp_connections_number);
}

non_null()
static int reconnect_tcp_relay_connection(TCP_Connections *tcp_c, int tcp_connections_number)
{
    TCP_con *tcp_con = get_tcp_connection(tcp_c, tcp_connections_number);

    if (tcp_con == nullptr) {
        return -1;
    }

    if (tcp_con->status == TCP_CONN_SLEEPING) {
        return -1;
    }

    IP_Port ip_port = tcp_con_ip_port(tcp_con->connection);
    uint8_t relay_pk[CRYPTO_PUBLIC_KEY_SIZE];
    memcpy(relay_pk, tcp_con_public_key(tcp_con->connection), CRYPTO_PUBLIC_KEY_SIZE);
    kill_TCP_connection(tcp_con->connection);
    tcp_con->connection = new_TCP_connection(tcp_c->logger, tcp_c->mono_time, tcp_c->rng, tcp_c->ns, &ip_port, relay_pk, tcp_c->self_public_key, tcp_c->self_secret_key, &tcp_c->proxy_info);

    if (tcp_con->connection == nullptr) {
        kill_tcp_relay_connection(tcp_c, tcp_connections_number);
        return -1;
    }

    for (uint32_t i = 0; i < tcp_c->connections_length; ++i) {
        TCP_Connection_to *con_to = get_connection(tcp_c, i);

        if (con_to != nullptr) {
            set_tcp_connection_status(con_to, tcp_connections_number, TCP_CONNECTIONS_STATUS_NONE, 0);
        }
    }

    if (tcp_con->onion) {
        --tcp_c->onion_num_conns;
        tcp_con->onion = 0;
    }

    tcp_con->lock_count = 0;
    tcp_con->sleep_count = 0;
    tcp_con->connected_time = 0;
    tcp_con->status = TCP_CONN_VALID;
    tcp_con->unsleep = 0;

    return 0;
}

non_null()
static int sleep_tcp_relay_connection(TCP_Connections *tcp_c, int tcp_connections_number)
{
    TCP_con *tcp_con = get_tcp_connection(tcp_c, tcp_connections_number);

    if (tcp_con == nullptr) {
        return -1;
    }

    if (tcp_con->status != TCP_CONN_CONNECTED) {
        return -1;
    }

    if (tcp_con->lock_count != tcp_con->sleep_count) {
        return -1;
    }

    tcp_con->ip_port = tcp_con_ip_port(tcp_con->connection);
    memcpy(tcp_con->relay_pk, tcp_con_public_key(tcp_con->connection), CRYPTO_PUBLIC_KEY_SIZE);

    kill_TCP_connection(tcp_con->connection);
    tcp_con->connection = nullptr;

    for (uint32_t i = 0; i < tcp_c->connections_length; ++i) {
        TCP_Connection_to *con_to = get_connection(tcp_c, i);

        if (con_to != nullptr) {
            set_tcp_connection_status(con_to, tcp_connections_number, TCP_CONNECTIONS_STATUS_NONE, 0);
        }
    }

    if (tcp_con->onion) {
        --tcp_c->onion_num_conns;
        tcp_con->onion = 0;
    }

    tcp_con->lock_count = 0;
    tcp_con->sleep_count = 0;
    tcp_con->connected_time = 0;
    tcp_con->status = TCP_CONN_SLEEPING;
    tcp_con->unsleep = 0;

    return 0;
}

non_null()
static int unsleep_tcp_relay_connection(TCP_Connections *tcp_c, int tcp_connections_number)
{
    TCP_con *tcp_con = get_tcp_connection(tcp_c, tcp_connections_number);

    if (tcp_con == nullptr) {
        return -1;
    }

    if (tcp_con->status != TCP_CONN_SLEEPING) {
        return -1;
    }

    tcp_con->connection = new_TCP_connection(
            tcp_c->logger, tcp_c->mono_time, tcp_c->rng, tcp_c->ns, &tcp_con->ip_port,
            tcp_con->relay_pk, tcp_c->self_public_key, tcp_c->self_secret_key, &tcp_c->proxy_info);

    if (tcp_con->connection == nullptr) {
        kill_tcp_relay_connection(tcp_c, tcp_connections_number);
        return -1;
    }

    tcp_con->lock_count = 0;
    tcp_con->sleep_count = 0;
    tcp_con->connected_time = 0;
    tcp_con->status = TCP_CONN_VALID;
    tcp_con->unsleep = 0;

    return 0;
}

/** @brief Send a TCP routing request.
 *
 * return 0 on success.
 * return -1 on failure.
 */
non_null()
static int send_tcp_relay_routing_request(const TCP_Connections *tcp_c, int tcp_connections_number,
        const uint8_t *public_key)
{
    TCP_con *tcp_con = get_tcp_connection(tcp_c, tcp_connections_number);

    if (tcp_con == nullptr) {
        return -1;
    }

    if (tcp_con->status == TCP_CONN_SLEEPING) {
        return -1;
    }

    if (send_routing_request(tcp_c->logger, tcp_con->connection, public_key) != 1) {
        return -1;
    }

    return 0;
}

non_null()
static int tcp_response_callback(void *object, uint8_t connection_id, const uint8_t *public_key)
{
    TCP_Client_Connection *tcp_client_con = (TCP_Client_Connection *)object;
    const TCP_Connections *tcp_c = (const TCP_Connections *)tcp_con_custom_object(tcp_client_con);

    const unsigned int tcp_connections_number = tcp_con_custom_uint(tcp_client_con);
    TCP_con *tcp_con = get_tcp_connection(tcp_c, tcp_connections_number);

    if (tcp_con == nullptr) {
        return -1;
    }

    const int connections_number = find_tcp_connection_to(tcp_c, public_key);

    if (connections_number == -1) {
        return -1;
    }

    TCP_Connection_to *con_to = get_connection(tcp_c, connections_number);

    if (con_to == nullptr) {
        return -1;
    }

    if (set_tcp_connection_status(con_to, tcp_connections_number, TCP_CONNECTIONS_STATUS_REGISTERED, connection_id) == -1) {
        return -1;
    }

    set_tcp_connection_number(tcp_con->connection, connection_id, connections_number);

    return 0;
}

non_null()
static int tcp_status_callback(void *object, uint32_t number, uint8_t connection_id, uint8_t status)
{
    const TCP_Client_Connection *tcp_client_con = (const TCP_Client_Connection *)object;
    const TCP_Connections *tcp_c = (const TCP_Connections *)tcp_con_custom_object(tcp_client_con);

    const unsigned int tcp_connections_number = tcp_con_custom_uint(tcp_client_con);
    TCP_con *tcp_con = get_tcp_connection(tcp_c, tcp_connections_number);
    TCP_Connection_to *con_to = get_connection(tcp_c, number);

    if (con_to == nullptr || tcp_con == nullptr) {
        return -1;
    }

    if (status == 1) {
        if (set_tcp_connection_status(con_to, tcp_connections_number, TCP_CONNECTIONS_STATUS_REGISTERED, connection_id) == -1) {
            return -1;
        }

        --tcp_con->lock_count;

        if (con_to->status == TCP_CONN_SLEEPING) {
            --tcp_con->sleep_count;
        }
    } else if (status == 2) {
        if (set_tcp_connection_status(con_to, tcp_connections_number, TCP_CONNECTIONS_STATUS_ONLINE, connection_id) == -1) {
            return -1;
        }

        ++tcp_con->lock_count;

        if (con_to->status == TCP_CONN_SLEEPING) {
            ++tcp_con->sleep_count;
        }
    }

    return 0;
}

non_null(1, 4) nullable(6)
static int tcp_conn_data_callback(void *object, uint32_t number, uint8_t connection_id, const uint8_t *data,
                                  uint16_t length, void *userdata)
{
    if (length == 0) {
        return -1;
    }

    const TCP_Client_Connection *tcp_client_con = (TCP_Client_Connection *)object;
    TCP_Connections *tcp_c = (TCP_Connections *)tcp_con_custom_object(tcp_client_con);

    const unsigned int tcp_connections_number = tcp_con_custom_uint(tcp_client_con);
    const TCP_con *tcp_con = get_tcp_connection(tcp_c, tcp_connections_number);

    if (tcp_con == nullptr) {
        return -1;
    }

    const TCP_Connection_to *con_to = get_connection(tcp_c, number);

    if (con_to == nullptr) {
        return -1;
    }

    if (tcp_c->tcp_data_callback != nullptr) {
        tcp_c->tcp_data_callback(tcp_c->tcp_data_callback_object, con_to->id, data, length, userdata);
    }

    return 0;
}

non_null()
static int tcp_conn_oob_callback(void *object, const uint8_t *public_key, const uint8_t *data, uint16_t length,
                                 void *userdata)
{
    if (length == 0) {
        return -1;
    }

    const TCP_Client_Connection *tcp_client_con = (const TCP_Client_Connection *)object;
    TCP_Connections *tcp_c = (TCP_Connections *)tcp_con_custom_object(tcp_client_con);

    const unsigned int tcp_connections_number = tcp_con_custom_uint(tcp_client_con);
    const TCP_con *tcp_con = get_tcp_connection(tcp_c, tcp_connections_number);

    if (tcp_con == nullptr) {
        return -1;
    }

    /* TODO(irungentoo): optimize */
    const int connections_number = find_tcp_connection_to(tcp_c, public_key);

    const TCP_Connection_to *con_to = get_connection(tcp_c, connections_number);

    if (con_to != nullptr && tcp_connection_in_conn(con_to, tcp_connections_number)) {
        return tcp_conn_data_callback(object, connections_number, 0, data, length, userdata);
    }

    if (tcp_c->tcp_oob_callback != nullptr) {
        tcp_c->tcp_oob_callback(tcp_c->tcp_oob_callback_object, public_key, tcp_connections_number, data, length, userdata);
    }

    return 0;
}

non_null()
static int tcp_onion_callback(void *object, const uint8_t *data, uint16_t length, void *userdata)
{
    TCP_Connections *tcp_c = (TCP_Connections *)object;

    if (tcp_c->tcp_onion_callback != nullptr) {
        tcp_c->tcp_onion_callback(tcp_c->tcp_onion_callback_object, data, length, userdata);
    }

    return 0;
}

non_null()
static void tcp_forwarding_callback(void *object, const uint8_t *data, uint16_t length, void *userdata)
{
    TCP_Connections *tcp_c = (TCP_Connections *)object;

    if (tcp_c->tcp_forwarded_response_callback != nullptr) {
        tcp_c->tcp_forwarded_response_callback(tcp_c->tcp_forwarded_response_callback_object, data, length, userdata);
    }
}

/** @brief Set callbacks for the TCP relay connection.
 *
 * return 0 on success.
 * return -1 on failure.
 */
non_null()
static int tcp_relay_set_callbacks(TCP_Connections *tcp_c, int tcp_connections_number)
{
    TCP_con *tcp_con = get_tcp_connection(tcp_c, tcp_connections_number);

    if (tcp_con == nullptr) {
        return -1;
    }

    TCP_Client_Connection *con = tcp_con->connection;

    tcp_con_set_custom_object(con, tcp_c);
    tcp_con_set_custom_uint(con, tcp_connections_number);
    onion_response_handler(con, &tcp_onion_callback, tcp_c);
    forwarding_handler(con, &tcp_forwarding_callback, tcp_c);
    routing_response_handler(con, &tcp_response_callback, con);
    routing_status_handler(con, &tcp_status_callback, con);
    routing_data_handler(con, &tcp_conn_data_callback, con);
    oob_data_handler(con, &tcp_conn_oob_callback, con);

    return 0;
}

non_null()
static int tcp_relay_on_online(TCP_Connections *tcp_c, int tcp_connections_number)
{
    TCP_con *tcp_con = get_tcp_connection(tcp_c, tcp_connections_number);

    if (tcp_con == nullptr) {
        return -1;
    }

    bool sent_any = false;

    for (uint32_t i = 0; i < tcp_c->connections_length; ++i) {
        TCP_Connection_to *con_to = get_connection(tcp_c, i);

        if (con_to != nullptr) {
            if (tcp_connection_in_conn(con_to, tcp_connections_number)) {
                if (send_tcp_relay_routing_request(tcp_c, tcp_connections_number, con_to->public_key) == 0) {
                    sent_any = true;
                }
            }
        }
    }

    tcp_relay_set_callbacks(tcp_c, tcp_connections_number);
    tcp_con->status = TCP_CONN_CONNECTED;

    /* If this connection isn't used by any connection, we don't need to wait for them to come online. */
    if (sent_any) {
        tcp_con->connected_time = mono_time_get(tcp_c->mono_time);
    } else {
        tcp_con->connected_time = 0;
    }

    if (tcp_c->onion_status && tcp_c->onion_num_conns < NUM_ONION_TCP_CONNECTIONS) {
        tcp_con->onion = 1;
        ++tcp_c->onion_num_conns;
    }

    return 0;
}

non_null()
static int add_tcp_relay_instance(TCP_Connections *tcp_c, const IP_Port *ip_port, const uint8_t *relay_pk)
{
    IP_Port ipp_copy = *ip_port;

    if (net_family_is_tcp_ipv4(ipp_copy.ip.family)) {
        ipp_copy.ip.family = net_family_ipv4();
    } else if (net_family_is_tcp_ipv6(ipp_copy.ip.family)) {
        ipp_copy.ip.family = net_family_ipv6();
    }

    if (!net_family_is_ipv4(ipp_copy.ip.family) && !net_family_is_ipv6(ipp_copy.ip.family)) {
        return -1;
    }

    const int tcp_connections_number = create_tcp_connection(tcp_c);

    if (tcp_connections_number == -1) {
        return -1;
    }

    TCP_con *tcp_con = &tcp_c->tcp_connections[tcp_connections_number];

    tcp_con->connection = new_TCP_connection(
            tcp_c->logger, tcp_c->mono_time, tcp_c->rng, tcp_c->ns, &ipp_copy,
            relay_pk, tcp_c->self_public_key, tcp_c->self_secret_key, &tcp_c->proxy_info);

    if (tcp_con->connection == nullptr) {
        return -1;
    }

    tcp_con->status = TCP_CONN_VALID;

    return tcp_connections_number;
}

/** @brief Add a TCP relay to the TCP_Connections instance.
 *
 * return 0 on success.
 * return -1 on failure.
 */
int add_tcp_relay_global(TCP_Connections *tcp_c, const IP_Port *ip_port, const uint8_t *relay_pk)
{
    const int tcp_connections_number = find_tcp_connection_relay(tcp_c, relay_pk);

    if (tcp_connections_number != -1) {
        return -1;
    }

    if (add_tcp_relay_instance(tcp_c, ip_port, relay_pk) == -1) {
        return -1;
    }

    return 0;
}

/** @brief Add a TCP relay tied to a connection.
 *
 * NOTE: This can only be used during the tcp_oob_callback.
 *
 * return 0 on success.
 * return -1 on failure.
 */
int add_tcp_number_relay_connection(const TCP_Connections *tcp_c, int connections_number,
                                    unsigned int tcp_connections_number)
{
    TCP_Connection_to *con_to = get_connection(tcp_c, connections_number);

    if (con_to == nullptr) {
        return -1;
    }

    TCP_con *tcp_con = get_tcp_connection(tcp_c, tcp_connections_number);

    if (tcp_con == nullptr) {
        return -1;
    }

    if (con_to->status != TCP_CONN_SLEEPING && tcp_con->status == TCP_CONN_SLEEPING) {
        tcp_con->unsleep = 1;
    }

    if (add_tcp_connection_to_conn(con_to, tcp_connections_number) == -1) {
        return -1;
    }

    if (tcp_con->status == TCP_CONN_CONNECTED) {
        if (send_tcp_relay_routing_request(tcp_c, tcp_connections_number, con_to->public_key) == 0) {
            tcp_con->connected_time = mono_time_get(tcp_c->mono_time);
        }
    }

    return 0;
}

/** @brief Add a TCP relay tied to a connection.
 *
 * This should be called with the same relay by two peers who want to create a TCP connection with each other.
 *
 * return 0 on success.
 * return -1 on failure.
 */
int add_tcp_relay_connection(TCP_Connections *tcp_c, int connections_number, const IP_Port *ip_port,
                             const uint8_t *relay_pk)
{
    TCP_Connection_to *con_to = get_connection(tcp_c, connections_number);

    if (con_to == nullptr) {
        return -1;
    }

    int tcp_connections_number = find_tcp_connection_relay(tcp_c, relay_pk);

    if (tcp_connections_number != -1) {
        return add_tcp_number_relay_connection(tcp_c, connections_number, tcp_connections_number);
    }

    if (online_tcp_connection_from_conn(con_to) >= RECOMMENDED_FRIEND_TCP_CONNECTIONS) {
        return -1;
    }

    tcp_connections_number = add_tcp_relay_instance(tcp_c, ip_port, relay_pk);

    const TCP_con *tcp_con = get_tcp_connection(tcp_c, tcp_connections_number);

    if (tcp_con == nullptr) {
        return -1;
    }

    if (add_tcp_connection_to_conn(con_to, tcp_connections_number) == -1) {
        return -1;
    }

    return 0;
}

/**
 * @return number of online tcp relays tied to the connection on success.
 * @retval 0 on failure.
 */
uint32_t tcp_connection_to_online_tcp_relays(const TCP_Connections *tcp_c, int connections_number)
{
    const TCP_Connection_to *con_to = get_connection(tcp_c, connections_number);

    if (con_to == nullptr) {
        return 0;
    }

    return online_tcp_connection_from_conn(con_to);
}

/** @brief Copies the tcp relay from tcp connections designated by `idx` to `tcp_relay`.
 *
 * Returns true if the relay was successfully copied.
 * Returns false if the connection index is invalid, or if the relay is not connected.
 */
non_null()
static bool copy_tcp_relay_conn(const TCP_Connections *tcp_c, Node_format *tcp_relay, uint16_t idx)
{
    const TCP_con *tcp_con = get_tcp_connection(tcp_c, idx);

    if (tcp_con == nullptr) {
        return false;
    }

    if (tcp_con->status != TCP_CONN_CONNECTED) {
        return false;
    }

    memcpy(tcp_relay->public_key, tcp_con_public_key(tcp_con->connection), CRYPTO_PUBLIC_KEY_SIZE);
    tcp_relay->ip_port = tcp_con_ip_port(tcp_con->connection);

    Family *const family = &tcp_relay->ip_port.ip.family;

    if (net_family_is_ipv4(*family)) {
        *family = net_family_tcp_ipv4();
    } else if (net_family_is_ipv6(*family)) {
        *family = net_family_tcp_ipv6();
    }

    return true;
}

/** @brief Copy a maximum of max_num TCP relays we are connected to to tcp_relays.
 *
 * NOTE that the family of the copied ip ports will be set to TCP_INET or TCP_INET6.
 *
 * return number of relays copied to tcp_relays on success.
 * return 0 on failure.
 */
uint32_t tcp_copy_connected_relays(const TCP_Connections *tcp_c, Node_format *tcp_relays, uint16_t max_num)
{
    const uint32_t r = random_u32(tcp_c->rng);
    uint32_t copied = 0;

    for (uint32_t i = 0; (i < tcp_c->tcp_connections_length) && (copied < max_num); ++i) {
        const uint16_t idx = (i + r) % tcp_c->tcp_connections_length;

        if (copy_tcp_relay_conn(tcp_c, &tcp_relays[copied], idx)) {
            ++copied;
        }
    }

    return copied;
}

non_null()
char *tcp_copy_all_connected_relays(const TCP_Connections *tcp_c, char* relays_report_string, uint16_t max_num, uint32_t* num)
{
    char *p = relays_report_string;
    uint32_t copied = 0;
    for (uint32_t i = 0; (i < tcp_c->tcp_connections_length) && (copied < max_num); ++i) {
        const TCP_con *tcp_con = get_tcp_connection(tcp_c, i);

        if (tcp_con == nullptr) {
            continue;
        }

        if (tcp_con->status != TCP_CONN_CONNECTED) {
            continue;
        }

        const IP_Port conn_ip_port = tcp_con_ip_port(tcp_con->connection);
        if (net_family_is_ipv4(conn_ip_port.ip.family)) {
            char ipv4[20];
            memset(ipv4, 0, 20);
            snprintf(ipv4, 16, "%d.%d.%d.%d",
                conn_ip_port.ip.ip.v4.uint8[0],
                conn_ip_port.ip.ip.v4.uint8[1],
                conn_ip_port.ip.ip.v4.uint8[2],
                conn_ip_port.ip.ip.v4.uint8[3]
            );
            p += snprintf(p, 60, "port=%5d ip=%s\n", net_ntohs(conn_ip_port.port), ipv4);
        } else if (net_family_is_ipv6(conn_ip_port.ip.family)) {
            char ipv6[401];
            memset(ipv6, 0, 401);
            bool res = ip_parse_addr(&conn_ip_port.ip, ipv6, 400);
            if (!res) {
                snprintf(ipv6, 16, "<error in ipv6>");
            }
            p += snprintf(p, 60, "port=%5d ip=%s\n", net_ntohs(conn_ip_port.port), ipv6);
        }

        ++copied;
    }

    *num = *num + copied;
    return p;
}

uint32_t tcp_copy_connected_relays_index(const TCP_Connections *tcp_c, Node_format *tcp_relays, uint16_t max_num,
        uint32_t idx)
{
    if (tcp_c->tcp_connections_length == 0) {
        return 0;
    }

    uint32_t copied = 0;
    const uint16_t num_to_copy = min_u16(max_num, tcp_c->tcp_connections_length);
    const uint16_t start = idx % tcp_c->tcp_connections_length;
    const uint16_t end = (start + num_to_copy) % tcp_c->tcp_connections_length;

    for (uint16_t i = start; i != end; i = (i + 1) % tcp_c->tcp_connections_length) {
        if (copy_tcp_relay_conn(tcp_c, &tcp_relays[copied], i)) {
            ++copied;
        }
    }

    return copied;
}

/** @brief Set if we want TCP_connection to allocate some connection for onion use.
 *
 * If status is 1, allocate some connections. if status is 0, don't.
 *
 * return 0 on success.
 * return -1 on failure.
 */
int set_tcp_onion_status(TCP_Connections *tcp_c, bool status)
{
    if (tcp_c->onion_status == status) {
        return -1;
    }

    if (status) {
        for (uint32_t i = 0; i < tcp_c->tcp_connections_length; ++i) {
            TCP_con *tcp_con = get_tcp_connection(tcp_c, i);

            if (tcp_con != nullptr) {
                if (tcp_con->status == TCP_CONN_CONNECTED && !tcp_con->onion) {
                    ++tcp_c->onion_num_conns;
                    tcp_con->onion = 1;
                }
            }

            if (tcp_c->onion_num_conns >= NUM_ONION_TCP_CONNECTIONS) {
                break;
            }
        }

        if (tcp_c->onion_num_conns < NUM_ONION_TCP_CONNECTIONS) {
            const unsigned int wakeup = NUM_ONION_TCP_CONNECTIONS - tcp_c->onion_num_conns;

            for (uint32_t i = 0; i < tcp_c->tcp_connections_length; ++i) {
                TCP_con *tcp_con = get_tcp_connection(tcp_c, i);

                if (tcp_con != nullptr) {
                    if (tcp_con->status == TCP_CONN_SLEEPING) {
                        tcp_con->unsleep = 1;
                    }
                }

                if (wakeup == 0) {
                    break;
                }
            }
        }

        tcp_c->onion_status = 1;
    } else {
        for (uint32_t i = 0; i < tcp_c->tcp_connections_length; ++i) {
            TCP_con *tcp_con = get_tcp_connection(tcp_c, i);

            if (tcp_con != nullptr) {
                if (tcp_con->onion) {
                    --tcp_c->onion_num_conns;
                    tcp_con->onion = 0;
                }
            }
        }

        tcp_c->onion_status = 0;
    }

    return 0;
}

/** @brief Returns a new TCP_Connections object associated with the secret_key.
 *
 * In order for others to connect to this instance `new_tcp_connection_to()` must be called with the
 * public_key associated with secret_key.
 *
 * Returns NULL on failure.
 */
TCP_Connections *new_tcp_connections(
        const Logger *logger, const Random *rng, const Network *ns, Mono_Time *mono_time, const uint8_t *secret_key,
        const TCP_Proxy_Info *proxy_info)
{
    if (secret_key == nullptr) {
        return nullptr;
    }

    TCP_Connections *temp = (TCP_Connections *)calloc(1, sizeof(TCP_Connections));

    if (temp == nullptr) {
        return nullptr;
    }

    temp->logger = logger;
    temp->rng = rng;
    temp->mono_time = mono_time;
    temp->ns = ns;

    memcpy(temp->self_secret_key, secret_key, CRYPTO_SECRET_KEY_SIZE);
    crypto_derive_public_key(temp->self_public_key, temp->self_secret_key);
    temp->proxy_info = *proxy_info;

    return temp;
}

non_null(1, 2) nullable(3)
static void do_tcp_conns(const Logger *logger, TCP_Connections *tcp_c, void *userdata)
{
    for (uint32_t i = 0; i < tcp_c->tcp_connections_length; ++i) {
        TCP_con *tcp_con = get_tcp_connection(tcp_c, i);

        if (tcp_con == nullptr) {
            continue;
        }

        if (tcp_con->status != TCP_CONN_SLEEPING) {
            do_TCP_connection(logger, tcp_c->mono_time, tcp_con->connection, userdata);

            /* callbacks can change TCP connection address. */
            tcp_con = get_tcp_connection(tcp_c, i);

            // Make sure the TCP connection wasn't dropped in any of the callbacks.
            assert(tcp_con != nullptr);

            if (tcp_con_status(tcp_con->connection) == TCP_CLIENT_DISCONNECTED) {
                if (tcp_con->status == TCP_CONN_CONNECTED) {
                    reconnect_tcp_relay_connection(tcp_c, i);
                } else {
                    kill_tcp_relay_connection(tcp_c, i);
                }

                continue;
            }

            if (tcp_con->status == TCP_CONN_VALID && tcp_con_status(tcp_con->connection) == TCP_CLIENT_CONFIRMED) {
                tcp_relay_on_online(tcp_c, i);
            }

            if (tcp_con->status == TCP_CONN_CONNECTED
                    && !tcp_con->onion && tcp_con->lock_count > 0
                    && tcp_con->lock_count == tcp_con->sleep_count
                    && mono_time_is_timeout(tcp_c->mono_time, tcp_con->connected_time, TCP_CONNECTION_ANNOUNCE_TIMEOUT)) {
                sleep_tcp_relay_connection(tcp_c, i);
            }
        }

        if (tcp_con->status == TCP_CONN_SLEEPING && tcp_con->unsleep) {
            unsleep_tcp_relay_connection(tcp_c, i);
        }
    }
}

non_null()
static void kill_nonused_tcp(TCP_Connections *tcp_c)
{
    if (tcp_c->tcp_connections_length <= RECOMMENDED_FRIEND_TCP_CONNECTIONS) {
        return;
    }

    const uint32_t num_online = tcp_connected_relays_count(tcp_c);

    if (num_online <= RECOMMENDED_FRIEND_TCP_CONNECTIONS) {
        return;
    }

    const uint32_t max_kill_count = num_online - RECOMMENDED_FRIEND_TCP_CONNECTIONS;
    uint32_t kill_count = 0;

    for (uint32_t i = 0; i < tcp_c->tcp_connections_length && kill_count < max_kill_count; ++i) {
        const TCP_con *tcp_con = get_tcp_connection(tcp_c, i);

        if (tcp_con == nullptr) {
            continue;
        }

        if (tcp_con->status == TCP_CONN_CONNECTED) {
            if (tcp_con->onion || tcp_con->lock_count > 0) {  // connection is in use so we skip it
                continue;
            }

            if (mono_time_is_timeout(tcp_c->mono_time, tcp_con->connected_time, TCP_CONNECTION_ANNOUNCE_TIMEOUT)) {
                kill_tcp_relay_connection(tcp_c, i);
                ++kill_count;
            }
        }
    }
}

void do_tcp_connections(const Logger *logger, TCP_Connections *tcp_c, void *userdata)
{
    do_tcp_conns(logger, tcp_c, userdata);
    kill_nonused_tcp(tcp_c);
}

void kill_tcp_connections(TCP_Connections *tcp_c)
{
    if (tcp_c == nullptr) {
        return;
    }

    for (uint32_t i = 0; i < tcp_c->tcp_connections_length; ++i) {
        kill_TCP_connection(tcp_c->tcp_connections[i].connection);
    }

    crypto_memzero(tcp_c->self_secret_key, sizeof(tcp_c->self_secret_key));

    free(tcp_c->tcp_connections);
    free(tcp_c->connections);
    free(tcp_c);
}
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2018 The TokTok team.
 * Copyright © 2014 Tox project.
 */

/**
 * Implementation of the TCP relay server part of Tox.
 */

#include <stdlib.h>
#include <string.h>
#if !defined(_WIN32) && !defined(__WIN32__) && !defined (WIN32)
#include <sys/ioctl.h>
#endif

#ifdef TCP_SERVER_USE_EPOLL
#include <sys/epoll.h>
#include <unistd.h>
#endif


#ifdef TCP_SERVER_USE_EPOLL
#define TCP_SOCKET_LISTENING 0
#define TCP_SOCKET_INCOMING 1
#define TCP_SOCKET_UNCONFIRMED 2
#define TCP_SOCKET_CONFIRMED 3
#endif

typedef struct TCP_Secure_Conn {
    uint8_t public_key[CRYPTO_PUBLIC_KEY_SIZE];
    uint32_t index;
    // TODO(iphydf): Add an enum for this (same as in TCP_client.c, probably).
    uint8_t status; /* 0 if not used, 1 if other is offline, 2 if other is online. */
    uint8_t other_id;
} TCP_Secure_Conn;

typedef struct TCP_Secure_Connection {
    TCP_Connection con;

    uint8_t public_key[CRYPTO_PUBLIC_KEY_SIZE];
    uint8_t recv_nonce[CRYPTO_NONCE_SIZE]; /* Nonce of received packets. */
    uint16_t next_packet_length;
    TCP_Secure_Conn connections[NUM_CLIENT_CONNECTIONS];
    uint8_t status;

    uint64_t identifier;

    uint64_t last_pinged;
    uint64_t ping_id;
} TCP_Secure_Connection;


struct TCP_Server {
    const Logger *logger;
    const Random *rng;
    const Network *ns;
    Onion *onion;
    Forwarding *forwarding;

#ifdef TCP_SERVER_USE_EPOLL
    int efd;
    uint64_t last_run_pinged;
#endif
    Socket *socks_listening;
    unsigned int num_listening_socks;

    uint8_t public_key[CRYPTO_PUBLIC_KEY_SIZE];
    uint8_t secret_key[CRYPTO_SECRET_KEY_SIZE];
    TCP_Secure_Connection incoming_connection_queue[MAX_INCOMING_CONNECTIONS];
    uint16_t incoming_connection_queue_index;
    TCP_Secure_Connection unconfirmed_connection_queue[MAX_INCOMING_CONNECTIONS];
    uint16_t unconfirmed_connection_queue_index;

    TCP_Secure_Connection *accepted_connection_array;
    uint32_t size_accepted_connections;
    uint32_t num_accepted_connections;

    uint64_t counter;

    BS_List accepted_key_list;
};

const uint8_t *tcp_server_public_key(const TCP_Server *tcp_server)
{
    return tcp_server->public_key;
}

size_t tcp_server_listen_count(const TCP_Server *tcp_server)
{
    return tcp_server->num_listening_socks;
}

/** This is needed to compile on Android below API 21 */
#ifdef TCP_SERVER_USE_EPOLL
#ifndef EPOLLRDHUP
#define EPOLLRDHUP 0x2000
#endif
#endif

/** @brief Increase the size of the connection list
 *
 * @retval -1 on failure
 * @retval 0 on success.
 */
non_null()
static int alloc_new_connections(TCP_Server *tcp_server, uint32_t num)
{
    const uint32_t new_size = tcp_server->size_accepted_connections + num;

    if (new_size < tcp_server->size_accepted_connections) {
        return -1;
    }

    TCP_Secure_Connection *new_connections = (TCP_Secure_Connection *)realloc(
                tcp_server->accepted_connection_array,
                new_size * sizeof(TCP_Secure_Connection));

    if (new_connections == nullptr) {
        return -1;
    }

    const uint32_t old_size = tcp_server->size_accepted_connections;
    const uint32_t size_new_entries = num * sizeof(TCP_Secure_Connection);
    memset(new_connections + old_size, 0, size_new_entries);

    tcp_server->accepted_connection_array = new_connections;
    tcp_server->size_accepted_connections = new_size;
    return 0;
}

non_null()
static void wipe_secure_connection(TCP_Secure_Connection *con)
{
    if (con->status != 0) {
        wipe_priority_list(con->con.priority_queue_start);
        crypto_memzero(con, sizeof(TCP_Secure_Connection));
    }
}

non_null()
static void move_secure_connection(TCP_Secure_Connection *con_new, TCP_Secure_Connection *con_old)
{
    *con_new = *con_old;
    crypto_memzero(con_old, sizeof(TCP_Secure_Connection));
}

non_null()
static void free_accepted_connection_array(TCP_Server *tcp_server)
{
    if (tcp_server->accepted_connection_array == nullptr) {
        return;
    }

    for (uint32_t i = 0; i < tcp_server->size_accepted_connections; ++i) {
        wipe_secure_connection(&tcp_server->accepted_connection_array[i]);
    }

    free(tcp_server->accepted_connection_array);
    tcp_server->accepted_connection_array = nullptr;
    tcp_server->size_accepted_connections = 0;
}

/**
 * @return index corresponding to connection with peer on success
 * @retval -1 on failure.
 */
non_null()
static int get_TCP_connection_index(const TCP_Server *tcp_server, const uint8_t *public_key)
{
    return bs_list_find(&tcp_server->accepted_key_list, public_key);
}


non_null()
static int kill_accepted(TCP_Server *tcp_server, int index);

/** @brief Add accepted TCP connection to the list.
 *
 * @return index on success
 * @retval -1 on failure
 */
non_null()
static int add_accepted(TCP_Server *tcp_server, const Mono_Time *mono_time, TCP_Secure_Connection *con)
{
    int index = get_TCP_connection_index(tcp_server, con->public_key);

    if (index != -1) { /* If an old connection to the same public key exists, kill it. */
        kill_accepted(tcp_server, index);
        index = -1;
    }

    if (tcp_server->size_accepted_connections == tcp_server->num_accepted_connections) {
        if (alloc_new_connections(tcp_server, 4) == -1) {
            return -1;
        }

        index = tcp_server->num_accepted_connections;
    } else {
        for (uint32_t i = tcp_server->size_accepted_connections; i != 0; --i) {
            if (tcp_server->accepted_connection_array[i - 1].status == TCP_STATUS_NO_STATUS) {
                index = i - 1;
                break;
            }
        }
    }

    if (index == -1) {
        LOGGER_ERROR(tcp_server->logger, "FAIL index is -1");
        return -1;
    }

    if (!bs_list_add(&tcp_server->accepted_key_list, con->public_key, index)) {
        return -1;
    }

    move_secure_connection(&tcp_server->accepted_connection_array[index], con);

    tcp_server->accepted_connection_array[index].status = TCP_STATUS_CONFIRMED;
    ++tcp_server->num_accepted_connections;
    tcp_server->accepted_connection_array[index].identifier = ++tcp_server->counter;
    tcp_server->accepted_connection_array[index].last_pinged = mono_time_get(mono_time);
    tcp_server->accepted_connection_array[index].ping_id = 0;

    return index;
}

/** @brief Delete accepted connection from list.
 *
 * @retval 0 on success
 * @retval -1 on failure
 */
non_null()
static int del_accepted(TCP_Server *tcp_server, int index)
{
    if ((uint32_t)index >= tcp_server->size_accepted_connections) {
        return -1;
    }

    if (tcp_server->accepted_connection_array[index].status == TCP_STATUS_NO_STATUS) {
        return -1;
    }

    if (!bs_list_remove(&tcp_server->accepted_key_list, tcp_server->accepted_connection_array[index].public_key, index)) {
        return -1;
    }

    wipe_secure_connection(&tcp_server->accepted_connection_array[index]);
    --tcp_server->num_accepted_connections;

    if (tcp_server->num_accepted_connections == 0) {
        free_accepted_connection_array(tcp_server);
    }

    return 0;
}

/** Kill a TCP_Secure_Connection */
non_null()
static void kill_TCP_secure_connection(TCP_Secure_Connection *con)
{
    kill_sock(con->con.ns, con->con.sock);
    wipe_secure_connection(con);
}

non_null()
static int rm_connection_index(TCP_Server *tcp_server, TCP_Secure_Connection *con, uint8_t con_number);

/** @brief Kill an accepted TCP_Secure_Connection
 *
 * return -1 on failure.
 * return 0 on success.
 */
static int kill_accepted(TCP_Server *tcp_server, int index)
{
    if ((uint32_t)index >= tcp_server->size_accepted_connections) {
        return -1;
    }

    for (uint32_t i = 0; i < NUM_CLIENT_CONNECTIONS; ++i) {
        rm_connection_index(tcp_server, &tcp_server->accepted_connection_array[index], i);
    }

    const Socket sock = tcp_server->accepted_connection_array[index].con.sock;

    if (del_accepted(tcp_server, index) != 0) {
        return -1;
    }

    kill_sock(tcp_server->ns, sock);
    return 0;
}

/**
 * @retval 1 if everything went well.
 * @retval -1 if the connection must be killed.
 */
non_null()
static int handle_TCP_handshake(const Logger *logger, TCP_Secure_Connection *con, const uint8_t *data, uint16_t length,
                                const uint8_t *self_secret_key)
{
    if (length != TCP_CLIENT_HANDSHAKE_SIZE) {
        LOGGER_ERROR(logger, "invalid handshake length: %d != %d", length, TCP_CLIENT_HANDSHAKE_SIZE);
        return -1;
    }

    if (con->status != TCP_STATUS_CONNECTED) {
        LOGGER_ERROR(logger, "TCP connection %u not connected", (unsigned int)con->identifier);
        return -1;
    }

    uint8_t shared_key[CRYPTO_SHARED_KEY_SIZE];
    encrypt_precompute(data, self_secret_key, shared_key);
    uint8_t plain[TCP_HANDSHAKE_PLAIN_SIZE];
    int len = decrypt_data_symmetric(shared_key, data + CRYPTO_PUBLIC_KEY_SIZE,
                                     data + CRYPTO_PUBLIC_KEY_SIZE + CRYPTO_NONCE_SIZE, TCP_HANDSHAKE_PLAIN_SIZE + CRYPTO_MAC_SIZE, plain);

    if (len != TCP_HANDSHAKE_PLAIN_SIZE) {
        LOGGER_ERROR(logger, "invalid TCP handshake decrypted length: %d != %d", len, TCP_HANDSHAKE_PLAIN_SIZE);
        crypto_memzero(shared_key, sizeof(shared_key));
        return -1;
    }

    memcpy(con->public_key, data, CRYPTO_PUBLIC_KEY_SIZE);
    uint8_t temp_secret_key[CRYPTO_SECRET_KEY_SIZE];
    uint8_t resp_plain[TCP_HANDSHAKE_PLAIN_SIZE];
    crypto_new_keypair(con->con.rng, resp_plain, temp_secret_key);
    random_nonce(con->con.rng, con->con.sent_nonce);
    memcpy(resp_plain + CRYPTO_PUBLIC_KEY_SIZE, con->con.sent_nonce, CRYPTO_NONCE_SIZE);
    memcpy(con->recv_nonce, plain + CRYPTO_PUBLIC_KEY_SIZE, CRYPTO_NONCE_SIZE);

    uint8_t response[TCP_SERVER_HANDSHAKE_SIZE];
    random_nonce(con->con.rng, response);

    len = encrypt_data_symmetric(shared_key, response, resp_plain, TCP_HANDSHAKE_PLAIN_SIZE,
                                 response + CRYPTO_NONCE_SIZE);

    if (len != TCP_HANDSHAKE_PLAIN_SIZE + CRYPTO_MAC_SIZE) {
        crypto_memzero(shared_key, sizeof(shared_key));
        return -1;
    }

    IP_Port ipp = {{{0}}};

    if (TCP_SERVER_HANDSHAKE_SIZE != net_send(con->con.ns, logger, con->con.sock, response, TCP_SERVER_HANDSHAKE_SIZE, &ipp)) {
        crypto_memzero(shared_key, sizeof(shared_key));
        return -1;
    }

    encrypt_precompute(plain, temp_secret_key, con->con.shared_key);
    con->status = TCP_STATUS_UNCONFIRMED;

    crypto_memzero(shared_key, sizeof(shared_key));

    return 1;
}

/**
 * @retval 1 if connection handshake was handled correctly.
 * @retval 0 if we didn't get it yet.
 * @retval -1 if the connection must be killed.
 */
non_null()
static int read_connection_handshake(const Logger *logger, TCP_Secure_Connection *con, const uint8_t *self_secret_key)
{
    uint8_t data[TCP_CLIENT_HANDSHAKE_SIZE];
    const int len = read_TCP_packet(logger, con->con.ns, con->con.sock, data, TCP_CLIENT_HANDSHAKE_SIZE, &con->con.ip_port);

    if (len == -1) {
        LOGGER_TRACE(logger, "connection handshake is not ready yet");
        return 0;
    }

    return handle_TCP_handshake(logger, con, data, len, self_secret_key);
}

/**
 * @retval 1 on success.
 * @retval 0 if could not send packet.
 * @retval -1 on failure (connection must be killed).
 */
non_null()
static int send_routing_response(const Logger *logger, TCP_Secure_Connection *con, uint8_t rpid,
                                 const uint8_t *public_key)
{
    uint8_t data[2 + CRYPTO_PUBLIC_KEY_SIZE];
    data[0] = TCP_PACKET_ROUTING_RESPONSE;
    data[1] = rpid;
    memcpy(data + 2, public_key, CRYPTO_PUBLIC_KEY_SIZE);

    return write_packet_TCP_secure_connection(logger, &con->con, data, sizeof(data), true);
}

/**
 * @retval 1 on success.
 * @retval 0 if could not send packet.
 * @retval -1 on failure (connection must be killed).
 */
non_null()
static int send_connect_notification(const Logger *logger, TCP_Secure_Connection *con, uint8_t id)
{
    uint8_t data[2] = {TCP_PACKET_CONNECTION_NOTIFICATION, (uint8_t)(id + NUM_RESERVED_PORTS)};
    return write_packet_TCP_secure_connection(logger, &con->con, data, sizeof(data), true);
}

/**
 * @retval 1 on success.
 * @retval 0 if could not send packet.
 * @retval -1 on failure (connection must be killed).
 */
non_null()
static int send_disconnect_notification(const Logger *logger, TCP_Secure_Connection *con, uint8_t id)
{
    uint8_t data[2] = {TCP_PACKET_DISCONNECT_NOTIFICATION, (uint8_t)(id + NUM_RESERVED_PORTS)};
    return write_packet_TCP_secure_connection(logger, &con->con, data, sizeof(data), true);
}

/**
 * @retval 0 on success.
 * @retval -1 on failure (connection must be killed).
 */
non_null()
static int handle_TCP_routing_req(TCP_Server *tcp_server, uint32_t con_id, const uint8_t *public_key)
{
    uint32_t index = -1;
    TCP_Secure_Connection *con = &tcp_server->accepted_connection_array[con_id];

    /* If person tries to cennect to himself we deny the request*/
    if (pk_equal(con->public_key, public_key)) {
        if (send_routing_response(tcp_server->logger, con, 0, public_key) == -1) {
            return -1;
        }

        return 0;
    }

    for (uint32_t i = 0; i < NUM_CLIENT_CONNECTIONS; ++i) {
        if (con->connections[i].status != 0) {
            if (pk_equal(public_key, con->connections[i].public_key)) {
                if (send_routing_response(tcp_server->logger, con, i + NUM_RESERVED_PORTS, public_key) == -1) {
                    return -1;
                }

                return 0;
            }
        } else if (index == (uint32_t) -1) {
            index = i;
        }
    }

    if (index == (uint32_t) -1) {
        if (send_routing_response(tcp_server->logger, con, 0, public_key) == -1) {
            return -1;
        }

        return 0;
    }

    const int ret = send_routing_response(tcp_server->logger, con, index + NUM_RESERVED_PORTS, public_key);

    if (ret == 0) {
        return 0;
    }

    if (ret == -1) {
        return -1;
    }

    con->connections[index].status = 1;
    memcpy(con->connections[index].public_key, public_key, CRYPTO_PUBLIC_KEY_SIZE);
    const int other_index = get_TCP_connection_index(tcp_server, public_key);

    if (other_index != -1) {
        uint32_t other_id = -1;
        TCP_Secure_Connection *other_conn = &tcp_server->accepted_connection_array[other_index];

        for (uint32_t i = 0; i < NUM_CLIENT_CONNECTIONS; ++i) {
            if (other_conn->connections[i].status == 1
                    && pk_equal(other_conn->connections[i].public_key, con->public_key)) {
                other_id = i;
                break;
            }
        }

        if (other_id != (uint32_t) -1) {
            con->connections[index].status = 2;
            con->connections[index].index = other_index;
            con->connections[index].other_id = other_id;
            other_conn->connections[other_id].status = 2;
            other_conn->connections[other_id].index = con_id;
            other_conn->connections[other_id].other_id = index;
            // TODO(irungentoo): return values?
            send_connect_notification(tcp_server->logger, con, index);
            send_connect_notification(tcp_server->logger, other_conn, other_id);
        }
    }

    return 0;
}

/**
 * @retval 0 on success.
 * @retval -1 on failure (connection must be killed).
 */
non_null()
static int handle_TCP_oob_send(TCP_Server *tcp_server, uint32_t con_id, const uint8_t *public_key, const uint8_t *data,
                               uint16_t length)
{
    if (length == 0 || length > TCP_MAX_OOB_DATA_LENGTH) {
        return -1;
    }

    const TCP_Secure_Connection *con = &tcp_server->accepted_connection_array[con_id];

    const int other_index = get_TCP_connection_index(tcp_server, public_key);

    if (other_index != -1) {
        VLA(uint8_t, resp_packet, 1 + CRYPTO_PUBLIC_KEY_SIZE + length);
        resp_packet[0] = TCP_PACKET_OOB_RECV;
        memcpy(resp_packet + 1, con->public_key, CRYPTO_PUBLIC_KEY_SIZE);
        memcpy(resp_packet + 1 + CRYPTO_PUBLIC_KEY_SIZE, data, length);
        write_packet_TCP_secure_connection(tcp_server->logger, &tcp_server->accepted_connection_array[other_index].con,
                                           resp_packet, SIZEOF_VLA(resp_packet), false);
    }

    return 0;
}

/** @brief Remove connection with con_number from the connections array of con.
 *
 * return -1 on failure.
 * return 0 on success.
 */
static int rm_connection_index(TCP_Server *tcp_server, TCP_Secure_Connection *con, uint8_t con_number)
{
    if (con_number >= NUM_CLIENT_CONNECTIONS) {
        return -1;
    }

    if (con->connections[con_number].status != 0) {
        if (con->connections[con_number].status == 2) {
            const uint32_t index = con->connections[con_number].index;
            const uint8_t other_id = con->connections[con_number].other_id;

            if (index >= tcp_server->size_accepted_connections) {
                return -1;
            }

            tcp_server->accepted_connection_array[index].connections[other_id].other_id = 0;
            tcp_server->accepted_connection_array[index].connections[other_id].index = 0;
            tcp_server->accepted_connection_array[index].connections[other_id].status = 1;
            // TODO(irungentoo): return values?
            send_disconnect_notification(tcp_server->logger, &tcp_server->accepted_connection_array[index], other_id);
        }

        con->connections[con_number].index = 0;
        con->connections[con_number].other_id = 0;
        con->connections[con_number].status = 0;
        return 0;
    }

    return -1;
}

/** @brief Encode con_id and identifier as a custom IP_Port.
 *
 * @return ip_port.
 */
static IP_Port con_id_to_ip_port(uint32_t con_id, uint64_t identifier)
{
    IP_Port ip_port = {{{0}}};
    ip_port.ip.family = net_family_tcp_client();
    ip_port.ip.ip.v6.uint32[0] = con_id;
    ip_port.ip.ip.v6.uint64[1] = identifier;
    return ip_port;

}

/** @brief Decode ip_port created by con_id_to_ip_port to con_id.
 *
 * @retval true on success.
 * @retval false if ip_port is invalid.
 */
non_null()
static bool ip_port_to_con_id(const TCP_Server *tcp_server, const IP_Port *ip_port, uint32_t *con_id)
{
    *con_id = ip_port->ip.ip.v6.uint32[0];

    return net_family_is_tcp_client(ip_port->ip.family) &&
           *con_id < tcp_server->size_accepted_connections &&
           tcp_server->accepted_connection_array[*con_id].identifier == ip_port->ip.ip.v6.uint64[1];
}

non_null()
static int handle_onion_recv_1(void *object, const IP_Port *dest, const uint8_t *data, uint16_t length)
{
    TCP_Server *tcp_server = (TCP_Server *)object;
    uint32_t index;

    if (!ip_port_to_con_id(tcp_server, dest, &index)) {
        return 1;
    }

    TCP_Secure_Connection *con = &tcp_server->accepted_connection_array[index];

    VLA(uint8_t, packet, 1 + length);
    memcpy(packet + 1, data, length);
    packet[0] = TCP_PACKET_ONION_RESPONSE;

    if (write_packet_TCP_secure_connection(tcp_server->logger, &con->con, packet, SIZEOF_VLA(packet), false) != 1) {
        return 1;
    }

    return 0;
}

non_null()
static bool handle_forward_reply_tcp(void *object, const uint8_t *sendback_data, uint16_t sendback_data_len,
                                     const uint8_t *data, uint16_t length)
{
    TCP_Server *tcp_server = (TCP_Server *)object;

    if (sendback_data_len != 1 + sizeof(uint32_t) + sizeof(uint64_t)) {
        return false;
    }

    if (*sendback_data != SENDBACK_TCP) {
        return false;
    }

    uint32_t con_id;
    uint64_t identifier;
    net_unpack_u32(sendback_data + 1, &con_id);
    net_unpack_u64(sendback_data + 1 + sizeof(uint32_t), &identifier);

    if (con_id >= tcp_server->size_accepted_connections) {
        return false;
    }

    TCP_Secure_Connection *con = &tcp_server->accepted_connection_array[con_id];

    if (con->identifier != identifier) {
        return false;
    }

    VLA(uint8_t, packet, 1 + length);
    memcpy(packet + 1, data, length);
    packet[0] = TCP_PACKET_FORWARDING;

    return write_packet_TCP_secure_connection(tcp_server->logger, &con->con, packet, SIZEOF_VLA(packet), false) == 1;
}

/**
 * @retval 0 on success
 * @retval -1 on failure
 */
non_null()
static int handle_TCP_packet(TCP_Server *tcp_server, uint32_t con_id, const uint8_t *data, uint16_t length)
{
    if (length == 0) {
        return -1;
    }

    TCP_Secure_Connection *const con = &tcp_server->accepted_connection_array[con_id];

    switch (data[0]) {
        case TCP_PACKET_ROUTING_REQUEST: {
            if (length != 1 + CRYPTO_PUBLIC_KEY_SIZE) {
                return -1;
            }

            LOGGER_TRACE(tcp_server->logger, "handling routing request for %d", con_id);
            return handle_TCP_routing_req(tcp_server, con_id, data + 1);
        }

        case TCP_PACKET_CONNECTION_NOTIFICATION: {
            if (length != 2) {
                return -1;
            }

            LOGGER_TRACE(tcp_server->logger, "handling connection notification for %d", con_id);
            break;
        }

        case TCP_PACKET_DISCONNECT_NOTIFICATION: {
            if (length != 2) {
                return -1;
            }

            LOGGER_TRACE(tcp_server->logger, "handling disconnect notification for %d", con_id);
            return rm_connection_index(tcp_server, con, data[1] - NUM_RESERVED_PORTS);
        }

        case TCP_PACKET_PING: {
            if (length != 1 + sizeof(uint64_t)) {
                return -1;
            }

            LOGGER_TRACE(tcp_server->logger, "handling ping for %d", con_id);

            uint8_t response[1 + sizeof(uint64_t)];
            response[0] = TCP_PACKET_PONG;
            memcpy(response + 1, data + 1, sizeof(uint64_t));
            write_packet_TCP_secure_connection(tcp_server->logger, &con->con, response, sizeof(response), true);
            return 0;
        }

        case TCP_PACKET_PONG: {
            if (length != 1 + sizeof(uint64_t)) {
                return -1;
            }

            LOGGER_TRACE(tcp_server->logger, "handling pong for %d", con_id);

            uint64_t ping_id;
            memcpy(&ping_id, data + 1, sizeof(uint64_t));

            if (ping_id != 0) {
                if (ping_id == con->ping_id) {
                    con->ping_id = 0;
                }

                return 0;
            }

            return -1;
        }

        case TCP_PACKET_OOB_SEND: {
            if (length <= 1 + CRYPTO_PUBLIC_KEY_SIZE) {
                return -1;
            }

            LOGGER_TRACE(tcp_server->logger, "handling oob send for %d", con_id);

            return handle_TCP_oob_send(tcp_server, con_id, data + 1, data + 1 + CRYPTO_PUBLIC_KEY_SIZE,
                                       length - (1 + CRYPTO_PUBLIC_KEY_SIZE));
        }

        case TCP_PACKET_ONION_REQUEST: {
            LOGGER_TRACE(tcp_server->logger, "handling onion request for %d", con_id);

            if (tcp_server->onion != nullptr) {
                if (length <= 1 + CRYPTO_NONCE_SIZE + ONION_SEND_BASE * 2) {
                    return -1;
                }

                IP_Port source = con_id_to_ip_port(con_id, con->identifier);
                onion_send_1(tcp_server->onion, data + 1 + CRYPTO_NONCE_SIZE, length - (1 + CRYPTO_NONCE_SIZE), &source,
                             data + 1);
            }

            return 0;
        }

        case TCP_PACKET_ONION_RESPONSE: {
            LOGGER_TRACE(tcp_server->logger, "handling onion response for %d", con_id);
            return -1;
        }

        case TCP_PACKET_FORWARD_REQUEST: {
            if (tcp_server->forwarding == nullptr) {
                return -1;
            }

            const uint16_t sendback_data_len = 1 + sizeof(uint32_t) + sizeof(uint64_t);
            uint8_t sendback_data[1 + sizeof(uint32_t) + sizeof(uint64_t)];
            sendback_data[0] = SENDBACK_TCP;
            net_pack_u32(sendback_data + 1, con_id);
            net_pack_u64(sendback_data + 1 + sizeof(uint32_t), con->identifier);

            IP_Port dest;
            const int ipport_length = unpack_ip_port(&dest, data + 1, length - 1, false);

            if (ipport_length == -1) {
                return -1;
            }

            const uint8_t *const forward_data = data + (1 + ipport_length);
            const uint16_t forward_data_len = length - (1 + ipport_length);

            if (forward_data_len > MAX_FORWARD_DATA_SIZE) {
                return -1;
            }

            send_forwarding(tcp_server->forwarding, &dest, sendback_data, sendback_data_len, forward_data, forward_data_len);
            return 0;
        }

        case TCP_PACKET_FORWARDING: {
            return -1;
        }

        default: {
            if (data[0] < NUM_RESERVED_PORTS) {
                return -1;
            }

            const uint8_t c_id = data[0] - NUM_RESERVED_PORTS;
            LOGGER_TRACE(tcp_server->logger, "handling packet id %d for %d", c_id, con_id);

            if (c_id >= NUM_CLIENT_CONNECTIONS) {
                return -1;
            }

            if (con->connections[c_id].status == 0) {
                return -1;
            }

            if (con->connections[c_id].status != 2) {
                return 0;
            }

            const uint32_t index = con->connections[c_id].index;
            const uint8_t other_c_id = con->connections[c_id].other_id + NUM_RESERVED_PORTS;
            VLA(uint8_t, new_data, length);
            memcpy(new_data, data, length);
            new_data[0] = other_c_id;
            const int ret = write_packet_TCP_secure_connection(tcp_server->logger,
                            &tcp_server->accepted_connection_array[index].con, new_data, length, false);

            if (ret == -1) {
                return -1;
            }

            return 0;
        }
    }

    return 0;
}


non_null()
static int confirm_TCP_connection(TCP_Server *tcp_server, const Mono_Time *mono_time, TCP_Secure_Connection *con,
                                  const uint8_t *data, uint16_t length)
{
    const int index = add_accepted(tcp_server, mono_time, con);

    if (index == -1) {
        LOGGER_DEBUG(tcp_server->logger, "dropping connection %u: not accepted", (unsigned int)con->identifier);
        kill_TCP_secure_connection(con);
        return -1;
    }

    wipe_secure_connection(con);

    if (handle_TCP_packet(tcp_server, index, data, length) == -1) {
        LOGGER_DEBUG(tcp_server->logger, "dropping connection %u: data packet (len=%d) not handled",
                     (unsigned int)con->identifier, length);
        kill_accepted(tcp_server, index);
        return -1;
    }

    return index;
}

/**
 * @return index on success
 * @retval -1 on failure
 */
non_null()
static int accept_connection(TCP_Server *tcp_server, Socket sock)
{
    if (!sock_valid(sock)) {
        return -1;
    }

    if (!set_socket_nonblock(tcp_server->ns, sock)) {
        kill_sock(tcp_server->ns, sock);
        return -1;
    }

    if (!set_socket_nosigpipe(tcp_server->ns, sock)) {
        kill_sock(tcp_server->ns, sock);
        return -1;
    }

    const uint16_t index = tcp_server->incoming_connection_queue_index % MAX_INCOMING_CONNECTIONS;

    TCP_Secure_Connection *conn = &tcp_server->incoming_connection_queue[index];

    if (conn->status != TCP_STATUS_NO_STATUS) {
        LOGGER_DEBUG(tcp_server->logger, "connection %d dropped before accepting", index);
        kill_TCP_secure_connection(conn);
    }

    conn->status = TCP_STATUS_CONNECTED;
    conn->con.ns = tcp_server->ns;
    conn->con.rng = tcp_server->rng;
    conn->con.sock = sock;
    conn->next_packet_length = 0;

    ++tcp_server->incoming_connection_queue_index;
    return index;
}

non_null()
static Socket new_listening_TCP_socket(const Logger *logger, const Network *ns, Family family, uint16_t port)
{
    const Socket sock = net_socket(ns, family, TOX_SOCK_STREAM, TOX_PROTO_TCP);

    if (!sock_valid(sock)) {
        LOGGER_ERROR(logger, "TCP socket creation failed (family = %d)", family.value);
        return net_invalid_socket;
    }

    bool ok = set_socket_nonblock(ns, sock);

    if (ok && net_family_is_ipv6(family)) {
        ok = set_socket_dualstack(ns, sock);
    }

    if (ok) {
        ok = set_socket_reuseaddr(ns, sock);
    }

    ok = ok && bind_to_port(ns, sock, family, port) && (net_listen(ns, sock, TCP_MAX_BACKLOG) == 0);

    if (!ok) {
        char *const error = net_new_strerror(net_error());
        LOGGER_WARNING(logger, "could not bind to TCP port %d (family = %d): %s",
                       port, family.value, error != nullptr ? error : "(null)");
        net_kill_strerror(error);
        kill_sock(ns, sock);
        return net_invalid_socket;
    }

    LOGGER_DEBUG(logger, "successfully bound to TCP port %d", port);
    return sock;
}

TCP_Server *new_TCP_server(const Logger *logger, const Random *rng, const Network *ns,
                           bool ipv6_enabled, uint16_t num_sockets,
                           const uint16_t *ports, const uint8_t *secret_key, Onion *onion, Forwarding *forwarding)
{
    if (num_sockets == 0 || ports == nullptr) {
        LOGGER_ERROR(logger, "no sockets");
        return nullptr;
    }

    if (ns == nullptr) {
        LOGGER_ERROR(logger, "NULL network");
        return nullptr;
    }

    TCP_Server *temp = (TCP_Server *)calloc(1, sizeof(TCP_Server));

    if (temp == nullptr) {
        LOGGER_ERROR(logger, "TCP server allocation failed");
        return nullptr;
    }

    temp->logger = logger;
    temp->ns = ns;
    temp->rng = rng;

    temp->socks_listening = (Socket *)calloc(num_sockets, sizeof(Socket));

    if (temp->socks_listening == nullptr) {
        LOGGER_ERROR(logger, "socket allocation failed");
        free(temp);
        return nullptr;
    }

#ifdef TCP_SERVER_USE_EPOLL
    temp->efd = epoll_create(8);

    if (temp->efd == -1) {
        LOGGER_ERROR(logger, "epoll initialisation failed");
        free(temp->socks_listening);
        free(temp);
        return nullptr;
    }

#endif

    const Family family = ipv6_enabled ? net_family_ipv6() : net_family_ipv4();

    for (uint32_t i = 0; i < num_sockets; ++i) {
        const Socket sock = new_listening_TCP_socket(logger, ns, family, ports[i]);

        if (!sock_valid(sock)) {
            continue;
        }

#ifdef TCP_SERVER_USE_EPOLL
        struct epoll_event ev;

        ev.events = EPOLLIN | EPOLLET;
        ev.data.u64 = sock.sock | ((uint64_t)TCP_SOCKET_LISTENING << 32);

        if (epoll_ctl(temp->efd, EPOLL_CTL_ADD, sock.sock, &ev) == -1) {
            continue;
        }

#endif

        temp->socks_listening[temp->num_listening_socks] = sock;
        ++temp->num_listening_socks;
    }

    if (temp->num_listening_socks == 0) {
        free(temp->socks_listening);
        free(temp);
        return nullptr;
    }

    if (onion != nullptr) {
        temp->onion = onion;
        set_callback_handle_recv_1(onion, &handle_onion_recv_1, temp);
    }

    if (forwarding != nullptr) {
        temp->forwarding = forwarding;
        set_callback_forward_reply(forwarding, &handle_forward_reply_tcp, temp);
    }

    memcpy(temp->secret_key, secret_key, CRYPTO_SECRET_KEY_SIZE);
    crypto_derive_public_key(temp->public_key, temp->secret_key);

    bs_list_init(&temp->accepted_key_list, CRYPTO_PUBLIC_KEY_SIZE, 8);

    return temp;
}

#ifndef TCP_SERVER_USE_EPOLL
non_null()
static void do_TCP_accept_new(TCP_Server *tcp_server)
{
    for (uint32_t sock_idx = 0; sock_idx < tcp_server->num_listening_socks; ++sock_idx) {

        for (uint32_t connection_idx = 0; connection_idx < MAX_INCOMING_CONNECTIONS; ++connection_idx) {
            const Socket sock = net_accept(tcp_server->ns, tcp_server->socks_listening[sock_idx]);

            if (accept_connection(tcp_server, sock) == -1) {
                break;
            }
        }
    }
}
#endif

non_null()
static int do_incoming(TCP_Server *tcp_server, uint32_t i)
{
    TCP_Secure_Connection *const conn = &tcp_server->incoming_connection_queue[i];

    if (conn->status != TCP_STATUS_CONNECTED) {
        return -1;
    }

    LOGGER_TRACE(tcp_server->logger, "handling incoming TCP connection %d", i);

    const int ret = read_connection_handshake(tcp_server->logger, conn, tcp_server->secret_key);

    if (ret == -1) {
        LOGGER_TRACE(tcp_server->logger, "incoming connection %d dropped due to failed handshake", i);
        kill_TCP_secure_connection(conn);
        return -1;
    }

    if (ret != 1) {
        return -1;
    }

    const int index_new = tcp_server->unconfirmed_connection_queue_index % MAX_INCOMING_CONNECTIONS;
    TCP_Secure_Connection *conn_old = conn;
    TCP_Secure_Connection *conn_new = &tcp_server->unconfirmed_connection_queue[index_new];

    if (conn_new->status != TCP_STATUS_NO_STATUS) {
        LOGGER_ERROR(tcp_server->logger, "incoming connection %d would overwrite existing", i);
        kill_TCP_secure_connection(conn_new);
    }

    move_secure_connection(conn_new, conn_old);
    ++tcp_server->unconfirmed_connection_queue_index;

    return index_new;
}

non_null()
static int do_unconfirmed(TCP_Server *tcp_server, const Mono_Time *mono_time, uint32_t i)
{
    TCP_Secure_Connection *const conn = &tcp_server->unconfirmed_connection_queue[i];

    if (conn->status != TCP_STATUS_UNCONFIRMED) {
        return -1;
    }

    LOGGER_TRACE(tcp_server->logger, "handling unconfirmed TCP connection %d", i);

    uint8_t packet[MAX_PACKET_SIZE];
    const int len = read_packet_TCP_secure_connection(tcp_server->logger, conn->con.ns, conn->con.sock, &conn->next_packet_length, conn->con.shared_key, conn->recv_nonce, packet, sizeof(packet), &conn->con.ip_port);

    if (len == 0) {
        return -1;
    }

    if (len == -1) {
        kill_TCP_secure_connection(conn);
        return -1;
    }

    return confirm_TCP_connection(tcp_server, mono_time, conn, packet, len);
}

non_null()
static bool tcp_process_secure_packet(TCP_Server *tcp_server, uint32_t i)
{
    TCP_Secure_Connection *const conn = &tcp_server->accepted_connection_array[i];

    uint8_t packet[MAX_PACKET_SIZE];
    const int len = read_packet_TCP_secure_connection(tcp_server->logger, conn->con.ns, conn->con.sock, &conn->next_packet_length, conn->con.shared_key, conn->recv_nonce, packet, sizeof(packet), &conn->con.ip_port);
    LOGGER_TRACE(tcp_server->logger, "processing packet for %d: %d", i, len);

    if (len == 0) {
        return false;
    }

    if (len == -1) {
        kill_accepted(tcp_server, i);
        return false;
    }

    if (handle_TCP_packet(tcp_server, i, packet, len) == -1) {
        LOGGER_TRACE(tcp_server->logger, "dropping connection %d: data packet (len=%d) not handled", i, len);
        kill_accepted(tcp_server, i);
        return false;
    }

    return true;
}

non_null()
static void do_confirmed_recv(TCP_Server *tcp_server, uint32_t i)
{
    while (tcp_process_secure_packet(tcp_server, i)) {
        // Keep reading until an error occurs or there is no more data to read.
        continue;
    }
}

#ifndef TCP_SERVER_USE_EPOLL
non_null()
static void do_TCP_incoming(TCP_Server *tcp_server)
{
    for (uint32_t i = 0; i < MAX_INCOMING_CONNECTIONS; ++i) {
        do_incoming(tcp_server, i);
    }
}

non_null()
static void do_TCP_unconfirmed(TCP_Server *tcp_server, const Mono_Time *mono_time)
{
    for (uint32_t i = 0; i < MAX_INCOMING_CONNECTIONS; ++i) {
        do_unconfirmed(tcp_server, mono_time, i);
    }
}
#endif

non_null()
static void do_TCP_confirmed(TCP_Server *tcp_server, const Mono_Time *mono_time)
{
#ifdef TCP_SERVER_USE_EPOLL

    if (tcp_server->last_run_pinged == mono_time_get(mono_time)) {
        return;
    }

    tcp_server->last_run_pinged = mono_time_get(mono_time);
#endif

    for (uint32_t i = 0; i < tcp_server->size_accepted_connections; ++i) {
        TCP_Secure_Connection *conn = &tcp_server->accepted_connection_array[i];

        if (conn->status != TCP_STATUS_CONFIRMED) {
            continue;
        }

        if (mono_time_is_timeout(mono_time, conn->last_pinged, TCP_PING_FREQUENCY)) {
            uint8_t ping[1 + sizeof(uint64_t)];
            ping[0] = TCP_PACKET_PING;
            uint64_t ping_id = random_u64(conn->con.rng);

            if (ping_id == 0) {
                ++ping_id;
            }

            memcpy(ping + 1, &ping_id, sizeof(uint64_t));
            const int ret = write_packet_TCP_secure_connection(tcp_server->logger, &conn->con, ping, sizeof(ping), true);

            if (ret == 1) {
                conn->last_pinged = mono_time_get(mono_time);
                conn->ping_id = ping_id;
            } else {
                if (mono_time_is_timeout(mono_time, conn->last_pinged, TCP_PING_FREQUENCY + TCP_PING_TIMEOUT)) {
                    kill_accepted(tcp_server, i);
                    continue;
                }
            }
        }

        if (conn->ping_id != 0 && mono_time_is_timeout(mono_time, conn->last_pinged, TCP_PING_TIMEOUT)) {
            kill_accepted(tcp_server, i);
            continue;
        }

        send_pending_data(tcp_server->logger, &conn->con);

#ifndef TCP_SERVER_USE_EPOLL

        do_confirmed_recv(tcp_server, i);

#endif
    }
}

#ifdef TCP_SERVER_USE_EPOLL
non_null()
static bool tcp_epoll_process(TCP_Server *tcp_server, const Mono_Time *mono_time)
{
#define MAX_EVENTS 16
    struct epoll_event events[MAX_EVENTS];
    const int nfds = epoll_wait(tcp_server->efd, events, MAX_EVENTS, 0);
#undef MAX_EVENTS

    for (int n = 0; n < nfds; ++n) {
        const Socket sock = {(int)(events[n].data.u64 & 0xFFFFFFFF)};
        const int status = (events[n].data.u64 >> 32) & 0xFF;
        const int index = events[n].data.u64 >> 40;

        if ((events[n].events & EPOLLERR) != 0 || (events[n].events & EPOLLHUP) != 0 || (events[n].events & EPOLLRDHUP) != 0) {
            switch (status) {
                case TCP_SOCKET_LISTENING: {
                    // should never happen
                    LOGGER_ERROR(tcp_server->logger, "connection %d was in listening state", index);
                    break;
                }

                case TCP_SOCKET_INCOMING: {
                    LOGGER_TRACE(tcp_server->logger, "incoming connection %d dropped", index);
                    kill_TCP_secure_connection(&tcp_server->incoming_connection_queue[index]);
                    break;
                }

                case TCP_SOCKET_UNCONFIRMED: {
                    LOGGER_TRACE(tcp_server->logger, "unconfirmed connection %d dropped", index);
                    kill_TCP_secure_connection(&tcp_server->unconfirmed_connection_queue[index]);
                    break;
                }

                case TCP_SOCKET_CONFIRMED: {
                    LOGGER_TRACE(tcp_server->logger, "confirmed connection %d dropped", index);
                    kill_accepted(tcp_server, index);
                    break;
                }
            }

            continue;
        }


        if ((events[n].events & EPOLLIN) == 0) {
            continue;
        }

        switch (status) {
            case TCP_SOCKET_LISTENING: {
                // socket is from socks_listening, accept connection
                while (true) {
                    const Socket sock_new = net_accept(tcp_server->ns, sock);

                    if (!sock_valid(sock_new)) {
                        break;
                    }

                    const int index_new = accept_connection(tcp_server, sock_new);

                    if (index_new == -1) {
                        continue;
                    }

                    struct epoll_event ev;

                    ev.events = EPOLLIN | EPOLLET | EPOLLRDHUP;

                    ev.data.u64 = sock_new.sock | ((uint64_t)TCP_SOCKET_INCOMING << 32) | ((uint64_t)index_new << 40);

                    if (epoll_ctl(tcp_server->efd, EPOLL_CTL_ADD, sock_new.sock, &ev) == -1) {
                        LOGGER_DEBUG(tcp_server->logger, "new connection %d was dropped due to epoll error %d", index, net_error());
                        kill_TCP_secure_connection(&tcp_server->incoming_connection_queue[index_new]);
                        continue;
                    }
                }

                break;
            }

            case TCP_SOCKET_INCOMING: {
                const int index_new = do_incoming(tcp_server, index);

                if (index_new != -1) {
                    LOGGER_TRACE(tcp_server->logger, "incoming connection %d was accepted as %d", index, index_new);
                    events[n].events = EPOLLIN | EPOLLET | EPOLLRDHUP;
                    events[n].data.u64 = sock.sock | ((uint64_t)TCP_SOCKET_UNCONFIRMED << 32) | ((uint64_t)index_new << 40);

                    if (epoll_ctl(tcp_server->efd, EPOLL_CTL_MOD, sock.sock, &events[n]) == -1) {
                        LOGGER_DEBUG(tcp_server->logger, "incoming connection %d was dropped due to epoll error %d", index, net_error());
                        kill_TCP_secure_connection(&tcp_server->unconfirmed_connection_queue[index_new]);
                        break;
                    }
                }

                break;
            }

            case TCP_SOCKET_UNCONFIRMED: {
                const int index_new = do_unconfirmed(tcp_server, mono_time, index);

                if (index_new != -1) {
                    LOGGER_TRACE(tcp_server->logger, "unconfirmed connection %d was confirmed as %d", index, index_new);
                    events[n].events = EPOLLIN | EPOLLET | EPOLLRDHUP;
                    events[n].data.u64 = sock.sock | ((uint64_t)TCP_SOCKET_CONFIRMED << 32) | ((uint64_t)index_new << 40);

                    if (epoll_ctl(tcp_server->efd, EPOLL_CTL_MOD, sock.sock, &events[n]) == -1) {
                        // remove from confirmed connections
                        LOGGER_DEBUG(tcp_server->logger, "unconfirmed connection %d was dropped due to epoll error %d", index, net_error());
                        kill_accepted(tcp_server, index_new);
                        break;
                    }
                }

                break;
            }

            case TCP_SOCKET_CONFIRMED: {
                do_confirmed_recv(tcp_server, index);
                break;
            }
        }
    }

    return nfds > 0;
}

non_null()
static void do_TCP_epoll(TCP_Server *tcp_server, const Mono_Time *mono_time)
{
    while (tcp_epoll_process(tcp_server, mono_time)) {
        // Keep processing packets until there are no more FDs ready for reading.
        continue;
    }
}
#endif

void do_TCP_server(TCP_Server *tcp_server, const Mono_Time *mono_time)
{
#ifdef TCP_SERVER_USE_EPOLL
    do_TCP_epoll(tcp_server, mono_time);

#else
    do_TCP_accept_new(tcp_server);
    do_TCP_incoming(tcp_server);
    do_TCP_unconfirmed(tcp_server, mono_time);
#endif

    do_TCP_confirmed(tcp_server, mono_time);
}

void kill_TCP_server(TCP_Server *tcp_server)
{
    if (tcp_server == nullptr) {
        return;
    }

    for (uint32_t i = 0; i < tcp_server->num_listening_socks; ++i) {
        kill_sock(tcp_server->ns, tcp_server->socks_listening[i]);
    }

    if (tcp_server->onion != nullptr) {
        set_callback_handle_recv_1(tcp_server->onion, nullptr, nullptr);
    }

    if (tcp_server->forwarding != nullptr) {
        set_callback_forward_reply(tcp_server->forwarding, nullptr, nullptr);
    }

    bs_list_free(&tcp_server->accepted_key_list);

#ifdef TCP_SERVER_USE_EPOLL
    close(tcp_server->efd);
#endif

    for (uint32_t i = 0; i < MAX_INCOMING_CONNECTIONS; ++i) {
        wipe_secure_connection(&tcp_server->incoming_connection_queue[i]);
        wipe_secure_connection(&tcp_server->unconfirmed_connection_queue[i]);
    }

    free_accepted_connection_array(tcp_server);

    crypto_memzero(tcp_server->secret_key, sizeof(tcp_server->secret_key));

    free(tcp_server->socks_listening);
    free(tcp_server);
}
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2019-2021 The TokTok team.
 */

#include <string.h>


non_null(1,6) nullable(4)
static void create_timed_auth_to_hash(const Mono_Time *mono_time, uint16_t timeout, bool previous, const uint8_t *data,
                                      uint16_t length, uint8_t *to_hash)
{
    const uint64_t t = (mono_time_get(mono_time) / timeout) - (previous ? 1 : 0);
    memcpy(to_hash, &t, sizeof(t));

    if (data != nullptr) {
        memcpy(to_hash + sizeof(t), data, length);
    }
}

void generate_timed_auth(const Mono_Time *mono_time, uint16_t timeout, const uint8_t *key,
                         const uint8_t *data, uint16_t length, uint8_t *timed_auth)
{
    VLA(uint8_t, to_hash, sizeof(uint64_t) + length);
    create_timed_auth_to_hash(mono_time, timeout, false, data, length, to_hash);
    crypto_hmac(timed_auth, key, to_hash, SIZEOF_VLA(to_hash));
}

bool check_timed_auth(const Mono_Time *mono_time, uint16_t timeout, const uint8_t *key, const uint8_t *data,
                      uint16_t length, const uint8_t *timed_auth)
{
    VLA(uint8_t, to_hash, sizeof(uint64_t) + length);

    for (uint8_t i = 0; i < 2; ++i) {
        create_timed_auth_to_hash(mono_time, timeout, i != 0, data, length, to_hash);

        if (crypto_hmac_verify(timed_auth, key, to_hash, SIZEOF_VLA(to_hash))) {
            return true;
        }
    }

    return false;
}
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2021 The TokTok team.
 */

#include <stdlib.h>
#include <string.h>


#define SET_ERROR_PARAMETER(param, x) \
    do {                              \
        if (param != nullptr) {       \
            *param = x;               \
        }                             \
    } while (0)

uint32_t tox_version_major(void)
{
    return TOX_VERSION_MAJOR;
}
uint32_t tox_version_minor(void)
{
    return TOX_VERSION_MINOR;
}
uint32_t tox_version_patch(void)
{
    return TOX_VERSION_PATCH;
}
uint32_t tox_public_key_size(void)
{
    return TOX_PUBLIC_KEY_SIZE;
}
uint32_t tox_secret_key_size(void)
{
    return TOX_SECRET_KEY_SIZE;
}
uint32_t tox_conference_uid_size(void)
{
    return TOX_CONFERENCE_UID_SIZE;
}
uint32_t tox_conference_id_size(void)
{
    return TOX_CONFERENCE_ID_SIZE;
}
uint32_t tox_nospam_size(void)
{
    return TOX_NOSPAM_SIZE;
}
uint32_t tox_address_size(void)
{
    return TOX_ADDRESS_SIZE;
}
uint32_t tox_max_name_length(void)
{
    return TOX_MAX_NAME_LENGTH;
}
uint32_t tox_max_status_message_length(void)
{
    return TOX_MAX_STATUS_MESSAGE_LENGTH;
}
uint32_t tox_max_friend_request_length(void)
{
    return TOX_MAX_FRIEND_REQUEST_LENGTH;
}
uint32_t tox_max_message_length(void)
{
    return TOX_MAX_MESSAGE_LENGTH;
}
uint32_t tox_max_custom_packet_size(void)
{
    return TOX_MAX_CUSTOM_PACKET_SIZE;
}
uint32_t tox_hash_length(void)
{
    return TOX_HASH_LENGTH;
}
uint32_t tox_file_id_length(void)
{
    return TOX_FILE_ID_LENGTH;
}
uint32_t tox_max_filename_length(void)
{
    return TOX_MAX_FILENAME_LENGTH;
}
uint32_t tox_max_hostname_length(void)
{
    return TOX_MAX_HOSTNAME_LENGTH;
}
uint32_t tox_dht_node_ip_string_size(void)
{
    return TOX_DHT_NODE_IP_STRING_SIZE;
}
uint32_t tox_dht_node_public_key_size(void)
{
    return TOX_DHT_NODE_PUBLIC_KEY_SIZE;
}

//!TOKSTYLE-

#define ACCESSORS(type, ns, name) \
type tox_options_get_##ns##name(const struct Tox_Options *options) \
{ \
    return options->ns##name; \
} \
void tox_options_set_##ns##name(struct Tox_Options *options, type name) \
{ \
    options->ns##name = name; \
}

ACCESSORS(bool,, ipv6_enabled)
ACCESSORS(bool,, udp_enabled)
ACCESSORS(Tox_Proxy_Type, proxy_, type)
ACCESSORS(const char *, proxy_, host)
ACCESSORS(uint16_t, proxy_, port)
ACCESSORS(uint16_t,, start_port)
ACCESSORS(uint16_t,, end_port)
ACCESSORS(uint16_t,, tcp_port)
ACCESSORS(bool,, hole_punching_enabled)
ACCESSORS(Tox_Savedata_Type, savedata_, type)
ACCESSORS(size_t, savedata_, length)
ACCESSORS(tox_log_cb *, log_, callback)
ACCESSORS(void *, log_, user_data)
ACCESSORS(bool,, local_discovery_enabled)
ACCESSORS(bool,, dht_announcements_enabled)
ACCESSORS(bool,, experimental_thread_safety)
ACCESSORS(const Tox_System *,, operating_system)

//!TOKSTYLE+

const uint8_t *tox_options_get_savedata_data(const struct Tox_Options *options)
{
    return options->savedata_data;
}

void tox_options_set_savedata_data(struct Tox_Options *options, const uint8_t *data, size_t length)
{
    options->savedata_data = data;
    options->savedata_length = length;
}

void tox_options_default(struct Tox_Options *options)
{
    if (options != nullptr) {
        const struct Tox_Options default_options = {0};
        *options = default_options;
        tox_options_set_ipv6_enabled(options, true);
        tox_options_set_udp_enabled(options, true);
        tox_options_set_proxy_type(options, TOX_PROXY_TYPE_NONE);
        tox_options_set_hole_punching_enabled(options, true);
        tox_options_set_local_discovery_enabled(options, true);
        tox_options_set_dht_announcements_enabled(options, true);
        tox_options_set_experimental_thread_safety(options, true);
    }
}

struct Tox_Options *tox_options_new(Tox_Err_Options_New *error)
{
    struct Tox_Options *options = (struct Tox_Options *)calloc(1, sizeof(struct Tox_Options));

    if (options != nullptr) {
        tox_options_default(options);
        SET_ERROR_PARAMETER(error, TOX_ERR_OPTIONS_NEW_OK);
        return options;
    }

    SET_ERROR_PARAMETER(error, TOX_ERR_OPTIONS_NEW_MALLOC);
    return nullptr;
}

void tox_options_free(struct Tox_Options *options)
{
    free(options);
}
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2018 The TokTok team.
 * Copyright © 2013 Tox project.
 */

/**
 * The Tox public API.
 */
#ifndef _XOPEN_SOURCE
#define _XOPEN_SOURCE 600
#endif


#include <assert.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>



#pragma clang diagnostic push
#pragma clang diagnostic warning "-Wmissing-variable-declarations"
bool global_filetransfer_is_resumable = false;
bool global_force_udp_only_mode = false;
bool global_do_not_sync_av = false;
bool global_onion_active = true;
#pragma clang diagnostic pop

#define SET_ERROR_PARAMETER(param, x) \
    do {                              \
        if (param != nullptr) {       \
            *param = x;               \
        }                             \
    } while (0)

static_assert(TOX_HASH_LENGTH == CRYPTO_SHA256_SIZE,
              "TOX_HASH_LENGTH is assumed to be equal to CRYPTO_SHA256_SIZE");
static_assert(FILE_ID_LENGTH == CRYPTO_SYMMETRIC_KEY_SIZE,
              "FILE_ID_LENGTH is assumed to be equal to CRYPTO_SYMMETRIC_KEY_SIZE");
static_assert(TOX_DHT_NODE_IP_STRING_SIZE == IP_NTOA_LEN,
              "TOX_DHT_NODE_IP_STRING_SIZE is assumed to be equal to IP_NTOA_LEN");
static_assert(TOX_DHT_NODE_PUBLIC_KEY_SIZE == CRYPTO_PUBLIC_KEY_SIZE,
              "TOX_DHT_NODE_PUBLIC_KEY_SIZE is assumed to be equal to CRYPTO_PUBLIC_KEY_SIZE");
static_assert(TOX_FILE_ID_LENGTH == CRYPTO_SYMMETRIC_KEY_SIZE,
              "TOX_FILE_ID_LENGTH is assumed to be equal to CRYPTO_SYMMETRIC_KEY_SIZE");
static_assert(TOX_FILE_ID_LENGTH == TOX_HASH_LENGTH,
              "TOX_FILE_ID_LENGTH is assumed to be equal to TOX_HASH_LENGTH");
static_assert(TOX_PUBLIC_KEY_SIZE == CRYPTO_PUBLIC_KEY_SIZE,
              "TOX_PUBLIC_KEY_SIZE is assumed to be equal to CRYPTO_PUBLIC_KEY_SIZE");
static_assert(TOX_SECRET_KEY_SIZE == CRYPTO_SECRET_KEY_SIZE,
              "TOX_SECRET_KEY_SIZE is assumed to be equal to CRYPTO_SECRET_KEY_SIZE");
static_assert(TOX_MAX_NAME_LENGTH == MAX_NAME_LENGTH,
              "TOX_MAX_NAME_LENGTH is assumed to be equal to MAX_NAME_LENGTH");
static_assert(TOX_MAX_STATUS_MESSAGE_LENGTH == MAX_STATUSMESSAGE_LENGTH,
              "TOX_MAX_STATUS_MESSAGE_LENGTH is assumed to be equal to MAX_STATUSMESSAGE_LENGTH");
static_assert(TOX_GROUP_MAX_MESSAGE_LENGTH == GROUP_MAX_MESSAGE_LENGTH,
              "TOX_GROUP_MAX_MESSAGE_LENGTH is assumed to be equal to GROUP_MAX_MESSAGE_LENGTH");
//static_assert(TOX_MAX_CUSTOM_PACKET_SIZE == MAX_GC_CUSTOM_PACKET_SIZE,
//              "TOX_MAX_CUSTOM_PACKET_SIZE is assumed to be equal to MAX_GC_CUSTOM_PACKET_SIZE");
static_assert(TOX_FILE_KIND_FTV2 == FILEKIND_FTV2,
              "TOX_FILE_KIND_FTV2 is assumed to be equal to FILEKIND_FTV2");

struct Tox_Userdata {
    Tox *tox;
    void *user_data;
};

static logger_cb tox_log_handler;
non_null(1, 3, 5, 6) nullable(7)
static void tox_log_handler(void *context, Logger_Level level, const char *file, int line, const char *func,
                            const char *message, void *userdata)
{
    Tox *tox = (Tox *)context;
    assert(tox != nullptr);

    if (tox->log_callback != nullptr) {
        tox->log_callback(tox, (Tox_Log_Level)level, file, line, func, message, userdata);
    }
}

static m_self_connection_status_cb tox_self_connection_status_handler;
non_null(1) nullable(3)
static void tox_self_connection_status_handler(Messenger *m, Onion_Connection_Status connection_status, void *user_data)
{
    struct Tox_Userdata *tox_data = (struct Tox_Userdata *)user_data;

    if (tox_data->tox->self_connection_status_callback != nullptr) {
        tox_unlock(tox_data->tox);
        tox_data->tox->self_connection_status_callback(tox_data->tox, (Tox_Connection)connection_status, tox_data->user_data);
        tox_lock(tox_data->tox);
    }
}

static m_friend_name_cb tox_friend_name_handler;
non_null(1, 3) nullable(5)
static void tox_friend_name_handler(Messenger *m, uint32_t friend_number, const uint8_t *name, size_t length,
                                    void *user_data)
{
    struct Tox_Userdata *tox_data = (struct Tox_Userdata *)user_data;

    if (tox_data->tox->friend_name_callback != nullptr) {
        tox_unlock(tox_data->tox);
        tox_data->tox->friend_name_callback(tox_data->tox, friend_number, name, length, tox_data->user_data);
        tox_lock(tox_data->tox);
    }
}

static m_friend_status_message_cb tox_friend_status_message_handler;
non_null(1, 3) nullable(5)
static void tox_friend_status_message_handler(Messenger *m, uint32_t friend_number, const uint8_t *message,
        size_t length, void *user_data)
{
    struct Tox_Userdata *tox_data = (struct Tox_Userdata *)user_data;

    if (tox_data->tox->friend_status_message_callback != nullptr) {
        tox_unlock(tox_data->tox);
        tox_data->tox->friend_status_message_callback(tox_data->tox, friend_number, message, length, tox_data->user_data);
        tox_lock(tox_data->tox);
    }
}

static m_friend_status_cb tox_friend_status_handler;
non_null(1) nullable(4)
static void tox_friend_status_handler(Messenger *m, uint32_t friend_number, unsigned int status, void *user_data)
{
    struct Tox_Userdata *tox_data = (struct Tox_Userdata *)user_data;

    if (tox_data->tox->friend_status_callback != nullptr) {
        tox_unlock(tox_data->tox);
        tox_data->tox->friend_status_callback(tox_data->tox, friend_number, (Tox_User_Status)status, tox_data->user_data);
        tox_lock(tox_data->tox);
    }
}

static m_friend_connection_status_cb tox_friend_connection_status_handler;
non_null(1) nullable(4)
static void tox_friend_connection_status_handler(Messenger *m, uint32_t friend_number, unsigned int connection_status,
        void *user_data)
{
    struct Tox_Userdata *tox_data = (struct Tox_Userdata *)user_data;

    if (tox_data->tox->friend_connection_status_callback != nullptr) {
        tox_unlock(tox_data->tox);
        tox_data->tox->friend_connection_status_callback(tox_data->tox, friend_number, (Tox_Connection)connection_status,
                tox_data->user_data);
        tox_lock(tox_data->tox);
    }
}

static m_friend_typing_cb tox_friend_typing_handler;
non_null(1) nullable(4)
static void tox_friend_typing_handler(Messenger *m, uint32_t friend_number, bool is_typing, void *user_data)
{
    struct Tox_Userdata *tox_data = (struct Tox_Userdata *)user_data;

    if (tox_data->tox->friend_typing_callback != nullptr) {
        tox_unlock(tox_data->tox);
        tox_data->tox->friend_typing_callback(tox_data->tox, friend_number, is_typing, tox_data->user_data);
        tox_lock(tox_data->tox);
    }
}

static m_friend_read_receipt_cb tox_friend_read_receipt_handler;
non_null(1) nullable(4)
static void tox_friend_read_receipt_handler(Messenger *m, uint32_t friend_number, uint32_t message_id, void *user_data)
{
    struct Tox_Userdata *tox_data = (struct Tox_Userdata *)user_data;

    if (tox_data->tox->friend_read_receipt_callback != nullptr) {
        tox_unlock(tox_data->tox);
        tox_data->tox->friend_read_receipt_callback(tox_data->tox, friend_number, message_id, tox_data->user_data);
        tox_lock(tox_data->tox);
    }
}

static m_friend_request_cb tox_friend_request_handler;
non_null(1, 2, 3) nullable(5)
static void tox_friend_request_handler(Messenger *m, const uint8_t *public_key, const uint8_t *message, size_t length,
                                       void *user_data)
{
    struct Tox_Userdata *tox_data = (struct Tox_Userdata *)user_data;

    if (tox_data->tox->friend_request_callback != nullptr) {
        tox_unlock(tox_data->tox);
        tox_data->tox->friend_request_callback(tox_data->tox, public_key, message, length, tox_data->user_data);
        tox_lock(tox_data->tox);
    }
}

static m_friend_message_cb tox_friend_message_handler;
non_null(1, 4) nullable(6)
static void tox_friend_message_handler(Messenger *m, uint32_t friend_number, unsigned int message_type,
                                       const uint8_t *message, size_t length, void *user_data)
{
    struct Tox_Userdata *tox_data = (struct Tox_Userdata *)user_data;

    if (tox_data->tox->friend_message_callback != nullptr) {
        tox_unlock(tox_data->tox);
        tox_data->tox->friend_message_callback(tox_data->tox, friend_number, (Tox_Message_Type)message_type, message, length,
                                               tox_data->user_data);
        tox_lock(tox_data->tox);
    }
}

static m_file_recv_control_cb tox_file_recv_control_handler;
non_null(1) nullable(5)
static void tox_file_recv_control_handler(Messenger *m, uint32_t friend_number, uint32_t file_number,
        unsigned int control, void *user_data)
{
    struct Tox_Userdata *tox_data = (struct Tox_Userdata *)user_data;

    if (tox_data->tox->file_recv_control_callback != nullptr) {
        tox_unlock(tox_data->tox);
        tox_data->tox->file_recv_control_callback(tox_data->tox, friend_number, file_number, (Tox_File_Control)control,
                tox_data->user_data);
        tox_lock(tox_data->tox);
    }
}

static m_file_chunk_request_cb tox_file_chunk_request_handler;
non_null(1) nullable(6)
static void tox_file_chunk_request_handler(Messenger *m, uint32_t friend_number, uint32_t file_number,
        uint64_t position, size_t length, void *user_data)
{
    struct Tox_Userdata *tox_data = (struct Tox_Userdata *)user_data;

    if (tox_data->tox->file_chunk_request_callback != nullptr) {
        tox_unlock(tox_data->tox);
        tox_data->tox->file_chunk_request_callback(tox_data->tox, friend_number, file_number, position, length,
                tox_data->user_data);
        tox_lock(tox_data->tox);
    }
}

static m_file_recv_cb tox_file_recv_handler;
non_null(1, 6) nullable(8)
static void tox_file_recv_handler(Messenger *m, uint32_t friend_number, uint32_t file_number, uint32_t kind,
                                  uint64_t file_size, const uint8_t *filename, size_t filename_length, void *user_data)
{
    struct Tox_Userdata *tox_data = (struct Tox_Userdata *)user_data;

    if (tox_data->tox->file_recv_callback != nullptr) {
        tox_unlock(tox_data->tox);
        tox_data->tox->file_recv_callback(tox_data->tox, friend_number, file_number, kind, file_size, filename, filename_length,
                                          tox_data->user_data);
        tox_lock(tox_data->tox);
    }
}

static m_file_recv_chunk_cb tox_file_recv_chunk_handler;
non_null(1, 5) nullable(7)
static void tox_file_recv_chunk_handler(Messenger *m, uint32_t friend_number, uint32_t file_number, uint64_t position,
                                        const uint8_t *data, size_t length, void *user_data)
{
    struct Tox_Userdata *tox_data = (struct Tox_Userdata *)user_data;

    if (tox_data->tox->file_recv_chunk_callback != nullptr) {
        tox_unlock(tox_data->tox);
        tox_data->tox->file_recv_chunk_callback(tox_data->tox, friend_number, file_number, position, data, length,
                                                tox_data->user_data);
        tox_lock(tox_data->tox);
    }
}

static g_conference_invite_cb tox_conference_invite_handler;
non_null(1, 4) nullable(6)
static void tox_conference_invite_handler(Messenger *m, uint32_t friend_number, int type, const uint8_t *cookie,
        size_t length, void *user_data)
{
    struct Tox_Userdata *tox_data = (struct Tox_Userdata *)user_data;

    if (tox_data->tox->conference_invite_callback != nullptr) {
        tox_unlock(tox_data->tox);
        tox_data->tox->conference_invite_callback(tox_data->tox, friend_number, (Tox_Conference_Type)type, cookie, length,
                tox_data->user_data);
        tox_lock(tox_data->tox);
    }
}

static g_conference_connected_cb tox_conference_connected_handler;
non_null(1) nullable(3)
static void tox_conference_connected_handler(Messenger *m, uint32_t conference_number, void *user_data)
{
    struct Tox_Userdata *tox_data = (struct Tox_Userdata *)user_data;

    if (tox_data->tox->conference_connected_callback != nullptr) {
        tox_unlock(tox_data->tox);
        tox_data->tox->conference_connected_callback(tox_data->tox, conference_number, tox_data->user_data);
        tox_lock(tox_data->tox);
    }
}

static g_conference_message_cb tox_conference_message_handler;
non_null(1, 5) nullable(7)
static void tox_conference_message_handler(Messenger *m, uint32_t conference_number, uint32_t peer_number, int type,
        const uint8_t *message, size_t length, void *user_data)
{
    struct Tox_Userdata *tox_data = (struct Tox_Userdata *)user_data;

    if (tox_data->tox->conference_message_callback != nullptr) {
        tox_unlock(tox_data->tox);
        tox_data->tox->conference_message_callback(tox_data->tox, conference_number, peer_number, (Tox_Message_Type)type,
                message, length, tox_data->user_data);
        tox_lock(tox_data->tox);
    }
}

static title_cb tox_conference_title_handler;
non_null(1, 4) nullable(6)
static void tox_conference_title_handler(Messenger *m, uint32_t conference_number, uint32_t peer_number,
        const uint8_t *title, size_t length, void *user_data)
{
    struct Tox_Userdata *tox_data = (struct Tox_Userdata *)user_data;

    if (tox_data->tox->conference_title_callback != nullptr) {
        tox_unlock(tox_data->tox);
        tox_data->tox->conference_title_callback(tox_data->tox, conference_number, peer_number, title, length,
                tox_data->user_data);
        tox_lock(tox_data->tox);
    }
}

static peer_name_cb tox_conference_peer_name_handler;
non_null(1, 4) nullable(6)
static void tox_conference_peer_name_handler(Messenger *m, uint32_t conference_number, uint32_t peer_number,
        const uint8_t *name, size_t length, void *user_data)
{
    struct Tox_Userdata *tox_data = (struct Tox_Userdata *)user_data;

    if (tox_data->tox->conference_peer_name_callback != nullptr) {
        tox_unlock(tox_data->tox);
        tox_data->tox->conference_peer_name_callback(tox_data->tox, conference_number, peer_number, name, length,
                tox_data->user_data);
        tox_lock(tox_data->tox);
    }
}

static peer_list_changed_cb tox_conference_peer_list_changed_handler;
non_null(1) nullable(3)
static void tox_conference_peer_list_changed_handler(Messenger *m, uint32_t conference_number, void *user_data)
{
    struct Tox_Userdata *tox_data = (struct Tox_Userdata *)user_data;

    if (tox_data->tox->conference_peer_list_changed_callback != nullptr) {
        tox_unlock(tox_data->tox);
        tox_data->tox->conference_peer_list_changed_callback(tox_data->tox, conference_number, tox_data->user_data);
        tox_lock(tox_data->tox);
    }
}

static dht_get_nodes_response_cb tox_dht_get_nodes_response_handler;
non_null(1, 2) nullable(3)
static void tox_dht_get_nodes_response_handler(const DHT *dht, const Node_format *node, void *user_data)
{
    struct Tox_Userdata *tox_data = (struct Tox_Userdata *)user_data;

    if (tox_data->tox->dht_get_nodes_response_callback == nullptr) {
        return;
    }

    Ip_Ntoa ip_str;
    tox_data->tox->dht_get_nodes_response_callback(
        tox_data->tox, node->public_key, net_ip_ntoa(&node->ip_port.ip, &ip_str), net_ntohs(node->ip_port.port),
        tox_data->user_data);
}

static m_friend_lossy_packet_cb tox_friend_lossy_packet_handler;
non_null(1, 4) nullable(6)
static void tox_friend_lossy_packet_handler(Messenger *m, uint32_t friend_number, uint8_t packet_id,
        const uint8_t *data, size_t length, void *user_data)
{
    assert(data != nullptr);
    assert(length > 0);

    struct Tox_Userdata *tox_data = (struct Tox_Userdata *)user_data;

    if (tox_data->tox->friend_lossy_packet_callback_per_pktid[packet_id] != nullptr) {
        tox_unlock(tox_data->tox);
        tox_data->tox->friend_lossy_packet_callback_per_pktid[packet_id](tox_data->tox, friend_number, data, length,
                tox_data->user_data);
        tox_lock(tox_data->tox);
    }
}

static m_friend_lossless_packet_cb tox_friend_lossless_packet_handler;
non_null(1, 4) nullable(6)
static void tox_friend_lossless_packet_handler(Messenger *m, uint32_t friend_number, uint8_t packet_id,
        const uint8_t *data, size_t length, void *user_data)
{
    assert(data != nullptr);
    assert(length > 0);

    struct Tox_Userdata *tox_data = (struct Tox_Userdata *)user_data;

    if (tox_data->tox->friend_lossless_packet_callback_per_pktid[packet_id] != nullptr) {
        tox_unlock(tox_data->tox);
        tox_data->tox->friend_lossless_packet_callback_per_pktid[packet_id](tox_data->tox, friend_number, data, length,
                tox_data->user_data);
        tox_lock(tox_data->tox);
    }
}

#ifndef VANILLA_NACL
non_null(1, 4) nullable(6)
static void tox_group_peer_name_handler(const Messenger *m, uint32_t group_number, uint32_t peer_id,
                                        const uint8_t *name, size_t length, void *user_data)
{
    struct Tox_Userdata *tox_data = (struct Tox_Userdata *)user_data;

    if (tox_data->tox->group_peer_name_callback != nullptr) {
        tox_unlock(tox_data->tox);
        tox_data->tox->group_peer_name_callback(tox_data->tox, group_number, peer_id, name, length, tox_data->user_data);
        tox_lock(tox_data->tox);
    }
}

non_null(1) nullable(5)
static void tox_group_peer_status_handler(const Messenger *m, uint32_t group_number, uint32_t peer_id,
        unsigned int status, void *user_data)
{
    struct Tox_Userdata *tox_data = (struct Tox_Userdata *)user_data;

    if (tox_data->tox->group_peer_status_callback != nullptr) {
        tox_unlock(tox_data->tox);
        tox_data->tox->group_peer_status_callback(tox_data->tox, group_number, peer_id, (Tox_User_Status)status,
                tox_data->user_data);
        tox_lock(tox_data->tox);
    }
}

non_null(1) nullable(4)
static void tox_group_connection_status_handler(const Messenger *m, uint32_t group_number, int32_t status, void *user_data)
{
    struct Tox_Userdata *tox_data = (struct Tox_Userdata *)user_data;

    if (tox_data->tox->group_connection_status_callback != nullptr) {
        tox_unlock(tox_data->tox);
        tox_data->tox->group_connection_status_callback(tox_data->tox, group_number, status, tox_data->user_data);
        tox_lock(tox_data->tox);
    }
}

non_null(1, 4) nullable(6)
static void tox_group_topic_handler(const Messenger *m, uint32_t group_number, uint32_t peer_id, const uint8_t *topic,
                                    size_t length, void *user_data)
{
    struct Tox_Userdata *tox_data = (struct Tox_Userdata *)user_data;

    if (tox_data->tox->group_topic_callback != nullptr) {
        tox_unlock(tox_data->tox);
        tox_data->tox->group_topic_callback(tox_data->tox, group_number, peer_id, topic, length, tox_data->user_data);
        tox_lock(tox_data->tox);
    }
}

non_null(1) nullable(4)
static void tox_group_topic_lock_handler(const Messenger *m, uint32_t group_number, unsigned int topic_lock,
        void *user_data)
{
    struct Tox_Userdata *tox_data = (struct Tox_Userdata *)user_data;

    if (tox_data->tox->group_topic_lock_callback != nullptr) {
        tox_unlock(tox_data->tox);
        tox_data->tox->group_topic_lock_callback(tox_data->tox, group_number, (Tox_Group_Topic_Lock)topic_lock,
                tox_data->user_data);
        tox_lock(tox_data->tox);
    }
}

non_null(1) nullable(4)
static void tox_group_voice_state_handler(const Messenger *m, uint32_t group_number, unsigned int voice_state,
        void *user_data)
{
    struct Tox_Userdata *tox_data = (struct Tox_Userdata *)user_data;

    if (tox_data->tox->group_voice_state_callback != nullptr) {
        tox_unlock(tox_data->tox);
        tox_data->tox->group_voice_state_callback(tox_data->tox, group_number, (Tox_Group_Voice_State)voice_state,
                tox_data->user_data);
        tox_lock(tox_data->tox);
    }
}

non_null(1) nullable(4)
static void tox_group_peer_limit_handler(const Messenger *m, uint32_t group_number, uint32_t peer_limit,
        void *user_data)
{
    struct Tox_Userdata *tox_data = (struct Tox_Userdata *)user_data;

    if (tox_data->tox->group_peer_limit_callback != nullptr) {
        tox_unlock(tox_data->tox);
        tox_data->tox->group_peer_limit_callback(tox_data->tox, group_number, peer_limit, tox_data->user_data);
        tox_lock(tox_data->tox);
    }
}

non_null(1) nullable(4)
static void tox_group_privacy_state_handler(const Messenger *m, uint32_t group_number, unsigned int privacy_state,
        void *user_data)
{
    struct Tox_Userdata *tox_data = (struct Tox_Userdata *)user_data;

    if (tox_data->tox->group_privacy_state_callback != nullptr) {
        tox_unlock(tox_data->tox);
        tox_data->tox->group_privacy_state_callback(tox_data->tox, group_number, (Tox_Group_Privacy_State)privacy_state,
                tox_data->user_data);
        tox_lock(tox_data->tox);
    }
}

non_null(1) nullable(3, 5)
static void tox_group_password_handler(const Messenger *m, uint32_t group_number, const uint8_t *password,
                                       size_t length, void *user_data)
{
    struct Tox_Userdata *tox_data = (struct Tox_Userdata *)user_data;

    if (tox_data->tox->group_password_callback != nullptr) {
        tox_unlock(tox_data->tox);
        tox_data->tox->group_password_callback(tox_data->tox, group_number, password, length, tox_data->user_data);
        tox_lock(tox_data->tox);
    }
}

non_null(1, 5) nullable(8)
static void tox_group_message_handler(const Messenger *m, uint32_t group_number, uint32_t peer_id, unsigned int type,
                                      const uint8_t *message, size_t length, uint32_t message_id, void *user_data)
{
    struct Tox_Userdata *tox_data = (struct Tox_Userdata *)user_data;

    if (tox_data->tox->group_message_callback != nullptr) {
        tox_unlock(tox_data->tox);
        tox_data->tox->group_message_callback(tox_data->tox, group_number, peer_id, (Tox_Message_Type)type, message, length,
                                              message_id, tox_data->user_data);
        tox_lock(tox_data->tox);
    }
}

non_null(1, 5) nullable(7)
static void tox_group_private_message_handler(const Messenger *m, uint32_t group_number, uint32_t peer_id,
        unsigned int type, const uint8_t *message, size_t length, void *user_data)
{
    struct Tox_Userdata *tox_data = (struct Tox_Userdata *)user_data;

    if (tox_data->tox->group_private_message_callback != nullptr) {
        tox_unlock(tox_data->tox);
        tox_data->tox->group_private_message_callback(tox_data->tox, group_number, peer_id, (Tox_Message_Type)type, message,
                length,
                tox_data->user_data);
        tox_lock(tox_data->tox);
    }
}

non_null(1, 4) nullable(6)
static void tox_group_custom_packet_handler(const Messenger *m, uint32_t group_number, uint32_t peer_id,
        const uint8_t *data, size_t length, void *user_data)
{
    struct Tox_Userdata *tox_data = (struct Tox_Userdata *)user_data;

    if (tox_data->tox->group_custom_packet_callback != nullptr) {
        tox_unlock(tox_data->tox);
        tox_data->tox->group_custom_packet_callback(tox_data->tox, group_number, peer_id, data, length, tox_data->user_data);
        tox_lock(tox_data->tox);
    }
}

non_null(1, 4) nullable(6)
static void tox_group_custom_private_packet_handler(const Messenger *m, uint32_t group_number, uint32_t peer_id,
        const uint8_t *data, size_t length, void *user_data)
{
    struct Tox_Userdata *tox_data = (struct Tox_Userdata *)user_data;

    if (tox_data->tox->group_custom_private_packet_callback != nullptr) {
        tox_unlock(tox_data->tox);
        tox_data->tox->group_custom_private_packet_callback(tox_data->tox, group_number, peer_id, data, length,
                tox_data->user_data);
        tox_lock(tox_data->tox);
    }
}

non_null(1, 3, 5) nullable(7)
static void tox_group_invite_handler(const Messenger *m, uint32_t friend_number, const uint8_t *invite_data,
                                     size_t length, const uint8_t *group_name, size_t group_name_length, void *user_data)
{
    struct Tox_Userdata *tox_data = (struct Tox_Userdata *)user_data;

    if (tox_data->tox->group_invite_callback != nullptr) {
        tox_unlock(tox_data->tox);
        tox_data->tox->group_invite_callback(tox_data->tox, friend_number, invite_data, length, group_name, group_name_length,
                                             tox_data->user_data);
        tox_lock(tox_data->tox);
    }
}

non_null(1) nullable(4)
static void tox_group_peer_join_handler(const Messenger *m, uint32_t group_number, uint32_t peer_id, void *user_data)
{
    struct Tox_Userdata *tox_data = (struct Tox_Userdata *)user_data;

    if (tox_data->tox->group_peer_join_callback != nullptr) {
        tox_unlock(tox_data->tox);
        tox_data->tox->group_peer_join_callback(tox_data->tox, group_number, peer_id, tox_data->user_data);
        tox_lock(tox_data->tox);
    }
}

non_null(1, 5) nullable(7, 9)
static void tox_group_peer_exit_handler(const Messenger *m, uint32_t group_number, uint32_t peer_id,
                                        unsigned int exit_type, const uint8_t *name, size_t name_length,
                                        const uint8_t *part_message, size_t length, void *user_data)
{
    struct Tox_Userdata *tox_data = (struct Tox_Userdata *)user_data;

    if (tox_data->tox->group_peer_exit_callback != nullptr) {
        tox_unlock(tox_data->tox);
        tox_data->tox->group_peer_exit_callback(tox_data->tox, group_number, peer_id, (Tox_Group_Exit_Type) exit_type, name,
                                                name_length,
                                                part_message, length, tox_data->user_data);
        tox_lock(tox_data->tox);
    }
}

non_null(1) nullable(3)
static void tox_group_self_join_handler(const Messenger *m, uint32_t group_number, void *user_data)
{
    struct Tox_Userdata *tox_data = (struct Tox_Userdata *)user_data;

    if (tox_data->tox->group_self_join_callback != nullptr) {
        tox_unlock(tox_data->tox);
        tox_data->tox->group_self_join_callback(tox_data->tox, group_number, tox_data->user_data);
        tox_lock(tox_data->tox);
    }
}

non_null(1) nullable(4)
static void tox_group_join_fail_handler(const Messenger *m, uint32_t group_number, unsigned int fail_type,
                                        void *user_data)
{
    struct Tox_Userdata *tox_data = (struct Tox_Userdata *)user_data;

    if (tox_data->tox->group_join_fail_callback != nullptr) {
        tox_unlock(tox_data->tox);
        tox_data->tox->group_join_fail_callback(tox_data->tox, group_number, (Tox_Group_Join_Fail)fail_type,
                                                tox_data->user_data);
        tox_lock(tox_data->tox);
    }
}

non_null(1) nullable(6)
static void tox_group_moderation_handler(const Messenger *m, uint32_t group_number, uint32_t source_peer_number,
        uint32_t target_peer_number, unsigned int mod_type, void *user_data)
{
    struct Tox_Userdata *tox_data = (struct Tox_Userdata *)user_data;

    if (tox_data->tox->group_moderation_callback != nullptr) {
        tox_unlock(tox_data->tox);
        tox_data->tox->group_moderation_callback(tox_data->tox, group_number, source_peer_number, target_peer_number,
                (Tox_Group_Mod_Event)mod_type,
                tox_data->user_data);
        tox_lock(tox_data->tox);
    }
}
#endif

bool tox_version_is_compatible(uint32_t major, uint32_t minor, uint32_t patch)
{
    return TOX_VERSION_IS_API_COMPATIBLE(major, minor, patch);
}

non_null()
static State_Load_Status state_load_callback(void *outer, const uint8_t *data, uint32_t length, uint16_t type)
{
    const Tox *tox = (const Tox *)outer;
    State_Load_Status status = STATE_LOAD_STATUS_CONTINUE;

    if (messenger_load_state_section(tox->m, data, length, type, &status)
            || conferences_load_state_section(tox->m->conferences_object, data, length, type, &status)) {
        return status;
    }

    if (type == STATE_TYPE_END) {
        if (length != 0) {
            return STATE_LOAD_STATUS_ERROR;
        }

        return STATE_LOAD_STATUS_END;
    }

    LOGGER_ERROR(tox->m->log, "Load state: contains unrecognized part (len %u, type %u)",
                 length, type);

    return STATE_LOAD_STATUS_CONTINUE;
}

/** Load tox from data of size length. */
non_null()
static int tox_load(Tox *tox, const uint8_t *data, uint32_t length)
{
    uint32_t data32[2];
    const uint32_t cookie_len = sizeof(data32);

    if (length < cookie_len) {
        return -1;
    }

    memcpy(data32, data, sizeof(uint32_t));
    lendian_bytes_to_host32(data32 + 1, data + sizeof(uint32_t));

    if (data32[0] != 0 || data32[1] != STATE_COOKIE_GLOBAL) {
        return -1;
    }

    return state_load(tox->m->log, state_load_callback, tox, data + cookie_len,
                      length - cookie_len, STATE_COOKIE_TYPE);
}

Tox *tox_new(const struct Tox_Options *options, Tox_Err_New *error)
{
    Tox *tox = (Tox *)calloc(1, sizeof(Tox));

    if (tox == nullptr) {
        SET_ERROR_PARAMETER(error, TOX_ERR_NEW_MALLOC);
        return nullptr;
    }

    Messenger_Options m_options = {0};

    bool load_savedata_sk = false;
    bool load_savedata_tox = false;

    struct Tox_Options *default_options = nullptr;

    if (options == nullptr) {
        Tox_Err_Options_New err;
        default_options = tox_options_new(&err);

        switch (err) {
            case TOX_ERR_OPTIONS_NEW_OK: {
                break;
            }

            case TOX_ERR_OPTIONS_NEW_MALLOC: {
                SET_ERROR_PARAMETER(error, TOX_ERR_NEW_MALLOC);
                free(tox);
                return nullptr;
            }
        }
    }

    const struct Tox_Options *const opts = options != nullptr ? options : default_options;
    assert(opts != nullptr);

    if (tox_options_get_savedata_type(opts) != TOX_SAVEDATA_TYPE_NONE) {
        if (tox_options_get_savedata_data(opts) == nullptr || tox_options_get_savedata_length(opts) == 0) {
            SET_ERROR_PARAMETER(error, TOX_ERR_NEW_LOAD_BAD_FORMAT);
            tox_options_free(default_options);
            free(tox);
            return nullptr;
        }
    }

    if (tox_options_get_savedata_type(opts) == TOX_SAVEDATA_TYPE_SECRET_KEY) {
        if (tox_options_get_savedata_length(opts) != TOX_SECRET_KEY_SIZE) {
            SET_ERROR_PARAMETER(error, TOX_ERR_NEW_LOAD_BAD_FORMAT);
            tox_options_free(default_options);
            free(tox);
            return nullptr;
        }

        load_savedata_sk = true;
    } else if (tox_options_get_savedata_type(opts) == TOX_SAVEDATA_TYPE_TOX_SAVE) {
        if (tox_options_get_savedata_length(opts) < TOX_ENC_SAVE_MAGIC_LENGTH) {
            SET_ERROR_PARAMETER(error, TOX_ERR_NEW_LOAD_BAD_FORMAT);
            tox_options_free(default_options);
            free(tox);
            return nullptr;
        }

        if (memcmp(tox_options_get_savedata_data(opts), TOX_ENC_SAVE_MAGIC_NUMBER, TOX_ENC_SAVE_MAGIC_LENGTH) == 0) {
            SET_ERROR_PARAMETER(error, TOX_ERR_NEW_LOAD_ENCRYPTED);
            tox_options_free(default_options);
            free(tox);
            return nullptr;
        }

        load_savedata_tox = true;
    }

    m_options.ipv6enabled = tox_options_get_ipv6_enabled(opts);
    m_options.udp_disabled = !tox_options_get_udp_enabled(opts);
    m_options.port_range[0] = tox_options_get_start_port(opts);
    m_options.port_range[1] = tox_options_get_end_port(opts);
    m_options.tcp_server_port = tox_options_get_tcp_port(opts);
    m_options.hole_punching_enabled = tox_options_get_hole_punching_enabled(opts);
    m_options.local_discovery_enabled = tox_options_get_local_discovery_enabled(opts);
    m_options.dht_announcements_enabled = tox_options_get_dht_announcements_enabled(opts);

    if (m_options.udp_disabled) {
        m_options.local_discovery_enabled = false;
    }

    tox->log_callback = tox_options_get_log_callback(opts);
    m_options.log_callback = tox_log_handler;
    m_options.log_context = tox;
    m_options.log_user_data = tox_options_get_log_user_data(opts);

    switch (tox_options_get_proxy_type(opts)) {
        case TOX_PROXY_TYPE_HTTP: {
            m_options.proxy_info.proxy_type = TCP_PROXY_HTTP;
            break;
        }

        case TOX_PROXY_TYPE_SOCKS5: {
            m_options.proxy_info.proxy_type = TCP_PROXY_SOCKS5;
            break;
        }

        case TOX_PROXY_TYPE_NONE: {
            m_options.proxy_info.proxy_type = TCP_PROXY_NONE;
            break;
        }

        default: {
            SET_ERROR_PARAMETER(error, TOX_ERR_NEW_PROXY_BAD_TYPE);
            tox_options_free(default_options);
            free(tox);
            return nullptr;
        }
    }

    const Tox_System *sys = tox_options_get_operating_system(opts);
    const Tox_System default_system = tox_default_system();

    if (sys == nullptr) {
        sys = &default_system;
    }

    if (sys->rng == nullptr || sys->ns == nullptr) {
        // TODO(iphydf): Not quite right, but similar.
        SET_ERROR_PARAMETER(error, TOX_ERR_NEW_MALLOC);
        tox_options_free(default_options);
        free(tox);
        return nullptr;
    }

    tox->rng = *sys->rng;
    tox->ns = *sys->ns;

    if (m_options.proxy_info.proxy_type != TCP_PROXY_NONE) {
        if (tox_options_get_proxy_port(opts) == 0) {
            SET_ERROR_PARAMETER(error, TOX_ERR_NEW_PROXY_BAD_PORT);
            tox_options_free(default_options);
            free(tox);
            return nullptr;
        }

        ip_init(&m_options.proxy_info.ip_port.ip, m_options.ipv6enabled);

        if (m_options.ipv6enabled) {
            m_options.proxy_info.ip_port.ip.family = net_family_unspec();
        }

        const char *const proxy_host = tox_options_get_proxy_host(opts);

        if (proxy_host == nullptr
                || !addr_resolve_or_parse_ip(&tox->ns, proxy_host, &m_options.proxy_info.ip_port.ip, nullptr)) {
            SET_ERROR_PARAMETER(error, TOX_ERR_NEW_PROXY_BAD_HOST);
            // TODO(irungentoo): TOX_ERR_NEW_PROXY_NOT_FOUND if domain.
            tox_options_free(default_options);
            free(tox);
            return nullptr;
        }

        m_options.proxy_info.ip_port.port = net_htons(tox_options_get_proxy_port(opts));
    }

    tox->mono_time = mono_time_new(sys->mono_time_callback, sys->mono_time_user_data);

    if (tox->mono_time == nullptr) {
        SET_ERROR_PARAMETER(error, TOX_ERR_NEW_MALLOC);
        tox_options_free(default_options);
        free(tox);
        return nullptr;
    }

    if (tox_options_get_experimental_thread_safety(opts)) {
        tox->mutex = (pthread_mutex_t *)calloc(1, sizeof(pthread_mutex_t));

        if (tox->mutex == nullptr) {
            SET_ERROR_PARAMETER(error, TOX_ERR_NEW_MALLOC);
            tox_options_free(default_options);
            free(tox);
            return nullptr;
        }

        pthread_mutex_init(tox->mutex, nullptr);
    } else {
        tox->mutex = nullptr;
    }

    tox_lock(tox);

    Messenger_Error m_error;
    tox->m = new_messenger(tox->mono_time, &tox->rng, &tox->ns, &m_options, &m_error);

    if (tox->m == nullptr) {
        if (m_error == MESSENGER_ERROR_PORT) {
            SET_ERROR_PARAMETER(error, TOX_ERR_NEW_PORT_ALLOC);
        } else if (m_error == MESSENGER_ERROR_TCP_SERVER) {
            SET_ERROR_PARAMETER(error, TOX_ERR_NEW_PORT_ALLOC);
        } else {
            SET_ERROR_PARAMETER(error, TOX_ERR_NEW_MALLOC);
        }

        mono_time_free(tox->mono_time);
        tox_options_free(default_options);
        tox_unlock(tox);

        if (tox->mutex != nullptr) {
            pthread_mutex_destroy(tox->mutex);
        }

        free(tox->mutex);
        free(tox);
        return nullptr;
    }

    if (new_groupchats(tox->mono_time, tox->m) == nullptr) {
        kill_messenger(tox->m);

        mono_time_free(tox->mono_time);
        tox_options_free(default_options);
        tox_unlock(tox);

        if (tox->mutex != nullptr) {
            pthread_mutex_destroy(tox->mutex);
        }

        free(tox->mutex);
        free(tox);

        SET_ERROR_PARAMETER(error, TOX_ERR_NEW_MALLOC);
        return nullptr;
    }

    if (load_savedata_tox
            && tox_load(tox, tox_options_get_savedata_data(opts), tox_options_get_savedata_length(opts)) == -1) {
        kill_groupchats(tox->m->conferences_object);
        kill_messenger(tox->m);

        mono_time_free(tox->mono_time);
        tox_options_free(default_options);
        tox_unlock(tox);

        if (tox->mutex != nullptr) {
            pthread_mutex_destroy(tox->mutex);
        }

        free(tox->mutex);
        free(tox);

        SET_ERROR_PARAMETER(error, TOX_ERR_NEW_LOAD_BAD_FORMAT);
        return nullptr;
    }

    if (load_savedata_sk) {
        load_secret_key(tox->m->net_crypto, tox_options_get_savedata_data(opts));
    }

    m_callback_namechange(tox->m, tox_friend_name_handler);
    m_callback_core_connection(tox->m, tox_self_connection_status_handler);
    m_callback_statusmessage(tox->m, tox_friend_status_message_handler);
    m_callback_userstatus(tox->m, tox_friend_status_handler);
    m_callback_connectionstatus(tox->m, tox_friend_connection_status_handler);
    m_callback_typingchange(tox->m, tox_friend_typing_handler);
    m_callback_read_receipt(tox->m, tox_friend_read_receipt_handler);
    m_callback_friendrequest(tox->m, tox_friend_request_handler);
    m_callback_friendmessage(tox->m, tox_friend_message_handler);
    callback_file_control(tox->m, tox_file_recv_control_handler);
    callback_file_reqchunk(tox->m, tox_file_chunk_request_handler);
    callback_file_sendrequest(tox->m, tox_file_recv_handler);
    callback_file_data(tox->m, tox_file_recv_chunk_handler);
    dht_callback_get_nodes_response(tox->m->dht, tox_dht_get_nodes_response_handler);
    g_callback_group_invite(tox->m->conferences_object, tox_conference_invite_handler);
    g_callback_group_connected(tox->m->conferences_object, tox_conference_connected_handler);
    g_callback_group_message(tox->m->conferences_object, tox_conference_message_handler);
    g_callback_group_title(tox->m->conferences_object, tox_conference_title_handler);
    g_callback_peer_name(tox->m->conferences_object, tox_conference_peer_name_handler);
    g_callback_peer_list_changed(tox->m->conferences_object, tox_conference_peer_list_changed_handler);
    custom_lossy_packet_registerhandler(tox->m, tox_friend_lossy_packet_handler);
    custom_lossless_packet_registerhandler(tox->m, tox_friend_lossless_packet_handler);

#ifndef VANILLA_NACL
    m_callback_group_invite(tox->m, tox_group_invite_handler);
    gc_callback_message(tox->m, tox_group_message_handler);
    gc_callback_private_message(tox->m, tox_group_private_message_handler);
    gc_callback_custom_packet(tox->m, tox_group_custom_packet_handler);
    gc_callback_custom_private_packet(tox->m, tox_group_custom_private_packet_handler);
    gc_callback_moderation(tox->m, tox_group_moderation_handler);
    gc_callback_nick_change(tox->m, tox_group_peer_name_handler);
    gc_callback_status_change(tox->m, tox_group_peer_status_handler);
    gc_callback_connection_status_change(tox->m, tox_group_connection_status_handler);
    gc_callback_topic_change(tox->m, tox_group_topic_handler);
    gc_callback_peer_limit(tox->m, tox_group_peer_limit_handler);
    gc_callback_privacy_state(tox->m, tox_group_privacy_state_handler);
    gc_callback_topic_lock(tox->m, tox_group_topic_lock_handler);
    gc_callback_password(tox->m, tox_group_password_handler);
    gc_callback_peer_join(tox->m, tox_group_peer_join_handler);
    gc_callback_peer_exit(tox->m, tox_group_peer_exit_handler);
    gc_callback_self_join(tox->m, tox_group_self_join_handler);
    gc_callback_rejected(tox->m, tox_group_join_fail_handler);
    gc_callback_voice_state(tox->m, tox_group_voice_state_handler);
#endif

    tox_options_free(default_options);

    tox_unlock(tox);

    SET_ERROR_PARAMETER(error, TOX_ERR_NEW_OK);

    return tox;
}

void tox_kill(Tox *tox)
{
    if (tox == nullptr) {
        return;
    }

    tox_lock(tox);
    LOGGER_ASSERT(tox->m->log, tox->toxav_object == nullptr, "Attempted to kill tox while toxav is still alive");
    kill_groupchats(tox->m->conferences_object);
    kill_messenger(tox->m);
    mono_time_free(tox->mono_time);
    tox_unlock(tox);

    if (tox->mutex != nullptr) {
        pthread_mutex_destroy(tox->mutex);
        free(tox->mutex);
    }

    free(tox);
    tox = nullptr;
}

void tox_get_options(Tox *tox, struct Tox_Options *options)
{
    tox_options_default(options);
    const Messenger_Options *m_options = &tox->m->options;

    // TODO(iphydf): Fill in the other options.
    tox_options_set_log_callback(options, (tox_log_cb *)m_options->log_callback);
    tox_options_set_log_user_data(options, m_options->log_user_data);
}

static uint32_t end_size(void)
{
    return 2 * sizeof(uint32_t);
}

non_null()
static void end_save(uint8_t *data)
{
    state_write_section_header(data, STATE_COOKIE_TYPE, 0, STATE_TYPE_END);
}

size_t tox_get_savedata_size(const Tox *tox)
{
    assert(tox != nullptr);
    tox_lock(tox);
    const size_t ret = 2 * sizeof(uint32_t)
                       + messenger_size(tox->m)
                       + conferences_size(tox->m->conferences_object)
                       + end_size();
    tox_unlock(tox);
    return ret;
}

void tox_get_savedata(const Tox *tox, uint8_t *savedata)
{
    assert(tox != nullptr);

    if (savedata == nullptr) {
        return;
    }

    memset(savedata, 0, tox_get_savedata_size(tox));

    tox_lock(tox);

    const uint32_t size32 = sizeof(uint32_t);

    // write cookie
    memset(savedata, 0, size32);
    savedata += size32;
    host_to_lendian_bytes32(savedata, STATE_COOKIE_GLOBAL);
    savedata += size32;

    savedata = messenger_save(tox->m, savedata);
    savedata = conferences_save(tox->m->conferences_object, savedata);
    end_save(savedata);

    tox_unlock(tox);
}

non_null(5) nullable(1, 2, 4, 6)
static int32_t resolve_bootstrap_node(Tox *tox, const char *host, uint16_t port, const uint8_t *public_key,
                                      IP_Port **root, Tox_Err_Bootstrap *error)
{
    assert(tox != nullptr);
    assert(root != nullptr);

    if (host == nullptr || public_key == nullptr) {
        SET_ERROR_PARAMETER(error, TOX_ERR_BOOTSTRAP_NULL);
        return -1;
    }

    if (port == 0) {
        SET_ERROR_PARAMETER(error, TOX_ERR_BOOTSTRAP_BAD_PORT);
        return -1;
    }

    const int32_t count = net_getipport(host, root, TOX_SOCK_DGRAM);

    if (count == -1) {
        LOGGER_DEBUG(tox->m->log, "could not resolve bootstrap node '%s'", host);
        net_freeipport(*root);
        SET_ERROR_PARAMETER(error, TOX_ERR_BOOTSTRAP_BAD_HOST);
        return -1;
    }

    if (*root == nullptr) {
        return -1;
    }

    assert(*root != nullptr);
    return count;
}

bool tox_bootstrap(Tox *tox, const char *host, uint16_t port, const uint8_t *public_key, Tox_Err_Bootstrap *error)
{
    IP_Port *root;
    const int32_t count = resolve_bootstrap_node(tox, host, port, public_key, &root, error);

    if (count == -1) {
        return false;
    }

    tox_lock(tox);
    assert(count >= 0);
    bool onion_success = false;
    // UDP bootstrap is default success if it's disabled (because we don't even try).
    bool udp_success = tox->m->options.udp_disabled;

    for (int32_t i = 0; i < count; ++i) {
        root[i].port = net_htons(port);

        if (onion_add_bs_path_node(tox->m->onion_c, &root[i], public_key)) {
            // If UDP is enabled, the caller cares about whether any of the
            // bootstrap calls below will succeed. In TCP-only mode, adding
            // onion path nodes successfully is sufficient.
            onion_success = true;
        }

        if (!tox->m->options.udp_disabled) {
            if (dht_bootstrap(tox->m->dht, &root[i], public_key)) {
                // If any of the bootstrap calls worked, we call it success.
                udp_success = true;
            }
        }
    }

    tox_unlock(tox);

    net_freeipport(root);

    if (count == 0 || !onion_success || !udp_success) {
        LOGGER_DEBUG(tox->m->log, "bootstrap node '%s' resolved to %d IP_Ports%s (onion: %s, UDP: %s)",
                     host, count,
                     count > 0 ? ", but failed to bootstrap with any of them" : "",
                     onion_success ? "success" : "FAILURE",
                     tox->m->options.udp_disabled ? "disabled" : (udp_success ? "success" : "FAILURE"));
        SET_ERROR_PARAMETER(error, TOX_ERR_BOOTSTRAP_BAD_HOST);
        return false;
    }

    SET_ERROR_PARAMETER(error, TOX_ERR_BOOTSTRAP_OK);
    return true;
}

bool tox_add_tcp_relay(Tox *tox, const char *host, uint16_t port, const uint8_t *public_key,
                       Tox_Err_Bootstrap *error)
{
    IP_Port *root;
    const int32_t count = resolve_bootstrap_node(tox, host, port, public_key, &root, error);

    if (count == -1) {
        return false;
    }

    tox_lock(tox);
    assert(count >= 0);

    for (int32_t i = 0; i < count; ++i) {
        root[i].port = net_htons(port);

        add_tcp_relay(tox->m->net_crypto, &root[i], public_key);
    }

    tox_unlock(tox);

    net_freeipport(root);

    if (count == 0) {
        SET_ERROR_PARAMETER(error, TOX_ERR_BOOTSTRAP_BAD_HOST);
        return false;
    }

    SET_ERROR_PARAMETER(error, TOX_ERR_BOOTSTRAP_OK);
    return true;
}

Tox_Connection tox_self_get_connection_status(const Tox *tox)
{
    assert(tox != nullptr);
    tox_lock(tox);
    const Onion_Connection_Status ret = onion_connection_status(tox->m->onion_c, true);
    tox_unlock(tox);

    switch (ret) {
        case ONION_CONNECTION_STATUS_NONE:
            return TOX_CONNECTION_NONE;

        case ONION_CONNECTION_STATUS_TCP:
            return TOX_CONNECTION_TCP;

        case ONION_CONNECTION_STATUS_UDP:
            return TOX_CONNECTION_UDP;
    }

    LOGGER_FATAL(tox->m->log, "impossible return value: %d", ret);
}


void tox_callback_self_connection_status(Tox *tox, tox_self_connection_status_cb *callback)
{
    assert(tox != nullptr);
    tox->self_connection_status_callback = callback;
}

uint32_t tox_iteration_interval(const Tox *tox)
{
    assert(tox != nullptr);
    tox_lock(tox);
    uint32_t ret = messenger_run_interval(tox->m);

    tox_unlock(tox);
    return ret;
}

void tox_iterate(Tox *tox, void *user_data)
{
    assert(tox != nullptr);
    tox_lock(tox);

    mono_time_update(tox->mono_time);

    struct Tox_Userdata tox_data = { tox, user_data };
    do_messenger(tox->m, &tox_data);
    do_groupchats(tox->m->conferences_object, &tox_data);

    tox_unlock(tox);
}

void tox_self_get_address(const Tox *tox, uint8_t *address)
{
    assert(tox != nullptr);

    if (address != nullptr) {
        tox_lock(tox);
        getaddress(tox->m, address);
        tox_unlock(tox);
    }
}

void tox_self_set_nospam(Tox *tox, uint32_t nospam)
{
    assert(tox != nullptr);
    tox_lock(tox);
    set_nospam(tox->m->fr, net_htonl(nospam));
    tox_unlock(tox);
}

uint32_t tox_self_get_nospam(const Tox *tox)
{
    assert(tox != nullptr);
    tox_lock(tox);
    const uint32_t ret = net_ntohl(get_nospam(tox->m->fr));
    tox_unlock(tox);
    return ret;
}

void tox_self_get_public_key(const Tox *tox, uint8_t *public_key)
{
    assert(tox != nullptr);

    if (public_key != nullptr) {
        tox_lock(tox);
        memcpy(public_key, nc_get_self_public_key(tox->m->net_crypto), CRYPTO_PUBLIC_KEY_SIZE);
        tox_unlock(tox);
    }
}

void tox_self_get_secret_key(const Tox *tox, uint8_t *secret_key)
{
    assert(tox != nullptr);

    if (secret_key != nullptr) {
        tox_lock(tox);
        memcpy(secret_key, nc_get_self_secret_key(tox->m->net_crypto), CRYPTO_SECRET_KEY_SIZE);
        tox_unlock(tox);
    }
}

bool tox_self_set_name(Tox *tox, const uint8_t *name, size_t length, Tox_Err_Set_Info *error)
{
    assert(tox != nullptr);

    if (name == nullptr && length != 0) {
        SET_ERROR_PARAMETER(error, TOX_ERR_SET_INFO_NULL);
        return false;
    }

    tox_lock(tox);

    if (setname(tox->m, name, length) == 0) {
        // TODO(irungentoo): function to set different per group names?
        send_name_all_groups(tox->m->conferences_object);
        SET_ERROR_PARAMETER(error, TOX_ERR_SET_INFO_OK);
        tox_unlock(tox);
        return true;
    }

    SET_ERROR_PARAMETER(error, TOX_ERR_SET_INFO_TOO_LONG);
    tox_unlock(tox);
    return false;
}

bool tox_messagev3_get_new_message_id(uint8_t *msg_id)
{
    if (msg_id == nullptr) {
        return false;
    }

    /* Tox keys are 32 bytes like TOX_MSGV3_MSGID_LENGTH. */
    new_symmetric_key_implicit_random(msg_id);
    return true;
}

size_t tox_self_get_name_size(const Tox *tox)
{
    assert(tox != nullptr);
    tox_lock(tox);
    const size_t ret = m_get_self_name_size(tox->m);
    tox_unlock(tox);
    return ret;
}

void tox_self_get_name(const Tox *tox, uint8_t *name)
{
    assert(tox != nullptr);

    if (name != nullptr) {
        tox_lock(tox);
        getself_name(tox->m, name);
        tox_unlock(tox);
    }
}

bool tox_self_set_status_message(Tox *tox, const uint8_t *status_message, size_t length, Tox_Err_Set_Info *error)
{
    assert(tox != nullptr);

    if (status_message == nullptr && length != 0) {
        SET_ERROR_PARAMETER(error, TOX_ERR_SET_INFO_NULL);
        return false;
    }

    tox_lock(tox);

    if (m_set_statusmessage(tox->m, status_message, length) == 0) {
        SET_ERROR_PARAMETER(error, TOX_ERR_SET_INFO_OK);
        tox_unlock(tox);
        return true;
    }

    SET_ERROR_PARAMETER(error, TOX_ERR_SET_INFO_TOO_LONG);
    tox_unlock(tox);
    return false;
}

size_t tox_self_get_status_message_size(const Tox *tox)
{
    assert(tox != nullptr);
    tox_lock(tox);
    const size_t ret = m_get_self_statusmessage_size(tox->m);
    tox_unlock(tox);
    return ret;
}

void tox_self_get_status_message(const Tox *tox, uint8_t *status_message)
{
    assert(tox != nullptr);

    if (status_message != nullptr) {
        tox_lock(tox);
        m_copy_self_statusmessage(tox->m, status_message);
        tox_unlock(tox);
    }
}

void tox_self_set_status(Tox *tox, Tox_User_Status status)
{
    assert(tox != nullptr);
    tox_lock(tox);
    m_set_userstatus(tox->m, status);
    tox_unlock(tox);
}

Tox_User_Status tox_self_get_status(const Tox *tox)
{
    assert(tox != nullptr);
    tox_lock(tox);
    const uint8_t status = m_get_self_userstatus(tox->m);
    tox_unlock(tox);
    return (Tox_User_Status)status;
}

non_null(1) nullable(3)
static void set_friend_error(const Logger *log, int32_t ret, Tox_Err_Friend_Add *error)
{
    switch (ret) {
        case FAERR_TOOLONG: {
            SET_ERROR_PARAMETER(error, TOX_ERR_FRIEND_ADD_TOO_LONG);
            break;
        }

        case FAERR_NOMESSAGE: {
            SET_ERROR_PARAMETER(error, TOX_ERR_FRIEND_ADD_NO_MESSAGE);
            break;
        }

        case FAERR_OWNKEY: {
            SET_ERROR_PARAMETER(error, TOX_ERR_FRIEND_ADD_OWN_KEY);
            break;
        }

        case FAERR_ALREADYSENT: {
            SET_ERROR_PARAMETER(error, TOX_ERR_FRIEND_ADD_ALREADY_SENT);
            break;
        }

        case FAERR_BADCHECKSUM: {
            SET_ERROR_PARAMETER(error, TOX_ERR_FRIEND_ADD_BAD_CHECKSUM);
            break;
        }

        case FAERR_SETNEWNOSPAM: {
            SET_ERROR_PARAMETER(error, TOX_ERR_FRIEND_ADD_SET_NEW_NOSPAM);
            break;
        }

        case FAERR_NOMEM: {
            SET_ERROR_PARAMETER(error, TOX_ERR_FRIEND_ADD_MALLOC);
            break;
        }

        default: {
            /* can't happen */
            LOGGER_FATAL(log, "impossible return value: %d", ret);
            break;
        }
    }
}

uint32_t tox_friend_add(Tox *tox, const uint8_t *address, const uint8_t *message, size_t length,
                        Tox_Err_Friend_Add *error)
{
    assert(tox != nullptr);

    if (address == nullptr || message == nullptr) {
        SET_ERROR_PARAMETER(error, TOX_ERR_FRIEND_ADD_NULL);
        return UINT32_MAX;
    }

    tox_lock(tox);
    const int32_t ret = m_addfriend(tox->m, address, message, length);

    if (ret >= 0) {
        SET_ERROR_PARAMETER(error, TOX_ERR_FRIEND_ADD_OK);
        tox_unlock(tox);
        return (uint32_t)ret;
    }

    set_friend_error(tox->m->log, ret, error);
    tox_unlock(tox);
    return UINT32_MAX;
}

uint32_t tox_friend_add_norequest(Tox *tox, const uint8_t *public_key, Tox_Err_Friend_Add *error)
{
    assert(tox != nullptr);

    if (public_key == nullptr) {
        SET_ERROR_PARAMETER(error, TOX_ERR_FRIEND_ADD_NULL);
        return UINT32_MAX;
    }

    tox_lock(tox);
    const int32_t ret = m_addfriend_norequest(tox->m, public_key);

    if (ret >= 0) {
        SET_ERROR_PARAMETER(error, TOX_ERR_FRIEND_ADD_OK);
        tox_unlock(tox);
        return (uint32_t)ret;
    }

    set_friend_error(tox->m->log, ret, error);
    tox_unlock(tox);
    return UINT32_MAX;
}

bool tox_friend_delete(Tox *tox, uint32_t friend_number, Tox_Err_Friend_Delete *error)
{
    assert(tox != nullptr);
    tox_lock(tox);
    const int ret = m_delfriend(tox->m, friend_number);
    tox_unlock(tox);

    // TODO(irungentoo): handle if realloc fails?
    if (ret == -1) {
        SET_ERROR_PARAMETER(error, TOX_ERR_FRIEND_DELETE_FRIEND_NOT_FOUND);
        return false;
    }

    SET_ERROR_PARAMETER(error, TOX_ERR_FRIEND_DELETE_OK);
    return true;
}

uint32_t tox_friend_by_public_key(const Tox *tox, const uint8_t *public_key, Tox_Err_Friend_By_Public_Key *error)
{
    assert(tox != nullptr);

    if (public_key == nullptr) {
        SET_ERROR_PARAMETER(error, TOX_ERR_FRIEND_BY_PUBLIC_KEY_NULL);
        return UINT32_MAX;
    }

    tox_lock(tox);
    const int32_t ret = getfriend_id(tox->m, public_key);
    tox_unlock(tox);

    if (ret == -1) {
        SET_ERROR_PARAMETER(error, TOX_ERR_FRIEND_BY_PUBLIC_KEY_NOT_FOUND);
        return UINT32_MAX;
    }

    SET_ERROR_PARAMETER(error, TOX_ERR_FRIEND_BY_PUBLIC_KEY_OK);
    assert(ret >= 0);
    return (uint32_t)ret;
}

bool tox_friend_get_public_key(const Tox *tox, uint32_t friend_number, uint8_t *public_key,
                               Tox_Err_Friend_Get_Public_Key *error)
{
    assert(tox != nullptr);

    if (public_key == nullptr) {
        return false;
    }

    tox_lock(tox);

    if (get_real_pk(tox->m, friend_number, public_key) == -1) {
        SET_ERROR_PARAMETER(error, TOX_ERR_FRIEND_GET_PUBLIC_KEY_FRIEND_NOT_FOUND);
        tox_unlock(tox);
        return false;
    }

    SET_ERROR_PARAMETER(error, TOX_ERR_FRIEND_GET_PUBLIC_KEY_OK);
    tox_unlock(tox);
    return true;
}

bool tox_friend_exists(const Tox *tox, uint32_t friend_number)
{
    assert(tox != nullptr);
    tox_lock(tox);
    const bool ret = m_friend_exists(tox->m, friend_number);
    tox_unlock(tox);
    return ret;
}

uint64_t tox_friend_get_last_online(const Tox *tox, uint32_t friend_number, Tox_Err_Friend_Get_Last_Online *error)
{
    assert(tox != nullptr);
    tox_lock(tox);
    const uint64_t timestamp = m_get_last_online(tox->m, friend_number);
    tox_unlock(tox);

    if (timestamp == UINT64_MAX) {
        SET_ERROR_PARAMETER(error, TOX_ERR_FRIEND_GET_LAST_ONLINE_FRIEND_NOT_FOUND);
        return UINT64_MAX;
    }

    SET_ERROR_PARAMETER(error, TOX_ERR_FRIEND_GET_LAST_ONLINE_OK);
    return timestamp;
}

uint64_t tox_friend_get_capabilities(const Tox *tox, uint32_t friend_number)
{
    tox_lock(tox);
    const uint64_t capabilities = m_get_friend_toxcore_capabilities(tox->m, friend_number);
    tox_unlock(tox);

    return capabilities;
}

uint64_t tox_self_get_capabilities(void)
{
    return (TOX_CAPABILITIES_CURRENT);
}

size_t tox_self_get_friend_list_size(const Tox *tox)
{
    assert(tox != nullptr);
    tox_lock(tox);
    const size_t ret = count_friendlist(tox->m);
    tox_unlock(tox);
    return ret;
}

void tox_self_get_friend_list(const Tox *tox, uint32_t *friend_list)
{
    assert(tox != nullptr);

    if (friend_list != nullptr) {
        tox_lock(tox);
        // TODO(irungentoo): size parameter?
        copy_friendlist(tox->m, friend_list, count_friendlist(tox->m));
        tox_unlock(tox);
    }
}

size_t tox_friend_get_name_size(const Tox *tox, uint32_t friend_number, Tox_Err_Friend_Query *error)
{
    assert(tox != nullptr);
    tox_lock(tox);
    const int ret = m_get_name_size(tox->m, friend_number);
    tox_unlock(tox);

    if (ret == -1) {
        SET_ERROR_PARAMETER(error, TOX_ERR_FRIEND_QUERY_FRIEND_NOT_FOUND);
        return SIZE_MAX;
    }

    SET_ERROR_PARAMETER(error, TOX_ERR_FRIEND_QUERY_OK);
    return ret;
}

bool tox_friend_get_name(const Tox *tox, uint32_t friend_number, uint8_t *name, Tox_Err_Friend_Query *error)
{
    assert(tox != nullptr);

    if (name == nullptr) {
        SET_ERROR_PARAMETER(error, TOX_ERR_FRIEND_QUERY_NULL);
        return false;
    }

    tox_lock(tox);
    const int ret = getname(tox->m, friend_number, name);
    tox_unlock(tox);

    if (ret == -1) {
        SET_ERROR_PARAMETER(error, TOX_ERR_FRIEND_QUERY_FRIEND_NOT_FOUND);
        return false;
    }

    SET_ERROR_PARAMETER(error, TOX_ERR_FRIEND_QUERY_OK);
    return true;
}

void tox_callback_friend_name(Tox *tox, tox_friend_name_cb *callback)
{
    assert(tox != nullptr);
    tox->friend_name_callback = callback;
}

size_t tox_friend_get_status_message_size(const Tox *tox, uint32_t friend_number, Tox_Err_Friend_Query *error)
{
    assert(tox != nullptr);
    tox_lock(tox);
    const int ret = m_get_statusmessage_size(tox->m, friend_number);
    tox_unlock(tox);

    if (ret == -1) {
        SET_ERROR_PARAMETER(error, TOX_ERR_FRIEND_QUERY_FRIEND_NOT_FOUND);
        return SIZE_MAX;
    }

    SET_ERROR_PARAMETER(error, TOX_ERR_FRIEND_QUERY_OK);
    return ret;
}

bool tox_friend_get_status_message(const Tox *tox, uint32_t friend_number, uint8_t *status_message,
                                   Tox_Err_Friend_Query *error)
{
    assert(tox != nullptr);

    if (status_message == nullptr) {
        SET_ERROR_PARAMETER(error, TOX_ERR_FRIEND_QUERY_NULL);
        return false;
    }

    tox_lock(tox);
    const int size = m_get_statusmessage_size(tox->m, friend_number);

    if (size == -1) {
        SET_ERROR_PARAMETER(error, TOX_ERR_FRIEND_QUERY_FRIEND_NOT_FOUND);
        tox_unlock(tox);
        return false;
    }

    const int ret = m_copy_statusmessage(tox->m, friend_number, status_message, size);
    LOGGER_ASSERT(tox->m->log, ret == size, "concurrency problem: friend status message changed");

    SET_ERROR_PARAMETER(error, TOX_ERR_FRIEND_QUERY_OK);
    tox_unlock(tox);
    return ret == size;
}

void tox_callback_friend_status_message(Tox *tox, tox_friend_status_message_cb *callback)
{
    assert(tox != nullptr);
    tox->friend_status_message_callback = callback;
}

Tox_User_Status tox_friend_get_status(const Tox *tox, uint32_t friend_number, Tox_Err_Friend_Query *error)
{
    assert(tox != nullptr);
    tox_lock(tox);
    const int ret = m_get_userstatus(tox->m, friend_number);
    tox_unlock(tox);

    if (ret == USERSTATUS_INVALID) {
        SET_ERROR_PARAMETER(error, TOX_ERR_FRIEND_QUERY_FRIEND_NOT_FOUND);
        return TOX_USER_STATUS_NONE;
    }

    SET_ERROR_PARAMETER(error, TOX_ERR_FRIEND_QUERY_OK);
    return (Tox_User_Status)ret;
}

void tox_callback_friend_status(Tox *tox, tox_friend_status_cb *callback)
{
    assert(tox != nullptr);
    tox->friend_status_callback = callback;
}

Tox_Connection tox_friend_get_connection_status(const Tox *tox, uint32_t friend_number, Tox_Err_Friend_Query *error)
{
    assert(tox != nullptr);
    tox_lock(tox);
    const int ret = m_get_friend_connectionstatus(tox->m, friend_number);
    tox_unlock(tox);

    if (ret == -1) {
        SET_ERROR_PARAMETER(error, TOX_ERR_FRIEND_QUERY_FRIEND_NOT_FOUND);
        return TOX_CONNECTION_NONE;
    }

    SET_ERROR_PARAMETER(error, TOX_ERR_FRIEND_QUERY_OK);
    return (Tox_Connection)ret;
}

void tox_friend_get_connection_ip(const Tox *tox, uint32_t friend_number, uint8_t *ip_str)
{
    if (ip_str == nullptr) {
        return;
    }
    assert(tox != nullptr);
    tox_lock(tox);
    m_get_friend_connection_ip(tox->m, friend_number, ip_str);
    tox_unlock(tox);
}


void tox_callback_friend_connection_status(Tox *tox, tox_friend_connection_status_cb *callback)
{
    assert(tox != nullptr);
    tox->friend_connection_status_callback = callback;
}

bool tox_friend_get_typing(const Tox *tox, uint32_t friend_number, Tox_Err_Friend_Query *error)
{
    assert(tox != nullptr);
    tox_lock(tox);
    const int ret = m_get_istyping(tox->m, friend_number);
    tox_unlock(tox);

    if (ret == -1) {
        SET_ERROR_PARAMETER(error, TOX_ERR_FRIEND_QUERY_FRIEND_NOT_FOUND);
        return false;
    }

    SET_ERROR_PARAMETER(error, TOX_ERR_FRIEND_QUERY_OK);
    return ret != 0;
}

void tox_callback_friend_typing(Tox *tox, tox_friend_typing_cb *callback)
{
    assert(tox != nullptr);
    tox->friend_typing_callback = callback;
}

bool tox_self_set_typing(Tox *tox, uint32_t friend_number, bool typing, Tox_Err_Set_Typing *error)
{
    assert(tox != nullptr);
    tox_lock(tox);

    if (m_set_usertyping(tox->m, friend_number, typing) == -1) {
        SET_ERROR_PARAMETER(error, TOX_ERR_SET_TYPING_FRIEND_NOT_FOUND);
        tox_unlock(tox);
        return false;
    }

    SET_ERROR_PARAMETER(error, TOX_ERR_SET_TYPING_OK);
    tox_unlock(tox);
    return true;
}

non_null(1) nullable(3)
static void set_message_error(const Logger *log, int ret, Tox_Err_Friend_Send_Message *error)
{
    switch (ret) {
        case 0: {
            SET_ERROR_PARAMETER(error, TOX_ERR_FRIEND_SEND_MESSAGE_OK);
            break;
        }

        case -1: {
            SET_ERROR_PARAMETER(error, TOX_ERR_FRIEND_SEND_MESSAGE_FRIEND_NOT_FOUND);
            break;
        }

        case -2: {
            SET_ERROR_PARAMETER(error, TOX_ERR_FRIEND_SEND_MESSAGE_TOO_LONG);
            break;
        }

        case -3: {
            SET_ERROR_PARAMETER(error, TOX_ERR_FRIEND_SEND_MESSAGE_FRIEND_NOT_CONNECTED);
            break;
        }

        case -4: {
            SET_ERROR_PARAMETER(error, TOX_ERR_FRIEND_SEND_MESSAGE_SENDQ);
            break;
        }

        case -5: {
            LOGGER_FATAL(log, "impossible: Messenger and Tox disagree on message types");
            break;
        }

        default: {
            /* can't happen */
            LOGGER_FATAL(log, "impossible return value: %d", ret);
            break;
        }
    }
}

uint32_t tox_friend_send_message(Tox *tox, uint32_t friend_number, Tox_Message_Type type, const uint8_t *message,
                                 size_t length, Tox_Err_Friend_Send_Message *error)
{
    assert(tox != nullptr);

    if (message == nullptr) {
        SET_ERROR_PARAMETER(error, TOX_ERR_FRIEND_SEND_MESSAGE_NULL);
        return 0;
    }

    if (length == 0) {
        SET_ERROR_PARAMETER(error, TOX_ERR_FRIEND_SEND_MESSAGE_EMPTY);
        return 0;
    }

    uint32_t message_id = 0;
    tox_lock(tox);
    set_message_error(tox->m->log, m_send_message_generic(tox->m, friend_number, type, message, length, &message_id),
                      error);
    tox_unlock(tox);
    return message_id;
}

void tox_callback_friend_read_receipt(Tox *tox, tox_friend_read_receipt_cb *callback)
{
    assert(tox != nullptr);
    tox->friend_read_receipt_callback = callback;
}

void tox_callback_friend_request(Tox *tox, tox_friend_request_cb *callback)
{
    assert(tox != nullptr);
    tox->friend_request_callback = callback;
}

void tox_callback_friend_message(Tox *tox, tox_friend_message_cb *callback)
{
    assert(tox != nullptr);
    tox->friend_message_callback = callback;
}

bool tox_hash(uint8_t *hash, const uint8_t *data, size_t length)
{
    if (hash == nullptr || (data == nullptr && length != 0)) {
        return false;
    }

    crypto_sha256(hash, data, length);
    return true;
}

bool tox_file_control(Tox *tox, uint32_t friend_number, uint32_t file_number, Tox_File_Control control,
                      Tox_Err_File_Control *error)
{
    assert(tox != nullptr);
    tox_lock(tox);
    const int ret = file_control(tox->m, friend_number, file_number, control);
    tox_unlock(tox);

    if (ret == 0) {
        SET_ERROR_PARAMETER(error, TOX_ERR_FILE_CONTROL_OK);
        return true;
    }

    switch (ret) {
        case -1: {
            SET_ERROR_PARAMETER(error, TOX_ERR_FILE_CONTROL_FRIEND_NOT_FOUND);
            return false;
        }

        case -2: {
            SET_ERROR_PARAMETER(error, TOX_ERR_FILE_CONTROL_FRIEND_NOT_CONNECTED);
            return false;
        }

        case -3: {
            SET_ERROR_PARAMETER(error, TOX_ERR_FILE_CONTROL_NOT_FOUND);
            return false;
        }

        case -4: {
            /* can't happen (this code is returned if `control` is invalid type) */
            LOGGER_FATAL(tox->m->log, "impossible return value: %d", ret);
            return false;
        }

        case -5: {
            SET_ERROR_PARAMETER(error, TOX_ERR_FILE_CONTROL_ALREADY_PAUSED);
            return false;
        }

        case -6: {
            SET_ERROR_PARAMETER(error, TOX_ERR_FILE_CONTROL_DENIED);
            return false;
        }

        case -7: {
            SET_ERROR_PARAMETER(error, TOX_ERR_FILE_CONTROL_NOT_PAUSED);
            return false;
        }

        case -8: {
            SET_ERROR_PARAMETER(error, TOX_ERR_FILE_CONTROL_SENDQ);
            return false;
        }
    }

    /* can't happen */
    LOGGER_FATAL(tox->m->log, "impossible return value: %d", ret);

    return false;
}

bool tox_file_seek(Tox *tox, uint32_t friend_number, uint32_t file_number, uint64_t position,
                   Tox_Err_File_Seek *error)
{
    assert(tox != nullptr);
    tox_lock(tox);
    const int ret = file_seek(tox->m, friend_number, file_number, position);
    tox_unlock(tox);

    if (ret == 0) {
        SET_ERROR_PARAMETER(error, TOX_ERR_FILE_SEEK_OK);
        return true;
    }

    switch (ret) {
        case -1: {
            SET_ERROR_PARAMETER(error, TOX_ERR_FILE_SEEK_FRIEND_NOT_FOUND);
            return false;
        }

        case -2: {
            SET_ERROR_PARAMETER(error, TOX_ERR_FILE_SEEK_FRIEND_NOT_CONNECTED);
            return false;
        }

        case -3: {
            SET_ERROR_PARAMETER(error, TOX_ERR_FILE_SEEK_NOT_FOUND);
            return false;
        }

        case -4: // fall-through
        case -5: {
            SET_ERROR_PARAMETER(error, TOX_ERR_FILE_SEEK_DENIED);
            return false;
        }

        case -6: {
            SET_ERROR_PARAMETER(error, TOX_ERR_FILE_SEEK_INVALID_POSITION);
            return false;
        }

        case -8: {
            SET_ERROR_PARAMETER(error, TOX_ERR_FILE_SEEK_SENDQ);
            return false;
        }
    }

    /* can't happen */
    LOGGER_FATAL(tox->m->log, "impossible return value: %d", ret);

    return false;
}

void tox_callback_file_recv_control(Tox *tox, tox_file_recv_control_cb *callback)
{
    assert(tox != nullptr);
    tox->file_recv_control_callback = callback;
}

bool tox_file_get_file_id(const Tox *tox, uint32_t friend_number, uint32_t file_number, uint8_t *file_id,
                          Tox_Err_File_Get *error)
{
    assert(tox != nullptr);

    if (file_id == nullptr) {
        SET_ERROR_PARAMETER(error, TOX_ERR_FILE_GET_NULL);
        return false;
    }

    tox_lock(tox);
    const int ret = file_get_id(tox->m, friend_number, file_number, file_id);
    tox_unlock(tox);

    if (ret == 0) {
        SET_ERROR_PARAMETER(error, TOX_ERR_FILE_GET_OK);
        return true;
    }

    if (ret == -1) {
        SET_ERROR_PARAMETER(error, TOX_ERR_FILE_GET_FRIEND_NOT_FOUND);
    } else {
        SET_ERROR_PARAMETER(error, TOX_ERR_FILE_GET_NOT_FOUND);
    }

    return false;
}

uint32_t tox_file_send(Tox *tox, uint32_t friend_number, uint32_t kind, uint64_t file_size, const uint8_t *file_id,
                       const uint8_t *filename, size_t filename_length, Tox_Err_File_Send *error)
{
    assert(tox != nullptr);

    if (filename == nullptr && filename_length != 0) {
        SET_ERROR_PARAMETER(error, TOX_ERR_FILE_SEND_NULL);
        return UINT32_MAX;
    }

    uint8_t f_id[FILE_ID_LENGTH];

    if (file_id == nullptr) {
        /* Tox keys are 32 bytes like FILE_ID_LENGTH. */
        new_symmetric_key(&tox->rng, f_id);
        file_id = f_id;
    }

    tox_lock(tox);
    const long int file_num = new_filesender(tox->m, friend_number, kind, file_size, file_id, filename, filename_length);
    tox_unlock(tox);

    if (file_num >= 0) {
        SET_ERROR_PARAMETER(error, TOX_ERR_FILE_SEND_OK);
        return file_num;
    }

    switch (file_num) {
        case -1: {
            SET_ERROR_PARAMETER(error, TOX_ERR_FILE_SEND_FRIEND_NOT_FOUND);
            return UINT32_MAX;
        }

        case -2: {
            SET_ERROR_PARAMETER(error, TOX_ERR_FILE_SEND_NAME_TOO_LONG);
            return UINT32_MAX;
        }

        case -3: {
            SET_ERROR_PARAMETER(error, TOX_ERR_FILE_SEND_TOO_MANY);
            return UINT32_MAX;
        }

        case -4: {
            SET_ERROR_PARAMETER(error, TOX_ERR_FILE_SEND_FRIEND_NOT_CONNECTED);
            return UINT32_MAX;
        }
    }

    /* can't happen */
    LOGGER_FATAL(tox->m->log, "impossible return value: %ld", file_num);

    return UINT32_MAX;
}

bool tox_file_send_chunk(Tox *tox, uint32_t friend_number, uint32_t file_number, uint64_t position, const uint8_t *data,
                         size_t length, Tox_Err_File_Send_Chunk *error)
{
    assert(tox != nullptr);
    tox_lock(tox);
    const int ret = send_file_data(tox->m, friend_number, file_number, position, data, length);
    tox_unlock(tox);

    if (ret == 0) {
        SET_ERROR_PARAMETER(error, TOX_ERR_FILE_SEND_CHUNK_OK);
        return true;
    }

    switch (ret) {
        case -1: {
            SET_ERROR_PARAMETER(error, TOX_ERR_FILE_SEND_CHUNK_FRIEND_NOT_FOUND);
            return false;
        }

        case -2: {
            SET_ERROR_PARAMETER(error, TOX_ERR_FILE_SEND_CHUNK_FRIEND_NOT_CONNECTED);
            return false;
        }

        case -3: {
            SET_ERROR_PARAMETER(error, TOX_ERR_FILE_SEND_CHUNK_NOT_FOUND);
            return false;
        }

        case -4: {
            SET_ERROR_PARAMETER(error, TOX_ERR_FILE_SEND_CHUNK_NOT_TRANSFERRING);
            return false;
        }

        case -5: {
            SET_ERROR_PARAMETER(error, TOX_ERR_FILE_SEND_CHUNK_INVALID_LENGTH);
            return false;
        }

        case -6: {
            SET_ERROR_PARAMETER(error, TOX_ERR_FILE_SEND_CHUNK_SENDQ);
            return false;
        }

        case -7: {
            SET_ERROR_PARAMETER(error, TOX_ERR_FILE_SEND_CHUNK_WRONG_POSITION);
            return false;
        }
    }

    /* can't happen */
    LOGGER_FATAL(tox->m->log, "impossible return value: %d", ret);

    return false;
}

void tox_callback_file_chunk_request(Tox *tox, tox_file_chunk_request_cb *callback)
{
    assert(tox != nullptr);
    tox->file_chunk_request_callback = callback;
}

void tox_callback_file_recv(Tox *tox, tox_file_recv_cb *callback)
{
    assert(tox != nullptr);
    tox->file_recv_callback = callback;
}

void tox_callback_file_recv_chunk(Tox *tox, tox_file_recv_chunk_cb *callback)
{
    assert(tox != nullptr);
    tox->file_recv_chunk_callback = callback;
}

void tox_callback_conference_invite(Tox *tox, tox_conference_invite_cb *callback)
{
    assert(tox != nullptr);
    tox->conference_invite_callback = callback;
}

void tox_callback_conference_connected(Tox *tox, tox_conference_connected_cb *callback)
{
    assert(tox != nullptr);
    tox->conference_connected_callback = callback;
}

void tox_callback_conference_message(Tox *tox, tox_conference_message_cb *callback)
{
    assert(tox != nullptr);
    tox->conference_message_callback = callback;
}

void tox_callback_conference_title(Tox *tox, tox_conference_title_cb *callback)
{
    assert(tox != nullptr);
    tox->conference_title_callback = callback;
}

void tox_callback_conference_peer_name(Tox *tox, tox_conference_peer_name_cb *callback)
{
    assert(tox != nullptr);
    tox->conference_peer_name_callback = callback;
}

void tox_callback_conference_peer_list_changed(Tox *tox, tox_conference_peer_list_changed_cb *callback)
{
    assert(tox != nullptr);
    tox->conference_peer_list_changed_callback = callback;
}

uint32_t tox_conference_new(Tox *tox, Tox_Err_Conference_New *error)
{
    assert(tox != nullptr);
    tox_lock(tox);
    const int ret = add_groupchat(tox->m->conferences_object, &tox->rng, GROUPCHAT_TYPE_TEXT);
    tox_unlock(tox);

    if (ret == -1) {
        SET_ERROR_PARAMETER(error, TOX_ERR_CONFERENCE_NEW_INIT);
        return UINT32_MAX;
    }

    SET_ERROR_PARAMETER(error, TOX_ERR_CONFERENCE_NEW_OK);
    return ret;
}

bool tox_conference_delete(Tox *tox, uint32_t conference_number, Tox_Err_Conference_Delete *error)
{
    assert(tox != nullptr);
    tox_lock(tox);
    const bool ret = del_groupchat(tox->m->conferences_object, conference_number, true);
    tox_unlock(tox);

    if (!ret) {
        SET_ERROR_PARAMETER(error, TOX_ERR_CONFERENCE_DELETE_CONFERENCE_NOT_FOUND);
        return false;
    }

    SET_ERROR_PARAMETER(error, TOX_ERR_CONFERENCE_DELETE_OK);
    return true;
}

uint32_t tox_conference_peer_count(const Tox *tox, uint32_t conference_number, Tox_Err_Conference_Peer_Query *error)
{
    assert(tox != nullptr);
    tox_lock(tox);
    const int ret = group_number_peers(tox->m->conferences_object, conference_number, false);
    tox_unlock(tox);

    if (ret == -1) {
        SET_ERROR_PARAMETER(error, TOX_ERR_CONFERENCE_PEER_QUERY_CONFERENCE_NOT_FOUND);
        return UINT32_MAX;
    }

    SET_ERROR_PARAMETER(error, TOX_ERR_CONFERENCE_PEER_QUERY_OK);
    return ret;
}

size_t tox_conference_peer_get_name_size(const Tox *tox, uint32_t conference_number, uint32_t peer_number,
        Tox_Err_Conference_Peer_Query *error)
{
    assert(tox != nullptr);
    tox_lock(tox);
    const int ret = group_peername_size(tox->m->conferences_object, conference_number, peer_number, false);
    tox_unlock(tox);

    switch (ret) {
        case -1: {
            SET_ERROR_PARAMETER(error, TOX_ERR_CONFERENCE_PEER_QUERY_CONFERENCE_NOT_FOUND);
            return -1;
        }

        case -2: {
            SET_ERROR_PARAMETER(error, TOX_ERR_CONFERENCE_PEER_QUERY_PEER_NOT_FOUND);
            return -1;
        }
    }

    SET_ERROR_PARAMETER(error, TOX_ERR_CONFERENCE_PEER_QUERY_OK);
    return ret;
}

bool tox_conference_peer_get_name(const Tox *tox, uint32_t conference_number, uint32_t peer_number, uint8_t *name,
                                  Tox_Err_Conference_Peer_Query *error)
{
    assert(tox != nullptr);
    tox_lock(tox);
    const int ret = group_peername(tox->m->conferences_object, conference_number, peer_number, name, false);
    tox_unlock(tox);

    switch (ret) {
        case -1: {
            SET_ERROR_PARAMETER(error, TOX_ERR_CONFERENCE_PEER_QUERY_CONFERENCE_NOT_FOUND);
            return false;
        }

        case -2: {
            SET_ERROR_PARAMETER(error, TOX_ERR_CONFERENCE_PEER_QUERY_PEER_NOT_FOUND);
            return false;
        }
    }

    SET_ERROR_PARAMETER(error, TOX_ERR_CONFERENCE_PEER_QUERY_OK);
    return true;
}

bool tox_conference_peer_get_public_key(const Tox *tox, uint32_t conference_number, uint32_t peer_number,
                                        uint8_t *public_key, Tox_Err_Conference_Peer_Query *error)
{
    assert(tox != nullptr);
    tox_lock(tox);
    const int ret = group_peer_pubkey(tox->m->conferences_object, conference_number, peer_number, public_key, false);
    tox_unlock(tox);

    switch (ret) {
        case -1: {
            SET_ERROR_PARAMETER(error, TOX_ERR_CONFERENCE_PEER_QUERY_CONFERENCE_NOT_FOUND);
            return false;
        }

        case -2: {
            SET_ERROR_PARAMETER(error, TOX_ERR_CONFERENCE_PEER_QUERY_PEER_NOT_FOUND);
            return false;
        }
    }

    SET_ERROR_PARAMETER(error, TOX_ERR_CONFERENCE_PEER_QUERY_OK);
    return true;
}

bool tox_conference_peer_number_is_ours(const Tox *tox, uint32_t conference_number, uint32_t peer_number,
                                        Tox_Err_Conference_Peer_Query *error)
{
    assert(tox != nullptr);
    tox_lock(tox);
    const int ret = group_peernumber_is_ours(tox->m->conferences_object, conference_number, peer_number);
    tox_unlock(tox);

    switch (ret) {
        case -1: {
            SET_ERROR_PARAMETER(error, TOX_ERR_CONFERENCE_PEER_QUERY_CONFERENCE_NOT_FOUND);
            return false;
        }

        case -2: {
            SET_ERROR_PARAMETER(error, TOX_ERR_CONFERENCE_PEER_QUERY_PEER_NOT_FOUND);
            return false;
        }

        case -3: {
            SET_ERROR_PARAMETER(error, TOX_ERR_CONFERENCE_PEER_QUERY_NO_CONNECTION);
            return false;
        }
    }

    SET_ERROR_PARAMETER(error, TOX_ERR_CONFERENCE_PEER_QUERY_OK);
    return ret != 0;
}

uint32_t tox_conference_offline_peer_count(const Tox *tox, uint32_t conference_number,
        Tox_Err_Conference_Peer_Query *error)
{
    assert(tox != nullptr);
    tox_lock(tox);
    const int ret = group_number_peers(tox->m->conferences_object, conference_number, true);
    tox_unlock(tox);

    if (ret == -1) {
        SET_ERROR_PARAMETER(error, TOX_ERR_CONFERENCE_PEER_QUERY_CONFERENCE_NOT_FOUND);
        return UINT32_MAX;
    }

    SET_ERROR_PARAMETER(error, TOX_ERR_CONFERENCE_PEER_QUERY_OK);
    return ret;
}

size_t tox_conference_offline_peer_get_name_size(const Tox *tox, uint32_t conference_number,
        uint32_t offline_peer_number,
        Tox_Err_Conference_Peer_Query *error)
{
    assert(tox != nullptr);
    tox_lock(tox);
    const int ret = group_peername_size(tox->m->conferences_object, conference_number, offline_peer_number, true);
    tox_unlock(tox);

    switch (ret) {
        case -1: {
            SET_ERROR_PARAMETER(error, TOX_ERR_CONFERENCE_PEER_QUERY_CONFERENCE_NOT_FOUND);
            return -1;
        }

        case -2: {
            SET_ERROR_PARAMETER(error, TOX_ERR_CONFERENCE_PEER_QUERY_PEER_NOT_FOUND);
            return -1;
        }
    }

    SET_ERROR_PARAMETER(error, TOX_ERR_CONFERENCE_PEER_QUERY_OK);
    return ret;
}

bool tox_conference_offline_peer_get_name(const Tox *tox, uint32_t conference_number, uint32_t offline_peer_number,
        uint8_t *name,
        Tox_Err_Conference_Peer_Query *error)
{
    assert(tox != nullptr);
    tox_lock(tox);
    const int ret = group_peername(tox->m->conferences_object, conference_number, offline_peer_number, name, true);
    tox_unlock(tox);

    switch (ret) {
        case -1: {
            SET_ERROR_PARAMETER(error, TOX_ERR_CONFERENCE_PEER_QUERY_CONFERENCE_NOT_FOUND);
            return false;
        }

        case -2: {
            SET_ERROR_PARAMETER(error, TOX_ERR_CONFERENCE_PEER_QUERY_PEER_NOT_FOUND);
            return false;
        }
    }

    SET_ERROR_PARAMETER(error, TOX_ERR_CONFERENCE_PEER_QUERY_OK);
    return true;
}

bool tox_conference_offline_peer_get_public_key(const Tox *tox, uint32_t conference_number,
        uint32_t offline_peer_number,
        uint8_t *public_key, Tox_Err_Conference_Peer_Query *error)
{
    assert(tox != nullptr);
    tox_lock(tox);
    const int ret = group_peer_pubkey(tox->m->conferences_object, conference_number, offline_peer_number, public_key, true);
    tox_unlock(tox);

    switch (ret) {
        case -1: {
            SET_ERROR_PARAMETER(error, TOX_ERR_CONFERENCE_PEER_QUERY_CONFERENCE_NOT_FOUND);
            return false;
        }

        case -2: {
            SET_ERROR_PARAMETER(error, TOX_ERR_CONFERENCE_PEER_QUERY_PEER_NOT_FOUND);
            return false;
        }
    }

    SET_ERROR_PARAMETER(error, TOX_ERR_CONFERENCE_PEER_QUERY_OK);
    return true;
}

uint64_t tox_conference_offline_peer_get_last_active(const Tox *tox, uint32_t conference_number,
        uint32_t offline_peer_number,
        Tox_Err_Conference_Peer_Query *error)
{
    assert(tox != nullptr);
    uint64_t last_active = UINT64_MAX;
    tox_lock(tox);
    const int ret = group_frozen_last_active(tox->m->conferences_object, conference_number, offline_peer_number,
                    &last_active);
    tox_unlock(tox);

    switch (ret) {
        case -1: {
            SET_ERROR_PARAMETER(error, TOX_ERR_CONFERENCE_PEER_QUERY_CONFERENCE_NOT_FOUND);
            return UINT64_MAX;
        }

        case -2: {
            SET_ERROR_PARAMETER(error, TOX_ERR_CONFERENCE_PEER_QUERY_PEER_NOT_FOUND);
            return UINT64_MAX;
        }
    }

    SET_ERROR_PARAMETER(error, TOX_ERR_CONFERENCE_PEER_QUERY_OK);
    return last_active;
}

bool tox_conference_set_max_offline(Tox *tox, uint32_t conference_number,
                                    uint32_t max_offline_peers,
                                    Tox_Err_Conference_Set_Max_Offline *error)
{
    assert(tox != nullptr);
    tox_lock(tox);
    const int ret = group_set_max_frozen(tox->m->conferences_object, conference_number, max_offline_peers);
    tox_unlock(tox);

    if (ret == -1) {
        SET_ERROR_PARAMETER(error, TOX_ERR_CONFERENCE_SET_MAX_OFFLINE_CONFERENCE_NOT_FOUND);
        return false;
    }

    SET_ERROR_PARAMETER(error, TOX_ERR_CONFERENCE_SET_MAX_OFFLINE_OK);
    return true;
}

bool tox_conference_invite(Tox *tox, uint32_t friend_number, uint32_t conference_number,
                           Tox_Err_Conference_Invite *error)
{
    assert(tox != nullptr);
    tox_lock(tox);
    const int ret = invite_friend(tox->m->conferences_object, friend_number, conference_number);
    tox_unlock(tox);

    switch (ret) {
        case -1: {
            SET_ERROR_PARAMETER(error, TOX_ERR_CONFERENCE_INVITE_CONFERENCE_NOT_FOUND);
            return false;
        }

        case -2: {
            SET_ERROR_PARAMETER(error, TOX_ERR_CONFERENCE_INVITE_FAIL_SEND);
            return false;
        }

        case -3: {
            SET_ERROR_PARAMETER(error, TOX_ERR_CONFERENCE_INVITE_NO_CONNECTION);
            return false;
        }
    }

    SET_ERROR_PARAMETER(error, TOX_ERR_CONFERENCE_INVITE_OK);
    return true;
}

uint32_t tox_conference_join(Tox *tox, uint32_t friend_number, const uint8_t *cookie, size_t length,
                             Tox_Err_Conference_Join *error)
{
    assert(tox != nullptr);
    tox_lock(tox);
    const int ret = join_groupchat(tox->m->conferences_object, friend_number, GROUPCHAT_TYPE_TEXT, cookie, length);
    tox_unlock(tox);

    switch (ret) {
        case -1: {
            SET_ERROR_PARAMETER(error, TOX_ERR_CONFERENCE_JOIN_INVALID_LENGTH);
            return UINT32_MAX;
        }

        case -2: {
            SET_ERROR_PARAMETER(error, TOX_ERR_CONFERENCE_JOIN_WRONG_TYPE);
            return UINT32_MAX;
        }

        case -3: {
            SET_ERROR_PARAMETER(error, TOX_ERR_CONFERENCE_JOIN_FRIEND_NOT_FOUND);
            return UINT32_MAX;
        }

        case -4: {
            SET_ERROR_PARAMETER(error, TOX_ERR_CONFERENCE_JOIN_DUPLICATE);
            return UINT32_MAX;
        }

        case -5: {
            SET_ERROR_PARAMETER(error, TOX_ERR_CONFERENCE_JOIN_INIT_FAIL);
            return UINT32_MAX;
        }

        case -6: {
            SET_ERROR_PARAMETER(error, TOX_ERR_CONFERENCE_JOIN_FAIL_SEND);
            return UINT32_MAX;
        }
    }

    SET_ERROR_PARAMETER(error, TOX_ERR_CONFERENCE_JOIN_OK);
    return ret;
}

bool tox_conference_send_message(Tox *tox, uint32_t conference_number, Tox_Message_Type type, const uint8_t *message,
                                 size_t length, Tox_Err_Conference_Send_Message *error)
{
    assert(tox != nullptr);
    tox_lock(tox);
    int ret = 0;

    if (type == TOX_MESSAGE_TYPE_NORMAL) {
        ret = group_message_send(tox->m->conferences_object, conference_number, message, length);
    } else {
        ret = group_action_send(tox->m->conferences_object, conference_number, message, length);
    }

    tox_unlock(tox);

    switch (ret) {
        case -1: {
            SET_ERROR_PARAMETER(error, TOX_ERR_CONFERENCE_SEND_MESSAGE_CONFERENCE_NOT_FOUND);
            return false;
        }

        case -2: {
            SET_ERROR_PARAMETER(error, TOX_ERR_CONFERENCE_SEND_MESSAGE_TOO_LONG);
            return false;
        }

        case -3: {
            SET_ERROR_PARAMETER(error, TOX_ERR_CONFERENCE_SEND_MESSAGE_NO_CONNECTION);
            return false;
        }

        case -4: {
            SET_ERROR_PARAMETER(error, TOX_ERR_CONFERENCE_SEND_MESSAGE_FAIL_SEND);
            return false;
        }
    }

    SET_ERROR_PARAMETER(error, TOX_ERR_CONFERENCE_SEND_MESSAGE_OK);
    return true;
}

size_t tox_conference_get_title_size(const Tox *tox, uint32_t conference_number, Tox_Err_Conference_Title *error)
{
    assert(tox != nullptr);
    tox_lock(tox);
    const int ret = group_title_get_size(tox->m->conferences_object, conference_number);
    tox_unlock(tox);

    switch (ret) {
        case -1: {
            SET_ERROR_PARAMETER(error, TOX_ERR_CONFERENCE_TITLE_CONFERENCE_NOT_FOUND);
            return -1;
        }

        case -2: {
            SET_ERROR_PARAMETER(error, TOX_ERR_CONFERENCE_TITLE_INVALID_LENGTH);
            return -1;
        }
    }

    SET_ERROR_PARAMETER(error, TOX_ERR_CONFERENCE_TITLE_OK);
    return ret;
}

bool tox_conference_get_title(const Tox *tox, uint32_t conference_number, uint8_t *title,
                              Tox_Err_Conference_Title *error)
{
    assert(tox != nullptr);
    tox_lock(tox);
    const int ret = group_title_get(tox->m->conferences_object, conference_number, title);
    tox_unlock(tox);

    switch (ret) {
        case -1: {
            SET_ERROR_PARAMETER(error, TOX_ERR_CONFERENCE_TITLE_CONFERENCE_NOT_FOUND);
            return false;
        }

        case -2: {
            SET_ERROR_PARAMETER(error, TOX_ERR_CONFERENCE_TITLE_INVALID_LENGTH);
            return false;
        }
    }

    SET_ERROR_PARAMETER(error, TOX_ERR_CONFERENCE_TITLE_OK);
    return true;
}

bool tox_conference_set_title(Tox *tox, uint32_t conference_number, const uint8_t *title, size_t length,
                              Tox_Err_Conference_Title *error)
{
    assert(tox != nullptr);
    tox_lock(tox);
    const int ret = group_title_send(tox->m->conferences_object, conference_number, title, length);
    tox_unlock(tox);

    switch (ret) {
        case -1: {
            SET_ERROR_PARAMETER(error, TOX_ERR_CONFERENCE_TITLE_CONFERENCE_NOT_FOUND);
            return false;
        }

        case -2: {
            SET_ERROR_PARAMETER(error, TOX_ERR_CONFERENCE_TITLE_INVALID_LENGTH);
            return false;
        }

        case -3: {
            SET_ERROR_PARAMETER(error, TOX_ERR_CONFERENCE_TITLE_FAIL_SEND);
            return false;
        }
    }

    SET_ERROR_PARAMETER(error, TOX_ERR_CONFERENCE_TITLE_OK);
    return true;
}

size_t tox_conference_get_chatlist_size(const Tox *tox)
{
    assert(tox != nullptr);
    tox_lock(tox);
    const size_t ret = count_chatlist(tox->m->conferences_object);
    tox_unlock(tox);
    return ret;
}

void tox_conference_get_chatlist(const Tox *tox, uint32_t *chatlist)
{
    assert(tox != nullptr);
    tox_lock(tox);
    const size_t list_size = count_chatlist(tox->m->conferences_object);
    copy_chatlist(tox->m->conferences_object, chatlist, list_size);
    tox_unlock(tox);
}

Tox_Conference_Type tox_conference_get_type(const Tox *tox, uint32_t conference_number,
        Tox_Err_Conference_Get_Type *error)
{
    assert(tox != nullptr);
    tox_lock(tox);
    const int ret = group_get_type(tox->m->conferences_object, conference_number);
    tox_unlock(tox);

    if (ret == -1) {
        SET_ERROR_PARAMETER(error, TOX_ERR_CONFERENCE_GET_TYPE_CONFERENCE_NOT_FOUND);
        return (Tox_Conference_Type)ret;
    }

    SET_ERROR_PARAMETER(error, TOX_ERR_CONFERENCE_GET_TYPE_OK);
    return (Tox_Conference_Type)ret;
}

bool tox_conference_get_id(const Tox *tox, uint32_t conference_number, uint8_t *id)
{
    assert(tox != nullptr);
    tox_lock(tox);
    const bool ret = conference_get_id(tox->m->conferences_object, conference_number, id);
    tox_unlock(tox);
    return ret;
}

// TODO(iphydf): Delete in 0.3.0.
bool tox_conference_get_uid(const Tox *tox, uint32_t conference_number, uint8_t *uid)
{
    assert(tox != nullptr);
    return tox_conference_get_id(tox, conference_number, uid);
}

uint32_t tox_conference_by_id(const Tox *tox, const uint8_t *id, Tox_Err_Conference_By_Id *error)
{
    assert(tox != nullptr);

    if (id == nullptr) {
        SET_ERROR_PARAMETER(error, TOX_ERR_CONFERENCE_BY_ID_NULL);
        return UINT32_MAX;
    }

    tox_lock(tox);
    const int32_t ret = conference_by_id(tox->m->conferences_object, id);
    tox_unlock(tox);

    if (ret == -1) {
        SET_ERROR_PARAMETER(error, TOX_ERR_CONFERENCE_BY_ID_NOT_FOUND);
        return UINT32_MAX;
    }

    SET_ERROR_PARAMETER(error, TOX_ERR_CONFERENCE_BY_ID_OK);
    assert(ret >= 0);
    return (uint32_t)ret;
}

// TODO(iphydf): Delete in 0.3.0.
uint32_t tox_conference_by_uid(const Tox *tox, const uint8_t *uid, Tox_Err_Conference_By_Uid *error)
{
    assert(tox != nullptr);
    Tox_Err_Conference_By_Id id_error;
    const uint32_t res = tox_conference_by_id(tox, uid, &id_error);

    switch (id_error) {
        case TOX_ERR_CONFERENCE_BY_ID_OK: {
            SET_ERROR_PARAMETER(error, TOX_ERR_CONFERENCE_BY_UID_OK);
            break;
        }

        case TOX_ERR_CONFERENCE_BY_ID_NULL: {
            SET_ERROR_PARAMETER(error, TOX_ERR_CONFERENCE_BY_UID_NULL);
            break;
        }

        case TOX_ERR_CONFERENCE_BY_ID_NOT_FOUND: {
            SET_ERROR_PARAMETER(error, TOX_ERR_CONFERENCE_BY_UID_NOT_FOUND);
            break;
        }
    }

    return res;
}

nullable(2)
static void set_custom_packet_error(int ret, Tox_Err_Friend_Custom_Packet *error)
{
    switch (ret) {
        case 0: {
            SET_ERROR_PARAMETER(error, TOX_ERR_FRIEND_CUSTOM_PACKET_OK);
            break;
        }

        case -1: {
            SET_ERROR_PARAMETER(error, TOX_ERR_FRIEND_CUSTOM_PACKET_FRIEND_NOT_FOUND);
            break;
        }

        case -2: {
            SET_ERROR_PARAMETER(error, TOX_ERR_FRIEND_CUSTOM_PACKET_TOO_LONG);
            break;
        }

        case -3: {
            SET_ERROR_PARAMETER(error, TOX_ERR_FRIEND_CUSTOM_PACKET_INVALID);
            break;
        }

        case -4: {
            SET_ERROR_PARAMETER(error, TOX_ERR_FRIEND_CUSTOM_PACKET_FRIEND_NOT_CONNECTED);
            break;
        }

        case -5: {
            SET_ERROR_PARAMETER(error, TOX_ERR_FRIEND_CUSTOM_PACKET_SENDQ);
            break;
        }
    }
}

bool tox_friend_send_lossy_packet(Tox *tox, uint32_t friend_number, const uint8_t *data, size_t length,
                                  Tox_Err_Friend_Custom_Packet *error)
{
    assert(tox != nullptr);

    if (data == nullptr) {
        SET_ERROR_PARAMETER(error, TOX_ERR_FRIEND_CUSTOM_PACKET_NULL);
        return false;
    }

    if (length == 0) {
        SET_ERROR_PARAMETER(error, TOX_ERR_FRIEND_CUSTOM_PACKET_EMPTY);
        return false;
    }

    if (data[0] < PACKET_ID_RANGE_LOSSY_START || data[0] > PACKET_ID_RANGE_LOSSY_END) {
        SET_ERROR_PARAMETER(error, TOX_ERR_FRIEND_CUSTOM_PACKET_INVALID);
        return false;
    }

    tox_lock(tox);
    const int ret = m_send_custom_lossy_packet(tox->m, friend_number, data, length);
    tox_unlock(tox);

    set_custom_packet_error(ret, error);

    return ret == 0;
}

void tox_callback_friend_lossy_packet(Tox *tox, tox_friend_lossy_packet_cb *callback)
{
    assert(tox != nullptr);

    /* start at PACKET_ID_RANGE_LOSSY_CUSTOM_START so ToxAV Packets are excluded */
    for (uint8_t i = PACKET_ID_RANGE_LOSSY_CUSTOM_START; i <= PACKET_ID_RANGE_LOSSY_END; ++i) {
        tox->friend_lossy_packet_callback_per_pktid[i] = callback;
    }
}

bool tox_friend_send_lossless_packet(Tox *tox, uint32_t friend_number, const uint8_t *data, size_t length,
                                     Tox_Err_Friend_Custom_Packet *error)
{
    assert(tox != nullptr);

    if (data == nullptr) {
        SET_ERROR_PARAMETER(error, TOX_ERR_FRIEND_CUSTOM_PACKET_NULL);
        return false;
    }

    if (length == 0) {
        SET_ERROR_PARAMETER(error, TOX_ERR_FRIEND_CUSTOM_PACKET_EMPTY);
        return false;
    }

    tox_lock(tox);
    const int ret = send_custom_lossless_packet(tox->m, friend_number, data, length);
    tox_unlock(tox);

    set_custom_packet_error(ret, error);

    return ret == 0;
}

void tox_callback_friend_lossless_packet(Tox *tox, tox_friend_lossless_packet_cb *callback)
{
    assert(tox != nullptr);

    for (uint8_t i = PACKET_ID_RANGE_LOSSLESS_CUSTOM_START; i <= PACKET_ID_RANGE_LOSSLESS_CUSTOM_END; ++i) {
        tox->friend_lossless_packet_callback_per_pktid[i] = callback;
    }
}

void tox_self_get_dht_id(const Tox *tox, uint8_t *dht_id)
{
    assert(tox != nullptr);

    if (dht_id != nullptr) {
        tox_lock(tox);
        memcpy(dht_id, dht_get_self_public_key(tox->m->dht), CRYPTO_PUBLIC_KEY_SIZE);
        tox_unlock(tox);
    }
}

uint16_t tox_self_get_udp_port(const Tox *tox, Tox_Err_Get_Port *error)
{
    assert(tox != nullptr);
    tox_lock(tox);
    const uint16_t port = net_htons(net_port(tox->m->net));
    tox_unlock(tox);

    if (port == 0) {
        SET_ERROR_PARAMETER(error, TOX_ERR_GET_PORT_NOT_BOUND);
        return 0;
    }

    SET_ERROR_PARAMETER(error, TOX_ERR_GET_PORT_OK);
    return port;
}

uint16_t tox_self_get_tcp_port(const Tox *tox, Tox_Err_Get_Port *error)
{
    assert(tox != nullptr);
    tox_lock(tox);

    if (tox->m->tcp_server != nullptr) {
        SET_ERROR_PARAMETER(error, TOX_ERR_GET_PORT_OK);
        const uint16_t ret = tox->m->options.tcp_server_port;
        tox_unlock(tox);
        return ret;
    }

    SET_ERROR_PARAMETER(error, TOX_ERR_GET_PORT_NOT_BOUND);
    tox_unlock(tox);
    return 0;
}

/* GROUPCHAT FUNCTIONS */

#ifndef VANILLA_NACL
void tox_callback_group_invite(Tox *tox, tox_group_invite_cb *callback)
{
    assert(tox != nullptr);
    tox->group_invite_callback = callback;
}

void tox_callback_group_message(Tox *tox, tox_group_message_cb *callback)
{
    assert(tox != nullptr);
    tox->group_message_callback = callback;
}

void tox_callback_group_private_message(Tox *tox, tox_group_private_message_cb *callback)
{
    assert(tox != nullptr);
    tox->group_private_message_callback = callback;
}

void tox_callback_group_custom_packet(Tox *tox, tox_group_custom_packet_cb *callback)
{
    assert(tox != nullptr);
    tox->group_custom_packet_callback = callback;
}

void tox_callback_group_custom_private_packet(Tox *tox, tox_group_custom_private_packet_cb *callback)
{
    assert(tox != nullptr);
    tox->group_custom_private_packet_callback = callback;
}

void tox_callback_group_moderation(Tox *tox, tox_group_moderation_cb *callback)
{
    assert(tox != nullptr);
    tox->group_moderation_callback = callback;
}

void tox_callback_group_peer_name(Tox *tox, tox_group_peer_name_cb *callback)
{
    assert(tox != nullptr);
    tox->group_peer_name_callback = callback;
}

void tox_callback_group_peer_status(Tox *tox, tox_group_peer_status_cb *callback)
{
    assert(tox != nullptr);
    tox->group_peer_status_callback = callback;
}

void tox_callback_group_connection_status(Tox *tox, tox_group_connection_status_cb *callback)
{
    assert(tox != nullptr);
    tox->group_connection_status_callback = callback;
}

void tox_callback_group_topic(Tox *tox, tox_group_topic_cb *callback)
{
    assert(tox != nullptr);
    tox->group_topic_callback = callback;
}

void tox_callback_group_privacy_state(Tox *tox, tox_group_privacy_state_cb *callback)
{
    assert(tox != nullptr);
    tox->group_privacy_state_callback = callback;
}

void tox_callback_group_topic_lock(Tox *tox, tox_group_topic_lock_cb *callback)
{
    assert(tox != nullptr);
    tox->group_topic_lock_callback = callback;
}

void tox_callback_group_voice_state(Tox *tox, tox_group_voice_state_cb *callback)
{
    assert(tox != nullptr);
    tox->group_voice_state_callback = callback;
}

void tox_callback_group_peer_limit(Tox *tox, tox_group_peer_limit_cb *callback)
{
    assert(tox != nullptr);
    tox->group_peer_limit_callback = callback;
}

void tox_callback_group_password(Tox *tox, tox_group_password_cb *callback)
{
    assert(tox != nullptr);
    tox->group_password_callback = callback;
}

void tox_callback_group_peer_join(Tox *tox, tox_group_peer_join_cb *callback)
{
    assert(tox != nullptr);
    tox->group_peer_join_callback = callback;
}

void tox_callback_group_peer_exit(Tox *tox, tox_group_peer_exit_cb *callback)
{
    assert(tox != nullptr);
    tox->group_peer_exit_callback = callback;
}

void tox_callback_group_self_join(Tox *tox, tox_group_self_join_cb *callback)
{
    assert(tox != nullptr);
    tox->group_self_join_callback = callback;
}

void tox_callback_group_join_fail(Tox *tox, tox_group_join_fail_cb *callback)
{
    assert(tox != nullptr);
    tox->group_join_fail_callback = callback;
}

void tox_group_get_peer_connection_ip(const Tox *tox, uint32_t group_number, uint32_t peer_id, uint8_t *ip_str)
{
    if (ip_str == nullptr) {
        return;
    }
    assert(tox != nullptr);
    tox_lock(tox);
    gc_get_group_peer_connection_ip(tox->m, group_number, peer_id, ip_str);
    tox_unlock(tox);
}

uint32_t tox_group_new(Tox *tox, Tox_Group_Privacy_State privacy_state, const uint8_t *group_name,
                       size_t group_name_length, const uint8_t *name, size_t name_length, Tox_Err_Group_New *error)
{
    assert(tox != nullptr);

    tox_lock(tox);
    const int ret = gc_group_add(tox->m->group_handler, (Group_Privacy_State) privacy_state,
                                 group_name, group_name_length, name, name_length);
    tox_unlock(tox);

    if (ret >= 0) {
        SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_NEW_OK);
        return ret;
    }

    switch (ret) {
        case -1: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_NEW_TOO_LONG);
            return UINT32_MAX;
        }

        case -2: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_NEW_EMPTY);
            return UINT32_MAX;
        }

        case -3: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_NEW_INIT);
            return UINT32_MAX;
        }

        case -4: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_NEW_STATE);
            return UINT32_MAX;
        }

        case -5: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_NEW_ANNOUNCE);
            return UINT32_MAX;
        }
    }

    /* can't happen */
    LOGGER_FATAL(tox->m->log, "impossible return value: %d", ret);

    return UINT32_MAX;
}

uint32_t tox_group_join(Tox *tox, const uint8_t *chat_id, const uint8_t *name, size_t name_length,
                        const uint8_t *password, size_t password_length, Tox_Err_Group_Join *error)
{
    assert(tox != nullptr);

    tox_lock(tox);
    const int ret = gc_group_join(tox->m->group_handler, chat_id, name, name_length, password, password_length);
    tox_unlock(tox);

    if (ret >= 0) {
        SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_JOIN_OK);
        return ret;
    }

    switch (ret) {
        case -1: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_JOIN_INIT);
            return UINT32_MAX;
        }

        case -2: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_JOIN_BAD_CHAT_ID);
            return UINT32_MAX;
        }

        case -3: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_JOIN_TOO_LONG);
            return UINT32_MAX;
        }

        case -4: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_JOIN_EMPTY);
            return UINT32_MAX;
        }

        case -5: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_JOIN_PASSWORD);
            return UINT32_MAX;
        }

        case -6: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_JOIN_CORE);
            return UINT32_MAX;
        }
    }

    /* can't happen */
    LOGGER_FATAL(tox->m->log, "impossible return value: %d", ret);

    return UINT32_MAX;
}

int32_t tox_group_is_connected(const Tox *tox, uint32_t group_number, Tox_Err_Group_Is_Connected *error)
{
    assert(tox != nullptr);

    tox_lock(tox);
    const GC_Chat *chat = gc_get_group(tox->m->group_handler, group_number);

    if (chat == nullptr) {
        SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_IS_CONNECTED_GROUP_NOT_FOUND);
        tox_unlock(tox);
        return -1;
    }

    SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_IS_CONNECTED_OK);

    int32_t ret = -1;
    if (chat->connection_state == CS_CONNECTING) {
        ret = 0;
    } else if (chat->connection_state == CS_CONNECTED) {
        ret = 1;
    }
    tox_unlock(tox);

    return ret;
}

bool tox_group_disconnect(const Tox *tox, uint32_t group_number, Tox_Err_Group_Disconnect *error)
{
    assert(tox != nullptr);

    tox_lock(tox);
    GC_Chat *chat = gc_get_group(tox->m->group_handler, group_number);

    if (chat == nullptr) {
        SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_DISCONNECT_GROUP_NOT_FOUND);
        tox_unlock(tox);
        return false;
    }

    if (chat->connection_state == CS_DISCONNECTED) {
        SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_DISCONNECT_ALREADY_DISCONNECTED);
        tox_unlock(tox);
        return false;
    }


    const bool ret = gc_disconnect_from_group(tox->m->group_handler, chat);

    tox_unlock(tox);

    if (!ret) {
        SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_DISCONNECT_GROUP_NOT_FOUND);
        return false;
    }

    SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_DISCONNECT_OK);

    return true;
}

bool tox_group_reconnect(Tox *tox, uint32_t group_number, Tox_Err_Group_Reconnect *error)
{
    assert(tox != nullptr);

    tox_lock(tox);
    GC_Chat *chat = gc_get_group(tox->m->group_handler, group_number);

    if (chat == nullptr) {
        SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_RECONNECT_GROUP_NOT_FOUND);
        tox_unlock(tox);
        return false;
    }

    const int ret = gc_rejoin_group(tox->m->group_handler, chat);
    tox_unlock(tox);

    switch (ret) {
        case 0: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_RECONNECT_OK);
            return true;
        }

        case -1: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_RECONNECT_GROUP_NOT_FOUND);
            return false;
        }

        case -2: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_RECONNECT_CORE);
            return false;
        }
    }

    /* can't happen */
    LOGGER_FATAL(tox->m->log, "impossible return value: %d", ret);

    return false;
}

bool tox_group_leave(Tox *tox, uint32_t group_number, const uint8_t *part_message, size_t length,
                     Tox_Err_Group_Leave *error)
{
    assert(tox != nullptr);

    tox_lock(tox);
    GC_Chat *chat = gc_get_group(tox->m->group_handler, group_number);

    if (chat == nullptr) {
        SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_LEAVE_GROUP_NOT_FOUND);
        tox_unlock(tox);
        return false;
    }

    const int ret = gc_group_exit(tox->m->group_handler, chat, part_message, length);
    tox_unlock(tox);

    switch (ret) {
        case 0: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_LEAVE_OK);
            return true;
        }

        case -1: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_LEAVE_TOO_LONG);
            return false;
        }

        case -2: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_LEAVE_FAIL_SEND);
            return true;   /* the group was still successfully deleted */
        }
    }

    /* can't happen */
    LOGGER_FATAL(tox->m->log, "impossible return value: %d", ret);

    return false;
}

bool tox_group_self_set_name(const Tox *tox, uint32_t group_number, const uint8_t *name, size_t length,
                             Tox_Err_Group_Self_Name_Set *error)
{
    assert(tox != nullptr);

    tox_lock(tox);
    const int ret = gc_set_self_nick(tox->m, group_number, name, length);
    tox_unlock(tox);

    switch (ret) {
        case 0: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_SELF_NAME_SET_OK);
            return true;
        }

        case -1: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_SELF_NAME_SET_GROUP_NOT_FOUND);
            return false;
        }

        case -2: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_SELF_NAME_SET_TOO_LONG);
            return false;
        }

        case -3: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_SELF_NAME_SET_INVALID);
            return false;
        }

        case -4: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_SELF_NAME_SET_FAIL_SEND);
            return false;
        }
    }

    /* can't happen */
    LOGGER_FATAL(tox->m->log, "impossible return value: %d", ret);

    return false;
}

size_t tox_group_self_get_name_size(const Tox *tox, uint32_t group_number, Tox_Err_Group_Self_Query *error)
{
    assert(tox != nullptr);

    tox_lock(tox);
    const GC_Chat *chat = gc_get_group(tox->m->group_handler, group_number);

    if (chat == nullptr) {
        SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_SELF_QUERY_GROUP_NOT_FOUND);
        tox_unlock(tox);
        return -1;
    }

    SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_SELF_QUERY_OK);

    const size_t ret = gc_get_self_nick_size(chat);
    tox_unlock(tox);

    return ret;
}

bool tox_group_self_get_name(const Tox *tox, uint32_t group_number, uint8_t *name, Tox_Err_Group_Self_Query *error)
{
    assert(tox != nullptr);

    tox_lock(tox);
    const GC_Chat *chat = gc_get_group(tox->m->group_handler, group_number);

    if (chat == nullptr) {
        SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_SELF_QUERY_GROUP_NOT_FOUND);
        tox_unlock(tox);
        return false;
    }

    SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_SELF_QUERY_OK);

    gc_get_self_nick(chat, name);
    tox_unlock(tox);

    return true;
}

bool tox_group_self_set_status(const Tox *tox, uint32_t group_number, Tox_User_Status status,
                               Tox_Err_Group_Self_Status_Set *error)
{
    assert(tox != nullptr);

    tox_lock(tox);
    const int ret = gc_set_self_status(tox->m, group_number, (Group_Peer_Status) status);
    tox_unlock(tox);

    switch (ret) {
        case 0: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_SELF_STATUS_SET_OK);
            return true;
        }

        case -1: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_SELF_STATUS_SET_GROUP_NOT_FOUND);
            return false;
        }

        case -2: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_SELF_STATUS_SET_FAIL_SEND);
            return false;
        }
    }

    /* can't happen */
    LOGGER_FATAL(tox->m->log, "impossible return value: %d", ret);

    return false;
}

Tox_User_Status tox_group_self_get_status(const Tox *tox, uint32_t group_number, Tox_Err_Group_Self_Query *error)
{
    assert(tox != nullptr);

    tox_lock(tox);
    const GC_Chat *chat = gc_get_group(tox->m->group_handler, group_number);

    if (chat == nullptr) {
        SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_SELF_QUERY_GROUP_NOT_FOUND);
        tox_unlock(tox);
        return (Tox_User_Status) - 1;
    }

    SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_SELF_QUERY_OK);

    const uint8_t status = gc_get_self_status(chat);
    tox_unlock(tox);

    return (Tox_User_Status)status;
}

Tox_Group_Role tox_group_self_get_role(const Tox *tox, uint32_t group_number, Tox_Err_Group_Self_Query *error)
{
    assert(tox != nullptr);

    tox_lock(tox);
    const GC_Chat *chat = gc_get_group(tox->m->group_handler, group_number);

    if (chat == nullptr) {
        SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_SELF_QUERY_GROUP_NOT_FOUND);
        tox_unlock(tox);
        return (Tox_Group_Role) - 1;
    }

    SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_SELF_QUERY_OK);

    const Group_Role role = gc_get_self_role(chat);
    tox_unlock(tox);

    return (Tox_Group_Role)role;
}

uint32_t tox_group_self_get_peer_id(const Tox *tox, uint32_t group_number, Tox_Err_Group_Self_Query *error)
{
    assert(tox != nullptr);

    tox_lock(tox);
    const GC_Chat *chat = gc_get_group(tox->m->group_handler, group_number);

    if (chat == nullptr) {
        SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_SELF_QUERY_GROUP_NOT_FOUND);
        tox_unlock(tox);
        return -1;
    }

    SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_SELF_QUERY_OK);

    const uint32_t ret = gc_get_self_peer_id(chat);
    tox_unlock(tox);

    return ret;
}

bool tox_group_self_get_public_key(const Tox *tox, uint32_t group_number, uint8_t *public_key,
                                   Tox_Err_Group_Self_Query *error)
{
    assert(tox != nullptr);

    tox_lock(tox);
    const GC_Chat *chat = gc_get_group(tox->m->group_handler, group_number);

    if (chat == nullptr) {
        SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_SELF_QUERY_GROUP_NOT_FOUND);
        tox_unlock(tox);
        return false;
    }

    SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_SELF_QUERY_OK);

    gc_get_self_public_key(chat, public_key);
    tox_unlock(tox);

    return true;
}

uint32_t tox_group_peer_count(const Tox *tox, uint32_t group_number, Tox_Err_Group_Peer_Query *error)
{
    assert(tox != nullptr);

    tox_lock(tox);
    const GC_Chat *chat = gc_get_group(tox->m->group_handler, group_number);

    if (chat == nullptr) {
        SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_PEER_QUERY_GROUP_NOT_FOUND);
        tox_unlock(tox);
        return -1;
    }

    const uint32_t ret = get_group_peercount(chat);
    tox_unlock(tox);

    SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_PEER_QUERY_OK);
    return ret;
}

uint32_t tox_group_offline_peer_count(const Tox *tox, uint32_t group_number, Tox_Err_Group_Peer_Query *error)
{
    assert(tox != nullptr);

    tox_lock(tox);
    const GC_Chat *chat = gc_get_group(tox->m->group_handler, group_number);

    if (chat == nullptr) {
        SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_PEER_QUERY_GROUP_NOT_FOUND);
        tox_unlock(tox);
        return -1;
    }

    const uint32_t ret = get_group_offline_peercount(chat);
    tox_unlock(tox);

    SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_PEER_QUERY_OK);
    return ret;
}

void tox_group_get_peerlist(const Tox *tox, uint32_t group_number, uint32_t *peerlist, Tox_Err_Group_Peer_Query *error)
{
    assert(tox != nullptr);

    tox_lock(tox);
    const GC_Chat *chat = gc_get_group(tox->m->group_handler, group_number);

    if (chat == nullptr) {
        SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_PEER_QUERY_GROUP_NOT_FOUND);
        tox_unlock(tox);
        return;
    }

    if (peerlist == nullptr) {
        SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_PEER_QUERY_GROUP_NOT_FOUND);
        tox_unlock(tox);
        return;
    }

    copy_peerlist(chat, peerlist);
    tox_unlock(tox);

    SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_PEER_QUERY_OK);
    return;
}

size_t tox_group_peer_get_name_size(const Tox *tox, uint32_t group_number, uint32_t peer_id,
                                    Tox_Err_Group_Peer_Query *error)
{
    assert(tox != nullptr);

    tox_lock(tox);
    const GC_Chat *chat = gc_get_group(tox->m->group_handler, group_number);

    if (chat == nullptr) {
        SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_PEER_QUERY_GROUP_NOT_FOUND);
        tox_unlock(tox);
        return -1;
    }

    const int ret = gc_get_peer_nick_size(chat, peer_id);
    tox_unlock(tox);

    if (ret == -1) {
        SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_PEER_QUERY_PEER_NOT_FOUND);
        return -1;
    } else {
        SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_PEER_QUERY_OK);
        return ret;
    }
}

bool tox_group_peer_get_name(const Tox *tox, uint32_t group_number, uint32_t peer_id, uint8_t *name,
                             Tox_Err_Group_Peer_Query *error)
{
    assert(tox != nullptr);

    tox_lock(tox);
    const GC_Chat *chat = gc_get_group(tox->m->group_handler, group_number);

    if (chat == nullptr) {
        SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_PEER_QUERY_GROUP_NOT_FOUND);
        tox_unlock(tox);
        return false;
    }

    const bool ret = gc_get_peer_nick(chat, peer_id, name);
    tox_unlock(tox);

    if (!ret) {
        SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_PEER_QUERY_PEER_NOT_FOUND);
        return false;
    }

    SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_PEER_QUERY_OK);
    return true;
}

Tox_User_Status tox_group_peer_get_status(const Tox *tox, uint32_t group_number, uint32_t peer_id,
        Tox_Err_Group_Peer_Query *error)
{
    assert(tox != nullptr);

    tox_lock(tox);
    const GC_Chat *chat = gc_get_group(tox->m->group_handler, group_number);

    if (chat == nullptr) {
        SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_PEER_QUERY_GROUP_NOT_FOUND);
        tox_unlock(tox);
        return (Tox_User_Status) - 1;
    }

    const uint8_t ret = gc_get_status(chat, peer_id);
    tox_unlock(tox);

    if (ret == UINT8_MAX) {
        SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_PEER_QUERY_PEER_NOT_FOUND);
        return (Tox_User_Status) - 1;
    }

    SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_PEER_QUERY_OK);
    return (Tox_User_Status)ret;
}

Tox_Group_Role tox_group_peer_get_role(const Tox *tox, uint32_t group_number, uint32_t peer_id,
                                       Tox_Err_Group_Peer_Query *error)
{
    assert(tox != nullptr);

    tox_lock(tox);
    const GC_Chat *chat = gc_get_group(tox->m->group_handler, group_number);

    if (chat == nullptr) {
        SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_PEER_QUERY_GROUP_NOT_FOUND);
        tox_unlock(tox);
        return (Tox_Group_Role) - 1;
    }

    const uint8_t ret = gc_get_role(chat, peer_id);
    tox_unlock(tox);

    if (ret == (uint8_t) -1) {
        SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_PEER_QUERY_PEER_NOT_FOUND);
        return (Tox_Group_Role) - 1;
    }

    SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_PEER_QUERY_OK);
    return (Tox_Group_Role)ret;
}

bool tox_group_savedpeer_get_public_key(const Tox *tox, uint32_t group_number, uint32_t slot_number, uint8_t *public_key,
                                   Tox_Err_Group_Peer_Query *error)
{
    assert(tox != nullptr);

    tox_lock(tox);
    const GC_Chat *chat = gc_get_group(tox->m->group_handler, group_number);

    if (chat == nullptr) {
        SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_PEER_QUERY_GROUP_NOT_FOUND);
        tox_unlock(tox);
        return false;
    }

    const int ret = gc_get_savedpeer_public_key_by_slot_number(chat, slot_number, public_key);
    tox_unlock(tox);

    if (ret == -1) {
        SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_PEER_QUERY_PEER_NOT_FOUND);
        return false;
    }

    SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_PEER_QUERY_OK);
    return true;
}

bool tox_group_peer_get_public_key(const Tox *tox, uint32_t group_number, uint32_t peer_id, uint8_t *public_key,
                                   Tox_Err_Group_Peer_Query *error)
{
    assert(tox != nullptr);

    tox_lock(tox);
    const GC_Chat *chat = gc_get_group(tox->m->group_handler, group_number);

    if (chat == nullptr) {
        SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_PEER_QUERY_GROUP_NOT_FOUND);
        tox_unlock(tox);
        return false;
    }

    const int ret = gc_get_peer_public_key_by_peer_id(chat, peer_id, public_key);
    tox_unlock(tox);

    if (ret == -1) {
        SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_PEER_QUERY_PEER_NOT_FOUND);
        return false;
    }

    SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_PEER_QUERY_OK);
    return true;
}

uint32_t tox_group_peer_by_public_key(const Tox *tox, uint32_t group_number, const uint8_t *public_key,
                                      Tox_Err_Group_Peer_Query *error)
{
    assert(tox != nullptr);

    tox_lock(tox);
    const GC_Chat *chat = gc_get_group(tox->m->group_handler, group_number);

    if (chat == nullptr) {
        SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_PEER_QUERY_GROUP_NOT_FOUND);
        tox_unlock(tox);
        return UINT32_MAX;
    }

    const int64_t peer_id = get_gc_peer_id_by_public_key(chat, public_key);
    tox_unlock(tox);

    if (peer_id == -1) {
        SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_PEER_QUERY_PEER_NOT_FOUND);
        return UINT32_MAX;
    }

    SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_PEER_QUERY_OK);
    return (uint32_t)peer_id;
}

Tox_Connection tox_group_peer_get_connection_status(const Tox *tox, uint32_t group_number, uint32_t peer_id,
        Tox_Err_Group_Peer_Query *error)
{
    assert(tox != nullptr);

    tox_lock(tox);
    const GC_Chat *chat = gc_get_group(tox->m->group_handler, group_number);

    if (chat == nullptr) {
        SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_PEER_QUERY_GROUP_NOT_FOUND);
        tox_unlock(tox);
        return TOX_CONNECTION_NONE;
    }

    const unsigned int ret = gc_get_peer_connection_status(chat, peer_id);
    tox_unlock(tox);

    if (ret == 0) {
        SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_PEER_QUERY_PEER_NOT_FOUND);
        return TOX_CONNECTION_NONE;
    }

    SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_PEER_QUERY_OK);
    return (Tox_Connection)ret;
}

bool tox_group_set_topic(const Tox *tox, uint32_t group_number, const uint8_t *topic, size_t length,
                         Tox_Err_Group_Topic_Set *error)
{
    assert(tox != nullptr);

    tox_lock(tox);
    GC_Chat *chat = gc_get_group(tox->m->group_handler, group_number);

    if (chat == nullptr) {
        SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_TOPIC_SET_GROUP_NOT_FOUND);
        tox_unlock(tox);
        return false;
    }

    if (chat->connection_state == CS_DISCONNECTED) {
        SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_TOPIC_SET_DISCONNECTED);
        tox_unlock(tox);
        return false;
    }

    const int ret = gc_set_topic(chat, topic, length);
    tox_unlock(tox);

    switch (ret) {
        case 0: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_TOPIC_SET_OK);
            return true;
        }

        case -1: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_TOPIC_SET_TOO_LONG);
            return false;
        }

        case -2: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_TOPIC_SET_PERMISSIONS);
            return false;
        }

        case -3: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_TOPIC_SET_FAIL_CREATE);
            return false;
        }

        case -4: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_TOPIC_SET_FAIL_SEND);
            return false;
        }
    }

    /* can't happen */
    LOGGER_FATAL(tox->m->log, "impossible return value: %d", ret);

    return false;
}

size_t tox_group_get_topic_size(const Tox *tox, uint32_t group_number, Tox_Err_Group_State_Queries *error)
{
    assert(tox != nullptr);

    tox_lock(tox);
    const GC_Chat *chat = gc_get_group(tox->m->group_handler, group_number);

    if (chat == nullptr) {
        SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_STATE_QUERIES_GROUP_NOT_FOUND);
        tox_unlock(tox);
        return -1;
    }

    SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_STATE_QUERIES_OK);

    const size_t ret = gc_get_topic_size(chat);
    tox_unlock(tox);

    return ret;
}

bool tox_group_get_topic(const Tox *tox, uint32_t group_number, uint8_t *topic, Tox_Err_Group_State_Queries *error)
{
    assert(tox != nullptr);

    tox_lock(tox);
    const GC_Chat *chat = gc_get_group(tox->m->group_handler, group_number);

    if (chat == nullptr) {
        SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_STATE_QUERIES_GROUP_NOT_FOUND);
        tox_unlock(tox);
        return false;
    }

    gc_get_topic(chat, topic);
    tox_unlock(tox);

    SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_STATE_QUERIES_OK);
    return true;
}

size_t tox_group_get_name_size(const Tox *tox, uint32_t group_number, Tox_Err_Group_State_Queries *error)
{
    assert(tox != nullptr);

    tox_lock(tox);
    const GC_Chat *chat = gc_get_group(tox->m->group_handler, group_number);

    if (chat == nullptr) {
        SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_STATE_QUERIES_GROUP_NOT_FOUND);
        tox_unlock(tox);
        return -1;
    }

    SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_STATE_QUERIES_OK);

    const size_t ret = gc_get_group_name_size(chat);
    tox_unlock(tox);

    return ret;
}

bool tox_group_get_name(const Tox *tox, uint32_t group_number, uint8_t *group_name, Tox_Err_Group_State_Queries *error)
{
    assert(tox != nullptr);

    tox_lock(tox);
    const GC_Chat *chat = gc_get_group(tox->m->group_handler, group_number);

    if (chat == nullptr) {
        SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_STATE_QUERIES_GROUP_NOT_FOUND);
        tox_unlock(tox);
        return false;
    }

    gc_get_group_name(chat, group_name);
    tox_unlock(tox);

    SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_STATE_QUERIES_OK);

    return true;
}

bool tox_group_get_chat_id(const Tox *tox, uint32_t group_number, uint8_t *chat_id, Tox_Err_Group_State_Queries *error)
{
    assert(tox != nullptr);

    tox_lock(tox);
    const GC_Chat *chat = gc_get_group(tox->m->group_handler, group_number);

    if (chat == nullptr) {
        SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_STATE_QUERIES_GROUP_NOT_FOUND);
        tox_unlock(tox);
        return false;
    }

    SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_STATE_QUERIES_OK);
    gc_get_chat_id(chat, chat_id);
    tox_unlock(tox);

    return true;
}

uint32_t tox_group_get_number_groups(const Tox *tox)
{
    assert(tox != nullptr);

    tox_lock(tox);
    const uint32_t ret = gc_count_groups(tox->m->group_handler);
    tox_unlock(tox);

    return ret;
}

void tox_group_get_grouplist(const Tox *tox, uint32_t *grouplist)
{
    assert(tox != nullptr);
    tox_lock(tox);
    const uint32_t list_size = gc_count_groups(tox->m->group_handler);
    copy_grouplist(tox->m->group_handler, grouplist, list_size);
    tox_unlock(tox);
}

uint32_t tox_group_by_chat_id(const Tox *tox, const uint8_t *chat_id, Tox_Err_Group_State_Queries *error)
{
    assert(tox != nullptr);

    if (chat_id == nullptr) {
        SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_STATE_QUERIES_GROUP_NOT_FOUND);
        return UINT32_MAX;
    }

    tox_lock(tox);
    const GC_Chat *chat = gc_get_group_by_public_key(tox->m->group_handler, chat_id);

    if (chat == nullptr)
    {
        SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_STATE_QUERIES_GROUP_NOT_FOUND);
        tox_unlock(tox);
        return UINT32_MAX;
    }

    uint32_t ret = chat->group_number;
    tox_unlock(tox);

    if (ret == -1) {
        SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_STATE_QUERIES_GROUP_NOT_FOUND);
        return UINT32_MAX;
    }

    SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_STATE_QUERIES_OK);
    assert(ret >= 0);
    return ret;
}

Tox_Group_Privacy_State tox_group_get_privacy_state(const Tox *tox, uint32_t group_number,
        Tox_Err_Group_State_Queries *error)
{
    assert(tox != nullptr);

    tox_lock(tox);
    const GC_Chat *chat = gc_get_group(tox->m->group_handler, group_number);

    if (chat == nullptr) {
        SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_STATE_QUERIES_GROUP_NOT_FOUND);
        tox_unlock(tox);
        return (Tox_Group_Privacy_State) - 1;
    }

    SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_STATE_QUERIES_OK);

    const uint8_t state = gc_get_privacy_state(chat);
    tox_unlock(tox);

    return (Tox_Group_Privacy_State)state;
}

Tox_Group_Topic_Lock tox_group_get_topic_lock(const Tox *tox, uint32_t group_number, Tox_Err_Group_State_Queries *error)
{
    assert(tox != nullptr);

    tox_lock(tox);
    const GC_Chat *chat = gc_get_group(tox->m->group_handler, group_number);

    if (chat == nullptr) {
        SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_STATE_QUERIES_GROUP_NOT_FOUND);
        tox_unlock(tox);
        return (Tox_Group_Topic_Lock) - 1;
    }

    SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_STATE_QUERIES_OK);

    const Group_Topic_Lock topic_lock = gc_get_topic_lock_state(chat);
    tox_unlock(tox);

    return (Tox_Group_Topic_Lock)topic_lock;
}

Tox_Group_Voice_State tox_group_get_voice_state(const Tox *tox, uint32_t group_number,
        Tox_Err_Group_State_Queries *error)
{
    assert(tox != nullptr);

    tox_lock(tox);
    const GC_Chat *chat = gc_get_group(tox->m->group_handler, group_number);

    if (chat == nullptr) {
        SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_STATE_QUERIES_GROUP_NOT_FOUND);
        tox_unlock(tox);
        return (Tox_Group_Voice_State) - 1;
    }

    SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_STATE_QUERIES_OK);

    const Group_Voice_State voice_state = gc_get_voice_state(chat);
    tox_unlock(tox);

    return (Tox_Group_Voice_State)voice_state;
}

uint16_t tox_group_get_peer_limit(const Tox *tox, uint32_t group_number, Tox_Err_Group_State_Queries *error)
{
    assert(tox != nullptr);

    tox_lock(tox);
    const GC_Chat *chat = gc_get_group(tox->m->group_handler, group_number);

    if (chat == nullptr) {
        SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_STATE_QUERIES_GROUP_NOT_FOUND);
        tox_unlock(tox);
        return -1;
    }

    SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_STATE_QUERIES_OK);

    const uint16_t ret = gc_get_max_peers(chat);
    tox_unlock(tox);

    return ret;
}

size_t tox_group_get_password_size(const Tox *tox, uint32_t group_number, Tox_Err_Group_State_Queries *error)
{
    assert(tox != nullptr);

    tox_lock(tox);
    const GC_Chat *chat = gc_get_group(tox->m->group_handler, group_number);

    if (chat == nullptr) {
        SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_STATE_QUERIES_GROUP_NOT_FOUND);
        tox_unlock(tox);
        return -1;
    }

    SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_STATE_QUERIES_OK);

    const size_t ret = gc_get_password_size(chat);
    tox_unlock(tox);

    return ret;
}

bool tox_group_get_password(const Tox *tox, uint32_t group_number, uint8_t *password,
                            Tox_Err_Group_State_Queries *error)
{
    assert(tox != nullptr);

    tox_lock(tox);
    const GC_Chat *chat = gc_get_group(tox->m->group_handler, group_number);

    if (chat == nullptr) {
        SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_STATE_QUERIES_GROUP_NOT_FOUND);
        tox_unlock(tox);
        return false;
    }

    SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_STATE_QUERIES_OK);

    gc_get_password(chat, password);
    tox_unlock(tox);

    return true;
}

bool tox_group_send_message(const Tox *tox, uint32_t group_number, Tox_Message_Type type, const uint8_t *message,
                            size_t length, uint32_t *message_id, Tox_Err_Group_Send_Message *error)
{
    assert(tox != nullptr);

    tox_lock(tox);
    const GC_Chat *chat = gc_get_group(tox->m->group_handler, group_number);

    if (chat == nullptr) {
        SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_SEND_MESSAGE_GROUP_NOT_FOUND);
        tox_unlock(tox);
        return false;
    }

    if (chat->connection_state == CS_DISCONNECTED) {
        SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_SEND_MESSAGE_DISCONNECTED);
        tox_unlock(tox);
        return false;
    }

    const int ret = gc_send_message(chat, message, length, type, message_id);
    tox_unlock(tox);

    switch (ret) {
        case 0: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_SEND_MESSAGE_OK);
            return true;
        }

        case -1: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_SEND_MESSAGE_TOO_LONG);
            return false;
        }

        case -2: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_SEND_MESSAGE_EMPTY);
            return false;
        }

        case -3: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_SEND_MESSAGE_BAD_TYPE);
            return false;
        }

        case -4: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_SEND_MESSAGE_PERMISSIONS);
            return false;
        }

        case -5: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_SEND_MESSAGE_FAIL_SEND);
            return false;
        }
    }

    /* can't happen */
    LOGGER_FATAL(tox->m->log, "impossible return value: %d", ret);

    return false;
}

bool tox_group_send_private_message(const Tox *tox, uint32_t group_number, uint32_t peer_id, Tox_Message_Type type,
                                    const uint8_t *message, size_t length, Tox_Err_Group_Send_Private_Message *error)
{
    assert(tox != nullptr);

    tox_lock(tox);
    const GC_Chat *chat = gc_get_group(tox->m->group_handler, group_number);

    if (chat == nullptr) {
        SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_SEND_PRIVATE_MESSAGE_GROUP_NOT_FOUND);
        tox_unlock(tox);
        return false;
    }

    if (chat->connection_state == CS_DISCONNECTED) {
        SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_SEND_PRIVATE_MESSAGE_DISCONNECTED);
        tox_unlock(tox);
        return false;
    }

    const int ret = gc_send_private_message(chat, peer_id, type, message, length);
    tox_unlock(tox);

    switch (ret) {
        case 0: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_SEND_PRIVATE_MESSAGE_OK);
            return true;
        }

        case -1: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_SEND_PRIVATE_MESSAGE_TOO_LONG);
            return false;
        }

        case -2: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_SEND_PRIVATE_MESSAGE_EMPTY);
            return false;
        }

        case -3: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_SEND_PRIVATE_MESSAGE_PEER_NOT_FOUND);
            return false;
        }

        case -4: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_SEND_PRIVATE_MESSAGE_BAD_TYPE);
            return false;
        }

        case -5: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_SEND_PRIVATE_MESSAGE_PERMISSIONS);
            return false;
        }

        case -6: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_SEND_PRIVATE_MESSAGE_FAIL_SEND);
            return false;
        }
    }

    /* can't happen */
    LOGGER_FATAL(tox->m->log, "impossible return value: %d", ret);

    return false;
}

bool tox_group_send_private_message_by_peerpubkey(const Tox *tox, uint32_t group_number, const uint8_t *public_key,
                                    Tox_Message_Type type, const uint8_t *message, size_t length,
                                    Tox_Err_Group_Send_Private_Message *error)
{
    assert(tox != nullptr);

    tox_lock(tox);
    const GC_Chat *chat = gc_get_group(tox->m->group_handler, group_number);

    if (chat == nullptr) {
        SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_SEND_PRIVATE_MESSAGE_GROUP_NOT_FOUND);
        tox_unlock(tox);
        return false;
    }

    if (chat->connection_state == CS_DISCONNECTED) {
        SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_SEND_PRIVATE_MESSAGE_DISCONNECTED);
        tox_unlock(tox);
        return false;
    }

    const int64_t peer_id = get_gc_peer_id_by_public_key(chat, public_key);

    if (peer_id == -1) {
        SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_SEND_PRIVATE_MESSAGE_PEER_NOT_FOUND);
        tox_unlock(tox);
        return false;
    }

    const int ret = gc_send_private_message(chat, (uint32_t)peer_id, type, message, length);
    tox_unlock(tox);

    switch (ret) {
        case 0: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_SEND_PRIVATE_MESSAGE_OK);
            return true;
        }

        case -1: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_SEND_PRIVATE_MESSAGE_TOO_LONG);
            return false;
        }

        case -2: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_SEND_PRIVATE_MESSAGE_EMPTY);
            return false;
        }

        case -3: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_SEND_PRIVATE_MESSAGE_PEER_NOT_FOUND);
            return false;
        }

        case -4: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_SEND_PRIVATE_MESSAGE_BAD_TYPE);
            return false;
        }

        case -5: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_SEND_PRIVATE_MESSAGE_PERMISSIONS);
            return false;
        }

        case -6: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_SEND_PRIVATE_MESSAGE_FAIL_SEND);
            return false;
        }
    }

    /* can't happen */
    LOGGER_FATAL(tox->m->log, "impossible return value: %d", ret);

    return false;
}

bool tox_group_send_custom_packet(const Tox *tox, uint32_t group_number, bool lossless, const uint8_t *data,
                                  size_t length, Tox_Err_Group_Send_Custom_Packet *error)
{
    assert(tox != nullptr);

    tox_lock(tox);
    const GC_Chat *chat = gc_get_group(tox->m->group_handler, group_number);

    if (chat == nullptr) {
        SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_SEND_CUSTOM_PACKET_GROUP_NOT_FOUND);
        tox_unlock(tox);
        return false;
    }

    if (chat->connection_state == CS_DISCONNECTED) {
        SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_SEND_CUSTOM_PACKET_DISCONNECTED);
        tox_unlock(tox);
        return false;
    }

    const int ret = gc_send_custom_packet(chat, lossless, data, length);
    tox_unlock(tox);

    switch (ret) {
        case 0: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_SEND_CUSTOM_PACKET_OK);
            return true;
        }

        case -1: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_SEND_CUSTOM_PACKET_TOO_LONG);
            return false;
        }

        case -2: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_SEND_CUSTOM_PACKET_EMPTY);
            return false;
        }

        case -3: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_SEND_CUSTOM_PACKET_PERMISSIONS);
            return false;
        }
    }

    /* can't happen */
    LOGGER_FATAL(tox->m->log, "impossible return value: %d", ret);

    return false;
}

bool tox_group_send_custom_private_packet(const Tox *tox, uint32_t group_number, uint32_t peer_id, bool lossless,
        const uint8_t *data, size_t length,
        Tox_Err_Group_Send_Custom_Private_Packet *error)
{
    assert(tox != nullptr);

    tox_lock(tox);
    const GC_Chat *chat = gc_get_group(tox->m->group_handler, group_number);

    if (chat == nullptr) {
        SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_SEND_CUSTOM_PRIVATE_PACKET_GROUP_NOT_FOUND);
        tox_unlock(tox);
        return false;
    }

    if (chat->connection_state == CS_DISCONNECTED) {
        SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_SEND_CUSTOM_PRIVATE_PACKET_DISCONNECTED);
        tox_unlock(tox);
        return false;
    }

    const int ret = gc_send_custom_private_packet(chat, lossless, peer_id, data, length);
    tox_unlock(tox);

    switch (ret) {
        case 0: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_SEND_CUSTOM_PRIVATE_PACKET_OK);
            return true;
        }

        case -1: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_SEND_CUSTOM_PRIVATE_PACKET_TOO_LONG);
            return false;
        }

        case -2: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_SEND_CUSTOM_PRIVATE_PACKET_EMPTY);
            return false;
        }

        case -3: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_SEND_CUSTOM_PRIVATE_PACKET_PEER_NOT_FOUND);
            return false;
        }

        case -4: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_SEND_CUSTOM_PRIVATE_PACKET_PERMISSIONS);
            return false;
        }

        case -5: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_SEND_CUSTOM_PRIVATE_PACKET_FAIL_SEND);
            return false;
        }
    }

    /* can't happen */
    LOGGER_FATAL(tox->m->log, "impossible return value: %d", ret);

    return false;
}

bool tox_group_invite_friend(const Tox *tox, uint32_t group_number, uint32_t friend_number,
                             Tox_Err_Group_Invite_Friend *error)
{
    assert(tox != nullptr);

    tox_lock(tox);
    GC_Chat *chat = gc_get_group(tox->m->group_handler, group_number);

    if (chat == nullptr) {
        SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_INVITE_FRIEND_GROUP_NOT_FOUND);
        tox_unlock(tox);
        return false;
    }

    if (chat->connection_state == CS_DISCONNECTED) {
        SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_INVITE_FRIEND_DISCONNECTED);
        tox_unlock(tox);
        return false;
    }

    if (!friend_is_valid(tox->m, friend_number)) {
        SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_INVITE_FRIEND_FRIEND_NOT_FOUND);
        tox_unlock(tox);
        return false;
    }

    const int ret = gc_invite_friend(tox->m->group_handler, chat, friend_number, send_group_invite_packet);
    tox_unlock(tox);

    switch (ret) {
        case 0: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_INVITE_FRIEND_OK);
            return true;
        }

        case -1: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_INVITE_FRIEND_FRIEND_NOT_FOUND);
            return false;
        }

        case -2: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_INVITE_FRIEND_INVITE_FAIL);
            return false;
        }

        case -3: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_INVITE_FRIEND_FAIL_SEND);
            return false;
        }
    }

    /* can't happen */
    LOGGER_FATAL(tox->m->log, "impossible return value: %d", ret);

    return false;
}

uint32_t tox_group_invite_accept(Tox *tox, uint32_t friend_number, const uint8_t *invite_data, size_t length,
                                 const uint8_t *name, size_t name_length, const uint8_t *password,
                                 size_t password_length, Tox_Err_Group_Invite_Accept *error)
{
    assert(tox != nullptr);

    tox_lock(tox);
    const int ret = gc_accept_invite(tox->m->group_handler, friend_number, invite_data, length, name, name_length, password,
                                     password_length);
    tox_unlock(tox);

    if (ret >= 0) {
        SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_INVITE_ACCEPT_OK);
        return ret;
    }

    switch (ret) {
        case -1: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_INVITE_ACCEPT_BAD_INVITE);
            return UINT32_MAX;
        }

        case -2: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_INVITE_ACCEPT_INIT_FAILED);
            return UINT32_MAX;
        }

        case -3: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_INVITE_ACCEPT_TOO_LONG);
            return UINT32_MAX;
        }

        case -4: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_INVITE_ACCEPT_EMPTY);
            return UINT32_MAX;
        }

        case -5: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_INVITE_ACCEPT_PASSWORD);
            return UINT32_MAX;
        }

        case -6: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_INVITE_ACCEPT_CORE);
            return UINT32_MAX;
        }

        case -7: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_INVITE_ACCEPT_FAIL_SEND);
            return UINT32_MAX;
        }
    }

    /* can't happen */
    LOGGER_FATAL(tox->m->log, "impossible return value: %d", ret);

    return UINT32_MAX;
}

bool tox_group_founder_set_password(const Tox *tox, uint32_t group_number, const uint8_t *password, size_t length,
                                    Tox_Err_Group_Founder_Set_Password *error)
{
    assert(tox != nullptr);

    tox_lock(tox);
    GC_Chat *chat = gc_get_group(tox->m->group_handler, group_number);

    if (chat == nullptr) {
        SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_FOUNDER_SET_PASSWORD_GROUP_NOT_FOUND);
        tox_unlock(tox);
        return false;
    }

    if (chat->connection_state == CS_DISCONNECTED) {
        SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_FOUNDER_SET_PASSWORD_DISCONNECTED);
        tox_unlock(tox);
        return false;
    }

    const int ret = gc_founder_set_password(chat, password, length);
    tox_unlock(tox);

    switch (ret) {
        case 0: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_FOUNDER_SET_PASSWORD_OK);
            return true;
        }

        case -1: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_FOUNDER_SET_PASSWORD_PERMISSIONS);
            return false;
        }

        case -2: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_FOUNDER_SET_PASSWORD_TOO_LONG);
            return false;
        }

        case -3: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_FOUNDER_SET_PASSWORD_FAIL_SEND);
            return false;
        }

        case -4: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_FOUNDER_SET_PASSWORD_MALLOC);
            return false;
        }
    }

    /* can't happen */
    LOGGER_FATAL(tox->m->log, "impossible return value: %d", ret);

    return false;
}

bool tox_group_founder_set_privacy_state(const Tox *tox, uint32_t group_number, Tox_Group_Privacy_State privacy_state,
        Tox_Err_Group_Founder_Set_Privacy_State *error)
{
    assert(tox != nullptr);

    tox_lock(tox);
    const int ret = gc_founder_set_privacy_state(tox->m, group_number, (Group_Privacy_State) privacy_state);
    tox_unlock(tox);

    switch (ret) {
        case 0: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_FOUNDER_SET_PRIVACY_STATE_OK);
            return true;
        }

        case -1: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_FOUNDER_SET_PRIVACY_STATE_GROUP_NOT_FOUND);
            return false;
        }

        case -2: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_FOUNDER_SET_PRIVACY_STATE_PERMISSIONS);
            return false;
        }

        case -3: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_FOUNDER_SET_PRIVACY_STATE_DISCONNECTED);
            return false;
        }

        case -4: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_FOUNDER_SET_PRIVACY_STATE_FAIL_SET);
            return false;
        }

        case -5: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_FOUNDER_SET_PRIVACY_STATE_FAIL_SEND);
            return false;
        }
    }

    /* can't happen */
    LOGGER_FATAL(tox->m->log, "impossible return value: %d", ret);

    return false;
}

bool tox_group_founder_set_topic_lock(const Tox *tox, uint32_t group_number, Tox_Group_Topic_Lock topic_lock,
                                      Tox_Err_Group_Founder_Set_Topic_Lock *error)
{
    assert(tox != nullptr);

    tox_lock(tox);
    const int ret = gc_founder_set_topic_lock(tox->m, group_number, (Group_Topic_Lock) topic_lock);
    tox_unlock(tox);

    switch (ret) {
        case 0: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_FOUNDER_SET_TOPIC_LOCK_OK);
            return true;
        }

        case -1: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_FOUNDER_SET_TOPIC_LOCK_GROUP_NOT_FOUND);
            return false;
        }

        case -2: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_FOUNDER_SET_TOPIC_LOCK_INVALID);
            return false;
        }

        case -3: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_FOUNDER_SET_TOPIC_LOCK_PERMISSIONS);
            return false;
        }

        case -4: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_FOUNDER_SET_TOPIC_LOCK_DISCONNECTED);
            return false;
        }

        case -5: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_FOUNDER_SET_TOPIC_LOCK_FAIL_SET);
            return false;
        }

        case -6: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_FOUNDER_SET_TOPIC_LOCK_FAIL_SEND);
            return false;
        }
    }

    /* can't happen */
    LOGGER_FATAL(tox->m->log, "impossible return value: %d", ret);

    return false;
}

bool tox_group_founder_set_voice_state(const Tox *tox, uint32_t group_number, Tox_Group_Voice_State voice_state,
                                       Tox_Err_Group_Founder_Set_Voice_State *error)
{
    assert(tox != nullptr);

    tox_lock(tox);
    const int ret = gc_founder_set_voice_state(tox->m, group_number, (Group_Voice_State)voice_state);
    tox_unlock(tox);

    switch (ret) {
        case 0: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_FOUNDER_SET_VOICE_STATE_OK);
            return true;
        }

        case -1: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_FOUNDER_SET_VOICE_STATE_GROUP_NOT_FOUND);
            return false;
        }

        case -2: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_FOUNDER_SET_VOICE_STATE_PERMISSIONS);
            return false;
        }

        case -3: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_FOUNDER_SET_VOICE_STATE_DISCONNECTED);
            return false;
        }

        case -4: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_FOUNDER_SET_VOICE_STATE_FAIL_SET);
            return false;
        }

        case -5: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_FOUNDER_SET_VOICE_STATE_FAIL_SEND);
            return false;
        }
    }

    /* can't happen */
    LOGGER_FATAL(tox->m->log, "impossible return value: %d", ret);

    return false;
}

bool tox_group_founder_set_peer_limit(const Tox *tox, uint32_t group_number, uint16_t max_peers,
                                      Tox_Err_Group_Founder_Set_Peer_Limit *error)
{
    assert(tox != nullptr);

    tox_lock(tox);
    GC_Chat *chat = gc_get_group(tox->m->group_handler, group_number);

    if (chat == nullptr) {
        SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_FOUNDER_SET_PEER_LIMIT_GROUP_NOT_FOUND);
        tox_unlock(tox);
        return false;
    }

    if (chat->connection_state == CS_DISCONNECTED) {
        SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_FOUNDER_SET_PEER_LIMIT_DISCONNECTED);
        tox_unlock(tox);
        return false;
    }

    const int ret = gc_founder_set_max_peers(chat, max_peers);
    tox_unlock(tox);

    switch (ret) {
        case 0: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_FOUNDER_SET_PEER_LIMIT_OK);
            return true;
        }

        case -1: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_FOUNDER_SET_PEER_LIMIT_PERMISSIONS);
            return false;
        }

        case -2: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_FOUNDER_SET_PEER_LIMIT_FAIL_SET);
            return false;
        }

        case -3: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_FOUNDER_SET_PEER_LIMIT_FAIL_SEND);
            return false;
        }
    }

    /* can't happen */
    LOGGER_FATAL(tox->m->log, "impossible return value: %d", ret);

    return false;
}

bool tox_group_set_ignore(const Tox *tox, uint32_t group_number, uint32_t peer_id, bool ignore,
                          Tox_Err_Group_Set_Ignore *error)
{
    assert(tox != nullptr);

    tox_lock(tox);
    const GC_Chat *chat = gc_get_group(tox->m->group_handler, group_number);

    if (chat == nullptr) {
        SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_SET_IGNORE_GROUP_NOT_FOUND);
        tox_unlock(tox);
        return false;
    }

    const int ret = gc_set_ignore(chat, peer_id, ignore);
    tox_unlock(tox);

    switch (ret) {
        case 0: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_SET_IGNORE_OK);
            return true;
        }

        case -1: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_SET_IGNORE_PEER_NOT_FOUND);
            return false;
        }

        case -2: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_SET_IGNORE_SELF);
            return false;
        }
    }

    /* can't happen */
    LOGGER_FATAL(tox->m->log, "impossible return value: %d", ret);

    return false;
}

bool tox_group_mod_set_role(const Tox *tox, uint32_t group_number, uint32_t peer_id, Tox_Group_Role role,
                            Tox_Err_Group_Mod_Set_Role *error)
{
    assert(tox != nullptr);

    tox_lock(tox);
    const int ret = gc_set_peer_role(tox->m, group_number, peer_id, (Group_Role) role);
    tox_unlock(tox);

    switch (ret) {
        case 0: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_MOD_SET_ROLE_OK);
            return true;
        }

        case -1: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_MOD_SET_ROLE_GROUP_NOT_FOUND);
            return false;
        }

        case -2: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_MOD_SET_ROLE_PEER_NOT_FOUND);
            return false;
        }

        case -3: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_MOD_SET_ROLE_PERMISSIONS);
            return false;
        }

        case -4: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_MOD_SET_ROLE_ASSIGNMENT);
            return false;
        }

        case -5: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_MOD_SET_ROLE_FAIL_ACTION);
            return false;
        }

        case -6: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_MOD_SET_ROLE_SELF);
            return false;
        }
    }

    /* can't happen */
    LOGGER_FATAL(tox->m->log, "impossible return value: %d", ret);

    return false;
}

bool tox_group_mod_kick_peer(const Tox *tox, uint32_t group_number, uint32_t peer_id,
                             Tox_Err_Group_Mod_Kick_Peer *error)
{
    assert(tox != nullptr);

    tox_lock(tox);
    const int ret = gc_kick_peer(tox->m, group_number, peer_id);
    tox_unlock(tox);

    switch (ret) {
        case 0: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_MOD_KICK_PEER_OK);
            return true;
        }

        case -1: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_MOD_KICK_PEER_GROUP_NOT_FOUND);
            return false;
        }

        case -2: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_MOD_KICK_PEER_PEER_NOT_FOUND);
            return false;
        }

        case -3: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_MOD_KICK_PEER_PERMISSIONS);
            return false;
        }

        case -4: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_MOD_KICK_PEER_FAIL_ACTION);
            return false;
        }

        case -5: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_MOD_KICK_PEER_FAIL_SEND);
            return false;
        }

        case -6: {
            SET_ERROR_PARAMETER(error, TOX_ERR_GROUP_MOD_KICK_PEER_SELF);
            return false;
        }
    }

    /* can't happen */
    LOGGER_FATAL(tox->m->log, "impossible return value: %d", ret);

    return false;
}

#endif /* VANILLA_NACL */


/* * * * * * * * * * * * * * *
 *
 * MessageV2 functions
 *
 * * * * * * * * * * * * * * */

/*
 * sending
 */
uint32_t tox_messagev2_size(uint32_t text_length, uint32_t type, uint32_t alter_type)
{
    if (type == TOX_FILE_KIND_MESSAGEV2_SEND) {
        return (TOX_PUBLIC_KEY_SIZE + 4 + 2 + text_length);
    } else if (type == TOX_FILE_KIND_MESSAGEV2_SYNC) {
        return (TOX_PUBLIC_KEY_SIZE + 4 + 2 + TOX_PUBLIC_KEY_SIZE + 4 + text_length);
    } else if (type == TOX_FILE_KIND_MESSAGEV2_ANSWER) {
        return (TOX_PUBLIC_KEY_SIZE + 4 + 2);
    } else { // TOX_FILE_KIND_MESSAGEV2_ALTER
        if (alter_type == TOX_MESSAGEV2_ALTER_TYPE_CORRECT) {
            return (TOX_PUBLIC_KEY_SIZE + 32 + 4 + 2 + 1 + text_length);
        } else { // TOX_MESSAGEV2_ALTER_TYPE_DELETE
            return (TOX_PUBLIC_KEY_SIZE + 32 + 4 + 2 + 1);
        }

    }
}


bool tox_messagev2_sync_wrap(uint32_t data_length, const uint8_t *original_sender_pubkey_bin,
                             uint32_t data_msg_type,
                             const uint8_t *raw_data, uint32_t ts_sec,
                             uint16_t ts_ms, uint8_t *raw_message,
                             uint8_t *msgid)
{

    if (raw_message == nullptr) {
        return false;
    }

    if (msgid == nullptr) {
        return false;
    }

    if (original_sender_pubkey_bin == nullptr) {
        return false;
    }

    if (raw_data == nullptr) {
        return false;
    }

    if (data_length == 0) {
        return false;
    }

    // uint8_t nonce[CRYPTO_NONCE_SIZE];
    // random_nonce(nonce);

    uint8_t *raw_message_cpy = raw_message;

    /* Tox keys are 32 bytes, so we use this directly as new "message id" */
    new_symmetric_key_implicit_random(msgid);

    memcpy(raw_message_cpy, msgid, TOX_PUBLIC_KEY_SIZE);
    raw_message_cpy += TOX_PUBLIC_KEY_SIZE;

    memcpy(raw_message_cpy, &ts_sec, 4);
    raw_message_cpy += 4;

    memcpy(raw_message_cpy, &ts_ms, 2);
    raw_message_cpy += 2;

    memcpy(raw_message_cpy, original_sender_pubkey_bin, TOX_PUBLIC_KEY_SIZE);
    raw_message_cpy += TOX_PUBLIC_KEY_SIZE;

    memcpy(raw_message_cpy, &data_msg_type, 4);
    raw_message_cpy += 4;

    memcpy(raw_message_cpy, raw_data, data_length);

    return true;
}

bool tox_messagev2_wrap(uint32_t text_length, uint32_t type,
                        uint32_t alter_type,
                        const uint8_t *message_text, uint32_t ts_sec,
                        uint16_t ts_ms, uint8_t *raw_message,
                        uint8_t *msgid)
{

    bool result_code = false;

    if (type == TOX_FILE_KIND_MESSAGEV2_SYNC) {
        return false;
    }

    if (raw_message == nullptr) {
        return false;
    }

    if (msgid == nullptr) {
        return false;
    }

    if ((message_text == nullptr) && (type == TOX_FILE_KIND_MESSAGEV2_SEND)) {
        return false;
    }

    if ((text_length == 0) && (type == TOX_FILE_KIND_MESSAGEV2_SEND)) {
        return false;
    }

    if ((message_text == nullptr) && (type == TOX_FILE_KIND_MESSAGEV2_ALTER) &&
            (alter_type == TOX_MESSAGEV2_ALTER_TYPE_CORRECT)) {
        return false;
    }

    if ((text_length == 0) && (type == TOX_FILE_KIND_MESSAGEV2_ALTER) &&
            (alter_type == TOX_MESSAGEV2_ALTER_TYPE_CORRECT)) {
        return false;
    }

    // uint8_t nonce[CRYPTO_NONCE_SIZE];
    // random_nonce(nonce);


    if (type == TOX_FILE_KIND_MESSAGEV2_SEND) {

        uint8_t *raw_message_cpy = raw_message;

        /* Tox keys are 32 bytes, so we use this directly as new "message id" */
        new_symmetric_key_implicit_random(msgid);

        memcpy(raw_message_cpy, msgid, TOX_PUBLIC_KEY_SIZE);
        raw_message_cpy += TOX_PUBLIC_KEY_SIZE;

        memcpy(raw_message_cpy, &ts_sec, 4);
        raw_message_cpy += 4;

        memcpy(raw_message_cpy, &ts_ms, 2);
        raw_message_cpy += 2;

        memcpy(raw_message_cpy, message_text, text_length);

        result_code = true;

    } else if (type == TOX_FILE_KIND_MESSAGEV2_ANSWER) {

        uint8_t *raw_message_cpy = raw_message;

        memcpy(raw_message_cpy, msgid, TOX_PUBLIC_KEY_SIZE);
        raw_message_cpy += TOX_PUBLIC_KEY_SIZE;

        memcpy(raw_message_cpy, &ts_sec, 4);
        raw_message_cpy += 4;

        memcpy(raw_message_cpy, &ts_ms, 2);

        result_code = true;

    } else { // TOX_FILE_KIND_MESSAGEV2_ALTER
        if (alter_type == TOX_MESSAGEV2_ALTER_TYPE_CORRECT) {
            // TODO(zoff): * write me *
            // TODO(zoff): * write me *
        } else { // TOX_MESSAGEV2_ALTER_TYPE_DELETE
            // TODO(zoff): * write me *
            // TODO(zoff): * write me *
        }
    }

    return result_code;
}

/*
 * receiving
 */
bool tox_messagev2_get_message_id(const uint8_t *raw_message, uint8_t *msg_id)
{
    if (raw_message == nullptr) {
        return false;
    }

    if (msg_id == nullptr) {
        return false;
    }

    memcpy(msg_id, raw_message, TOX_PUBLIC_KEY_SIZE);

    return true;
}

bool tox_messagev2_get_message_alter_id(uint8_t *raw_message, uint8_t *alter_id)
{
    if (raw_message == nullptr) {
        return false;
    }

    if (alter_id == nullptr) {
        return false;
    }

    memcpy(alter_id, raw_message + TOX_PUBLIC_KEY_SIZE + 4 + 2 + 1, TOX_PUBLIC_KEY_SIZE);

    return true;
}

bool tox_messagev2_get_sync_message_pubkey(const uint8_t *raw_message, uint8_t *pubkey)
{
    if (raw_message == nullptr) {
        return false;
    }

    if (pubkey == nullptr) {
        return false;
    }

    memcpy(pubkey, (raw_message + TOX_PUBLIC_KEY_SIZE + 4 + 2), TOX_PUBLIC_KEY_SIZE);

    return true;
}

uint32_t tox_messagev2_get_sync_message_type(const uint8_t *raw_message)
{
    if (raw_message == nullptr) {
        return UINT32_MAX;
    }

    uint32_t sync_msg_type;
    memcpy(&sync_msg_type, (raw_message + TOX_PUBLIC_KEY_SIZE + 4 + 2 + TOX_PUBLIC_KEY_SIZE), 4);

    return sync_msg_type;
}


uint8_t tox_messagev2_get_alter_type(uint8_t *raw_message)
{
    if (raw_message == nullptr) {
        return false;
    }

    uint8_t return_value;
    memcpy(&return_value, raw_message + TOX_PUBLIC_KEY_SIZE + 4 + 2, sizeof(return_value));

    // HINT: crude check, that type will be a valid value
    if (return_value != TOX_MESSAGEV2_ALTER_TYPE_DELETE) {
        return_value = TOX_MESSAGEV2_ALTER_TYPE_CORRECT;
    }

    return return_value;
}

uint32_t tox_messagev2_get_ts_sec(const uint8_t *raw_message)
{
    if (raw_message == nullptr) {
        return false;
    }

    uint32_t return_value;
    memcpy(&return_value, raw_message + TOX_PUBLIC_KEY_SIZE, sizeof(return_value));

    return return_value;
}

uint16_t tox_messagev2_get_ts_ms(const uint8_t *raw_message)
{
    if (raw_message == nullptr) {
        return false;
    }

    uint16_t return_value;
    memcpy(&return_value, raw_message + TOX_PUBLIC_KEY_SIZE + 4, sizeof(return_value));

    return return_value;
}

bool tox_messagev2_get_sync_message_data(const uint8_t *raw_message, uint32_t raw_message_len,
        uint8_t *message_text, uint32_t *text_length)
{
    bool result = false;

    if (raw_message == nullptr) {
        return false;
    }

    if (message_text == nullptr) {
        return false;
    }

    if (text_length == nullptr) {
        return false;
    }

    // HINT: we want at least 1 byte of real message text
    if (raw_message_len < (TOX_PUBLIC_KEY_SIZE + 4 + 2 + TOX_PUBLIC_KEY_SIZE + 4 + 1)) {
        return false;
    }

    *text_length = (raw_message_len - (TOX_PUBLIC_KEY_SIZE + 4 + 2 + TOX_PUBLIC_KEY_SIZE + 4));
    memcpy(message_text, raw_message + TOX_PUBLIC_KEY_SIZE + 4 + 2 + TOX_PUBLIC_KEY_SIZE + 4, *text_length);

    return result;

}

bool tox_messagev2_get_message_text(const uint8_t *raw_message, uint32_t raw_message_len,
                                    bool is_alter_msg,
                                    uint32_t alter_type, uint8_t *message_text,
                                    uint32_t *text_length)
{
    if (raw_message == nullptr) {
        return false;
    }

    if (message_text == nullptr) {
        return false;
    }

    if (text_length == nullptr) {
        return false;
    }

    if (is_alter_msg == true) {
        if (alter_type == TOX_MESSAGEV2_ALTER_TYPE_DELETE) {
            // TODO(zoff): * write me *
            *text_length = 0;
            return false;
        } else { // TOX_MESSAGEV2_ALTER_TYPE_CORRECT
            // TODO(zoff): * write me *
            *text_length = 0;
            return false;
        }
    } else { // TOX_FILE_KIND_MESSAGEV2_SEND
        // HINT: we want at least 1 byte of real message text
        if (raw_message_len < (TOX_PUBLIC_KEY_SIZE + 4 + 2 + 1)) {
            return false;
        }

        *text_length = (raw_message_len - (TOX_PUBLIC_KEY_SIZE + 4 + 2));
        memcpy(message_text, raw_message + TOX_PUBLIC_KEY_SIZE + 4 + 2, *text_length);
    }

    return true;
}

void tox_logmsg(const Tox *tox, Logger_Level level, const char *file, int line, const char *func, const char *fmt, ...)
{
    if (!tox) {
        return;
    }

    tox_lock(tox);
    va_list args;
    va_start(args, fmt);

    logger_api_write(tox->m->log, level, file, line, func, fmt, args);

    va_end(args);
    tox_unlock(tox);
}

void tox_set_force_udp_only_mode(bool value)
{
    global_force_udp_only_mode = value;
}

void tox_set_do_not_sync_av(bool value)
{
    global_do_not_sync_av = value;
}

void tox_set_onion_active(bool value)
{
    global_onion_active = value;
}

void tox_get_all_tcp_relays(const Tox *tox, char *report)
{
    tox_lock(tox);
    print_all_tcp_relays(tox->m, report);
    tox_unlock(tox);
}

void tox_get_all_udp_connections(const Tox *tox, char *report)
{
    tox_lock(tox);
    print_all_udp_connections(tox->m, report);
    tox_unlock(tox);
}
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2022 The TokTok team.
 */


#include <stdlib.h>


struct Tox_Dispatch {
    tox_events_conference_connected_cb *conference_connected_callback;
    tox_events_conference_invite_cb *conference_invite_callback;
    tox_events_conference_message_cb *conference_message_callback;
    tox_events_conference_peer_list_changed_cb *conference_peer_list_changed_callback;
    tox_events_conference_peer_name_cb *conference_peer_name_callback;
    tox_events_conference_title_cb *conference_title_callback;
    tox_events_file_chunk_request_cb *file_chunk_request_callback;
    tox_events_file_recv_cb *file_recv_callback;
    tox_events_file_recv_chunk_cb *file_recv_chunk_callback;
    tox_events_file_recv_control_cb *file_recv_control_callback;
    tox_events_friend_connection_status_cb *friend_connection_status_callback;
    tox_events_friend_lossless_packet_cb *friend_lossless_packet_callback;
    tox_events_friend_lossy_packet_cb *friend_lossy_packet_callback;
    tox_events_friend_message_cb *friend_message_callback;
    tox_events_friend_name_cb *friend_name_callback;
    tox_events_friend_read_receipt_cb *friend_read_receipt_callback;
    tox_events_friend_request_cb *friend_request_callback;
    tox_events_friend_status_cb *friend_status_callback;
    tox_events_friend_status_message_cb *friend_status_message_callback;
    tox_events_friend_typing_cb *friend_typing_callback;
    tox_events_self_connection_status_cb *self_connection_status_callback;
};

Tox_Dispatch *tox_dispatch_new(Tox_Err_Dispatch_New *error)
{
    Tox_Dispatch *dispatch = (Tox_Dispatch *)calloc(1, sizeof(Tox_Dispatch));

    if (dispatch == nullptr) {
        if (error != nullptr) {
            *error = TOX_ERR_DISPATCH_NEW_MALLOC;
        }

        return nullptr;
    }

    *dispatch = (Tox_Dispatch) {
        nullptr
    };

    if (error != nullptr) {
        *error = TOX_ERR_DISPATCH_NEW_OK;
    }

    return dispatch;
}

void tox_dispatch_free(Tox_Dispatch *dispatch)
{
    free(dispatch);
}

void tox_events_callback_conference_connected(
    Tox_Dispatch *dispatch, tox_events_conference_connected_cb *callback)
{
    dispatch->conference_connected_callback = callback;
}
void tox_events_callback_conference_invite(
    Tox_Dispatch *dispatch, tox_events_conference_invite_cb *callback)
{
    dispatch->conference_invite_callback = callback;
}
void tox_events_callback_conference_message(
    Tox_Dispatch *dispatch, tox_events_conference_message_cb *callback)
{
    dispatch->conference_message_callback = callback;
}
void tox_events_callback_conference_peer_list_changed(
    Tox_Dispatch *dispatch, tox_events_conference_peer_list_changed_cb *callback)
{
    dispatch->conference_peer_list_changed_callback = callback;
}
void tox_events_callback_conference_peer_name(
    Tox_Dispatch *dispatch, tox_events_conference_peer_name_cb *callback)
{
    dispatch->conference_peer_name_callback = callback;
}
void tox_events_callback_conference_title(
    Tox_Dispatch *dispatch, tox_events_conference_title_cb *callback)
{
    dispatch->conference_title_callback = callback;
}
void tox_events_callback_file_chunk_request(
    Tox_Dispatch *dispatch, tox_events_file_chunk_request_cb *callback)
{
    dispatch->file_chunk_request_callback = callback;
}
void tox_events_callback_file_recv(
    Tox_Dispatch *dispatch, tox_events_file_recv_cb *callback)
{
    dispatch->file_recv_callback = callback;
}
void tox_events_callback_file_recv_chunk(
    Tox_Dispatch *dispatch, tox_events_file_recv_chunk_cb *callback)
{
    dispatch->file_recv_chunk_callback = callback;
}
void tox_events_callback_file_recv_control(
    Tox_Dispatch *dispatch, tox_events_file_recv_control_cb *callback)
{
    dispatch->file_recv_control_callback = callback;
}
void tox_events_callback_friend_connection_status(
    Tox_Dispatch *dispatch, tox_events_friend_connection_status_cb *callback)
{
    dispatch->friend_connection_status_callback = callback;
}
void tox_events_callback_friend_lossless_packet(
    Tox_Dispatch *dispatch, tox_events_friend_lossless_packet_cb *callback)
{
    dispatch->friend_lossless_packet_callback = callback;
}
void tox_events_callback_friend_lossy_packet(
    Tox_Dispatch *dispatch, tox_events_friend_lossy_packet_cb *callback)
{
    dispatch->friend_lossy_packet_callback = callback;
}
void tox_events_callback_friend_message(
    Tox_Dispatch *dispatch, tox_events_friend_message_cb *callback)
{
    dispatch->friend_message_callback = callback;
}
void tox_events_callback_friend_name(
    Tox_Dispatch *dispatch, tox_events_friend_name_cb *callback)
{
    dispatch->friend_name_callback = callback;
}
void tox_events_callback_friend_read_receipt(
    Tox_Dispatch *dispatch, tox_events_friend_read_receipt_cb *callback)
{
    dispatch->friend_read_receipt_callback = callback;
}
void tox_events_callback_friend_request(
    Tox_Dispatch *dispatch, tox_events_friend_request_cb *callback)
{
    dispatch->friend_request_callback = callback;
}
void tox_events_callback_friend_status(
    Tox_Dispatch *dispatch, tox_events_friend_status_cb *callback)
{
    dispatch->friend_status_callback = callback;
}
void tox_events_callback_friend_status_message(
    Tox_Dispatch *dispatch, tox_events_friend_status_message_cb *callback)
{
    dispatch->friend_status_message_callback = callback;
}
void tox_events_callback_friend_typing(
    Tox_Dispatch *dispatch, tox_events_friend_typing_cb *callback)
{
    dispatch->friend_typing_callback = callback;
}
void tox_events_callback_self_connection_status(
    Tox_Dispatch *dispatch, tox_events_self_connection_status_cb *callback)
{
    dispatch->self_connection_status_callback = callback;
}

non_null(1, 3) nullable(2, 4)
static void tox_dispatch_invoke_conference_connected(
    const Tox_Dispatch *dispatch, const Tox_Events *events, Tox *tox, void *user_data)
{
    const uint32_t size = tox_events_get_conference_connected_size(events);

    for (uint32_t i = 0; i < size; ++i) {
        if (dispatch->conference_connected_callback != nullptr) {
            dispatch->conference_connected_callback(
                tox, tox_events_get_conference_connected(events, i), user_data);
        }
    }
}

non_null(1, 3) nullable(2, 4)
static void tox_dispatch_invoke_conference_invite(
    const Tox_Dispatch *dispatch, const Tox_Events *events, Tox *tox, void *user_data)
{
    const uint32_t size = tox_events_get_conference_invite_size(events);

    for (uint32_t i = 0; i < size; ++i) {
        if (dispatch->conference_invite_callback != nullptr) {
            dispatch->conference_invite_callback(
                tox, tox_events_get_conference_invite(events, i), user_data);
        }
    }
}

non_null(1, 3) nullable(2, 4)
static void tox_dispatch_invoke_conference_message(
    const Tox_Dispatch *dispatch, const Tox_Events *events, Tox *tox, void *user_data)
{
    const uint32_t size = tox_events_get_conference_message_size(events);

    for (uint32_t i = 0; i < size; ++i) {
        if (dispatch->conference_message_callback != nullptr) {
            dispatch->conference_message_callback(
                tox, tox_events_get_conference_message(events, i), user_data);
        }
    }
}

non_null(1, 3) nullable(2, 4)
static void tox_dispatch_invoke_conference_peer_list_changed(
    const Tox_Dispatch *dispatch, const Tox_Events *events, Tox *tox, void *user_data)
{
    const uint32_t size = tox_events_get_conference_peer_list_changed_size(events);

    for (uint32_t i = 0; i < size; ++i) {
        if (dispatch->conference_peer_list_changed_callback != nullptr) {
            dispatch->conference_peer_list_changed_callback(
                tox, tox_events_get_conference_peer_list_changed(events, i), user_data);
        }
    }
}

non_null(1, 3) nullable(2, 4)
static void tox_dispatch_invoke_conference_peer_name(
    const Tox_Dispatch *dispatch, const Tox_Events *events, Tox *tox, void *user_data)
{
    const uint32_t size = tox_events_get_conference_peer_name_size(events);

    for (uint32_t i = 0; i < size; ++i) {
        if (dispatch->conference_peer_name_callback != nullptr) {
            dispatch->conference_peer_name_callback(
                tox, tox_events_get_conference_peer_name(events, i), user_data);
        }
    }
}

non_null(1, 3) nullable(2, 4)
static void tox_dispatch_invoke_conference_title(
    const Tox_Dispatch *dispatch, const Tox_Events *events, Tox *tox, void *user_data)
{
    const uint32_t size = tox_events_get_conference_title_size(events);

    for (uint32_t i = 0; i < size; ++i) {
        if (dispatch->conference_title_callback != nullptr) {
            dispatch->conference_title_callback(
                tox, tox_events_get_conference_title(events, i), user_data);
        }
    }
}

non_null(1, 3) nullable(2, 4)
static void tox_dispatch_invoke_file_chunk_request(
    const Tox_Dispatch *dispatch, const Tox_Events *events, Tox *tox, void *user_data)
{
    const uint32_t size = tox_events_get_file_chunk_request_size(events);

    for (uint32_t i = 0; i < size; ++i) {
        if (dispatch->file_chunk_request_callback != nullptr) {
            dispatch->file_chunk_request_callback(
                tox, tox_events_get_file_chunk_request(events, i), user_data);
        }
    }
}

non_null(1, 3) nullable(2, 4)
static void tox_dispatch_invoke_file_recv(
    const Tox_Dispatch *dispatch, const Tox_Events *events, Tox *tox, void *user_data)
{
    const uint32_t size = tox_events_get_file_recv_size(events);

    for (uint32_t i = 0; i < size; ++i) {
        if (dispatch->file_recv_callback != nullptr) {
            dispatch->file_recv_callback(
                tox, tox_events_get_file_recv(events, i), user_data);
        }
    }
}

non_null(1, 3) nullable(2, 4)
static void tox_dispatch_invoke_file_recv_chunk(
    const Tox_Dispatch *dispatch, const Tox_Events *events, Tox *tox, void *user_data)
{
    const uint32_t size = tox_events_get_file_recv_chunk_size(events);

    for (uint32_t i = 0; i < size; ++i) {
        if (dispatch->file_recv_chunk_callback != nullptr) {
            dispatch->file_recv_chunk_callback(
                tox, tox_events_get_file_recv_chunk(events, i), user_data);
        }
    }
}

non_null(1, 3) nullable(2, 4)
static void tox_dispatch_invoke_file_recv_control(
    const Tox_Dispatch *dispatch, const Tox_Events *events, Tox *tox, void *user_data)
{
    const uint32_t size = tox_events_get_file_recv_control_size(events);

    for (uint32_t i = 0; i < size; ++i) {
        if (dispatch->file_recv_control_callback != nullptr) {
            dispatch->file_recv_control_callback(
                tox, tox_events_get_file_recv_control(events, i), user_data);
        }
    }
}

non_null(1, 3) nullable(2, 4)
static void tox_dispatch_invoke_friend_connection_status(
    const Tox_Dispatch *dispatch, const Tox_Events *events, Tox *tox, void *user_data)
{
    const uint32_t size = tox_events_get_friend_connection_status_size(events);

    for (uint32_t i = 0; i < size; ++i) {
        if (dispatch->friend_connection_status_callback != nullptr) {
            dispatch->friend_connection_status_callback(
                tox, tox_events_get_friend_connection_status(events, i), user_data);
        }
    }
}

non_null(1, 3) nullable(2, 4)
static void tox_dispatch_invoke_friend_lossless_packet(
    const Tox_Dispatch *dispatch, const Tox_Events *events, Tox *tox, void *user_data)
{
    const uint32_t size = tox_events_get_friend_lossless_packet_size(events);

    for (uint32_t i = 0; i < size; ++i) {
        if (dispatch->friend_lossless_packet_callback != nullptr) {
            dispatch->friend_lossless_packet_callback(
                tox, tox_events_get_friend_lossless_packet(events, i), user_data);
        }
    }
}

non_null(1, 3) nullable(2, 4)
static void tox_dispatch_invoke_friend_lossy_packet(
    const Tox_Dispatch *dispatch, const Tox_Events *events, Tox *tox, void *user_data)
{
    const uint32_t size = tox_events_get_friend_lossy_packet_size(events);

    for (uint32_t i = 0; i < size; ++i) {
        if (dispatch->friend_lossy_packet_callback != nullptr) {
            dispatch->friend_lossy_packet_callback(
                tox, tox_events_get_friend_lossy_packet(events, i), user_data);
        }
    }
}

non_null(1, 3) nullable(2, 4)
static void tox_dispatch_invoke_friend_message(
    const Tox_Dispatch *dispatch, const Tox_Events *events, Tox *tox, void *user_data)
{
    const uint32_t size = tox_events_get_friend_message_size(events);

    for (uint32_t i = 0; i < size; ++i) {
        if (dispatch->friend_message_callback != nullptr) {
            dispatch->friend_message_callback(
                tox, tox_events_get_friend_message(events, i), user_data);
        }
    }
}

non_null(1, 3) nullable(2, 4)
static void tox_dispatch_invoke_friend_name(
    const Tox_Dispatch *dispatch, const Tox_Events *events, Tox *tox, void *user_data)
{
    const uint32_t size = tox_events_get_friend_name_size(events);

    for (uint32_t i = 0; i < size; ++i) {
        if (dispatch->friend_name_callback != nullptr) {
            dispatch->friend_name_callback(
                tox, tox_events_get_friend_name(events, i), user_data);
        }
    }
}

non_null(1, 3) nullable(2, 4)
static void tox_dispatch_invoke_friend_read_receipt(
    const Tox_Dispatch *dispatch, const Tox_Events *events, Tox *tox, void *user_data)
{
    const uint32_t size = tox_events_get_friend_read_receipt_size(events);

    for (uint32_t i = 0; i < size; ++i) {
        if (dispatch->friend_read_receipt_callback != nullptr) {
            dispatch->friend_read_receipt_callback(
                tox, tox_events_get_friend_read_receipt(events, i), user_data);
        }
    }
}

non_null(1, 3) nullable(2, 4)
static void tox_dispatch_invoke_friend_request(
    const Tox_Dispatch *dispatch, const Tox_Events *events, Tox *tox, void *user_data)
{
    const uint32_t size = tox_events_get_friend_request_size(events);

    for (uint32_t i = 0; i < size; ++i) {
        if (dispatch->friend_request_callback != nullptr) {
            dispatch->friend_request_callback(
                tox, tox_events_get_friend_request(events, i), user_data);
        }
    }
}

non_null(1, 3) nullable(2, 4)
static void tox_dispatch_invoke_friend_status(
    const Tox_Dispatch *dispatch, const Tox_Events *events, Tox *tox, void *user_data)
{
    const uint32_t size = tox_events_get_friend_status_size(events);

    for (uint32_t i = 0; i < size; ++i) {
        if (dispatch->friend_status_callback != nullptr) {
            dispatch->friend_status_callback(
                tox, tox_events_get_friend_status(events, i), user_data);
        }
    }
}

non_null(1, 3) nullable(2, 4)
static void tox_dispatch_invoke_friend_status_message(
    const Tox_Dispatch *dispatch, const Tox_Events *events, Tox *tox, void *user_data)
{
    const uint32_t size = tox_events_get_friend_status_message_size(events);

    for (uint32_t i = 0; i < size; ++i) {
        if (dispatch->friend_status_message_callback != nullptr) {
            dispatch->friend_status_message_callback(
                tox, tox_events_get_friend_status_message(events, i), user_data);
        }
    }
}

non_null(1, 3) nullable(2, 4)
static void tox_dispatch_invoke_friend_typing(
    const Tox_Dispatch *dispatch, const Tox_Events *events, Tox *tox, void *user_data)
{
    const uint32_t size = tox_events_get_friend_typing_size(events);

    for (uint32_t i = 0; i < size; ++i) {
        if (dispatch->friend_typing_callback != nullptr) {
            dispatch->friend_typing_callback(
                tox, tox_events_get_friend_typing(events, i), user_data);
        }
    }
}

non_null(1, 3) nullable(2, 4)
static void tox_dispatch_invoke_self_connection_status(
    const Tox_Dispatch *dispatch, const Tox_Events *events, Tox *tox, void *user_data)
{
    const uint32_t size = tox_events_get_self_connection_status_size(events);

    for (uint32_t i = 0; i < size; ++i) {
        if (dispatch->self_connection_status_callback != nullptr) {
            dispatch->self_connection_status_callback(
                tox, tox_events_get_self_connection_status(events, i), user_data);
        }
    }
}

void tox_dispatch_invoke(const Tox_Dispatch *dispatch, const Tox_Events *events, Tox *tox, void *user_data)
{
    tox_dispatch_invoke_conference_connected(dispatch, events, tox, user_data);
    tox_dispatch_invoke_conference_invite(dispatch, events, tox, user_data);
    tox_dispatch_invoke_conference_message(dispatch, events, tox, user_data);
    tox_dispatch_invoke_conference_peer_list_changed(dispatch, events, tox, user_data);
    tox_dispatch_invoke_conference_peer_name(dispatch, events, tox, user_data);
    tox_dispatch_invoke_conference_title(dispatch, events, tox, user_data);
    tox_dispatch_invoke_file_chunk_request(dispatch, events, tox, user_data);
    tox_dispatch_invoke_file_recv(dispatch, events, tox, user_data);
    tox_dispatch_invoke_file_recv_chunk(dispatch, events, tox, user_data);
    tox_dispatch_invoke_file_recv_control(dispatch, events, tox, user_data);
    tox_dispatch_invoke_friend_connection_status(dispatch, events, tox, user_data);
    tox_dispatch_invoke_friend_lossless_packet(dispatch, events, tox, user_data);
    tox_dispatch_invoke_friend_lossy_packet(dispatch, events, tox, user_data);
    tox_dispatch_invoke_friend_message(dispatch, events, tox, user_data);
    tox_dispatch_invoke_friend_name(dispatch, events, tox, user_data);
    tox_dispatch_invoke_friend_read_receipt(dispatch, events, tox, user_data);
    tox_dispatch_invoke_friend_request(dispatch, events, tox, user_data);
    tox_dispatch_invoke_friend_status(dispatch, events, tox, user_data);
    tox_dispatch_invoke_friend_status_message(dispatch, events, tox, user_data);
    tox_dispatch_invoke_friend_typing(dispatch, events, tox, user_data);
    tox_dispatch_invoke_self_connection_status(dispatch, events, tox, user_data);
}
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2022 The TokTok team.
 */


#include <stdio.h>
#include <stdlib.h>
#include <string.h>



/*****************************************************
 *
 * :: Set up event handlers.
 *
 *****************************************************/


void tox_events_init(Tox *tox)
{
    tox_callback_conference_connected(tox, tox_events_handle_conference_connected);
    tox_callback_conference_invite(tox, tox_events_handle_conference_invite);
    tox_callback_conference_message(tox, tox_events_handle_conference_message);
    tox_callback_conference_peer_list_changed(tox, tox_events_handle_conference_peer_list_changed);
    tox_callback_conference_peer_name(tox, tox_events_handle_conference_peer_name);
    tox_callback_conference_title(tox, tox_events_handle_conference_title);
    tox_callback_file_chunk_request(tox, tox_events_handle_file_chunk_request);
    tox_callback_file_recv_chunk(tox, tox_events_handle_file_recv_chunk);
    tox_callback_file_recv_control(tox, tox_events_handle_file_recv_control);
    tox_callback_file_recv(tox, tox_events_handle_file_recv);
    tox_callback_friend_connection_status(tox, tox_events_handle_friend_connection_status);
    tox_callback_friend_lossless_packet(tox, tox_events_handle_friend_lossless_packet);
    tox_callback_friend_lossy_packet(tox, tox_events_handle_friend_lossy_packet);
    tox_callback_friend_message(tox, tox_events_handle_friend_message);
    tox_callback_friend_name(tox, tox_events_handle_friend_name);
    tox_callback_friend_read_receipt(tox, tox_events_handle_friend_read_receipt);
    tox_callback_friend_request(tox, tox_events_handle_friend_request);
    tox_callback_friend_status_message(tox, tox_events_handle_friend_status_message);
    tox_callback_friend_status(tox, tox_events_handle_friend_status);
    tox_callback_friend_typing(tox, tox_events_handle_friend_typing);
    tox_callback_self_connection_status(tox, tox_events_handle_self_connection_status);
}

Tox_Events *tox_events_iterate(Tox *tox, bool fail_hard, Tox_Err_Events_Iterate *error)
{
    Tox_Events_State state = {TOX_ERR_EVENTS_ITERATE_OK};
    tox_iterate(tox, &state);

    if (error != nullptr) {
        *error = state.error;
    }

    if (fail_hard && state.error != TOX_ERR_EVENTS_ITERATE_OK) {
        tox_events_free(state.events);
        return nullptr;
    }

    return state.events;
}

bool tox_events_pack(const Tox_Events *events, Bin_Pack *bp)
{
    const uint32_t count = tox_events_get_conference_connected_size(events)
                           + tox_events_get_conference_invite_size(events)
                           + tox_events_get_conference_message_size(events)
                           + tox_events_get_conference_peer_list_changed_size(events)
                           + tox_events_get_conference_peer_name_size(events)
                           + tox_events_get_conference_title_size(events)
                           + tox_events_get_file_chunk_request_size(events)
                           + tox_events_get_file_recv_chunk_size(events)
                           + tox_events_get_file_recv_control_size(events)
                           + tox_events_get_file_recv_size(events)
                           + tox_events_get_friend_connection_status_size(events)
                           + tox_events_get_friend_lossless_packet_size(events)
                           + tox_events_get_friend_lossy_packet_size(events)
                           + tox_events_get_friend_message_size(events)
                           + tox_events_get_friend_name_size(events)
                           + tox_events_get_friend_read_receipt_size(events)
                           + tox_events_get_friend_request_size(events)
                           + tox_events_get_friend_status_message_size(events)
                           + tox_events_get_friend_status_size(events)
                           + tox_events_get_friend_typing_size(events)
                           + tox_events_get_self_connection_status_size(events);

    return bin_pack_array(bp, count)
           && tox_events_pack_conference_connected(events, bp)
           && tox_events_pack_conference_invite(events, bp)
           && tox_events_pack_conference_message(events, bp)
           && tox_events_pack_conference_peer_list_changed(events, bp)
           && tox_events_pack_conference_peer_name(events, bp)
           && tox_events_pack_conference_title(events, bp)
           && tox_events_pack_file_chunk_request(events, bp)
           && tox_events_pack_file_recv_chunk(events, bp)
           && tox_events_pack_file_recv_control(events, bp)
           && tox_events_pack_file_recv(events, bp)
           && tox_events_pack_friend_connection_status(events, bp)
           && tox_events_pack_friend_lossless_packet(events, bp)
           && tox_events_pack_friend_lossy_packet(events, bp)
           && tox_events_pack_friend_message(events, bp)
           && tox_events_pack_friend_name(events, bp)
           && tox_events_pack_friend_read_receipt(events, bp)
           && tox_events_pack_friend_request(events, bp)
           && tox_events_pack_friend_status_message(events, bp)
           && tox_events_pack_friend_status(events, bp)
           && tox_events_pack_friend_typing(events, bp)
           && tox_events_pack_self_connection_status(events, bp);
}

non_null()
static bool tox_event_unpack(Tox_Events *events, Bin_Unpack *bu)
{
    uint32_t size;
    if (!bin_unpack_array(bu, &size)) {
        return false;
    }

    if (size != 2) {
        return false;
    }

    uint8_t type;
    if (!bin_unpack_u08(bu, &type)) {
        return false;
    }

    switch (type) {
        case TOX_EVENT_CONFERENCE_CONNECTED:
            return tox_events_unpack_conference_connected(events, bu);

        case TOX_EVENT_CONFERENCE_INVITE:
            return tox_events_unpack_conference_invite(events, bu);

        case TOX_EVENT_CONFERENCE_MESSAGE:
            return tox_events_unpack_conference_message(events, bu);

        case TOX_EVENT_CONFERENCE_PEER_LIST_CHANGED:
            return tox_events_unpack_conference_peer_list_changed(events, bu);

        case TOX_EVENT_CONFERENCE_PEER_NAME:
            return tox_events_unpack_conference_peer_name(events, bu);

        case TOX_EVENT_CONFERENCE_TITLE:
            return tox_events_unpack_conference_title(events, bu);

        case TOX_EVENT_FILE_CHUNK_REQUEST:
            return tox_events_unpack_file_chunk_request(events, bu);

        case TOX_EVENT_FILE_RECV_CHUNK:
            return tox_events_unpack_file_recv_chunk(events, bu);

        case TOX_EVENT_FILE_RECV_CONTROL:
            return tox_events_unpack_file_recv_control(events, bu);

        case TOX_EVENT_FILE_RECV:
            return tox_events_unpack_file_recv(events, bu);

        case TOX_EVENT_FRIEND_CONNECTION_STATUS:
            return tox_events_unpack_friend_connection_status(events, bu);

        case TOX_EVENT_FRIEND_LOSSLESS_PACKET:
            return tox_events_unpack_friend_lossless_packet(events, bu);

        case TOX_EVENT_FRIEND_LOSSY_PACKET:
            return tox_events_unpack_friend_lossy_packet(events, bu);

        case TOX_EVENT_FRIEND_MESSAGE:
            return tox_events_unpack_friend_message(events, bu);

        case TOX_EVENT_FRIEND_NAME:
            return tox_events_unpack_friend_name(events, bu);

        case TOX_EVENT_FRIEND_READ_RECEIPT:
            return tox_events_unpack_friend_read_receipt(events, bu);

        case TOX_EVENT_FRIEND_REQUEST:
            return tox_events_unpack_friend_request(events, bu);

        case TOX_EVENT_FRIEND_STATUS_MESSAGE:
            return tox_events_unpack_friend_status_message(events, bu);

        case TOX_EVENT_FRIEND_STATUS:
            return tox_events_unpack_friend_status(events, bu);

        case TOX_EVENT_FRIEND_TYPING:
            return tox_events_unpack_friend_typing(events, bu);

        case TOX_EVENT_SELF_CONNECTION_STATUS:
            return tox_events_unpack_self_connection_status(events, bu);

        default:
            return false;
    }

    return true;
}

bool tox_events_unpack(Tox_Events *events, Bin_Unpack *bu)
{
    uint32_t size;
    if (!bin_unpack_array(bu, &size)) {
        return false;
    }

    for (uint32_t i = 0; i < size; ++i) {
        if (!tox_event_unpack(events, bu)) {
            return false;
        }
    }

    return true;
}

non_null(1) nullable(2)
static bool tox_events_bin_pack_handler(Bin_Pack *bp, const void *obj)
{
    return tox_events_pack((const Tox_Events *)obj, bp);
}

uint32_t tox_events_bytes_size(const Tox_Events *events)
{
    return bin_pack_obj_size(tox_events_bin_pack_handler, events);
}

void tox_events_get_bytes(const Tox_Events *events, uint8_t *bytes)
{
    bin_pack_obj(tox_events_bin_pack_handler, events, bytes, UINT32_MAX);
}

Tox_Events *tox_events_load(const uint8_t *bytes, uint32_t bytes_size)
{
    Bin_Unpack *bu = bin_unpack_new(bytes, bytes_size);

    if (bu == nullptr) {
        return nullptr;
    }

    Tox_Events *events = (Tox_Events *)calloc(1, sizeof(Tox_Events));

    if (events == nullptr) {
        bin_unpack_free(bu);
        return nullptr;
    }

    *events = (Tox_Events) {
        nullptr
    };

    if (!tox_events_unpack(events, bu)) {
        tox_events_free(events);
        bin_unpack_free(bu);
        return nullptr;
    }

    bin_unpack_free(bu);
    return events;
}

bool tox_events_equal(const Tox_Events *a, const Tox_Events *b)
{
    const uint32_t a_size = tox_events_bytes_size(a);
    const uint32_t b_size = tox_events_bytes_size(b);

    if (a_size != b_size) {
        return false;
    }

    uint8_t *a_bytes = (uint8_t *)malloc(a_size);
    uint8_t *b_bytes = (uint8_t *)malloc(b_size);

    if (a_bytes == nullptr || b_bytes == nullptr) {
        free(b_bytes);
        free(a_bytes);
        return false;
    }

    tox_events_get_bytes(a, a_bytes);
    tox_events_get_bytes(b, b_bytes);

    const bool ret = memcmp(a_bytes, b_bytes, a_size) == 0;

    free(b_bytes);
    free(a_bytes);

    return ret;
}
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2022 The TokTok team.
 * Copyright © 2013 Tox project.
 */

/**
 * The Tox private API (for tests).
 */

#include <assert.h>


#define SET_ERROR_PARAMETER(param, x) \
    do {                              \
        if (param != nullptr) {       \
            *param = x;               \
        }                             \
    } while (0)

Tox_System tox_default_system(void)
{
    const Tox_System sys = {
        nullptr,  // mono_time_callback
        nullptr,  // mono_time_user_data
        system_random(),
        system_network(),
    };
    return sys;
}

void tox_lock(const Tox *tox)
{
    if (tox->mutex != nullptr) {
        pthread_mutex_lock(tox->mutex);
    }
}

void tox_unlock(const Tox *tox)
{
    if (tox->mutex != nullptr) {
        pthread_mutex_unlock(tox->mutex);
    }
}

void tox_callback_friend_lossy_packet_per_pktid(Tox *tox, tox_friend_lossy_packet_cb *callback, uint8_t pktid)
{
    assert(tox != nullptr);

    if (pktid >= PACKET_ID_RANGE_LOSSY_START && pktid <= PACKET_ID_RANGE_LOSSY_END) {
        tox->friend_lossy_packet_callback_per_pktid[pktid] = callback;
    }
}

void tox_callback_friend_lossless_packet_per_pktid(Tox *tox, tox_friend_lossless_packet_cb *callback, uint8_t pktid)
{
    assert(tox != nullptr);

    if ((pktid >= PACKET_ID_RANGE_LOSSLESS_CUSTOM_START && pktid <= PACKET_ID_RANGE_LOSSLESS_CUSTOM_END)
            || pktid == PACKET_ID_MSI) {
        tox->friend_lossless_packet_callback_per_pktid[pktid] = callback;
    }
}

void tox_set_av_object(Tox *tox, void *object)
{
    assert(tox != nullptr);
    tox_lock(tox);
    tox->toxav_object = object;
    tox_unlock(tox);
}

void *tox_get_av_object(const Tox *tox)
{
    assert(tox != nullptr);
    tox_lock(tox);
    void *object = tox->toxav_object;
    tox_unlock(tox);
    return object;
}

void tox_callback_dht_get_nodes_response(Tox *tox, tox_dht_get_nodes_response_cb *callback)
{
    assert(tox != nullptr);
    tox->dht_get_nodes_response_callback = callback;
}

bool tox_dht_get_nodes(const Tox *tox, const uint8_t *public_key, const char *ip, uint16_t port,
                       const uint8_t *target_public_key, Tox_Err_Dht_Get_Nodes *error)
{
    assert(tox != nullptr);

    tox_lock(tox);

    if (tox->m->options.udp_disabled) {
        SET_ERROR_PARAMETER(error, TOX_ERR_DHT_GET_NODES_UDP_DISABLED);
        tox_unlock(tox);
        return false;
    }

    if (public_key == nullptr || ip == nullptr || target_public_key == nullptr) {
        SET_ERROR_PARAMETER(error, TOX_ERR_DHT_GET_NODES_NULL);
        tox_unlock(tox);
        return false;
    }

    if (port == 0) {
        SET_ERROR_PARAMETER(error, TOX_ERR_DHT_GET_NODES_BAD_PORT);
        tox_unlock(tox);
        return false;
    }

    IP_Port *root;

    const int32_t count = net_getipport(ip, &root, TOX_SOCK_DGRAM);

    if (count < 1) {
        SET_ERROR_PARAMETER(error, TOX_ERR_DHT_GET_NODES_BAD_IP);
        net_freeipport(root);
        tox_unlock(tox);
        return false;
    }

    bool success = false;

    for (int32_t i = 0; i < count; ++i) {
        root[i].port = net_htons(port);

        if (dht_getnodes(tox->m->dht, &root[i], public_key, target_public_key)) {
            success = true;
        }
    }

    tox_unlock(tox);

    net_freeipport(root);

    if (!success) {
        SET_ERROR_PARAMETER(error, TOX_ERR_DHT_GET_NODES_FAIL);
        return false;
    }

    SET_ERROR_PARAMETER(error, TOX_ERR_DHT_GET_NODES_OK);

    return true;
}
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2022 The TokTok team.
 */


#include <stdint.h>


bool tox_unpack_conference_type(Bin_Unpack *bu, Tox_Conference_Type *val)
{
    uint32_t u32;

    if (!bin_unpack_u32(bu, &u32)) {
        return false;
    }

    *val = (Tox_Conference_Type)u32;
    return true;
}

bool tox_unpack_connection(Bin_Unpack *bu, Tox_Connection *val)
{
    uint32_t u32;

    if (!bin_unpack_u32(bu, &u32)) {
        return false;
    }

    *val = (Tox_Connection)u32;
    return true;
}

bool tox_unpack_file_control(Bin_Unpack *bu, Tox_File_Control *val)
{
    uint32_t u32;

    if (!bin_unpack_u32(bu, &u32)) {
        return false;
    }

    *val = (Tox_File_Control)u32;
    return true;
}

bool tox_unpack_message_type(Bin_Unpack *bu, Tox_Message_Type *val)
{
    uint32_t u32;

    if (!bin_unpack_u32(bu, &u32)) {
        return false;
    }

    *val = (Tox_Message_Type)u32;
    return true;
}

bool tox_unpack_user_status(Bin_Unpack *bu, Tox_User_Status *val)
{
    uint32_t u32;

    if (!bin_unpack_u32(bu, &u32)) {
        return false;
    }

    *val = (Tox_User_Status)u32;
    return true;
}
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2018 The TokTok team.
 * Copyright © 2013 Tox project.
 * Copyright © 2013 plutooo
 */

/**
 * Utilities.
 */
#ifndef _XOPEN_SOURCE
#define _XOPEN_SOURCE 600
#endif


#include <stdlib.h>
#include <string.h>
#include <time.h>


bool is_power_of_2(uint64_t x)
{
    return x != 0 && (x & (~x + 1)) == x;
}

void free_uint8_t_pointer_array(uint8_t **ary, size_t n_items)
{
    if (ary == nullptr) {
        return;
    }

    for (size_t i = 0; i < n_items; ++i) {
        if (ary[i] != nullptr) {
            free(ary[i]);
        }
    }

    free(ary);
}

uint16_t data_checksum(const uint8_t *data, uint32_t length)
{
    uint8_t checksum[2] = {0};
    uint16_t check;

    for (uint32_t i = 0; i < length; ++i) {
        checksum[i % 2] ^= data[i];
    }

    memcpy(&check, checksum, sizeof(check));
    return check;
}

int create_recursive_mutex(pthread_mutex_t *mutex)
{
    pthread_mutexattr_t attr;

    if (pthread_mutexattr_init(&attr) != 0) {
        return -1;
    }

    if (pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE) != 0) {
        pthread_mutexattr_destroy(&attr);
        return -1;
    }

    /* Create queue mutex */
    if (pthread_mutex_init(mutex, &attr) != 0) {
        pthread_mutexattr_destroy(&attr);
        return -1;
    }

    pthread_mutexattr_destroy(&attr);

    return 0;
}

bool memeq(const uint8_t *a, size_t a_size, const uint8_t *b, size_t b_size)
{
    return a_size == b_size && memcmp(a, b, a_size) == 0;
}

int16_t max_s16(int16_t a, int16_t b)
{
    return a > b ? a : b;
}
int32_t max_s32(int32_t a, int32_t b)
{
    return a > b ? a : b;
}
int64_t max_s64(int64_t a, int64_t b)
{
    return a > b ? a : b;
}

int16_t min_s16(int16_t a, int16_t b)
{
    return a < b ? a : b;
}
int32_t min_s32(int32_t a, int32_t b)
{
    return a < b ? a : b;
}
int64_t min_s64(int64_t a, int64_t b)
{
    return a < b ? a : b;
}

uint16_t max_u16(uint16_t a, uint16_t b)
{
    return a > b ? a : b;
}
uint32_t max_u32(uint32_t a, uint32_t b)
{
    return a > b ? a : b;
}
uint64_t max_u64(uint64_t a, uint64_t b)
{
    return a > b ? a : b;
}

uint16_t min_u16(uint16_t a, uint16_t b)
{
    return a < b ? a : b;
}
uint32_t min_u32(uint32_t a, uint32_t b)
{
    return a < b ? a : b;
}
uint64_t min_u64(uint64_t a, uint64_t b)
{
    return a < b ? a : b;
}

uint32_t jenkins_one_at_a_time_hash(const uint8_t *key, size_t len)
{
    uint32_t hash = 0;

    for (uint32_t i = 0; i < len; ++i) {
        hash += key[i];
        hash += (uint32_t)((uint64_t)hash << 10);
        hash ^= hash >> 6;
    }

    hash += (uint32_t)((uint64_t)hash << 3);
    hash ^= hash >> 11;
    hash += (uint32_t)((uint64_t)hash << 15);
    return hash;
}
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2022 The TokTok team.
 */


#include <assert.h>
#include <stdlib.h>
#include <string.h>



/*****************************************************
 *
 * :: struct and accessors
 *
 *****************************************************/


struct Tox_Event_Conference_Connected {
    uint32_t conference_number;
};

non_null()
static void tox_event_conference_connected_construct(Tox_Event_Conference_Connected *conference_connected)
{
    *conference_connected = (Tox_Event_Conference_Connected) {
        0
    };
}
non_null()
static void tox_event_conference_connected_destruct(Tox_Event_Conference_Connected *conference_connected)
{
    return;
}

non_null()
static void tox_event_conference_connected_set_conference_number(
    Tox_Event_Conference_Connected *conference_connected, uint32_t conference_number)
{
    assert(conference_connected != nullptr);
    conference_connected->conference_number = conference_number;
}
uint32_t tox_event_conference_connected_get_conference_number(
    const Tox_Event_Conference_Connected *conference_connected)
{
    assert(conference_connected != nullptr);
    return conference_connected->conference_number;
}

non_null()
static bool tox_event_conference_connected_pack(
    const Tox_Event_Conference_Connected *event, Bin_Pack *bp)
{
    assert(event != nullptr);
    return bin_pack_array(bp, 2)
           && bin_pack_u32(bp, TOX_EVENT_CONFERENCE_CONNECTED)
           && bin_pack_u32(bp, event->conference_number);
}

non_null()
static bool tox_event_conference_connected_unpack(
    Tox_Event_Conference_Connected *event, Bin_Unpack *bu)
{
    assert(event != nullptr);
    return bin_unpack_u32(bu, &event->conference_number);
}


/*****************************************************
 *
 * :: add/clear/get
 *
 *****************************************************/


non_null()
static Tox_Event_Conference_Connected *tox_events_add_conference_connected(Tox_Events *events)
{
    if (events->conference_connected_size == UINT32_MAX) {
        return nullptr;
    }

    if (events->conference_connected_size == events->conference_connected_capacity) {
        const uint32_t new_conference_connected_capacity = events->conference_connected_capacity * 2 + 1;
        Tox_Event_Conference_Connected *new_conference_connected = (Tox_Event_Conference_Connected *)realloc(
                    events->conference_connected, new_conference_connected_capacity * sizeof(Tox_Event_Conference_Connected));

        if (new_conference_connected == nullptr) {
            return nullptr;
        }

        events->conference_connected = new_conference_connected;
        events->conference_connected_capacity = new_conference_connected_capacity;
    }

    Tox_Event_Conference_Connected *const conference_connected =
        &events->conference_connected[events->conference_connected_size];
    tox_event_conference_connected_construct(conference_connected);
    ++events->conference_connected_size;
    return conference_connected;
}

void tox_events_clear_conference_connected(Tox_Events *events)
{
    if (events == nullptr) {
        return;
    }

    for (uint32_t i = 0; i < events->conference_connected_size; ++i) {
        tox_event_conference_connected_destruct(&events->conference_connected[i]);
    }

    free(events->conference_connected);
    events->conference_connected = nullptr;
    events->conference_connected_size = 0;
    events->conference_connected_capacity = 0;
}

uint32_t tox_events_get_conference_connected_size(const Tox_Events *events)
{
    if (events == nullptr) {
        return 0;
    }

    return events->conference_connected_size;
}

const Tox_Event_Conference_Connected *tox_events_get_conference_connected(const Tox_Events *events, uint32_t index)
{
    assert(index < events->conference_connected_size);
    assert(events->conference_connected != nullptr);
    return &events->conference_connected[index];
}

bool tox_events_pack_conference_connected(const Tox_Events *events, Bin_Pack *bp)
{
    const uint32_t size = tox_events_get_conference_connected_size(events);

    for (uint32_t i = 0; i < size; ++i) {
        if (!tox_event_conference_connected_pack(tox_events_get_conference_connected(events, i), bp)) {
            return false;
        }
    }
    return true;
}

bool tox_events_unpack_conference_connected(Tox_Events *events, Bin_Unpack *bu)
{
    Tox_Event_Conference_Connected *event = tox_events_add_conference_connected(events);

    if (event == nullptr) {
        return false;
    }

    return tox_event_conference_connected_unpack(event, bu);
}



/*****************************************************
 *
 * :: event handler
 *
 *****************************************************/


void tox_events_handle_conference_connected(Tox *tox, uint32_t conference_number, void *user_data)
{
    Tox_Events_State *state = tox_events_alloc(user_data);
    assert(state != nullptr);

    if (state->events == nullptr) {
        return;
    }

    Tox_Event_Conference_Connected *conference_connected = tox_events_add_conference_connected(state->events);

    if (conference_connected == nullptr) {
        state->error = TOX_ERR_EVENTS_ITERATE_MALLOC;
        return;
    }

    tox_event_conference_connected_set_conference_number(conference_connected, conference_number);
}
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2022 The TokTok team.
 */


#include <assert.h>
#include <stdlib.h>
#include <string.h>



/*****************************************************
 *
 * :: struct and accessors
 *
 *****************************************************/


struct Tox_Event_Conference_Invite {
    uint32_t friend_number;
    Tox_Conference_Type type;
    uint8_t *cookie;
    uint32_t cookie_length;
};

non_null()
static void tox_event_conference_invite_construct(Tox_Event_Conference_Invite *conference_invite)
{
    *conference_invite = (Tox_Event_Conference_Invite) {
        0
    };
}
non_null()
static void tox_event_conference_invite_destruct(Tox_Event_Conference_Invite *conference_invite)
{
    free(conference_invite->cookie);
}

non_null()
static void tox_event_conference_invite_set_friend_number(Tox_Event_Conference_Invite *conference_invite,
        uint32_t friend_number)
{
    assert(conference_invite != nullptr);
    conference_invite->friend_number = friend_number;
}
uint32_t tox_event_conference_invite_get_friend_number(const Tox_Event_Conference_Invite *conference_invite)
{
    assert(conference_invite != nullptr);
    return conference_invite->friend_number;
}

non_null()
static void tox_event_conference_invite_set_type(Tox_Event_Conference_Invite *conference_invite,
        Tox_Conference_Type type)
{
    assert(conference_invite != nullptr);
    conference_invite->type = type;
}
Tox_Conference_Type tox_event_conference_invite_get_type(const Tox_Event_Conference_Invite *conference_invite)
{
    assert(conference_invite != nullptr);
    return conference_invite->type;
}

non_null()
static bool tox_event_conference_invite_set_cookie(Tox_Event_Conference_Invite *conference_invite,
        const uint8_t *cookie, uint32_t cookie_length)
{
    assert(conference_invite != nullptr);

    if (conference_invite->cookie != nullptr) {
        free(conference_invite->cookie);
        conference_invite->cookie = nullptr;
        conference_invite->cookie_length = 0;
    }

    conference_invite->cookie = (uint8_t *)malloc(cookie_length);

    if (conference_invite->cookie == nullptr) {
        return false;
    }

    memcpy(conference_invite->cookie, cookie, cookie_length);
    conference_invite->cookie_length = cookie_length;
    return true;
}
uint32_t tox_event_conference_invite_get_cookie_length(const Tox_Event_Conference_Invite *conference_invite)
{
    assert(conference_invite != nullptr);
    return conference_invite->cookie_length;
}
const uint8_t *tox_event_conference_invite_get_cookie(const Tox_Event_Conference_Invite *conference_invite)
{
    assert(conference_invite != nullptr);
    return conference_invite->cookie;
}

non_null()
static bool tox_event_conference_invite_pack(
    const Tox_Event_Conference_Invite *event, Bin_Pack *bp)
{
    assert(event != nullptr);
    return bin_pack_array(bp, 2)
           && bin_pack_u32(bp, TOX_EVENT_CONFERENCE_INVITE)
           && bin_pack_array(bp, 3)
           && bin_pack_u32(bp, event->friend_number)
           && bin_pack_u32(bp, event->type)
           && bin_pack_bin(bp, event->cookie, event->cookie_length);
}

non_null()
static bool tox_event_conference_invite_unpack(
    Tox_Event_Conference_Invite *event, Bin_Unpack *bu)
{
    assert(event != nullptr);
    if (!bin_unpack_array_fixed(bu, 3)) {
        return false;
    }

    return bin_unpack_u32(bu, &event->friend_number)
           && tox_unpack_conference_type(bu, &event->type)
           && bin_unpack_bin(bu, &event->cookie, &event->cookie_length);
}


/*****************************************************
 *
 * :: add/clear/get
 *
 *****************************************************/


non_null()
static Tox_Event_Conference_Invite *tox_events_add_conference_invite(Tox_Events *events)
{
    if (events->conference_invite_size == UINT32_MAX) {
        return nullptr;
    }

    if (events->conference_invite_size == events->conference_invite_capacity) {
        const uint32_t new_conference_invite_capacity = events->conference_invite_capacity * 2 + 1;
        Tox_Event_Conference_Invite *new_conference_invite = (Tox_Event_Conference_Invite *)realloc(
                    events->conference_invite, new_conference_invite_capacity * sizeof(Tox_Event_Conference_Invite));

        if (new_conference_invite == nullptr) {
            return nullptr;
        }

        events->conference_invite = new_conference_invite;
        events->conference_invite_capacity = new_conference_invite_capacity;
    }

    Tox_Event_Conference_Invite *const conference_invite = &events->conference_invite[events->conference_invite_size];
    tox_event_conference_invite_construct(conference_invite);
    ++events->conference_invite_size;
    return conference_invite;
}

void tox_events_clear_conference_invite(Tox_Events *events)
{
    if (events == nullptr) {
        return;
    }

    for (uint32_t i = 0; i < events->conference_invite_size; ++i) {
        tox_event_conference_invite_destruct(&events->conference_invite[i]);
    }

    free(events->conference_invite);
    events->conference_invite = nullptr;
    events->conference_invite_size = 0;
    events->conference_invite_capacity = 0;
}

uint32_t tox_events_get_conference_invite_size(const Tox_Events *events)
{
    if (events == nullptr) {
        return 0;
    }

    return events->conference_invite_size;
}

const Tox_Event_Conference_Invite *tox_events_get_conference_invite(const Tox_Events *events, uint32_t index)
{
    assert(index < events->conference_invite_size);
    assert(events->conference_invite != nullptr);
    return &events->conference_invite[index];
}

bool tox_events_pack_conference_invite(const Tox_Events *events, Bin_Pack *bp)
{
    const uint32_t size = tox_events_get_conference_invite_size(events);

    for (uint32_t i = 0; i < size; ++i) {
        if (!tox_event_conference_invite_pack(tox_events_get_conference_invite(events, i), bp)) {
            return false;
        }
    }
    return true;
}

bool tox_events_unpack_conference_invite(Tox_Events *events, Bin_Unpack *bu)
{
    Tox_Event_Conference_Invite *event = tox_events_add_conference_invite(events);

    if (event == nullptr) {
        return false;
    }

    return tox_event_conference_invite_unpack(event, bu);
}


/*****************************************************
 *
 * :: event handler
 *
 *****************************************************/


void tox_events_handle_conference_invite(Tox *tox, uint32_t friend_number, Tox_Conference_Type type,
        const uint8_t *cookie, size_t length, void *user_data)
{
    Tox_Events_State *state = tox_events_alloc(user_data);
    assert(state != nullptr);

    if (state->events == nullptr) {
        return;
    }

    Tox_Event_Conference_Invite *conference_invite = tox_events_add_conference_invite(state->events);

    if (conference_invite == nullptr) {
        state->error = TOX_ERR_EVENTS_ITERATE_MALLOC;
        return;
    }

    tox_event_conference_invite_set_friend_number(conference_invite, friend_number);
    tox_event_conference_invite_set_type(conference_invite, type);
    tox_event_conference_invite_set_cookie(conference_invite, cookie, length);
}
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2022 The TokTok team.
 */


#include <assert.h>
#include <stdlib.h>
#include <string.h>



/*****************************************************
 *
 * :: struct and accessors
 *
 *****************************************************/


struct Tox_Event_Conference_Message {
    uint32_t conference_number;
    uint32_t peer_number;
    Tox_Message_Type type;
    uint8_t *message;
    uint32_t message_length;
};

non_null()
static void tox_event_conference_message_construct(Tox_Event_Conference_Message *conference_message)
{
    *conference_message = (Tox_Event_Conference_Message) {
        0
    };
}
non_null()
static void tox_event_conference_message_destruct(Tox_Event_Conference_Message *conference_message)
{
    free(conference_message->message);
}

non_null()
static void tox_event_conference_message_set_conference_number(Tox_Event_Conference_Message *conference_message,
        uint32_t conference_number)
{
    assert(conference_message != nullptr);
    conference_message->conference_number = conference_number;
}
uint32_t tox_event_conference_message_get_conference_number(const Tox_Event_Conference_Message *conference_message)
{
    assert(conference_message != nullptr);
    return conference_message->conference_number;
}

non_null()
static void tox_event_conference_message_set_peer_number(Tox_Event_Conference_Message *conference_message,
        uint32_t peer_number)
{
    assert(conference_message != nullptr);
    conference_message->peer_number = peer_number;
}
uint32_t tox_event_conference_message_get_peer_number(const Tox_Event_Conference_Message *conference_message)
{
    assert(conference_message != nullptr);
    return conference_message->peer_number;
}

non_null()
static void tox_event_conference_message_set_type(Tox_Event_Conference_Message *conference_message,
        Tox_Message_Type type)
{
    assert(conference_message != nullptr);
    conference_message->type = type;
}
Tox_Message_Type tox_event_conference_message_get_type(const Tox_Event_Conference_Message *conference_message)
{
    assert(conference_message != nullptr);
    return conference_message->type;
}

non_null()
static bool tox_event_conference_message_set_message(Tox_Event_Conference_Message *conference_message,
        const uint8_t *message, uint32_t message_length)
{
    assert(conference_message != nullptr);

    if (conference_message->message != nullptr) {
        free(conference_message->message);
        conference_message->message = nullptr;
        conference_message->message_length = 0;
    }

    conference_message->message = (uint8_t *)malloc(message_length);

    if (conference_message->message == nullptr) {
        return false;
    }

    memcpy(conference_message->message, message, message_length);
    conference_message->message_length = message_length;
    return true;
}
uint32_t tox_event_conference_message_get_message_length(const Tox_Event_Conference_Message *conference_message)
{
    assert(conference_message != nullptr);
    return conference_message->message_length;
}
const uint8_t *tox_event_conference_message_get_message(const Tox_Event_Conference_Message *conference_message)
{
    assert(conference_message != nullptr);
    return conference_message->message;
}

non_null()
static bool tox_event_conference_message_pack(
    const Tox_Event_Conference_Message *event, Bin_Pack *bp)
{
    assert(event != nullptr);
    return bin_pack_array(bp, 2)
           && bin_pack_u32(bp, TOX_EVENT_CONFERENCE_MESSAGE)
           && bin_pack_array(bp, 4)
           && bin_pack_u32(bp, event->conference_number)
           && bin_pack_u32(bp, event->peer_number)
           && bin_pack_u32(bp, event->type)
           && bin_pack_bin(bp, event->message, event->message_length);
}

non_null()
static bool tox_event_conference_message_unpack(
    Tox_Event_Conference_Message *event, Bin_Unpack *bu)
{
    assert(event != nullptr);
    if (!bin_unpack_array_fixed(bu, 4)) {
        return false;
    }

    return bin_unpack_u32(bu, &event->conference_number)
           && bin_unpack_u32(bu, &event->peer_number)
           && tox_unpack_message_type(bu, &event->type)
           && bin_unpack_bin(bu, &event->message, &event->message_length);
}


/*****************************************************
 *
 * :: add/clear/get
 *
 *****************************************************/


non_null()
static Tox_Event_Conference_Message *tox_events_add_conference_message(Tox_Events *events)
{
    if (events->conference_message_size == UINT32_MAX) {
        return nullptr;
    }

    if (events->conference_message_size == events->conference_message_capacity) {
        const uint32_t new_conference_message_capacity = events->conference_message_capacity * 2 + 1;
        Tox_Event_Conference_Message *new_conference_message = (Tox_Event_Conference_Message *)realloc(
                    events->conference_message, new_conference_message_capacity * sizeof(Tox_Event_Conference_Message));

        if (new_conference_message == nullptr) {
            return nullptr;
        }

        events->conference_message = new_conference_message;
        events->conference_message_capacity = new_conference_message_capacity;
    }

    Tox_Event_Conference_Message *const conference_message = &events->conference_message[events->conference_message_size];
    tox_event_conference_message_construct(conference_message);
    ++events->conference_message_size;
    return conference_message;
}

void tox_events_clear_conference_message(Tox_Events *events)
{
    if (events == nullptr) {
        return;
    }

    for (uint32_t i = 0; i < events->conference_message_size; ++i) {
        tox_event_conference_message_destruct(&events->conference_message[i]);
    }

    free(events->conference_message);
    events->conference_message = nullptr;
    events->conference_message_size = 0;
    events->conference_message_capacity = 0;
}

uint32_t tox_events_get_conference_message_size(const Tox_Events *events)
{
    if (events == nullptr) {
        return 0;
    }

    return events->conference_message_size;
}

const Tox_Event_Conference_Message *tox_events_get_conference_message(const Tox_Events *events, uint32_t index)
{
    assert(index < events->conference_message_size);
    assert(events->conference_message != nullptr);
    return &events->conference_message[index];
}

bool tox_events_pack_conference_message(const Tox_Events *events, Bin_Pack *bp)
{
    const uint32_t size = tox_events_get_conference_message_size(events);

    for (uint32_t i = 0; i < size; ++i) {
        if (!tox_event_conference_message_pack(tox_events_get_conference_message(events, i), bp)) {
            return false;
        }
    }
    return true;
}

bool tox_events_unpack_conference_message(Tox_Events *events, Bin_Unpack *bu)
{
    Tox_Event_Conference_Message *event = tox_events_add_conference_message(events);

    if (event == nullptr) {
        return false;
    }

    return tox_event_conference_message_unpack(event, bu);
}


/*****************************************************
 *
 * :: event handler
 *
 *****************************************************/


void tox_events_handle_conference_message(Tox *tox, uint32_t conference_number, uint32_t peer_number,
        Tox_Message_Type type, const uint8_t *message, size_t length, void *user_data)
{
    Tox_Events_State *state = tox_events_alloc(user_data);
    assert(state != nullptr);

    if (state->events == nullptr) {
        return;
    }

    Tox_Event_Conference_Message *conference_message = tox_events_add_conference_message(state->events);

    if (conference_message == nullptr) {
        state->error = TOX_ERR_EVENTS_ITERATE_MALLOC;
        return;
    }

    tox_event_conference_message_set_conference_number(conference_message, conference_number);
    tox_event_conference_message_set_peer_number(conference_message, peer_number);
    tox_event_conference_message_set_type(conference_message, type);
    tox_event_conference_message_set_message(conference_message, message, length);
}
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2022 The TokTok team.
 */


#include <assert.h>
#include <stdlib.h>
#include <string.h>



/*****************************************************
 *
 * :: struct and accessors
 *
 *****************************************************/


struct Tox_Event_Conference_Peer_List_Changed {
    uint32_t conference_number;
};

non_null()
static void tox_event_conference_peer_list_changed_construct(Tox_Event_Conference_Peer_List_Changed
        *conference_peer_list_changed)
{
    *conference_peer_list_changed = (Tox_Event_Conference_Peer_List_Changed) {
        0
    };
}
non_null()
static void tox_event_conference_peer_list_changed_destruct(Tox_Event_Conference_Peer_List_Changed
        *conference_peer_list_changed)
{
    return;
}

non_null()
static void tox_event_conference_peer_list_changed_set_conference_number(Tox_Event_Conference_Peer_List_Changed
        *conference_peer_list_changed, uint32_t conference_number)
{
    assert(conference_peer_list_changed != nullptr);
    conference_peer_list_changed->conference_number = conference_number;
}
uint32_t tox_event_conference_peer_list_changed_get_conference_number(const Tox_Event_Conference_Peer_List_Changed
        *conference_peer_list_changed)
{
    assert(conference_peer_list_changed != nullptr);
    return conference_peer_list_changed->conference_number;
}

non_null()
static bool tox_event_conference_peer_list_changed_pack(
    const Tox_Event_Conference_Peer_List_Changed *event, Bin_Pack *bp)
{
    assert(event != nullptr);
    return bin_pack_array(bp, 2)
           && bin_pack_u32(bp, TOX_EVENT_CONFERENCE_PEER_LIST_CHANGED)
           && bin_pack_u32(bp, event->conference_number);
}

non_null()
static bool tox_event_conference_peer_list_changed_unpack(
    Tox_Event_Conference_Peer_List_Changed *event, Bin_Unpack *bu)
{
    assert(event != nullptr);
    return bin_unpack_u32(bu, &event->conference_number);
}


/*****************************************************
 *
 * :: add/clear/get
 *
 *****************************************************/


non_null()
static Tox_Event_Conference_Peer_List_Changed *tox_events_add_conference_peer_list_changed(Tox_Events *events)
{
    if (events->conference_peer_list_changed_size == UINT32_MAX) {
        return nullptr;
    }

    if (events->conference_peer_list_changed_size == events->conference_peer_list_changed_capacity) {
        const uint32_t new_conference_peer_list_changed_capacity = events->conference_peer_list_changed_capacity * 2 + 1;
        Tox_Event_Conference_Peer_List_Changed *new_conference_peer_list_changed = (Tox_Event_Conference_Peer_List_Changed *)
                realloc(
                    events->conference_peer_list_changed,
                    new_conference_peer_list_changed_capacity * sizeof(Tox_Event_Conference_Peer_List_Changed));

        if (new_conference_peer_list_changed == nullptr) {
            return nullptr;
        }

        events->conference_peer_list_changed = new_conference_peer_list_changed;
        events->conference_peer_list_changed_capacity = new_conference_peer_list_changed_capacity;
    }

    Tox_Event_Conference_Peer_List_Changed *const conference_peer_list_changed =
        &events->conference_peer_list_changed[events->conference_peer_list_changed_size];
    tox_event_conference_peer_list_changed_construct(conference_peer_list_changed);
    ++events->conference_peer_list_changed_size;
    return conference_peer_list_changed;
}

void tox_events_clear_conference_peer_list_changed(Tox_Events *events)
{
    if (events == nullptr) {
        return;
    }

    for (uint32_t i = 0; i < events->conference_peer_list_changed_size; ++i) {
        tox_event_conference_peer_list_changed_destruct(&events->conference_peer_list_changed[i]);
    }

    free(events->conference_peer_list_changed);
    events->conference_peer_list_changed = nullptr;
    events->conference_peer_list_changed_size = 0;
    events->conference_peer_list_changed_capacity = 0;
}

uint32_t tox_events_get_conference_peer_list_changed_size(const Tox_Events *events)
{
    if (events == nullptr) {
        return 0;
    }

    return events->conference_peer_list_changed_size;
}

const Tox_Event_Conference_Peer_List_Changed *tox_events_get_conference_peer_list_changed(const Tox_Events *events,
        uint32_t index)
{
    assert(index < events->conference_peer_list_changed_size);
    assert(events->conference_peer_list_changed != nullptr);
    return &events->conference_peer_list_changed[index];
}

bool tox_events_pack_conference_peer_list_changed(const Tox_Events *events, Bin_Pack *bp)
{
    const uint32_t size = tox_events_get_conference_peer_list_changed_size(events);

    for (uint32_t i = 0; i < size; ++i) {
        if (!tox_event_conference_peer_list_changed_pack(tox_events_get_conference_peer_list_changed(events, i), bp)) {
            return false;
        }
    }
    return true;
}

bool tox_events_unpack_conference_peer_list_changed(Tox_Events *events, Bin_Unpack *bu)
{
    Tox_Event_Conference_Peer_List_Changed *event = tox_events_add_conference_peer_list_changed(events);

    if (event == nullptr) {
        return false;
    }

    return tox_event_conference_peer_list_changed_unpack(event, bu);
}


/*****************************************************
 *
 * :: event handler
 *
 *****************************************************/


void tox_events_handle_conference_peer_list_changed(Tox *tox, uint32_t conference_number, void *user_data)
{
    Tox_Events_State *state = tox_events_alloc(user_data);
    assert(state != nullptr);

    if (state->events == nullptr) {
        return;
    }

    Tox_Event_Conference_Peer_List_Changed *conference_peer_list_changed = tox_events_add_conference_peer_list_changed(
                state->events);

    if (conference_peer_list_changed == nullptr) {
        state->error = TOX_ERR_EVENTS_ITERATE_MALLOC;
        return;
    }

    tox_event_conference_peer_list_changed_set_conference_number(conference_peer_list_changed, conference_number);
}
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2022 The TokTok team.
 */


#include <assert.h>
#include <stdlib.h>
#include <string.h>



/*****************************************************
 *
 * :: struct and accessors
 *
 *****************************************************/


struct Tox_Event_Conference_Peer_Name {
    uint32_t conference_number;
    uint32_t peer_number;
    uint8_t *name;
    uint32_t name_length;
};

non_null()
static void tox_event_conference_peer_name_construct(Tox_Event_Conference_Peer_Name *conference_peer_name)
{
    *conference_peer_name = (Tox_Event_Conference_Peer_Name) {
        0
    };
}
non_null()
static void tox_event_conference_peer_name_destruct(Tox_Event_Conference_Peer_Name *conference_peer_name)
{
    free(conference_peer_name->name);
}

non_null()
static void tox_event_conference_peer_name_set_conference_number(Tox_Event_Conference_Peer_Name *conference_peer_name,
        uint32_t conference_number)
{
    assert(conference_peer_name != nullptr);
    conference_peer_name->conference_number = conference_number;
}
uint32_t tox_event_conference_peer_name_get_conference_number(const Tox_Event_Conference_Peer_Name
        *conference_peer_name)
{
    assert(conference_peer_name != nullptr);
    return conference_peer_name->conference_number;
}

non_null()
static void tox_event_conference_peer_name_set_peer_number(Tox_Event_Conference_Peer_Name *conference_peer_name,
        uint32_t peer_number)
{
    assert(conference_peer_name != nullptr);
    conference_peer_name->peer_number = peer_number;
}
uint32_t tox_event_conference_peer_name_get_peer_number(const Tox_Event_Conference_Peer_Name *conference_peer_name)
{
    assert(conference_peer_name != nullptr);
    return conference_peer_name->peer_number;
}

non_null()
static bool tox_event_conference_peer_name_set_name(Tox_Event_Conference_Peer_Name *conference_peer_name,
        const uint8_t *name, uint32_t name_length)
{
    assert(conference_peer_name != nullptr);

    if (conference_peer_name->name != nullptr) {
        free(conference_peer_name->name);
        conference_peer_name->name = nullptr;
        conference_peer_name->name_length = 0;
    }

    conference_peer_name->name = (uint8_t *)malloc(name_length);

    if (conference_peer_name->name == nullptr) {
        return false;
    }

    memcpy(conference_peer_name->name, name, name_length);
    conference_peer_name->name_length = name_length;
    return true;
}
uint32_t tox_event_conference_peer_name_get_name_length(const Tox_Event_Conference_Peer_Name *conference_peer_name)
{
    assert(conference_peer_name != nullptr);
    return conference_peer_name->name_length;
}
const uint8_t *tox_event_conference_peer_name_get_name(const Tox_Event_Conference_Peer_Name *conference_peer_name)
{
    assert(conference_peer_name != nullptr);
    return conference_peer_name->name;
}

non_null()
static bool tox_event_conference_peer_name_pack(
    const Tox_Event_Conference_Peer_Name *event, Bin_Pack *bp)
{
    assert(event != nullptr);
    return bin_pack_array(bp, 2)
           && bin_pack_u32(bp, TOX_EVENT_CONFERENCE_PEER_NAME)
           && bin_pack_array(bp, 3)
           && bin_pack_u32(bp, event->conference_number)
           && bin_pack_u32(bp, event->peer_number)
           && bin_pack_bin(bp, event->name, event->name_length);
}

non_null()
static bool tox_event_conference_peer_name_unpack(
    Tox_Event_Conference_Peer_Name *event, Bin_Unpack *bu)
{
    assert(event != nullptr);
    if (!bin_unpack_array_fixed(bu, 3)) {
        return false;
    }

    return bin_unpack_u32(bu, &event->conference_number)
           && bin_unpack_u32(bu, &event->peer_number)
           && bin_unpack_bin(bu, &event->name, &event->name_length);
}


/*****************************************************
 *
 * :: add/clear/get
 *
 *****************************************************/


non_null()
static Tox_Event_Conference_Peer_Name *tox_events_add_conference_peer_name(Tox_Events *events)
{
    if (events->conference_peer_name_size == UINT32_MAX) {
        return nullptr;
    }

    if (events->conference_peer_name_size == events->conference_peer_name_capacity) {
        const uint32_t new_conference_peer_name_capacity = events->conference_peer_name_capacity * 2 + 1;
        Tox_Event_Conference_Peer_Name *new_conference_peer_name = (Tox_Event_Conference_Peer_Name *)realloc(
                    events->conference_peer_name, new_conference_peer_name_capacity * sizeof(Tox_Event_Conference_Peer_Name));

        if (new_conference_peer_name == nullptr) {
            return nullptr;
        }

        events->conference_peer_name = new_conference_peer_name;
        events->conference_peer_name_capacity = new_conference_peer_name_capacity;
    }

    Tox_Event_Conference_Peer_Name *const conference_peer_name =
        &events->conference_peer_name[events->conference_peer_name_size];
    tox_event_conference_peer_name_construct(conference_peer_name);
    ++events->conference_peer_name_size;
    return conference_peer_name;
}

void tox_events_clear_conference_peer_name(Tox_Events *events)
{
    if (events == nullptr) {
        return;
    }

    for (uint32_t i = 0; i < events->conference_peer_name_size; ++i) {
        tox_event_conference_peer_name_destruct(&events->conference_peer_name[i]);
    }

    free(events->conference_peer_name);
    events->conference_peer_name = nullptr;
    events->conference_peer_name_size = 0;
    events->conference_peer_name_capacity = 0;
}

uint32_t tox_events_get_conference_peer_name_size(const Tox_Events *events)
{
    if (events == nullptr) {
        return 0;
    }

    return events->conference_peer_name_size;
}

const Tox_Event_Conference_Peer_Name *tox_events_get_conference_peer_name(const Tox_Events *events, uint32_t index)
{
    assert(index < events->conference_peer_name_size);
    assert(events->conference_peer_name != nullptr);
    return &events->conference_peer_name[index];
}

bool tox_events_pack_conference_peer_name(const Tox_Events *events, Bin_Pack *bp)
{
    const uint32_t size = tox_events_get_conference_peer_name_size(events);

    for (uint32_t i = 0; i < size; ++i) {
        if (!tox_event_conference_peer_name_pack(tox_events_get_conference_peer_name(events, i), bp)) {
            return false;
        }
    }
    return true;
}

bool tox_events_unpack_conference_peer_name(Tox_Events *events, Bin_Unpack *bu)
{
    Tox_Event_Conference_Peer_Name *event = tox_events_add_conference_peer_name(events);

    if (event == nullptr) {
        return false;
    }

    return tox_event_conference_peer_name_unpack(event, bu);
}


/*****************************************************
 *
 * :: event handler
 *
 *****************************************************/


void tox_events_handle_conference_peer_name(Tox *tox, uint32_t conference_number, uint32_t peer_number,
        const uint8_t *name, size_t length, void *user_data)
{
    Tox_Events_State *state = tox_events_alloc(user_data);
    assert(state != nullptr);

    if (state->events == nullptr) {
        return;
    }

    Tox_Event_Conference_Peer_Name *conference_peer_name = tox_events_add_conference_peer_name(state->events);

    if (conference_peer_name == nullptr) {
        state->error = TOX_ERR_EVENTS_ITERATE_MALLOC;
        return;
    }

    tox_event_conference_peer_name_set_conference_number(conference_peer_name, conference_number);
    tox_event_conference_peer_name_set_peer_number(conference_peer_name, peer_number);
    tox_event_conference_peer_name_set_name(conference_peer_name, name, length);
}
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2022 The TokTok team.
 */


#include <assert.h>
#include <stdlib.h>
#include <string.h>



/*****************************************************
 *
 * :: struct and accessors
 *
 *****************************************************/


struct Tox_Event_Conference_Title {
    uint32_t conference_number;
    uint32_t peer_number;
    uint8_t *title;
    uint32_t title_length;
};

non_null()
static void tox_event_conference_title_construct(Tox_Event_Conference_Title *conference_title)
{
    *conference_title = (Tox_Event_Conference_Title) {
        0
    };
}
non_null()
static void tox_event_conference_title_destruct(Tox_Event_Conference_Title *conference_title)
{
    free(conference_title->title);
}

non_null()
static void tox_event_conference_title_set_conference_number(Tox_Event_Conference_Title *conference_title,
        uint32_t conference_number)
{
    assert(conference_title != nullptr);
    conference_title->conference_number = conference_number;
}
uint32_t tox_event_conference_title_get_conference_number(const Tox_Event_Conference_Title *conference_title)
{
    assert(conference_title != nullptr);
    return conference_title->conference_number;
}

non_null()
static void tox_event_conference_title_set_peer_number(Tox_Event_Conference_Title *conference_title,
        uint32_t peer_number)
{
    assert(conference_title != nullptr);
    conference_title->peer_number = peer_number;
}
uint32_t tox_event_conference_title_get_peer_number(const Tox_Event_Conference_Title *conference_title)
{
    assert(conference_title != nullptr);
    return conference_title->peer_number;
}

non_null()
static bool tox_event_conference_title_set_title(Tox_Event_Conference_Title *conference_title, const uint8_t *title,
        uint32_t title_length)
{
    assert(conference_title != nullptr);

    if (conference_title->title != nullptr) {
        free(conference_title->title);
        conference_title->title = nullptr;
        conference_title->title_length = 0;
    }

    conference_title->title = (uint8_t *)malloc(title_length);

    if (conference_title->title == nullptr) {
        return false;
    }

    memcpy(conference_title->title, title, title_length);
    conference_title->title_length = title_length;
    return true;
}
uint32_t tox_event_conference_title_get_title_length(const Tox_Event_Conference_Title *conference_title)
{
    assert(conference_title != nullptr);
    return conference_title->title_length;
}
const uint8_t *tox_event_conference_title_get_title(const Tox_Event_Conference_Title *conference_title)
{
    assert(conference_title != nullptr);
    return conference_title->title;
}

non_null()
static bool tox_event_conference_title_pack(
    const Tox_Event_Conference_Title *event, Bin_Pack *bp)
{
    assert(event != nullptr);
    return bin_pack_array(bp, 2)
           && bin_pack_u32(bp, TOX_EVENT_CONFERENCE_TITLE)
           && bin_pack_array(bp, 3)
           && bin_pack_u32(bp, event->conference_number)
           && bin_pack_u32(bp, event->peer_number)
           && bin_pack_bin(bp, event->title, event->title_length);
}

non_null()
static bool tox_event_conference_title_unpack(
    Tox_Event_Conference_Title *event, Bin_Unpack *bu)
{
    assert(event != nullptr);
    if (!bin_unpack_array_fixed(bu, 3)) {
        return false;
    }

    return bin_unpack_u32(bu, &event->conference_number)
           && bin_unpack_u32(bu, &event->peer_number)
           && bin_unpack_bin(bu, &event->title, &event->title_length);
}


/*****************************************************
 *
 * :: add/clear/get
 *
 *****************************************************/


non_null()
static Tox_Event_Conference_Title *tox_events_add_conference_title(Tox_Events *events)
{
    if (events->conference_title_size == UINT32_MAX) {
        return nullptr;
    }

    if (events->conference_title_size == events->conference_title_capacity) {
        const uint32_t new_conference_title_capacity = events->conference_title_capacity * 2 + 1;
        Tox_Event_Conference_Title *new_conference_title = (Tox_Event_Conference_Title *)realloc(
                    events->conference_title, new_conference_title_capacity * sizeof(Tox_Event_Conference_Title));

        if (new_conference_title == nullptr) {
            return nullptr;
        }

        events->conference_title = new_conference_title;
        events->conference_title_capacity = new_conference_title_capacity;
    }

    Tox_Event_Conference_Title *const conference_title = &events->conference_title[events->conference_title_size];
    tox_event_conference_title_construct(conference_title);
    ++events->conference_title_size;
    return conference_title;
}

void tox_events_clear_conference_title(Tox_Events *events)
{
    if (events == nullptr) {
        return;
    }

    for (uint32_t i = 0; i < events->conference_title_size; ++i) {
        tox_event_conference_title_destruct(&events->conference_title[i]);
    }

    free(events->conference_title);
    events->conference_title = nullptr;
    events->conference_title_size = 0;
    events->conference_title_capacity = 0;
}

uint32_t tox_events_get_conference_title_size(const Tox_Events *events)
{
    if (events == nullptr) {
        return 0;
    }

    return events->conference_title_size;
}

const Tox_Event_Conference_Title *tox_events_get_conference_title(const Tox_Events *events, uint32_t index)
{
    assert(index < events->conference_title_size);
    assert(events->conference_title != nullptr);
    return &events->conference_title[index];
}

bool tox_events_pack_conference_title(const Tox_Events *events, Bin_Pack *bp)
{
    const uint32_t size = tox_events_get_conference_title_size(events);

    for (uint32_t i = 0; i < size; ++i) {
        if (!tox_event_conference_title_pack(tox_events_get_conference_title(events, i), bp)) {
            return false;
        }
    }
    return true;
}

bool tox_events_unpack_conference_title(Tox_Events *events, Bin_Unpack *bu)
{
    Tox_Event_Conference_Title *event = tox_events_add_conference_title(events);

    if (event == nullptr) {
        return false;
    }

    return tox_event_conference_title_unpack(event, bu);
}


/*****************************************************
 *
 * :: event handler
 *
 *****************************************************/


void tox_events_handle_conference_title(Tox *tox, uint32_t conference_number, uint32_t peer_number,
                                        const uint8_t *title, size_t length, void *user_data)
{
    Tox_Events_State *state = tox_events_alloc(user_data);
    assert(state != nullptr);

    if (state->events == nullptr) {
        return;
    }

    Tox_Event_Conference_Title *conference_title = tox_events_add_conference_title(state->events);

    if (conference_title == nullptr) {
        state->error = TOX_ERR_EVENTS_ITERATE_MALLOC;
        return;
    }

    tox_event_conference_title_set_conference_number(conference_title, conference_number);
    tox_event_conference_title_set_peer_number(conference_title, peer_number);
    tox_event_conference_title_set_title(conference_title, title, length);
}
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2022 The TokTok team.
 */


#include <assert.h>
#include <stdlib.h>


Tox_Events_State *tox_events_alloc(void *user_data)
{
    Tox_Events_State *state = (Tox_Events_State *)user_data;
    assert(state != nullptr);

    if (state->events != nullptr) {
        // Already allocated.
        return state;
    }

    state->events = (Tox_Events *)calloc(1, sizeof(Tox_Events));

    if (state->events == nullptr) {
        // It's still null => allocation failed.
        state->error = TOX_ERR_EVENTS_ITERATE_MALLOC;
    } else {
        *state->events = (Tox_Events) {
            nullptr
        };
    }

    return state;
}

void tox_events_free(Tox_Events *events)
{
    if (events == nullptr) {
        return;
    }

    tox_events_clear_conference_connected(events);
    tox_events_clear_conference_invite(events);
    tox_events_clear_conference_message(events);
    tox_events_clear_conference_peer_list_changed(events);
    tox_events_clear_conference_peer_name(events);
    tox_events_clear_conference_title(events);
    tox_events_clear_file_chunk_request(events);
    tox_events_clear_file_recv_chunk(events);
    tox_events_clear_file_recv_control(events);
    tox_events_clear_file_recv(events);
    tox_events_clear_friend_connection_status(events);
    tox_events_clear_friend_lossless_packet(events);
    tox_events_clear_friend_lossy_packet(events);
    tox_events_clear_friend_message(events);
    tox_events_clear_friend_name(events);
    tox_events_clear_friend_read_receipt(events);
    tox_events_clear_friend_request(events);
    tox_events_clear_friend_status(events);
    tox_events_clear_friend_status_message(events);
    tox_events_clear_friend_typing(events);
    tox_events_clear_self_connection_status(events);
    free(events);
}
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2022 The TokTok team.
 */


#include <assert.h>
#include <stdlib.h>
#include <string.h>



/*****************************************************
 *
 * :: struct and accessors
 *
 *****************************************************/


struct Tox_Event_File_Chunk_Request {
    uint32_t friend_number;
    uint32_t file_number;
    uint64_t position;
    uint16_t length;
};

non_null()
static void tox_event_file_chunk_request_construct(Tox_Event_File_Chunk_Request *file_chunk_request)
{
    *file_chunk_request = (Tox_Event_File_Chunk_Request) {
        0
    };
}
non_null()
static void tox_event_file_chunk_request_destruct(Tox_Event_File_Chunk_Request *file_chunk_request)
{
    return;
}

non_null()
static void tox_event_file_chunk_request_set_friend_number(Tox_Event_File_Chunk_Request *file_chunk_request,
        uint32_t friend_number)
{
    assert(file_chunk_request != nullptr);
    file_chunk_request->friend_number = friend_number;
}
uint32_t tox_event_file_chunk_request_get_friend_number(const Tox_Event_File_Chunk_Request *file_chunk_request)
{
    assert(file_chunk_request != nullptr);
    return file_chunk_request->friend_number;
}

non_null()
static void tox_event_file_chunk_request_set_file_number(Tox_Event_File_Chunk_Request *file_chunk_request,
        uint32_t file_number)
{
    assert(file_chunk_request != nullptr);
    file_chunk_request->file_number = file_number;
}
uint32_t tox_event_file_chunk_request_get_file_number(const Tox_Event_File_Chunk_Request *file_chunk_request)
{
    assert(file_chunk_request != nullptr);
    return file_chunk_request->file_number;
}

non_null()
static void tox_event_file_chunk_request_set_position(Tox_Event_File_Chunk_Request *file_chunk_request,
        uint64_t position)
{
    assert(file_chunk_request != nullptr);
    file_chunk_request->position = position;
}
uint64_t tox_event_file_chunk_request_get_position(const Tox_Event_File_Chunk_Request *file_chunk_request)
{
    assert(file_chunk_request != nullptr);
    return file_chunk_request->position;
}

non_null()
static void tox_event_file_chunk_request_set_length(Tox_Event_File_Chunk_Request *file_chunk_request, uint16_t length)
{
    assert(file_chunk_request != nullptr);
    file_chunk_request->length = length;
}
uint16_t tox_event_file_chunk_request_get_length(const Tox_Event_File_Chunk_Request *file_chunk_request)
{
    assert(file_chunk_request != nullptr);
    return file_chunk_request->length;
}

non_null()
static bool tox_event_file_chunk_request_pack(
    const Tox_Event_File_Chunk_Request *event, Bin_Pack *bp)
{
    assert(event != nullptr);
    return bin_pack_array(bp, 2)
           && bin_pack_u32(bp, TOX_EVENT_FILE_CHUNK_REQUEST)
           && bin_pack_array(bp, 4)
           && bin_pack_u32(bp, event->friend_number)
           && bin_pack_u32(bp, event->file_number)
           && bin_pack_u64(bp, event->position)
           && bin_pack_u16(bp, event->length);
}

non_null()
static bool tox_event_file_chunk_request_unpack(
    Tox_Event_File_Chunk_Request *event, Bin_Unpack *bu)
{
    assert(event != nullptr);
    if (!bin_unpack_array_fixed(bu, 4)) {
        return false;
    }

    return bin_unpack_u32(bu, &event->friend_number)
           && bin_unpack_u32(bu, &event->file_number)
           && bin_unpack_u64(bu, &event->position)
           && bin_unpack_u16(bu, &event->length);
}


/*****************************************************
 *
 * :: add/clear/get
 *
 *****************************************************/


non_null()
static Tox_Event_File_Chunk_Request *tox_events_add_file_chunk_request(Tox_Events *events)
{
    if (events->file_chunk_request_size == UINT32_MAX) {
        return nullptr;
    }

    if (events->file_chunk_request_size == events->file_chunk_request_capacity) {
        const uint32_t new_file_chunk_request_capacity = events->file_chunk_request_capacity * 2 + 1;
        Tox_Event_File_Chunk_Request *new_file_chunk_request = (Tox_Event_File_Chunk_Request *)realloc(
                    events->file_chunk_request, new_file_chunk_request_capacity * sizeof(Tox_Event_File_Chunk_Request));

        if (new_file_chunk_request == nullptr) {
            return nullptr;
        }

        events->file_chunk_request = new_file_chunk_request;
        events->file_chunk_request_capacity = new_file_chunk_request_capacity;
    }

    Tox_Event_File_Chunk_Request *const file_chunk_request = &events->file_chunk_request[events->file_chunk_request_size];
    tox_event_file_chunk_request_construct(file_chunk_request);
    ++events->file_chunk_request_size;
    return file_chunk_request;
}

void tox_events_clear_file_chunk_request(Tox_Events *events)
{
    if (events == nullptr) {
        return;
    }

    for (uint32_t i = 0; i < events->file_chunk_request_size; ++i) {
        tox_event_file_chunk_request_destruct(&events->file_chunk_request[i]);
    }

    free(events->file_chunk_request);
    events->file_chunk_request = nullptr;
    events->file_chunk_request_size = 0;
    events->file_chunk_request_capacity = 0;
}

uint32_t tox_events_get_file_chunk_request_size(const Tox_Events *events)
{
    if (events == nullptr) {
        return 0;
    }

    return events->file_chunk_request_size;
}

const Tox_Event_File_Chunk_Request *tox_events_get_file_chunk_request(const Tox_Events *events, uint32_t index)
{
    assert(index < events->file_chunk_request_size);
    assert(events->file_chunk_request != nullptr);
    return &events->file_chunk_request[index];
}

bool tox_events_pack_file_chunk_request(const Tox_Events *events, Bin_Pack *bp)
{
    const uint32_t size = tox_events_get_file_chunk_request_size(events);

    for (uint32_t i = 0; i < size; ++i) {
        if (!tox_event_file_chunk_request_pack(tox_events_get_file_chunk_request(events, i), bp)) {
            return false;
        }
    }
    return true;
}

bool tox_events_unpack_file_chunk_request(Tox_Events *events, Bin_Unpack *bu)
{
    Tox_Event_File_Chunk_Request *event = tox_events_add_file_chunk_request(events);

    if (event == nullptr) {
        return false;
    }

    return tox_event_file_chunk_request_unpack(event, bu);
}


/*****************************************************
 *
 * :: event handler
 *
 *****************************************************/


void tox_events_handle_file_chunk_request(Tox *tox, uint32_t friend_number, uint32_t file_number, uint64_t position,
        size_t length, void *user_data)
{
    Tox_Events_State *state = tox_events_alloc(user_data);
    assert(state != nullptr);

    if (state->events == nullptr) {
        return;
    }

    Tox_Event_File_Chunk_Request *file_chunk_request = tox_events_add_file_chunk_request(state->events);

    if (file_chunk_request == nullptr) {
        state->error = TOX_ERR_EVENTS_ITERATE_MALLOC;
        return;
    }

    tox_event_file_chunk_request_set_friend_number(file_chunk_request, friend_number);
    tox_event_file_chunk_request_set_file_number(file_chunk_request, file_number);
    tox_event_file_chunk_request_set_position(file_chunk_request, position);
    tox_event_file_chunk_request_set_length(file_chunk_request, length);
}
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2022 The TokTok team.
 */


#include <assert.h>
#include <stdlib.h>
#include <string.h>



/*****************************************************
 *
 * :: struct and accessors
 *
 *****************************************************/


struct Tox_Event_File_Recv {
    uint32_t friend_number;
    uint32_t file_number;
    uint32_t kind;
    uint64_t file_size;
    uint8_t *filename;
    uint32_t filename_length;
};

non_null()
static void tox_event_file_recv_construct(Tox_Event_File_Recv *file_recv)
{
    *file_recv = (Tox_Event_File_Recv) {
        0
    };
}
non_null()
static void tox_event_file_recv_destruct(Tox_Event_File_Recv *file_recv)
{
    free(file_recv->filename);
}

non_null()
static void tox_event_file_recv_set_friend_number(Tox_Event_File_Recv *file_recv,
        uint32_t friend_number)
{
    assert(file_recv != nullptr);
    file_recv->friend_number = friend_number;
}
uint32_t tox_event_file_recv_get_friend_number(const Tox_Event_File_Recv *file_recv)
{
    assert(file_recv != nullptr);
    return file_recv->friend_number;
}

non_null()
static void tox_event_file_recv_set_file_number(Tox_Event_File_Recv *file_recv,
        uint32_t file_number)
{
    assert(file_recv != nullptr);
    file_recv->file_number = file_number;
}
uint32_t tox_event_file_recv_get_file_number(const Tox_Event_File_Recv *file_recv)
{
    assert(file_recv != nullptr);
    return file_recv->file_number;
}

non_null()
static void tox_event_file_recv_set_kind(Tox_Event_File_Recv *file_recv,
        uint32_t kind)
{
    assert(file_recv != nullptr);
    file_recv->kind = kind;
}
uint32_t tox_event_file_recv_get_kind(const Tox_Event_File_Recv *file_recv)
{
    assert(file_recv != nullptr);
    return file_recv->kind;
}

non_null()
static void tox_event_file_recv_set_file_size(Tox_Event_File_Recv *file_recv,
        uint64_t file_size)
{
    assert(file_recv != nullptr);
    file_recv->file_size = file_size;
}
uint64_t tox_event_file_recv_get_file_size(const Tox_Event_File_Recv *file_recv)
{
    assert(file_recv != nullptr);
    return file_recv->file_size;
}

non_null()
static bool tox_event_file_recv_set_filename(Tox_Event_File_Recv *file_recv, const uint8_t *filename,
        uint32_t filename_length)
{
    assert(file_recv != nullptr);

    if (file_recv->filename != nullptr) {
        free(file_recv->filename);
        file_recv->filename = nullptr;
        file_recv->filename_length = 0;
    }

    file_recv->filename = (uint8_t *)malloc(filename_length);

    if (file_recv->filename == nullptr) {
        return false;
    }

    memcpy(file_recv->filename, filename, filename_length);
    file_recv->filename_length = filename_length;
    return true;
}
uint32_t tox_event_file_recv_get_filename_length(const Tox_Event_File_Recv *file_recv)
{
    assert(file_recv != nullptr);
    return file_recv->filename_length;
}
const uint8_t *tox_event_file_recv_get_filename(const Tox_Event_File_Recv *file_recv)
{
    assert(file_recv != nullptr);
    return file_recv->filename;
}

non_null()
static bool tox_event_file_recv_pack(
    const Tox_Event_File_Recv *event, Bin_Pack *bp)
{
    assert(event != nullptr);
    return bin_pack_array(bp, 2)
           && bin_pack_u32(bp, TOX_EVENT_FILE_RECV)
           && bin_pack_array(bp, 5)
           && bin_pack_u32(bp, event->friend_number)
           && bin_pack_u32(bp, event->file_number)
           && bin_pack_u32(bp, event->kind)
           && bin_pack_u64(bp, event->file_size)
           && bin_pack_bin(bp, event->filename, event->filename_length);
}

non_null()
static bool tox_event_file_recv_unpack(
    Tox_Event_File_Recv *event, Bin_Unpack *bu)
{
    assert(event != nullptr);
    if (!bin_unpack_array_fixed(bu, 5)) {
        return false;
    }

    return bin_unpack_u32(bu, &event->friend_number)
           && bin_unpack_u32(bu, &event->file_number)
           && bin_unpack_u32(bu, &event->kind)
           && bin_unpack_u64(bu, &event->file_size)
           && bin_unpack_bin(bu, &event->filename, &event->filename_length);
}


/*****************************************************
 *
 * :: add/clear/get
 *
 *****************************************************/


non_null()
static Tox_Event_File_Recv *tox_events_add_file_recv(Tox_Events *events)
{
    if (events->file_recv_size == UINT32_MAX) {
        return nullptr;
    }

    if (events->file_recv_size == events->file_recv_capacity) {
        const uint32_t new_file_recv_capacity = events->file_recv_capacity * 2 + 1;
        Tox_Event_File_Recv *new_file_recv = (Tox_Event_File_Recv *)realloc(
                events->file_recv, new_file_recv_capacity * sizeof(Tox_Event_File_Recv));

        if (new_file_recv == nullptr) {
            return nullptr;
        }

        events->file_recv = new_file_recv;
        events->file_recv_capacity = new_file_recv_capacity;
    }

    Tox_Event_File_Recv *const file_recv = &events->file_recv[events->file_recv_size];
    tox_event_file_recv_construct(file_recv);
    ++events->file_recv_size;
    return file_recv;
}

void tox_events_clear_file_recv(Tox_Events *events)
{
    if (events == nullptr) {
        return;
    }

    for (uint32_t i = 0; i < events->file_recv_size; ++i) {
        tox_event_file_recv_destruct(&events->file_recv[i]);
    }

    free(events->file_recv);
    events->file_recv = nullptr;
    events->file_recv_size = 0;
    events->file_recv_capacity = 0;
}

uint32_t tox_events_get_file_recv_size(const Tox_Events *events)
{
    if (events == nullptr) {
        return 0;
    }

    return events->file_recv_size;
}

const Tox_Event_File_Recv *tox_events_get_file_recv(const Tox_Events *events, uint32_t index)
{
    assert(index < events->file_recv_size);
    assert(events->file_recv != nullptr);
    return &events->file_recv[index];
}

bool tox_events_pack_file_recv(const Tox_Events *events, Bin_Pack *bp)
{
    const uint32_t size = tox_events_get_file_recv_size(events);

    for (uint32_t i = 0; i < size; ++i) {
        if (!tox_event_file_recv_pack(tox_events_get_file_recv(events, i), bp)) {
            return false;
        }
    }
    return true;
}

bool tox_events_unpack_file_recv(Tox_Events *events, Bin_Unpack *bu)
{
    Tox_Event_File_Recv *event = tox_events_add_file_recv(events);

    if (event == nullptr) {
        return false;
    }

    return tox_event_file_recv_unpack(event, bu);
}


/*****************************************************
 *
 * :: event handler
 *
 *****************************************************/


void tox_events_handle_file_recv(Tox *tox, uint32_t friend_number, uint32_t file_number, uint32_t kind,
                                 uint64_t file_size, const uint8_t *filename, size_t filename_length, void *user_data)
{
    Tox_Events_State *state = tox_events_alloc(user_data);
    assert(state != nullptr);

    if (state->events == nullptr) {
        return;
    }

    Tox_Event_File_Recv *file_recv = tox_events_add_file_recv(state->events);

    if (file_recv == nullptr) {
        state->error = TOX_ERR_EVENTS_ITERATE_MALLOC;
        return;
    }

    tox_event_file_recv_set_friend_number(file_recv, friend_number);
    tox_event_file_recv_set_file_number(file_recv, file_number);
    tox_event_file_recv_set_kind(file_recv, kind);
    tox_event_file_recv_set_file_size(file_recv, file_size);
    tox_event_file_recv_set_filename(file_recv, filename, filename_length);
}
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2022 The TokTok team.
 */


#include <assert.h>
#include <stdlib.h>
#include <string.h>



/*****************************************************
 *
 * :: struct and accessors
 *
 *****************************************************/


struct Tox_Event_File_Recv_Chunk {
    uint32_t friend_number;
    uint32_t file_number;
    uint64_t position;
    uint8_t *data;
    uint32_t data_length;
};

non_null()
static void tox_event_file_recv_chunk_construct(Tox_Event_File_Recv_Chunk *file_recv_chunk)
{
    *file_recv_chunk = (Tox_Event_File_Recv_Chunk) {
        0
    };
}
non_null()
static void tox_event_file_recv_chunk_destruct(Tox_Event_File_Recv_Chunk *file_recv_chunk)
{
    free(file_recv_chunk->data);
}

non_null()
static void tox_event_file_recv_chunk_set_friend_number(Tox_Event_File_Recv_Chunk *file_recv_chunk,
        uint32_t friend_number)
{
    assert(file_recv_chunk != nullptr);
    file_recv_chunk->friend_number = friend_number;
}
uint32_t tox_event_file_recv_chunk_get_friend_number(const Tox_Event_File_Recv_Chunk *file_recv_chunk)
{
    assert(file_recv_chunk != nullptr);
    return file_recv_chunk->friend_number;
}

non_null()
static void tox_event_file_recv_chunk_set_file_number(Tox_Event_File_Recv_Chunk *file_recv_chunk,
        uint32_t file_number)
{
    assert(file_recv_chunk != nullptr);
    file_recv_chunk->file_number = file_number;
}
uint32_t tox_event_file_recv_chunk_get_file_number(const Tox_Event_File_Recv_Chunk *file_recv_chunk)
{
    assert(file_recv_chunk != nullptr);
    return file_recv_chunk->file_number;
}

non_null()
static void tox_event_file_recv_chunk_set_position(Tox_Event_File_Recv_Chunk *file_recv_chunk,
        uint64_t position)
{
    assert(file_recv_chunk != nullptr);
    file_recv_chunk->position = position;
}
uint64_t tox_event_file_recv_chunk_get_position(const Tox_Event_File_Recv_Chunk *file_recv_chunk)
{
    assert(file_recv_chunk != nullptr);
    return file_recv_chunk->position;
}

non_null()
static bool tox_event_file_recv_chunk_set_data(Tox_Event_File_Recv_Chunk *file_recv_chunk, const uint8_t *data,
        uint32_t data_length)
{
    assert(file_recv_chunk != nullptr);

    if (file_recv_chunk->data != nullptr) {
        free(file_recv_chunk->data);
        file_recv_chunk->data = nullptr;
        file_recv_chunk->data_length = 0;
    }

    file_recv_chunk->data = (uint8_t *)malloc(data_length);

    if (file_recv_chunk->data == nullptr) {
        return false;
    }

    memcpy(file_recv_chunk->data, data, data_length);
    file_recv_chunk->data_length = data_length;
    return true;
}
uint32_t tox_event_file_recv_chunk_get_length(const Tox_Event_File_Recv_Chunk *file_recv_chunk)
{
    assert(file_recv_chunk != nullptr);
    return file_recv_chunk->data_length;
}
const uint8_t *tox_event_file_recv_chunk_get_data(const Tox_Event_File_Recv_Chunk *file_recv_chunk)
{
    assert(file_recv_chunk != nullptr);
    return file_recv_chunk->data;
}

non_null()
static bool tox_event_file_recv_chunk_pack(
    const Tox_Event_File_Recv_Chunk *event, Bin_Pack *bp)
{
    assert(event != nullptr);
    return bin_pack_array(bp, 2)
           && bin_pack_u32(bp, TOX_EVENT_FILE_RECV_CHUNK)
           && bin_pack_array(bp, 4)
           && bin_pack_u32(bp, event->friend_number)
           && bin_pack_u32(bp, event->file_number)
           && bin_pack_u64(bp, event->position)
           && bin_pack_bin(bp, event->data, event->data_length);
}

non_null()
static bool tox_event_file_recv_chunk_unpack(
    Tox_Event_File_Recv_Chunk *event, Bin_Unpack *bu)
{
    assert(event != nullptr);
    if (!bin_unpack_array_fixed(bu, 4)) {
        return false;
    }

    return bin_unpack_u32(bu, &event->friend_number)
           && bin_unpack_u32(bu, &event->file_number)
           && bin_unpack_u64(bu, &event->position)
           && bin_unpack_bin(bu, &event->data, &event->data_length);
}


/*****************************************************
 *
 * :: add/clear/get
 *
 *****************************************************/


non_null()
static Tox_Event_File_Recv_Chunk *tox_events_add_file_recv_chunk(Tox_Events *events)
{
    if (events->file_recv_chunk_size == UINT32_MAX) {
        return nullptr;
    }

    if (events->file_recv_chunk_size == events->file_recv_chunk_capacity) {
        const uint32_t new_file_recv_chunk_capacity = events->file_recv_chunk_capacity * 2 + 1;
        Tox_Event_File_Recv_Chunk *new_file_recv_chunk = (Tox_Event_File_Recv_Chunk *)realloc(
                    events->file_recv_chunk, new_file_recv_chunk_capacity * sizeof(Tox_Event_File_Recv_Chunk));

        if (new_file_recv_chunk == nullptr) {
            return nullptr;
        }

        events->file_recv_chunk = new_file_recv_chunk;
        events->file_recv_chunk_capacity = new_file_recv_chunk_capacity;
    }

    Tox_Event_File_Recv_Chunk *const file_recv_chunk = &events->file_recv_chunk[events->file_recv_chunk_size];
    tox_event_file_recv_chunk_construct(file_recv_chunk);
    ++events->file_recv_chunk_size;
    return file_recv_chunk;
}

void tox_events_clear_file_recv_chunk(Tox_Events *events)
{
    if (events == nullptr) {
        return;
    }

    for (uint32_t i = 0; i < events->file_recv_chunk_size; ++i) {
        tox_event_file_recv_chunk_destruct(&events->file_recv_chunk[i]);
    }

    free(events->file_recv_chunk);
    events->file_recv_chunk = nullptr;
    events->file_recv_chunk_size = 0;
    events->file_recv_chunk_capacity = 0;
}

uint32_t tox_events_get_file_recv_chunk_size(const Tox_Events *events)
{
    if (events == nullptr) {
        return 0;
    }

    return events->file_recv_chunk_size;
}

const Tox_Event_File_Recv_Chunk *tox_events_get_file_recv_chunk(const Tox_Events *events, uint32_t index)
{
    assert(index < events->file_recv_chunk_size);
    assert(events->file_recv_chunk != nullptr);
    return &events->file_recv_chunk[index];
}

bool tox_events_pack_file_recv_chunk(const Tox_Events *events, Bin_Pack *bp)
{
    const uint32_t size = tox_events_get_file_recv_chunk_size(events);

    for (uint32_t i = 0; i < size; ++i) {
        if (!tox_event_file_recv_chunk_pack(tox_events_get_file_recv_chunk(events, i), bp)) {
            return false;
        }
    }
    return true;
}

bool tox_events_unpack_file_recv_chunk(Tox_Events *events, Bin_Unpack *bu)
{
    Tox_Event_File_Recv_Chunk *event = tox_events_add_file_recv_chunk(events);

    if (event == nullptr) {
        return false;
    }

    return tox_event_file_recv_chunk_unpack(event, bu);
}


/*****************************************************
 *
 * :: event handler
 *
 *****************************************************/


void tox_events_handle_file_recv_chunk(Tox *tox, uint32_t friend_number, uint32_t file_number, uint64_t position,
                                       const uint8_t *data, size_t length, void *user_data)
{
    Tox_Events_State *state = tox_events_alloc(user_data);
    assert(state != nullptr);

    if (state->events == nullptr) {
        return;
    }

    Tox_Event_File_Recv_Chunk *file_recv_chunk = tox_events_add_file_recv_chunk(state->events);

    if (file_recv_chunk == nullptr) {
        state->error = TOX_ERR_EVENTS_ITERATE_MALLOC;
        return;
    }

    tox_event_file_recv_chunk_set_friend_number(file_recv_chunk, friend_number);
    tox_event_file_recv_chunk_set_file_number(file_recv_chunk, file_number);
    tox_event_file_recv_chunk_set_position(file_recv_chunk, position);
    tox_event_file_recv_chunk_set_data(file_recv_chunk, data, length);
}
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2022 The TokTok team.
 */


#include <assert.h>
#include <stdlib.h>
#include <string.h>



/*****************************************************
 *
 * :: struct and accessors
 *
 *****************************************************/


struct Tox_Event_File_Recv_Control {
    uint32_t friend_number;
    uint32_t file_number;
    Tox_File_Control control;
};

non_null()
static void tox_event_file_recv_control_construct(Tox_Event_File_Recv_Control *file_recv_control)
{
    *file_recv_control = (Tox_Event_File_Recv_Control) {
        0
    };
}
non_null()
static void tox_event_file_recv_control_destruct(Tox_Event_File_Recv_Control *file_recv_control)
{
    return;
}

non_null()
static void tox_event_file_recv_control_set_friend_number(Tox_Event_File_Recv_Control *file_recv_control,
        uint32_t friend_number)
{
    assert(file_recv_control != nullptr);
    file_recv_control->friend_number = friend_number;
}
uint32_t tox_event_file_recv_control_get_friend_number(const Tox_Event_File_Recv_Control *file_recv_control)
{
    assert(file_recv_control != nullptr);
    return file_recv_control->friend_number;
}

non_null()
static void tox_event_file_recv_control_set_file_number(Tox_Event_File_Recv_Control *file_recv_control,
        uint32_t file_number)
{
    assert(file_recv_control != nullptr);
    file_recv_control->file_number = file_number;
}
uint32_t tox_event_file_recv_control_get_file_number(const Tox_Event_File_Recv_Control *file_recv_control)
{
    assert(file_recv_control != nullptr);
    return file_recv_control->file_number;
}

non_null()
static void tox_event_file_recv_control_set_control(Tox_Event_File_Recv_Control *file_recv_control,
        Tox_File_Control control)
{
    assert(file_recv_control != nullptr);
    file_recv_control->control = control;
}
Tox_File_Control tox_event_file_recv_control_get_control(const Tox_Event_File_Recv_Control *file_recv_control)
{
    assert(file_recv_control != nullptr);
    return file_recv_control->control;
}

non_null()
static bool tox_event_file_recv_control_pack(
    const Tox_Event_File_Recv_Control *event, Bin_Pack *bp)
{
    assert(event != nullptr);
    return bin_pack_array(bp, 2)
           && bin_pack_u32(bp, TOX_EVENT_FILE_RECV_CONTROL)
           && bin_pack_array(bp, 3)
           && bin_pack_u32(bp, event->friend_number)
           && bin_pack_u32(bp, event->file_number)
           && bin_pack_u32(bp, event->control);
}

non_null()
static bool tox_event_file_recv_control_unpack(
    Tox_Event_File_Recv_Control *event, Bin_Unpack *bu)
{
    assert(event != nullptr);
    if (!bin_unpack_array_fixed(bu, 3)) {
        return false;
    }

    return bin_unpack_u32(bu, &event->friend_number)
           && bin_unpack_u32(bu, &event->file_number)
           && tox_unpack_file_control(bu, &event->control);
}


/*****************************************************
 *
 * :: add/clear/get
 *
 *****************************************************/


non_null()
static Tox_Event_File_Recv_Control *tox_events_add_file_recv_control(Tox_Events *events)
{
    if (events->file_recv_control_size == UINT32_MAX) {
        return nullptr;
    }

    if (events->file_recv_control_size == events->file_recv_control_capacity) {
        const uint32_t new_file_recv_control_capacity = events->file_recv_control_capacity * 2 + 1;
        Tox_Event_File_Recv_Control *new_file_recv_control = (Tox_Event_File_Recv_Control *)realloc(
                    events->file_recv_control, new_file_recv_control_capacity * sizeof(Tox_Event_File_Recv_Control));

        if (new_file_recv_control == nullptr) {
            return nullptr;
        }

        events->file_recv_control = new_file_recv_control;
        events->file_recv_control_capacity = new_file_recv_control_capacity;
    }

    Tox_Event_File_Recv_Control *const file_recv_control = &events->file_recv_control[events->file_recv_control_size];
    tox_event_file_recv_control_construct(file_recv_control);
    ++events->file_recv_control_size;
    return file_recv_control;
}

void tox_events_clear_file_recv_control(Tox_Events *events)
{
    if (events == nullptr) {
        return;
    }

    for (uint32_t i = 0; i < events->file_recv_control_size; ++i) {
        tox_event_file_recv_control_destruct(&events->file_recv_control[i]);
    }

    free(events->file_recv_control);
    events->file_recv_control = nullptr;
    events->file_recv_control_size = 0;
    events->file_recv_control_capacity = 0;
}

uint32_t tox_events_get_file_recv_control_size(const Tox_Events *events)
{
    if (events == nullptr) {
        return 0;
    }

    return events->file_recv_control_size;
}

const Tox_Event_File_Recv_Control *tox_events_get_file_recv_control(const Tox_Events *events, uint32_t index)
{
    assert(index < events->file_recv_control_size);
    assert(events->file_recv_control != nullptr);
    return &events->file_recv_control[index];
}

bool tox_events_pack_file_recv_control(const Tox_Events *events, Bin_Pack *bp)
{
    const uint32_t size = tox_events_get_file_recv_control_size(events);

    for (uint32_t i = 0; i < size; ++i) {
        if (!tox_event_file_recv_control_pack(tox_events_get_file_recv_control(events, i), bp)) {
            return false;
        }
    }
    return true;
}

bool tox_events_unpack_file_recv_control(Tox_Events *events, Bin_Unpack *bu)
{
    Tox_Event_File_Recv_Control *event = tox_events_add_file_recv_control(events);

    if (event == nullptr) {
        return false;
    }

    return tox_event_file_recv_control_unpack(event, bu);
}


/*****************************************************
 *
 * :: event handler
 *
 *****************************************************/


void tox_events_handle_file_recv_control(Tox *tox, uint32_t friend_number, uint32_t file_number,
        Tox_File_Control control, void *user_data)
{
    Tox_Events_State *state = tox_events_alloc(user_data);
    assert(state != nullptr);

    if (state->events == nullptr) {
        return;
    }

    Tox_Event_File_Recv_Control *file_recv_control = tox_events_add_file_recv_control(state->events);

    if (file_recv_control == nullptr) {
        state->error = TOX_ERR_EVENTS_ITERATE_MALLOC;
        return;
    }

    tox_event_file_recv_control_set_friend_number(file_recv_control, friend_number);
    tox_event_file_recv_control_set_file_number(file_recv_control, file_number);
    tox_event_file_recv_control_set_control(file_recv_control, control);
}
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2022 The TokTok team.
 */


#include <assert.h>
#include <stdlib.h>
#include <string.h>



/*****************************************************
 *
 * :: struct and accessors
 *
 *****************************************************/


struct Tox_Event_Friend_Connection_Status {
    uint32_t friend_number;
    Tox_Connection connection_status;
};

non_null()
static void tox_event_friend_connection_status_construct(Tox_Event_Friend_Connection_Status *friend_connection_status)
{
    *friend_connection_status = (Tox_Event_Friend_Connection_Status) {
        0
    };
}
non_null()
static void tox_event_friend_connection_status_destruct(Tox_Event_Friend_Connection_Status *friend_connection_status)
{
    return;
}

non_null()
static void tox_event_friend_connection_status_set_friend_number(Tox_Event_Friend_Connection_Status
        *friend_connection_status, uint32_t friend_number)
{
    assert(friend_connection_status != nullptr);
    friend_connection_status->friend_number = friend_number;
}
uint32_t tox_event_friend_connection_status_get_friend_number(const Tox_Event_Friend_Connection_Status
        *friend_connection_status)
{
    assert(friend_connection_status != nullptr);
    return friend_connection_status->friend_number;
}

non_null()
static void tox_event_friend_connection_status_set_connection_status(Tox_Event_Friend_Connection_Status
        *friend_connection_status, Tox_Connection connection_status)
{
    assert(friend_connection_status != nullptr);
    friend_connection_status->connection_status = connection_status;
}
Tox_Connection tox_event_friend_connection_status_get_connection_status(const Tox_Event_Friend_Connection_Status
        *friend_connection_status)
{
    assert(friend_connection_status != nullptr);
    return friend_connection_status->connection_status;
}

non_null()
static bool tox_event_friend_connection_status_pack(
    const Tox_Event_Friend_Connection_Status *event, Bin_Pack *bp)
{
    assert(event != nullptr);
    return bin_pack_array(bp, 2)
           && bin_pack_u32(bp, TOX_EVENT_FRIEND_CONNECTION_STATUS)
           && bin_pack_array(bp, 2)
           && bin_pack_u32(bp, event->friend_number)
           && bin_pack_u32(bp, event->connection_status);
}

non_null()
static bool tox_event_friend_connection_status_unpack(
    Tox_Event_Friend_Connection_Status *event, Bin_Unpack *bu)
{
    assert(event != nullptr);
    if (!bin_unpack_array_fixed(bu, 2)) {
        return false;
    }

    return bin_unpack_u32(bu, &event->friend_number)
           && tox_unpack_connection(bu, &event->connection_status);
}


/*****************************************************
 *
 * :: add/clear/get
 *
 *****************************************************/


non_null()
static Tox_Event_Friend_Connection_Status *tox_events_add_friend_connection_status(Tox_Events *events)
{
    if (events->friend_connection_status_size == UINT32_MAX) {
        return nullptr;
    }

    if (events->friend_connection_status_size == events->friend_connection_status_capacity) {
        const uint32_t new_friend_connection_status_capacity = events->friend_connection_status_capacity * 2 + 1;
        Tox_Event_Friend_Connection_Status *new_friend_connection_status = (Tox_Event_Friend_Connection_Status *)realloc(
                    events->friend_connection_status, new_friend_connection_status_capacity * sizeof(Tox_Event_Friend_Connection_Status));

        if (new_friend_connection_status == nullptr) {
            return nullptr;
        }

        events->friend_connection_status = new_friend_connection_status;
        events->friend_connection_status_capacity = new_friend_connection_status_capacity;
    }

    Tox_Event_Friend_Connection_Status *const friend_connection_status =
        &events->friend_connection_status[events->friend_connection_status_size];
    tox_event_friend_connection_status_construct(friend_connection_status);
    ++events->friend_connection_status_size;
    return friend_connection_status;
}

void tox_events_clear_friend_connection_status(Tox_Events *events)
{
    if (events == nullptr) {
        return;
    }

    for (uint32_t i = 0; i < events->friend_connection_status_size; ++i) {
        tox_event_friend_connection_status_destruct(&events->friend_connection_status[i]);
    }

    free(events->friend_connection_status);
    events->friend_connection_status = nullptr;
    events->friend_connection_status_size = 0;
    events->friend_connection_status_capacity = 0;
}

uint32_t tox_events_get_friend_connection_status_size(const Tox_Events *events)
{
    if (events == nullptr) {
        return 0;
    }

    return events->friend_connection_status_size;
}

const Tox_Event_Friend_Connection_Status *tox_events_get_friend_connection_status(const Tox_Events *events,
        uint32_t index)
{
    assert(index < events->friend_connection_status_size);
    assert(events->friend_connection_status != nullptr);
    return &events->friend_connection_status[index];
}

bool tox_events_pack_friend_connection_status(const Tox_Events *events, Bin_Pack *bp)
{
    const uint32_t size = tox_events_get_friend_connection_status_size(events);

    for (uint32_t i = 0; i < size; ++i) {
        if (!tox_event_friend_connection_status_pack(tox_events_get_friend_connection_status(events, i), bp)) {
            return false;
        }
    }
    return true;
}

bool tox_events_unpack_friend_connection_status(Tox_Events *events, Bin_Unpack *bu)
{
    Tox_Event_Friend_Connection_Status *event = tox_events_add_friend_connection_status(events);

    if (event == nullptr) {
        return false;
    }

    return tox_event_friend_connection_status_unpack(event, bu);
}


/*****************************************************
 *
 * :: event handler
 *
 *****************************************************/


void tox_events_handle_friend_connection_status(Tox *tox, uint32_t friend_number, Tox_Connection connection_status,
        void *user_data)
{
    Tox_Events_State *state = tox_events_alloc(user_data);
    assert(state != nullptr);

    if (state->events == nullptr) {
        return;
    }

    Tox_Event_Friend_Connection_Status *friend_connection_status = tox_events_add_friend_connection_status(state->events);

    if (friend_connection_status == nullptr) {
        state->error = TOX_ERR_EVENTS_ITERATE_MALLOC;
        return;
    }

    tox_event_friend_connection_status_set_friend_number(friend_connection_status, friend_number);
    tox_event_friend_connection_status_set_connection_status(friend_connection_status, connection_status);
}
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2022 The TokTok team.
 */


#include <assert.h>
#include <stdlib.h>
#include <string.h>



/*****************************************************
 *
 * :: struct and accessors
 *
 *****************************************************/


struct Tox_Event_Friend_Lossless_Packet {
    uint32_t friend_number;
    uint8_t *data;
    uint32_t data_length;
};

non_null()
static void tox_event_friend_lossless_packet_construct(Tox_Event_Friend_Lossless_Packet *friend_lossless_packet)
{
    *friend_lossless_packet = (Tox_Event_Friend_Lossless_Packet) {
        0
    };
}
non_null()
static void tox_event_friend_lossless_packet_destruct(Tox_Event_Friend_Lossless_Packet *friend_lossless_packet)
{
    free(friend_lossless_packet->data);
}

non_null()
static void tox_event_friend_lossless_packet_set_friend_number(Tox_Event_Friend_Lossless_Packet *friend_lossless_packet,
        uint32_t friend_number)
{
    assert(friend_lossless_packet != nullptr);
    friend_lossless_packet->friend_number = friend_number;
}
uint32_t tox_event_friend_lossless_packet_get_friend_number(const Tox_Event_Friend_Lossless_Packet
        *friend_lossless_packet)
{
    assert(friend_lossless_packet != nullptr);
    return friend_lossless_packet->friend_number;
}

non_null()
static bool tox_event_friend_lossless_packet_set_data(Tox_Event_Friend_Lossless_Packet *friend_lossless_packet,
        const uint8_t *data, uint32_t data_length)
{
    assert(friend_lossless_packet != nullptr);

    if (friend_lossless_packet->data != nullptr) {
        free(friend_lossless_packet->data);
        friend_lossless_packet->data = nullptr;
        friend_lossless_packet->data_length = 0;
    }

    friend_lossless_packet->data = (uint8_t *)malloc(data_length);

    if (friend_lossless_packet->data == nullptr) {
        return false;
    }

    memcpy(friend_lossless_packet->data, data, data_length);
    friend_lossless_packet->data_length = data_length;
    return true;
}
uint32_t tox_event_friend_lossless_packet_get_data_length(const Tox_Event_Friend_Lossless_Packet *friend_lossless_packet)
{
    assert(friend_lossless_packet != nullptr);
    return friend_lossless_packet->data_length;
}
const uint8_t *tox_event_friend_lossless_packet_get_data(const Tox_Event_Friend_Lossless_Packet *friend_lossless_packet)
{
    assert(friend_lossless_packet != nullptr);
    return friend_lossless_packet->data;
}

non_null()
static bool tox_event_friend_lossless_packet_pack(
    const Tox_Event_Friend_Lossless_Packet *event, Bin_Pack *bp)
{
    assert(event != nullptr);
    return bin_pack_array(bp, 2)
           && bin_pack_u32(bp, TOX_EVENT_FRIEND_LOSSLESS_PACKET)
           && bin_pack_array(bp, 2)
           && bin_pack_u32(bp, event->friend_number)
           && bin_pack_bin(bp, event->data, event->data_length);
}

non_null()
static bool tox_event_friend_lossless_packet_unpack(
    Tox_Event_Friend_Lossless_Packet *event, Bin_Unpack *bu)
{
    assert(event != nullptr);
    if (!bin_unpack_array_fixed(bu, 2)) {
        return false;
    }

    return bin_unpack_u32(bu, &event->friend_number)
           && bin_unpack_bin(bu, &event->data, &event->data_length);
}


/*****************************************************
 *
 * :: add/clear/get
 *
 *****************************************************/


non_null()
static Tox_Event_Friend_Lossless_Packet *tox_events_add_friend_lossless_packet(Tox_Events *events)
{
    if (events->friend_lossless_packet_size == UINT32_MAX) {
        return nullptr;
    }

    if (events->friend_lossless_packet_size == events->friend_lossless_packet_capacity) {
        const uint32_t new_friend_lossless_packet_capacity = events->friend_lossless_packet_capacity * 2 + 1;
        Tox_Event_Friend_Lossless_Packet *new_friend_lossless_packet = (Tox_Event_Friend_Lossless_Packet *)realloc(
                    events->friend_lossless_packet, new_friend_lossless_packet_capacity * sizeof(Tox_Event_Friend_Lossless_Packet));

        if (new_friend_lossless_packet == nullptr) {
            return nullptr;
        }

        events->friend_lossless_packet = new_friend_lossless_packet;
        events->friend_lossless_packet_capacity = new_friend_lossless_packet_capacity;
    }

    Tox_Event_Friend_Lossless_Packet *const friend_lossless_packet =
        &events->friend_lossless_packet[events->friend_lossless_packet_size];
    tox_event_friend_lossless_packet_construct(friend_lossless_packet);
    ++events->friend_lossless_packet_size;
    return friend_lossless_packet;
}

void tox_events_clear_friend_lossless_packet(Tox_Events *events)
{
    if (events == nullptr) {
        return;
    }

    for (uint32_t i = 0; i < events->friend_lossless_packet_size; ++i) {
        tox_event_friend_lossless_packet_destruct(&events->friend_lossless_packet[i]);
    }

    free(events->friend_lossless_packet);
    events->friend_lossless_packet = nullptr;
    events->friend_lossless_packet_size = 0;
    events->friend_lossless_packet_capacity = 0;
}

uint32_t tox_events_get_friend_lossless_packet_size(const Tox_Events *events)
{
    if (events == nullptr) {
        return 0;
    }

    return events->friend_lossless_packet_size;
}

const Tox_Event_Friend_Lossless_Packet *tox_events_get_friend_lossless_packet(const Tox_Events *events, uint32_t index)
{
    assert(index < events->friend_lossless_packet_size);
    assert(events->friend_lossless_packet != nullptr);
    return &events->friend_lossless_packet[index];
}

bool tox_events_pack_friend_lossless_packet(const Tox_Events *events, Bin_Pack *bp)
{
    const uint32_t size = tox_events_get_friend_lossless_packet_size(events);

    for (uint32_t i = 0; i < size; ++i) {
        if (!tox_event_friend_lossless_packet_pack(tox_events_get_friend_lossless_packet(events, i), bp)) {
            return false;
        }
    }
    return true;
}

bool tox_events_unpack_friend_lossless_packet(Tox_Events *events, Bin_Unpack *bu)
{
    Tox_Event_Friend_Lossless_Packet *event = tox_events_add_friend_lossless_packet(events);

    if (event == nullptr) {
        return false;
    }

    return tox_event_friend_lossless_packet_unpack(event, bu);
}


/*****************************************************
 *
 * :: event handler
 *
 *****************************************************/


void tox_events_handle_friend_lossless_packet(Tox *tox, uint32_t friend_number, const uint8_t *data, size_t length,
        void *user_data)
{
    Tox_Events_State *state = tox_events_alloc(user_data);
    assert(state != nullptr);

    if (state->events == nullptr) {
        return;
    }

    Tox_Event_Friend_Lossless_Packet *friend_lossless_packet = tox_events_add_friend_lossless_packet(state->events);

    if (friend_lossless_packet == nullptr) {
        state->error = TOX_ERR_EVENTS_ITERATE_MALLOC;
        return;
    }

    tox_event_friend_lossless_packet_set_friend_number(friend_lossless_packet, friend_number);
    tox_event_friend_lossless_packet_set_data(friend_lossless_packet, data, length);
}
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2022 The TokTok team.
 */


#include <assert.h>
#include <stdlib.h>
#include <string.h>



/*****************************************************
 *
 * :: struct and accessors
 *
 *****************************************************/


struct Tox_Event_Friend_Lossy_Packet {
    uint32_t friend_number;
    uint8_t *data;
    uint32_t data_length;
};

non_null()
static void tox_event_friend_lossy_packet_construct(Tox_Event_Friend_Lossy_Packet *friend_lossy_packet)
{
    *friend_lossy_packet = (Tox_Event_Friend_Lossy_Packet) {
        0
    };
}
non_null()
static void tox_event_friend_lossy_packet_destruct(Tox_Event_Friend_Lossy_Packet *friend_lossy_packet)
{
    free(friend_lossy_packet->data);
}

non_null()
static void tox_event_friend_lossy_packet_set_friend_number(Tox_Event_Friend_Lossy_Packet *friend_lossy_packet,
        uint32_t friend_number)
{
    assert(friend_lossy_packet != nullptr);
    friend_lossy_packet->friend_number = friend_number;
}
uint32_t tox_event_friend_lossy_packet_get_friend_number(const Tox_Event_Friend_Lossy_Packet *friend_lossy_packet)
{
    assert(friend_lossy_packet != nullptr);
    return friend_lossy_packet->friend_number;
}

non_null()
static bool tox_event_friend_lossy_packet_set_data(Tox_Event_Friend_Lossy_Packet *friend_lossy_packet,
        const uint8_t *data, uint32_t data_length)
{
    assert(friend_lossy_packet != nullptr);

    if (friend_lossy_packet->data != nullptr) {
        free(friend_lossy_packet->data);
        friend_lossy_packet->data = nullptr;
        friend_lossy_packet->data_length = 0;
    }

    friend_lossy_packet->data = (uint8_t *)malloc(data_length);

    if (friend_lossy_packet->data == nullptr) {
        return false;
    }

    memcpy(friend_lossy_packet->data, data, data_length);
    friend_lossy_packet->data_length = data_length;
    return true;
}
uint32_t tox_event_friend_lossy_packet_get_data_length(const Tox_Event_Friend_Lossy_Packet *friend_lossy_packet)
{
    assert(friend_lossy_packet != nullptr);
    return friend_lossy_packet->data_length;
}
const uint8_t *tox_event_friend_lossy_packet_get_data(const Tox_Event_Friend_Lossy_Packet *friend_lossy_packet)
{
    assert(friend_lossy_packet != nullptr);
    return friend_lossy_packet->data;
}

non_null()
static bool tox_event_friend_lossy_packet_pack(
    const Tox_Event_Friend_Lossy_Packet *event, Bin_Pack *bp)
{
    assert(event != nullptr);
    return bin_pack_array(bp, 2)
           && bin_pack_u32(bp, TOX_EVENT_FRIEND_LOSSY_PACKET)
           && bin_pack_array(bp, 2)
           && bin_pack_u32(bp, event->friend_number)
           && bin_pack_bin(bp, event->data, event->data_length);
}

non_null()
static bool tox_event_friend_lossy_packet_unpack(
    Tox_Event_Friend_Lossy_Packet *event, Bin_Unpack *bu)
{
    assert(event != nullptr);
    if (!bin_unpack_array_fixed(bu, 2)) {
        return false;
    }

    return bin_unpack_u32(bu, &event->friend_number)
           && bin_unpack_bin(bu, &event->data, &event->data_length);
}


/*****************************************************
 *
 * :: add/clear/get
 *
 *****************************************************/


non_null()
static Tox_Event_Friend_Lossy_Packet *tox_events_add_friend_lossy_packet(Tox_Events *events)
{
    if (events->friend_lossy_packet_size == UINT32_MAX) {
        return nullptr;
    }

    if (events->friend_lossy_packet_size == events->friend_lossy_packet_capacity) {
        const uint32_t new_friend_lossy_packet_capacity = events->friend_lossy_packet_capacity * 2 + 1;
        Tox_Event_Friend_Lossy_Packet *new_friend_lossy_packet = (Tox_Event_Friend_Lossy_Packet *)realloc(
                    events->friend_lossy_packet, new_friend_lossy_packet_capacity * sizeof(Tox_Event_Friend_Lossy_Packet));

        if (new_friend_lossy_packet == nullptr) {
            return nullptr;
        }

        events->friend_lossy_packet = new_friend_lossy_packet;
        events->friend_lossy_packet_capacity = new_friend_lossy_packet_capacity;
    }

    Tox_Event_Friend_Lossy_Packet *const friend_lossy_packet =
        &events->friend_lossy_packet[events->friend_lossy_packet_size];
    tox_event_friend_lossy_packet_construct(friend_lossy_packet);
    ++events->friend_lossy_packet_size;
    return friend_lossy_packet;
}

void tox_events_clear_friend_lossy_packet(Tox_Events *events)
{
    if (events == nullptr) {
        return;
    }

    for (uint32_t i = 0; i < events->friend_lossy_packet_size; ++i) {
        tox_event_friend_lossy_packet_destruct(&events->friend_lossy_packet[i]);
    }

    free(events->friend_lossy_packet);
    events->friend_lossy_packet = nullptr;
    events->friend_lossy_packet_size = 0;
    events->friend_lossy_packet_capacity = 0;
}

uint32_t tox_events_get_friend_lossy_packet_size(const Tox_Events *events)
{
    if (events == nullptr) {
        return 0;
    }

    return events->friend_lossy_packet_size;
}

const Tox_Event_Friend_Lossy_Packet *tox_events_get_friend_lossy_packet(const Tox_Events *events, uint32_t index)
{
    assert(index < events->friend_lossy_packet_size);
    assert(events->friend_lossy_packet != nullptr);
    return &events->friend_lossy_packet[index];
}

bool tox_events_pack_friend_lossy_packet(const Tox_Events *events, Bin_Pack *bp)
{
    const uint32_t size = tox_events_get_friend_lossy_packet_size(events);

    for (uint32_t i = 0; i < size; ++i) {
        if (!tox_event_friend_lossy_packet_pack(tox_events_get_friend_lossy_packet(events, i), bp)) {
            return false;
        }
    }
    return true;
}

bool tox_events_unpack_friend_lossy_packet(Tox_Events *events, Bin_Unpack *bu)
{
    Tox_Event_Friend_Lossy_Packet *event = tox_events_add_friend_lossy_packet(events);

    if (event == nullptr) {
        return false;
    }

    return tox_event_friend_lossy_packet_unpack(event, bu);
}


/*****************************************************
 *
 * :: event handler
 *
 *****************************************************/


void tox_events_handle_friend_lossy_packet(Tox *tox, uint32_t friend_number, const uint8_t *data, size_t length,
        void *user_data)
{
    Tox_Events_State *state = tox_events_alloc(user_data);
    assert(state != nullptr);

    if (state->events == nullptr) {
        return;
    }

    Tox_Event_Friend_Lossy_Packet *friend_lossy_packet = tox_events_add_friend_lossy_packet(state->events);

    if (friend_lossy_packet == nullptr) {
        state->error = TOX_ERR_EVENTS_ITERATE_MALLOC;
        return;
    }

    tox_event_friend_lossy_packet_set_friend_number(friend_lossy_packet, friend_number);
    tox_event_friend_lossy_packet_set_data(friend_lossy_packet, data, length);
}
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2022 The TokTok team.
 */


#include <assert.h>
#include <stdlib.h>
#include <string.h>



/*****************************************************
 *
 * :: struct and accessors
 *
 *****************************************************/


struct Tox_Event_Friend_Message {
    uint32_t friend_number;
    Tox_Message_Type type;
    uint8_t *message;
    uint32_t message_length;
};

non_null()
static void tox_event_friend_message_construct(Tox_Event_Friend_Message *friend_message)
{
    *friend_message = (Tox_Event_Friend_Message) {
        0
    };
}
non_null()
static void tox_event_friend_message_destruct(Tox_Event_Friend_Message *friend_message)
{
    free(friend_message->message);
}

non_null()
static void tox_event_friend_message_set_friend_number(Tox_Event_Friend_Message *friend_message,
        uint32_t friend_number)
{
    assert(friend_message != nullptr);
    friend_message->friend_number = friend_number;
}
uint32_t tox_event_friend_message_get_friend_number(const Tox_Event_Friend_Message *friend_message)
{
    assert(friend_message != nullptr);
    return friend_message->friend_number;
}

non_null()
static void tox_event_friend_message_set_type(Tox_Event_Friend_Message *friend_message, Tox_Message_Type type)
{
    assert(friend_message != nullptr);
    friend_message->type = type;
}
Tox_Message_Type tox_event_friend_message_get_type(const Tox_Event_Friend_Message *friend_message)
{
    assert(friend_message != nullptr);
    return friend_message->type;
}

non_null()
static bool tox_event_friend_message_set_message(Tox_Event_Friend_Message *friend_message, const uint8_t *message,
        uint32_t message_length)
{
    assert(friend_message != nullptr);

    if (friend_message->message != nullptr) {
        free(friend_message->message);
        friend_message->message = nullptr;
        friend_message->message_length = 0;
    }

    friend_message->message = (uint8_t *)malloc(message_length);

    if (friend_message->message == nullptr) {
        return false;
    }

    memcpy(friend_message->message, message, message_length);
    friend_message->message_length = message_length;
    return true;
}
uint32_t tox_event_friend_message_get_message_length(const Tox_Event_Friend_Message *friend_message)
{
    assert(friend_message != nullptr);
    return friend_message->message_length;
}
const uint8_t *tox_event_friend_message_get_message(const Tox_Event_Friend_Message *friend_message)
{
    assert(friend_message != nullptr);
    return friend_message->message;
}

non_null()
static bool tox_event_friend_message_pack(
    const Tox_Event_Friend_Message *event, Bin_Pack *bp)
{
    assert(event != nullptr);
    return bin_pack_array(bp, 2)
           && bin_pack_u32(bp, TOX_EVENT_FRIEND_MESSAGE)
           && bin_pack_array(bp, 3)
           && bin_pack_u32(bp, event->friend_number)
           && bin_pack_u32(bp, event->type)
           && bin_pack_bin(bp, event->message, event->message_length);
}

non_null()
static bool tox_event_friend_message_unpack(
    Tox_Event_Friend_Message *event, Bin_Unpack *bu)
{
    assert(event != nullptr);
    if (!bin_unpack_array_fixed(bu, 3)) {
        return false;
    }

    return bin_unpack_u32(bu, &event->friend_number)
           && tox_unpack_message_type(bu, &event->type)
           && bin_unpack_bin(bu, &event->message, &event->message_length);
}


/*****************************************************
 *
 * :: add/clear/get
 *
 *****************************************************/


non_null()
static Tox_Event_Friend_Message *tox_events_add_friend_message(Tox_Events *events)
{
    if (events->friend_message_size == UINT32_MAX) {
        return nullptr;
    }

    if (events->friend_message_size == events->friend_message_capacity) {
        const uint32_t new_friend_message_capacity = events->friend_message_capacity * 2 + 1;
        Tox_Event_Friend_Message *new_friend_message = (Tox_Event_Friend_Message *)realloc(
                    events->friend_message, new_friend_message_capacity * sizeof(Tox_Event_Friend_Message));

        if (new_friend_message == nullptr) {
            return nullptr;
        }

        events->friend_message = new_friend_message;
        events->friend_message_capacity = new_friend_message_capacity;
    }

    Tox_Event_Friend_Message *const friend_message = &events->friend_message[events->friend_message_size];
    tox_event_friend_message_construct(friend_message);
    ++events->friend_message_size;
    return friend_message;
}

void tox_events_clear_friend_message(Tox_Events *events)
{
    if (events == nullptr) {
        return;
    }

    for (uint32_t i = 0; i < events->friend_message_size; ++i) {
        tox_event_friend_message_destruct(&events->friend_message[i]);
    }

    free(events->friend_message);
    events->friend_message = nullptr;
    events->friend_message_size = 0;
    events->friend_message_capacity = 0;
}

uint32_t tox_events_get_friend_message_size(const Tox_Events *events)
{
    if (events == nullptr) {
        return 0;
    }

    return events->friend_message_size;
}

const Tox_Event_Friend_Message *tox_events_get_friend_message(const Tox_Events *events, uint32_t index)
{
    assert(index < events->friend_message_size);
    assert(events->friend_message != nullptr);
    return &events->friend_message[index];
}

bool tox_events_pack_friend_message(const Tox_Events *events, Bin_Pack *bp)
{
    const uint32_t size = tox_events_get_friend_message_size(events);

    for (uint32_t i = 0; i < size; ++i) {
        if (!tox_event_friend_message_pack(tox_events_get_friend_message(events, i), bp)) {
            return false;
        }
    }
    return true;
}

bool tox_events_unpack_friend_message(Tox_Events *events, Bin_Unpack *bu)
{
    Tox_Event_Friend_Message *event = tox_events_add_friend_message(events);

    if (event == nullptr) {
        return false;
    }

    return tox_event_friend_message_unpack(event, bu);
}


/*****************************************************
 *
 * :: event handler
 *
 *****************************************************/


void tox_events_handle_friend_message(Tox *tox, uint32_t friend_number, Tox_Message_Type type, const uint8_t *message,
                                      size_t length, void *user_data)
{
    Tox_Events_State *state = tox_events_alloc(user_data);
    assert(state != nullptr);

    if (state->events == nullptr) {
        return;
    }

    Tox_Event_Friend_Message *friend_message = tox_events_add_friend_message(state->events);

    if (friend_message == nullptr) {
        state->error = TOX_ERR_EVENTS_ITERATE_MALLOC;
        return;
    }

    tox_event_friend_message_set_friend_number(friend_message, friend_number);
    tox_event_friend_message_set_type(friend_message, type);
    tox_event_friend_message_set_message(friend_message, message, length);
}
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2022 The TokTok team.
 */


#include <assert.h>
#include <stdlib.h>
#include <string.h>



/*****************************************************
 *
 * :: struct and accessors
 *
 *****************************************************/


struct Tox_Event_Friend_Name {
    uint32_t friend_number;
    uint8_t *name;
    uint32_t name_length;
};

non_null()
static void tox_event_friend_name_construct(Tox_Event_Friend_Name *friend_name)
{
    *friend_name = (Tox_Event_Friend_Name) {
        0
    };
}
non_null()
static void tox_event_friend_name_destruct(Tox_Event_Friend_Name *friend_name)
{
    free(friend_name->name);
}

non_null()
static void tox_event_friend_name_set_friend_number(Tox_Event_Friend_Name *friend_name,
        uint32_t friend_number)
{
    assert(friend_name != nullptr);
    friend_name->friend_number = friend_number;
}
uint32_t tox_event_friend_name_get_friend_number(const Tox_Event_Friend_Name *friend_name)
{
    assert(friend_name != nullptr);
    return friend_name->friend_number;
}

non_null()
static bool tox_event_friend_name_set_name(Tox_Event_Friend_Name *friend_name, const uint8_t *name,
        uint32_t name_length)
{
    assert(friend_name != nullptr);

    if (friend_name->name != nullptr) {
        free(friend_name->name);
        friend_name->name = nullptr;
        friend_name->name_length = 0;
    }

    friend_name->name = (uint8_t *)malloc(name_length);

    if (friend_name->name == nullptr) {
        return false;
    }

    memcpy(friend_name->name, name, name_length);
    friend_name->name_length = name_length;
    return true;
}
uint32_t tox_event_friend_name_get_name_length(const Tox_Event_Friend_Name *friend_name)
{
    assert(friend_name != nullptr);
    return friend_name->name_length;
}
const uint8_t *tox_event_friend_name_get_name(const Tox_Event_Friend_Name *friend_name)
{
    assert(friend_name != nullptr);
    return friend_name->name;
}

non_null()
static bool tox_event_friend_name_pack(
    const Tox_Event_Friend_Name *event, Bin_Pack *bp)
{
    assert(event != nullptr);
    return bin_pack_array(bp, 2)
           && bin_pack_u32(bp, TOX_EVENT_FRIEND_NAME)
           && bin_pack_array(bp, 2)
           && bin_pack_u32(bp, event->friend_number)
           && bin_pack_bin(bp, event->name, event->name_length);
}

non_null()
static bool tox_event_friend_name_unpack(
    Tox_Event_Friend_Name *event, Bin_Unpack *bu)
{
    assert(event != nullptr);
    if (!bin_unpack_array_fixed(bu, 2)) {
        return false;
    }

    return bin_unpack_u32(bu, &event->friend_number)
           && bin_unpack_bin(bu, &event->name, &event->name_length);
}


/*****************************************************
 *
 * :: add/clear/get
 *
 *****************************************************/


non_null()
static Tox_Event_Friend_Name *tox_events_add_friend_name(Tox_Events *events)
{
    if (events->friend_name_size == UINT32_MAX) {
        return nullptr;
    }

    if (events->friend_name_size == events->friend_name_capacity) {
        const uint32_t new_friend_name_capacity = events->friend_name_capacity * 2 + 1;
        Tox_Event_Friend_Name *new_friend_name = (Tox_Event_Friend_Name *)realloc(
                    events->friend_name, new_friend_name_capacity * sizeof(Tox_Event_Friend_Name));

        if (new_friend_name == nullptr) {
            return nullptr;
        }

        events->friend_name = new_friend_name;
        events->friend_name_capacity = new_friend_name_capacity;
    }

    Tox_Event_Friend_Name *const friend_name = &events->friend_name[events->friend_name_size];
    tox_event_friend_name_construct(friend_name);
    ++events->friend_name_size;
    return friend_name;
}

void tox_events_clear_friend_name(Tox_Events *events)
{
    if (events == nullptr) {
        return;
    }

    for (uint32_t i = 0; i < events->friend_name_size; ++i) {
        tox_event_friend_name_destruct(&events->friend_name[i]);
    }

    free(events->friend_name);
    events->friend_name = nullptr;
    events->friend_name_size = 0;
    events->friend_name_capacity = 0;
}

uint32_t tox_events_get_friend_name_size(const Tox_Events *events)
{
    if (events == nullptr) {
        return 0;
    }

    return events->friend_name_size;
}

const Tox_Event_Friend_Name *tox_events_get_friend_name(const Tox_Events *events, uint32_t index)
{
    assert(index < events->friend_name_size);
    assert(events->friend_name != nullptr);
    return &events->friend_name[index];
}

bool tox_events_pack_friend_name(const Tox_Events *events, Bin_Pack *bp)
{
    const uint32_t size = tox_events_get_friend_name_size(events);

    for (uint32_t i = 0; i < size; ++i) {
        if (!tox_event_friend_name_pack(tox_events_get_friend_name(events, i), bp)) {
            return false;
        }
    }
    return true;
}

bool tox_events_unpack_friend_name(Tox_Events *events, Bin_Unpack *bu)
{
    Tox_Event_Friend_Name *event = tox_events_add_friend_name(events);

    if (event == nullptr) {
        return false;
    }

    return tox_event_friend_name_unpack(event, bu);
}


/*****************************************************
 *
 * :: event handler
 *
 *****************************************************/


void tox_events_handle_friend_name(Tox *tox, uint32_t friend_number, const uint8_t *name, size_t length,
                                   void *user_data)
{
    Tox_Events_State *state = tox_events_alloc(user_data);
    assert(state != nullptr);

    if (state->events == nullptr) {
        return;
    }

    Tox_Event_Friend_Name *friend_name = tox_events_add_friend_name(state->events);

    if (friend_name == nullptr) {
        state->error = TOX_ERR_EVENTS_ITERATE_MALLOC;
        return;
    }

    tox_event_friend_name_set_friend_number(friend_name, friend_number);
    tox_event_friend_name_set_name(friend_name, name, length);
}
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2022 The TokTok team.
 */


#include <assert.h>
#include <stdlib.h>
#include <string.h>



/*****************************************************
 *
 * :: struct and accessors
 *
 *****************************************************/


struct Tox_Event_Friend_Read_Receipt {
    uint32_t friend_number;
    uint32_t message_id;
};

non_null()
static void tox_event_friend_read_receipt_construct(Tox_Event_Friend_Read_Receipt *friend_read_receipt)
{
    *friend_read_receipt = (Tox_Event_Friend_Read_Receipt) {
        0
    };
}
non_null()
static void tox_event_friend_read_receipt_destruct(Tox_Event_Friend_Read_Receipt *friend_read_receipt)
{
    return;
}

non_null()
static void tox_event_friend_read_receipt_set_friend_number(Tox_Event_Friend_Read_Receipt *friend_read_receipt,
        uint32_t friend_number)
{
    assert(friend_read_receipt != nullptr);
    friend_read_receipt->friend_number = friend_number;
}
uint32_t tox_event_friend_read_receipt_get_friend_number(const Tox_Event_Friend_Read_Receipt *friend_read_receipt)
{
    assert(friend_read_receipt != nullptr);
    return friend_read_receipt->friend_number;
}

non_null()
static void tox_event_friend_read_receipt_set_message_id(Tox_Event_Friend_Read_Receipt *friend_read_receipt,
        uint32_t message_id)
{
    assert(friend_read_receipt != nullptr);
    friend_read_receipt->message_id = message_id;
}
uint32_t tox_event_friend_read_receipt_get_message_id(const Tox_Event_Friend_Read_Receipt *friend_read_receipt)
{
    assert(friend_read_receipt != nullptr);
    return friend_read_receipt->message_id;
}

non_null()
static bool tox_event_friend_read_receipt_pack(
    const Tox_Event_Friend_Read_Receipt *event, Bin_Pack *bp)
{
    assert(event != nullptr);
    return bin_pack_array(bp, 2)
           && bin_pack_u32(bp, TOX_EVENT_FRIEND_READ_RECEIPT)
           && bin_pack_array(bp, 2)
           && bin_pack_u32(bp, event->friend_number)
           && bin_pack_u32(bp, event->message_id);
}

non_null()
static bool tox_event_friend_read_receipt_unpack(
    Tox_Event_Friend_Read_Receipt *event, Bin_Unpack *bu)
{
    assert(event != nullptr);
    if (!bin_unpack_array_fixed(bu, 2)) {
        return false;
    }

    return bin_unpack_u32(bu, &event->friend_number)
           && bin_unpack_u32(bu, &event->message_id);
}


/*****************************************************
 *
 * :: add/clear/get
 *
 *****************************************************/


non_null()
static Tox_Event_Friend_Read_Receipt *tox_events_add_friend_read_receipt(Tox_Events *events)
{
    if (events->friend_read_receipt_size == UINT32_MAX) {
        return nullptr;
    }

    if (events->friend_read_receipt_size == events->friend_read_receipt_capacity) {
        const uint32_t new_friend_read_receipt_capacity = events->friend_read_receipt_capacity * 2 + 1;
        Tox_Event_Friend_Read_Receipt *new_friend_read_receipt = (Tox_Event_Friend_Read_Receipt *)realloc(
                    events->friend_read_receipt, new_friend_read_receipt_capacity * sizeof(Tox_Event_Friend_Read_Receipt));

        if (new_friend_read_receipt == nullptr) {
            return nullptr;
        }

        events->friend_read_receipt = new_friend_read_receipt;
        events->friend_read_receipt_capacity = new_friend_read_receipt_capacity;
    }

    Tox_Event_Friend_Read_Receipt *const friend_read_receipt =
        &events->friend_read_receipt[events->friend_read_receipt_size];
    tox_event_friend_read_receipt_construct(friend_read_receipt);
    ++events->friend_read_receipt_size;
    return friend_read_receipt;
}

void tox_events_clear_friend_read_receipt(Tox_Events *events)
{
    if (events == nullptr) {
        return;
    }

    for (uint32_t i = 0; i < events->friend_read_receipt_size; ++i) {
        tox_event_friend_read_receipt_destruct(&events->friend_read_receipt[i]);
    }

    free(events->friend_read_receipt);
    events->friend_read_receipt = nullptr;
    events->friend_read_receipt_size = 0;
    events->friend_read_receipt_capacity = 0;
}

uint32_t tox_events_get_friend_read_receipt_size(const Tox_Events *events)
{
    if (events == nullptr) {
        return 0;
    }

    return events->friend_read_receipt_size;
}

const Tox_Event_Friend_Read_Receipt *tox_events_get_friend_read_receipt(const Tox_Events *events, uint32_t index)
{
    assert(index < events->friend_read_receipt_size);
    assert(events->friend_read_receipt != nullptr);
    return &events->friend_read_receipt[index];
}

bool tox_events_pack_friend_read_receipt(const Tox_Events *events, Bin_Pack *bp)
{
    const uint32_t size = tox_events_get_friend_read_receipt_size(events);

    for (uint32_t i = 0; i < size; ++i) {
        if (!tox_event_friend_read_receipt_pack(tox_events_get_friend_read_receipt(events, i), bp)) {
            return false;
        }
    }
    return true;
}

bool tox_events_unpack_friend_read_receipt(Tox_Events *events, Bin_Unpack *bu)
{
    Tox_Event_Friend_Read_Receipt *event = tox_events_add_friend_read_receipt(events);

    if (event == nullptr) {
        return false;
    }

    return tox_event_friend_read_receipt_unpack(event, bu);
}


/*****************************************************
 *
 * :: event handler
 *
 *****************************************************/


void tox_events_handle_friend_read_receipt(Tox *tox, uint32_t friend_number, uint32_t message_id, void *user_data)
{
    Tox_Events_State *state = tox_events_alloc(user_data);
    assert(state != nullptr);

    if (state->events == nullptr) {
        return;
    }

    Tox_Event_Friend_Read_Receipt *friend_read_receipt = tox_events_add_friend_read_receipt(state->events);

    if (friend_read_receipt == nullptr) {
        state->error = TOX_ERR_EVENTS_ITERATE_MALLOC;
        return;
    }

    tox_event_friend_read_receipt_set_friend_number(friend_read_receipt, friend_number);
    tox_event_friend_read_receipt_set_message_id(friend_read_receipt, message_id);
}
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2022 The TokTok team.
 */


#include <assert.h>
#include <stdlib.h>
#include <string.h>



/*****************************************************
 *
 * :: struct and accessors
 *
 *****************************************************/


struct Tox_Event_Friend_Request {
    uint8_t public_key[TOX_PUBLIC_KEY_SIZE];
    uint8_t *message;
    uint32_t message_length;
};

non_null()
static void tox_event_friend_request_construct(Tox_Event_Friend_Request *friend_request)
{
    *friend_request = (Tox_Event_Friend_Request) {
        0
    };
}
non_null()
static void tox_event_friend_request_destruct(Tox_Event_Friend_Request *friend_request)
{
    free(friend_request->message);
}

non_null()
static bool tox_event_friend_request_set_public_key(Tox_Event_Friend_Request *friend_request, const uint8_t *public_key)
{
    assert(friend_request != nullptr);

    memcpy(friend_request->public_key, public_key, TOX_PUBLIC_KEY_SIZE);
    return true;
}
const uint8_t *tox_event_friend_request_get_public_key(const Tox_Event_Friend_Request *friend_request)
{
    assert(friend_request != nullptr);
    return friend_request->public_key;
}

non_null()
static bool tox_event_friend_request_set_message(Tox_Event_Friend_Request *friend_request, const uint8_t *message,
        uint32_t message_length)
{
    assert(friend_request != nullptr);

    if (friend_request->message != nullptr) {
        free(friend_request->message);
        friend_request->message = nullptr;
        friend_request->message_length = 0;
    }

    friend_request->message = (uint8_t *)malloc(message_length);

    if (friend_request->message == nullptr) {
        return false;
    }

    memcpy(friend_request->message, message, message_length);
    friend_request->message_length = message_length;
    return true;
}
uint32_t tox_event_friend_request_get_message_length(const Tox_Event_Friend_Request *friend_request)
{
    assert(friend_request != nullptr);
    return friend_request->message_length;
}
const uint8_t *tox_event_friend_request_get_message(const Tox_Event_Friend_Request *friend_request)
{
    assert(friend_request != nullptr);
    return friend_request->message;
}

non_null()
static bool tox_event_friend_request_pack(
    const Tox_Event_Friend_Request *event, Bin_Pack *bp)
{
    assert(event != nullptr);
    return bin_pack_array(bp, 2)
           && bin_pack_u32(bp, TOX_EVENT_FRIEND_REQUEST)
           && bin_pack_array(bp, 2)
           && bin_pack_bin(bp, event->public_key, TOX_PUBLIC_KEY_SIZE)
           && bin_pack_bin(bp, event->message, event->message_length);
}

non_null()
static bool tox_event_friend_request_unpack(
    Tox_Event_Friend_Request *event, Bin_Unpack *bu)
{
    assert(event != nullptr);
    if (!bin_unpack_array_fixed(bu, 2)) {
        return false;
    }

    return bin_unpack_bin_fixed(bu, event->public_key, TOX_PUBLIC_KEY_SIZE)
           && bin_unpack_bin(bu, &event->message, &event->message_length);
}


/*****************************************************
 *
 * :: add/clear/get
 *
 *****************************************************/


non_null()
static Tox_Event_Friend_Request *tox_events_add_friend_request(Tox_Events *events)
{
    if (events->friend_request_size == UINT32_MAX) {
        return nullptr;
    }

    if (events->friend_request_size == events->friend_request_capacity) {
        const uint32_t new_friend_request_capacity = events->friend_request_capacity * 2 + 1;
        Tox_Event_Friend_Request *new_friend_request = (Tox_Event_Friend_Request *)realloc(
                    events->friend_request, new_friend_request_capacity * sizeof(Tox_Event_Friend_Request));

        if (new_friend_request == nullptr) {
            return nullptr;
        }

        events->friend_request = new_friend_request;
        events->friend_request_capacity = new_friend_request_capacity;
    }

    Tox_Event_Friend_Request *const friend_request = &events->friend_request[events->friend_request_size];
    tox_event_friend_request_construct(friend_request);
    ++events->friend_request_size;
    return friend_request;
}

void tox_events_clear_friend_request(Tox_Events *events)
{
    if (events == nullptr) {
        return;
    }

    for (uint32_t i = 0; i < events->friend_request_size; ++i) {
        tox_event_friend_request_destruct(&events->friend_request[i]);
    }

    free(events->friend_request);
    events->friend_request = nullptr;
    events->friend_request_size = 0;
    events->friend_request_capacity = 0;
}

uint32_t tox_events_get_friend_request_size(const Tox_Events *events)
{
    if (events == nullptr) {
        return 0;
    }

    return events->friend_request_size;
}

const Tox_Event_Friend_Request *tox_events_get_friend_request(const Tox_Events *events, uint32_t index)
{
    assert(index < events->friend_request_size);
    assert(events->friend_request != nullptr);
    return &events->friend_request[index];
}

bool tox_events_pack_friend_request(const Tox_Events *events, Bin_Pack *bp)
{
    const uint32_t size = tox_events_get_friend_request_size(events);

    for (uint32_t i = 0; i < size; ++i) {
        if (!tox_event_friend_request_pack(tox_events_get_friend_request(events, i), bp)) {
            return false;
        }
    }
    return true;
}

bool tox_events_unpack_friend_request(Tox_Events *events, Bin_Unpack *bu)
{
    Tox_Event_Friend_Request *event = tox_events_add_friend_request(events);

    if (event == nullptr) {
        return false;
    }

    return tox_event_friend_request_unpack(event, bu);
}


/*****************************************************
 *
 * :: event handler
 *
 *****************************************************/


void tox_events_handle_friend_request(Tox *tox, const uint8_t *public_key, const uint8_t *message, size_t length,
                                      void *user_data)
{
    Tox_Events_State *state = tox_events_alloc(user_data);
    assert(state != nullptr);

    if (state->events == nullptr) {
        return;
    }

    Tox_Event_Friend_Request *friend_request = tox_events_add_friend_request(state->events);

    if (friend_request == nullptr) {
        state->error = TOX_ERR_EVENTS_ITERATE_MALLOC;
        return;
    }

    tox_event_friend_request_set_public_key(friend_request, public_key);
    tox_event_friend_request_set_message(friend_request, message, length);
}
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2022 The TokTok team.
 */


#include <assert.h>
#include <stdlib.h>
#include <string.h>



/*****************************************************
 *
 * :: struct and accessors
 *
 *****************************************************/


struct Tox_Event_Friend_Status {
    uint32_t friend_number;
    Tox_User_Status status;
};

non_null()
static void tox_event_friend_status_construct(Tox_Event_Friend_Status *friend_status)
{
    *friend_status = (Tox_Event_Friend_Status) {
        0
    };
}
non_null()
static void tox_event_friend_status_destruct(Tox_Event_Friend_Status *friend_status)
{
    return;
}

non_null()
static void tox_event_friend_status_set_friend_number(Tox_Event_Friend_Status *friend_status,
        uint32_t friend_number)
{
    assert(friend_status != nullptr);
    friend_status->friend_number = friend_number;
}
uint32_t tox_event_friend_status_get_friend_number(const Tox_Event_Friend_Status *friend_status)
{
    assert(friend_status != nullptr);
    return friend_status->friend_number;
}

non_null()
static void tox_event_friend_status_set_status(Tox_Event_Friend_Status *friend_status,
        Tox_User_Status status)
{
    assert(friend_status != nullptr);
    friend_status->status = status;
}
Tox_User_Status tox_event_friend_status_get_status(const Tox_Event_Friend_Status *friend_status)
{
    assert(friend_status != nullptr);
    return friend_status->status;
}

non_null()
static bool tox_event_friend_status_pack(
    const Tox_Event_Friend_Status *event, Bin_Pack *bp)
{
    assert(event != nullptr);
    return bin_pack_array(bp, 2)
           && bin_pack_u32(bp, TOX_EVENT_FRIEND_STATUS)
           && bin_pack_array(bp, 2)
           && bin_pack_u32(bp, event->friend_number)
           && bin_pack_u32(bp, event->status);
}

non_null()
static bool tox_event_friend_status_unpack(
    Tox_Event_Friend_Status *event, Bin_Unpack *bu)
{
    assert(event != nullptr);
    if (!bin_unpack_array_fixed(bu, 2)) {
        return false;
    }

    return bin_unpack_u32(bu, &event->friend_number)
           && tox_unpack_user_status(bu, &event->status);
}


/*****************************************************
 *
 * :: add/clear/get
 *
 *****************************************************/


non_null()
static Tox_Event_Friend_Status *tox_events_add_friend_status(Tox_Events *events)
{
    if (events->friend_status_size == UINT32_MAX) {
        return nullptr;
    }

    if (events->friend_status_size == events->friend_status_capacity) {
        const uint32_t new_friend_status_capacity = events->friend_status_capacity * 2 + 1;
        Tox_Event_Friend_Status *new_friend_status = (Tox_Event_Friend_Status *)realloc(
                    events->friend_status, new_friend_status_capacity * sizeof(Tox_Event_Friend_Status));

        if (new_friend_status == nullptr) {
            return nullptr;
        }

        events->friend_status = new_friend_status;
        events->friend_status_capacity = new_friend_status_capacity;
    }

    Tox_Event_Friend_Status *const friend_status = &events->friend_status[events->friend_status_size];
    tox_event_friend_status_construct(friend_status);
    ++events->friend_status_size;
    return friend_status;
}

void tox_events_clear_friend_status(Tox_Events *events)
{
    if (events == nullptr) {
        return;
    }

    for (uint32_t i = 0; i < events->friend_status_size; ++i) {
        tox_event_friend_status_destruct(&events->friend_status[i]);
    }

    free(events->friend_status);
    events->friend_status = nullptr;
    events->friend_status_size = 0;
    events->friend_status_capacity = 0;
}

uint32_t tox_events_get_friend_status_size(const Tox_Events *events)
{
    if (events == nullptr) {
        return 0;
    }

    return events->friend_status_size;
}

const Tox_Event_Friend_Status *tox_events_get_friend_status(const Tox_Events *events, uint32_t index)
{
    assert(index < events->friend_status_size);
    assert(events->friend_status != nullptr);
    return &events->friend_status[index];
}

bool tox_events_pack_friend_status(const Tox_Events *events, Bin_Pack *bp)
{
    const uint32_t size = tox_events_get_friend_status_size(events);

    for (uint32_t i = 0; i < size; ++i) {
        if (!tox_event_friend_status_pack(tox_events_get_friend_status(events, i), bp)) {
            return false;
        }
    }
    return true;
}

bool tox_events_unpack_friend_status(Tox_Events *events, Bin_Unpack *bu)
{
    Tox_Event_Friend_Status *event = tox_events_add_friend_status(events);

    if (event == nullptr) {
        return false;
    }

    return tox_event_friend_status_unpack(event, bu);
}


/*****************************************************
 *
 * :: event handler
 *
 *****************************************************/


void tox_events_handle_friend_status(Tox *tox, uint32_t friend_number, Tox_User_Status status,
                                     void *user_data)
{
    Tox_Events_State *state = tox_events_alloc(user_data);
    assert(state != nullptr);

    if (state->events == nullptr) {
        return;
    }

    Tox_Event_Friend_Status *friend_status = tox_events_add_friend_status(state->events);

    if (friend_status == nullptr) {
        state->error = TOX_ERR_EVENTS_ITERATE_MALLOC;
        return;
    }

    tox_event_friend_status_set_friend_number(friend_status, friend_number);
    tox_event_friend_status_set_status(friend_status, status);
}
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2022 The TokTok team.
 */


#include <assert.h>
#include <stdlib.h>
#include <string.h>



/*****************************************************
 *
 * :: struct and accessors
 *
 *****************************************************/


struct Tox_Event_Friend_Status_Message {
    uint32_t friend_number;
    uint8_t *message;
    uint32_t message_length;
};

non_null()
static void tox_event_friend_status_message_construct(Tox_Event_Friend_Status_Message *friend_status_message)
{
    *friend_status_message = (Tox_Event_Friend_Status_Message) {
        0
    };
}
non_null()
static void tox_event_friend_status_message_destruct(Tox_Event_Friend_Status_Message *friend_status_message)
{
    free(friend_status_message->message);
}

non_null()
static void tox_event_friend_status_message_set_friend_number(Tox_Event_Friend_Status_Message *friend_status_message,
        uint32_t friend_number)
{
    assert(friend_status_message != nullptr);
    friend_status_message->friend_number = friend_number;
}
uint32_t tox_event_friend_status_message_get_friend_number(const Tox_Event_Friend_Status_Message *friend_status_message)
{
    assert(friend_status_message != nullptr);
    return friend_status_message->friend_number;
}

non_null()
static bool tox_event_friend_status_message_set_message(Tox_Event_Friend_Status_Message *friend_status_message,
        const uint8_t *message, uint32_t message_length)
{
    assert(friend_status_message != nullptr);

    if (friend_status_message->message != nullptr) {
        free(friend_status_message->message);
        friend_status_message->message = nullptr;
        friend_status_message->message_length = 0;
    }

    friend_status_message->message = (uint8_t *)malloc(message_length);

    if (friend_status_message->message == nullptr) {
        return false;
    }

    memcpy(friend_status_message->message, message, message_length);
    friend_status_message->message_length = message_length;
    return true;
}
uint32_t tox_event_friend_status_message_get_message_length(const Tox_Event_Friend_Status_Message
        *friend_status_message)
{
    assert(friend_status_message != nullptr);
    return friend_status_message->message_length;
}
const uint8_t *tox_event_friend_status_message_get_message(const Tox_Event_Friend_Status_Message
        *friend_status_message)
{
    assert(friend_status_message != nullptr);
    return friend_status_message->message;
}

non_null()
static bool tox_event_friend_status_message_pack(
    const Tox_Event_Friend_Status_Message *event, Bin_Pack *bp)
{
    assert(event != nullptr);
    return bin_pack_array(bp, 2)
           && bin_pack_u32(bp, TOX_EVENT_FRIEND_STATUS_MESSAGE)
           && bin_pack_array(bp, 2)
           && bin_pack_u32(bp, event->friend_number)
           && bin_pack_bin(bp, event->message, event->message_length);
}

non_null()
static bool tox_event_friend_status_message_unpack(
    Tox_Event_Friend_Status_Message *event, Bin_Unpack *bu)
{
    assert(event != nullptr);
    if (!bin_unpack_array_fixed(bu, 2)) {
        return false;
    }

    return bin_unpack_u32(bu, &event->friend_number)
           && bin_unpack_bin(bu, &event->message, &event->message_length);
}


/*****************************************************
 *
 * :: add/clear/get
 *
 *****************************************************/


non_null()
static Tox_Event_Friend_Status_Message *tox_events_add_friend_status_message(Tox_Events *events)
{
    if (events->friend_status_message_size == UINT32_MAX) {
        return nullptr;
    }

    if (events->friend_status_message_size == events->friend_status_message_capacity) {
        const uint32_t new_friend_status_message_capacity = events->friend_status_message_capacity * 2 + 1;
        Tox_Event_Friend_Status_Message *new_friend_status_message = (Tox_Event_Friend_Status_Message *)realloc(
                    events->friend_status_message, new_friend_status_message_capacity * sizeof(Tox_Event_Friend_Status_Message));

        if (new_friend_status_message == nullptr) {
            return nullptr;
        }

        events->friend_status_message = new_friend_status_message;
        events->friend_status_message_capacity = new_friend_status_message_capacity;
    }

    Tox_Event_Friend_Status_Message *const friend_status_message =
        &events->friend_status_message[events->friend_status_message_size];
    tox_event_friend_status_message_construct(friend_status_message);
    ++events->friend_status_message_size;
    return friend_status_message;
}

void tox_events_clear_friend_status_message(Tox_Events *events)
{
    if (events == nullptr) {
        return;
    }

    for (uint32_t i = 0; i < events->friend_status_message_size; ++i) {
        tox_event_friend_status_message_destruct(&events->friend_status_message[i]);
    }

    free(events->friend_status_message);
    events->friend_status_message = nullptr;
    events->friend_status_message_size = 0;
    events->friend_status_message_capacity = 0;
}

uint32_t tox_events_get_friend_status_message_size(const Tox_Events *events)
{
    if (events == nullptr) {
        return 0;
    }

    return events->friend_status_message_size;
}

const Tox_Event_Friend_Status_Message *tox_events_get_friend_status_message(const Tox_Events *events, uint32_t index)
{
    assert(index < events->friend_status_message_size);
    assert(events->friend_status_message != nullptr);
    return &events->friend_status_message[index];
}

bool tox_events_pack_friend_status_message(const Tox_Events *events, Bin_Pack *bp)
{
    const uint32_t size = tox_events_get_friend_status_message_size(events);

    for (uint32_t i = 0; i < size; ++i) {
        if (!tox_event_friend_status_message_pack(tox_events_get_friend_status_message(events, i), bp)) {
            return false;
        }
    }
    return true;
}

bool tox_events_unpack_friend_status_message(Tox_Events *events, Bin_Unpack *bu)
{
    Tox_Event_Friend_Status_Message *event = tox_events_add_friend_status_message(events);

    if (event == nullptr) {
        return false;
    }

    return tox_event_friend_status_message_unpack(event, bu);
}


/*****************************************************
 *
 * :: event handler
 *
 *****************************************************/


void tox_events_handle_friend_status_message(Tox *tox, uint32_t friend_number, const uint8_t *message,
        size_t length, void *user_data)
{
    Tox_Events_State *state = tox_events_alloc(user_data);
    assert(state != nullptr);

    if (state->events == nullptr) {
        return;
    }

    Tox_Event_Friend_Status_Message *friend_status_message = tox_events_add_friend_status_message(state->events);

    if (friend_status_message == nullptr) {
        state->error = TOX_ERR_EVENTS_ITERATE_MALLOC;
        return;
    }

    tox_event_friend_status_message_set_friend_number(friend_status_message, friend_number);
    tox_event_friend_status_message_set_message(friend_status_message, message, length);
}
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2022 The TokTok team.
 */


#include <assert.h>
#include <stdlib.h>
#include <string.h>



/*****************************************************
 *
 * :: struct and accessors
 *
 *****************************************************/


struct Tox_Event_Friend_Typing {
    uint32_t friend_number;
    bool typing;
};

non_null()
static void tox_event_friend_typing_construct(Tox_Event_Friend_Typing *friend_typing)
{
    *friend_typing = (Tox_Event_Friend_Typing) {
        0
    };
}
non_null()
static void tox_event_friend_typing_destruct(Tox_Event_Friend_Typing *friend_typing)
{
    return;
}

non_null()
static void tox_event_friend_typing_set_friend_number(Tox_Event_Friend_Typing *friend_typing,
        uint32_t friend_number)
{
    assert(friend_typing != nullptr);
    friend_typing->friend_number = friend_number;
}
uint32_t tox_event_friend_typing_get_friend_number(const Tox_Event_Friend_Typing *friend_typing)
{
    assert(friend_typing != nullptr);
    return friend_typing->friend_number;
}

non_null()
static void tox_event_friend_typing_set_typing(Tox_Event_Friend_Typing *friend_typing, bool typing)
{
    assert(friend_typing != nullptr);
    friend_typing->typing = typing;
}
bool tox_event_friend_typing_get_typing(const Tox_Event_Friend_Typing *friend_typing)
{
    assert(friend_typing != nullptr);
    return friend_typing->typing;
}

non_null()
static bool tox_event_friend_typing_pack(
    const Tox_Event_Friend_Typing *event, Bin_Pack *bp)
{
    assert(event != nullptr);
    return bin_pack_array(bp, 2)
           && bin_pack_u32(bp, TOX_EVENT_FRIEND_TYPING)
           && bin_pack_array(bp, 2)
           && bin_pack_u32(bp, event->friend_number)
           && bin_pack_bool(bp, event->typing);
}

non_null()
static bool tox_event_friend_typing_unpack(
    Tox_Event_Friend_Typing *event, Bin_Unpack *bu)
{
    assert(event != nullptr);
    if (!bin_unpack_array_fixed(bu, 2)) {
        return false;
    }

    return bin_unpack_u32(bu, &event->friend_number)
           && bin_unpack_bool(bu, &event->typing);
}


/*****************************************************
 *
 * :: add/clear/get
 *
 *****************************************************/


non_null()
static Tox_Event_Friend_Typing *tox_events_add_friend_typing(Tox_Events *events)
{
    if (events->friend_typing_size == UINT32_MAX) {
        return nullptr;
    }

    if (events->friend_typing_size == events->friend_typing_capacity) {
        const uint32_t new_friend_typing_capacity = events->friend_typing_capacity * 2 + 1;
        Tox_Event_Friend_Typing *new_friend_typing = (Tox_Event_Friend_Typing *)realloc(
                    events->friend_typing, new_friend_typing_capacity * sizeof(Tox_Event_Friend_Typing));

        if (new_friend_typing == nullptr) {
            return nullptr;
        }

        events->friend_typing = new_friend_typing;
        events->friend_typing_capacity = new_friend_typing_capacity;
    }

    Tox_Event_Friend_Typing *const friend_typing = &events->friend_typing[events->friend_typing_size];
    tox_event_friend_typing_construct(friend_typing);
    ++events->friend_typing_size;
    return friend_typing;
}

void tox_events_clear_friend_typing(Tox_Events *events)
{
    if (events == nullptr) {
        return;
    }

    for (uint32_t i = 0; i < events->friend_typing_size; ++i) {
        tox_event_friend_typing_destruct(&events->friend_typing[i]);
    }

    free(events->friend_typing);
    events->friend_typing = nullptr;
    events->friend_typing_size = 0;
    events->friend_typing_capacity = 0;
}

uint32_t tox_events_get_friend_typing_size(const Tox_Events *events)
{
    if (events == nullptr) {
        return 0;
    }

    return events->friend_typing_size;
}

const Tox_Event_Friend_Typing *tox_events_get_friend_typing(const Tox_Events *events, uint32_t index)
{
    assert(index < events->friend_typing_size);
    assert(events->friend_typing != nullptr);
    return &events->friend_typing[index];
}

bool tox_events_pack_friend_typing(const Tox_Events *events, Bin_Pack *bp)
{
    const uint32_t size = tox_events_get_friend_typing_size(events);

    for (uint32_t i = 0; i < size; ++i) {
        if (!tox_event_friend_typing_pack(tox_events_get_friend_typing(events, i), bp)) {
            return false;
        }
    }
    return true;
}

bool tox_events_unpack_friend_typing(Tox_Events *events, Bin_Unpack *bu)
{
    Tox_Event_Friend_Typing *event = tox_events_add_friend_typing(events);

    if (event == nullptr) {
        return false;
    }

    return tox_event_friend_typing_unpack(event, bu);
}


/*****************************************************
 *
 * :: event handler
 *
 *****************************************************/


void tox_events_handle_friend_typing(Tox *tox, uint32_t friend_number, bool typing, void *user_data)
{
    Tox_Events_State *state = tox_events_alloc(user_data);
    assert(state != nullptr);

    if (state->events == nullptr) {
        return;
    }

    Tox_Event_Friend_Typing *friend_typing = tox_events_add_friend_typing(state->events);

    if (friend_typing == nullptr) {
        state->error = TOX_ERR_EVENTS_ITERATE_MALLOC;
        return;
    }

    tox_event_friend_typing_set_friend_number(friend_typing, friend_number);
    tox_event_friend_typing_set_typing(friend_typing, typing);
}
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2022 The TokTok team.
 */


#include <assert.h>
#include <stdlib.h>
#include <string.h>



/*****************************************************
 *
 * :: struct and accessors
 *
 *****************************************************/


struct Tox_Event_Self_Connection_Status {
    Tox_Connection connection_status;
};

non_null()
static void tox_event_self_connection_status_construct(Tox_Event_Self_Connection_Status *self_connection_status)
{
    *self_connection_status = (Tox_Event_Self_Connection_Status) {
        TOX_CONNECTION_NONE
    };
}
non_null()
static void tox_event_self_connection_status_destruct(Tox_Event_Self_Connection_Status *self_connection_status)
{
    return;
}

non_null()
static void tox_event_self_connection_status_set_connection_status(Tox_Event_Self_Connection_Status
        *self_connection_status, Tox_Connection connection_status)
{
    assert(self_connection_status != nullptr);
    self_connection_status->connection_status = connection_status;
}
Tox_Connection tox_event_self_connection_status_get_connection_status(const Tox_Event_Self_Connection_Status
        *self_connection_status)
{
    assert(self_connection_status != nullptr);
    return self_connection_status->connection_status;
}

non_null()
static bool tox_event_self_connection_status_pack(
    const Tox_Event_Self_Connection_Status *event, Bin_Pack *bp)
{
    assert(event != nullptr);
    return bin_pack_array(bp, 2)
           && bin_pack_u32(bp, TOX_EVENT_SELF_CONNECTION_STATUS)
           && bin_pack_u32(bp, event->connection_status);
}

non_null()
static bool tox_event_self_connection_status_unpack(
    Tox_Event_Self_Connection_Status *event, Bin_Unpack *bu)
{
    assert(event != nullptr);
    return tox_unpack_connection(bu, &event->connection_status);
}


/*****************************************************
 *
 * :: add/clear/get
 *
 *****************************************************/


non_null()
static Tox_Event_Self_Connection_Status *tox_events_add_self_connection_status(Tox_Events *events)
{
    if (events->self_connection_status_size == UINT32_MAX) {
        return nullptr;
    }

    if (events->self_connection_status_size == events->self_connection_status_capacity) {
        const uint32_t new_self_connection_status_capacity = events->self_connection_status_capacity * 2 + 1;
        Tox_Event_Self_Connection_Status *new_self_connection_status = (Tox_Event_Self_Connection_Status *)realloc(
                    events->self_connection_status, new_self_connection_status_capacity * sizeof(Tox_Event_Self_Connection_Status));

        if (new_self_connection_status == nullptr) {
            return nullptr;
        }

        events->self_connection_status = new_self_connection_status;
        events->self_connection_status_capacity = new_self_connection_status_capacity;
    }

    Tox_Event_Self_Connection_Status *const self_connection_status =
        &events->self_connection_status[events->self_connection_status_size];
    tox_event_self_connection_status_construct(self_connection_status);
    ++events->self_connection_status_size;
    return self_connection_status;
}

void tox_events_clear_self_connection_status(Tox_Events *events)
{
    if (events == nullptr) {
        return;
    }

    for (uint32_t i = 0; i < events->self_connection_status_size; ++i) {
        tox_event_self_connection_status_destruct(&events->self_connection_status[i]);
    }

    free(events->self_connection_status);
    events->self_connection_status = nullptr;
    events->self_connection_status_size = 0;
    events->self_connection_status_capacity = 0;
}

uint32_t tox_events_get_self_connection_status_size(const Tox_Events *events)
{
    if (events == nullptr) {
        return 0;
    }

    return events->self_connection_status_size;
}

const Tox_Event_Self_Connection_Status *tox_events_get_self_connection_status(const Tox_Events *events, uint32_t index)
{
    assert(index < events->self_connection_status_size);
    assert(events->self_connection_status != nullptr);
    return &events->self_connection_status[index];
}

bool tox_events_pack_self_connection_status(const Tox_Events *events, Bin_Pack *bp)
{
    const uint32_t size = tox_events_get_self_connection_status_size(events);

    for (uint32_t i = 0; i < size; ++i) {
        if (!tox_event_self_connection_status_pack(tox_events_get_self_connection_status(events, i), bp)) {
            return false;
        }
    }
    return true;
}

bool tox_events_unpack_self_connection_status(Tox_Events *events, Bin_Unpack *bu)
{
    Tox_Event_Self_Connection_Status *event = tox_events_add_self_connection_status(events);

    if (event == nullptr) {
        return false;
    }

    return tox_event_self_connection_status_unpack(event, bu);
}


/*****************************************************
 *
 * :: event handler
 *
 *****************************************************/


void tox_events_handle_self_connection_status(Tox *tox, Tox_Connection connection_status, void *user_data)
{
    Tox_Events_State *state = tox_events_alloc(user_data);
    assert(state != nullptr);

    if (state->events == nullptr) {
        return;
    }

    Tox_Event_Self_Connection_Status *self_connection_status = tox_events_add_self_connection_status(state->events);

    if (self_connection_status == nullptr) {
        state->error = TOX_ERR_EVENTS_ITERATE_MALLOC;
        return;
    }

    tox_event_self_connection_status_set_connection_status(self_connection_status, connection_status);
}
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2018 The TokTok team.
 * Copyright © 2013 Tox project.
 */

/**
 * Batch encryption functions.
 */

#include <sodium.h>

#include <stdlib.h>
#include <string.h>


static_assert(TOX_PASS_SALT_LENGTH == crypto_pwhash_scryptsalsa208sha256_SALTBYTES,
              "TOX_PASS_SALT_LENGTH is assumed to be equal to crypto_pwhash_scryptsalsa208sha256_SALTBYTES");
static_assert(TOX_PASS_KEY_LENGTH == CRYPTO_SHARED_KEY_SIZE,
              "TOX_PASS_KEY_LENGTH is assumed to be equal to CRYPTO_SHARED_KEY_SIZE");
static_assert(TOX_PASS_ENCRYPTION_EXTRA_LENGTH == (crypto_box_MACBYTES + crypto_box_NONCEBYTES +
              crypto_pwhash_scryptsalsa208sha256_SALTBYTES + TOX_ENC_SAVE_MAGIC_LENGTH),
              "TOX_PASS_ENCRYPTION_EXTRA_LENGTH is assumed to be equal to (crypto_box_MACBYTES + crypto_box_NONCEBYTES + crypto_pwhash_scryptsalsa208sha256_SALTBYTES + TOX_ENC_SAVE_MAGIC_LENGTH)");

#define SET_ERROR_PARAMETER(param, x) \
    do {                              \
        if (param != nullptr) {       \
            *param = x;               \
        }                             \
    } while (0)

uint32_t tox_pass_salt_length(void)
{
    return TOX_PASS_SALT_LENGTH;
}
uint32_t tox_pass_key_length(void)
{
    return TOX_PASS_KEY_LENGTH;
}
uint32_t tox_pass_encryption_extra_length(void)
{
    return TOX_PASS_ENCRYPTION_EXTRA_LENGTH;
}

struct Tox_Pass_Key {
    uint8_t salt[TOX_PASS_SALT_LENGTH];
    uint8_t key[TOX_PASS_KEY_LENGTH];
};

void tox_pass_key_free(Tox_Pass_Key *key)
{
    free(key);
}

/* Clients should consider alerting their users that, unlike plain data, if even one bit
 * becomes corrupted, the data will be entirely unrecoverable.
 * Ditto if they forget their password, there is no way to recover the data.
 */

/**
 * Retrieves the salt used to encrypt the given data.
 *
 * The retrieved salt can then be passed to tox_pass_key_derive_with_salt to
 * produce the same key as was previously used. Any data encrypted with this
 * module can be used as input.
 *
 * The cipher text must be at least TOX_PASS_ENCRYPTION_EXTRA_LENGTH bytes in length.
 * The salt must be TOX_PASS_SALT_LENGTH bytes in length.
 * If the passed byte arrays are smaller than required, the behaviour is
 * undefined.
 *
 * If the cipher text pointer or the salt is NULL, this function returns false.
 *
 * Success does not say anything about the validity of the data, only that
 * data of the appropriate size was copied.
 *
 * @return true on success.
 */
bool tox_get_salt(const uint8_t *ciphertext, uint8_t *salt, Tox_Err_Get_Salt *error)
{
    if (ciphertext == nullptr || salt == nullptr) {
        SET_ERROR_PARAMETER(error, TOX_ERR_GET_SALT_NULL);
        return false;
    }

    if (memcmp(ciphertext, TOX_ENC_SAVE_MAGIC_NUMBER, TOX_ENC_SAVE_MAGIC_LENGTH) != 0) {
        SET_ERROR_PARAMETER(error, TOX_ERR_GET_SALT_BAD_FORMAT);
        return false;
    }

    ciphertext += TOX_ENC_SAVE_MAGIC_LENGTH;
    memcpy(salt, ciphertext, crypto_pwhash_scryptsalsa208sha256_SALTBYTES);
    SET_ERROR_PARAMETER(error, TOX_ERR_GET_SALT_OK);
    return true;
}

/**
 * Generates a secret symmetric key from the given passphrase.
 *
 * Be sure to not compromise the key! Only keep it in memory, do not write
 * it to disk.
 *
 * Note that this function is not deterministic; to derive the same key from
 * a password, you also must know the random salt that was used. A
 * deterministic version of this function is `tox_pass_key_derive_with_salt`.
 *
 * @param passphrase The user-provided password. Can be empty.
 * @param passphrase_len The length of the password.
 *
 * @return new symmetric key on success, NULL on failure.
 */
Tox_Pass_Key *tox_pass_key_derive(const uint8_t *passphrase, size_t passphrase_len,
                                  Tox_Err_Key_Derivation *error)
{
    const Random *rng = system_random();

    if (rng == nullptr) {
        SET_ERROR_PARAMETER(error, TOX_ERR_KEY_DERIVATION_FAILED);
        return nullptr;
    }

    uint8_t salt[crypto_pwhash_scryptsalsa208sha256_SALTBYTES];
    random_bytes(rng, salt, sizeof(salt));
    return tox_pass_key_derive_with_salt(passphrase, passphrase_len, salt, error);
}

/**
 * Same as above, except use the given salt for deterministic key derivation.
 *
 * @param passphrase The user-provided password. Can be empty.
 * @param passphrase_len The length of the password.
 * @param salt An array of at least TOX_PASS_SALT_LENGTH bytes.
 *
 * @return new symmetric key on success, NULL on failure.
 */
Tox_Pass_Key *tox_pass_key_derive_with_salt(const uint8_t *passphrase, size_t passphrase_len,
        const uint8_t *salt, Tox_Err_Key_Derivation *error)
{
    if (salt == nullptr || (passphrase == nullptr && passphrase_len != 0)) {
        SET_ERROR_PARAMETER(error, TOX_ERR_KEY_DERIVATION_NULL);
        return nullptr;
    }

    uint8_t passkey[crypto_hash_sha256_BYTES];
    crypto_hash_sha256(passkey, passphrase, passphrase_len);

    uint8_t key[CRYPTO_SHARED_KEY_SIZE];

    // Derive a key from the password
    // http://doc.libsodium.org/key_derivation/README.html
    // note that, according to the documentation, a generic pwhash interface will be created
    // once the pwhash competition (https://password-hashing.net/) is over */
    if (crypto_pwhash_scryptsalsa208sha256(
                key, sizeof(key), (char *)passkey, sizeof(passkey), salt,
                crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_INTERACTIVE * 2, /* slightly stronger */
                crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_INTERACTIVE) != 0) {
        /* out of memory most likely */
        SET_ERROR_PARAMETER(error, TOX_ERR_KEY_DERIVATION_FAILED);
        return nullptr;
    }

    crypto_memzero(passkey, crypto_hash_sha256_BYTES); /* wipe plaintext pw */

    Tox_Pass_Key *out_key = (Tox_Pass_Key *)calloc(1, sizeof(Tox_Pass_Key));

    if (out_key == nullptr) {
        SET_ERROR_PARAMETER(error, TOX_ERR_KEY_DERIVATION_FAILED);
        return nullptr;
    }

    memcpy(out_key->salt, salt, crypto_pwhash_scryptsalsa208sha256_SALTBYTES);
    memcpy(out_key->key, key, CRYPTO_SHARED_KEY_SIZE);
    SET_ERROR_PARAMETER(error, TOX_ERR_KEY_DERIVATION_OK);
    return out_key;
}

/**
 * Encrypt a plain text with a key produced by tox_pass_key_derive or tox_pass_key_derive_with_salt.
 *
 * The output array must be at least `plaintext_len + TOX_PASS_ENCRYPTION_EXTRA_LENGTH`
 * bytes long.
 *
 * @param plaintext A byte array of length `plaintext_len`.
 * @param plaintext_len The length of the plain text array. Bigger than 0.
 * @param ciphertext The cipher text array to write the encrypted data to.
 *
 * @return true on success.
 */
bool tox_pass_key_encrypt(const Tox_Pass_Key *key, const uint8_t *plaintext, size_t plaintext_len,
                          uint8_t *ciphertext, Tox_Err_Encryption *error)
{
    const Random *rng = system_random();

    if (rng == nullptr) {
        SET_ERROR_PARAMETER(error, TOX_ERR_ENCRYPTION_FAILED);
        return false;
    }

    if (plaintext_len == 0 || plaintext == nullptr || key == nullptr || ciphertext == nullptr) {
        SET_ERROR_PARAMETER(error, TOX_ERR_ENCRYPTION_NULL);
        return false;
    }

    // the output data consists of, in order:
    // salt, nonce, mac, enc_data
    // where the mac is automatically prepended by the encrypt()
    // the salt+nonce is called the prefix
    // I'm not sure what else I'm supposed to do with the salt and nonce, since we
    // need them to decrypt the data

    /* first add the magic number */
    memcpy(ciphertext, TOX_ENC_SAVE_MAGIC_NUMBER, TOX_ENC_SAVE_MAGIC_LENGTH);
    ciphertext += TOX_ENC_SAVE_MAGIC_LENGTH;

    /* then add the rest prefix */
    memcpy(ciphertext, key->salt, crypto_pwhash_scryptsalsa208sha256_SALTBYTES);
    ciphertext += crypto_pwhash_scryptsalsa208sha256_SALTBYTES;

    uint8_t nonce[crypto_box_NONCEBYTES];
    random_nonce(rng, nonce);
    memcpy(ciphertext, nonce, crypto_box_NONCEBYTES);
    ciphertext += crypto_box_NONCEBYTES;

    /* now encrypt */
    if (encrypt_data_symmetric(key->key, nonce, plaintext, plaintext_len, ciphertext)
            != plaintext_len + crypto_box_MACBYTES) {
        SET_ERROR_PARAMETER(error, TOX_ERR_ENCRYPTION_FAILED);
        return false;
    }

    SET_ERROR_PARAMETER(error, TOX_ERR_ENCRYPTION_OK);
    return true;
}

/**
 * Encrypts the given data with the given passphrase.
 *
 * The output array must be at least `plaintext_len + TOX_PASS_ENCRYPTION_EXTRA_LENGTH`
 * bytes long. This delegates to tox_pass_key_derive and
 * tox_pass_key_encrypt.
 *
 * @param plaintext A byte array of length `plaintext_len`.
 * @param plaintext_len The length of the plain text array. Bigger than 0.
 * @param passphrase The user-provided password. Can be empty.
 * @param passphrase_len The length of the password.
 * @param ciphertext The cipher text array to write the encrypted data to.
 *
 * @return true on success.
 */
bool tox_pass_encrypt(const uint8_t *plaintext, size_t plaintext_len, const uint8_t *passphrase, size_t passphrase_len,
                      uint8_t *ciphertext, Tox_Err_Encryption *error)
{
    Tox_Err_Key_Derivation err;
    Tox_Pass_Key *key = tox_pass_key_derive(passphrase, passphrase_len, &err);

    if (key == nullptr) {
        if (err == TOX_ERR_KEY_DERIVATION_NULL) {
            SET_ERROR_PARAMETER(error, TOX_ERR_ENCRYPTION_NULL);
        } else if (err == TOX_ERR_KEY_DERIVATION_FAILED) {
            SET_ERROR_PARAMETER(error, TOX_ERR_ENCRYPTION_KEY_DERIVATION_FAILED);
        }

        return false;
    }

    const bool result = tox_pass_key_encrypt(key, plaintext, plaintext_len, ciphertext, error);
    tox_pass_key_free(key);
    return result;
}

/**
 * This is the inverse of tox_pass_key_encrypt, also using only keys produced by
 * tox_pass_key_derive or tox_pass_key_derive_with_salt.
 *
 * @param ciphertext A byte array of length `ciphertext_len`.
 * @param ciphertext_len The length of the cipher text array. At least TOX_PASS_ENCRYPTION_EXTRA_LENGTH.
 * @param plaintext The plain text array to write the decrypted data to.
 *
 * @return true on success.
 */
bool tox_pass_key_decrypt(const Tox_Pass_Key *key, const uint8_t *ciphertext, size_t ciphertext_len,
                          uint8_t *plaintext, Tox_Err_Decryption *error)
{
    if (ciphertext_len <= TOX_PASS_ENCRYPTION_EXTRA_LENGTH) {
        SET_ERROR_PARAMETER(error, TOX_ERR_DECRYPTION_INVALID_LENGTH);
        return false;
    }

    if (ciphertext == nullptr || key == nullptr || plaintext == nullptr) {
        SET_ERROR_PARAMETER(error, TOX_ERR_DECRYPTION_NULL);
        return false;
    }

    if (memcmp(ciphertext, TOX_ENC_SAVE_MAGIC_NUMBER, TOX_ENC_SAVE_MAGIC_LENGTH) != 0) {
        SET_ERROR_PARAMETER(error, TOX_ERR_DECRYPTION_BAD_FORMAT);
        return false;
    }

    ciphertext += TOX_ENC_SAVE_MAGIC_LENGTH;
    ciphertext += crypto_pwhash_scryptsalsa208sha256_SALTBYTES; // salt only affects key derivation

    const size_t decrypt_length = ciphertext_len - TOX_PASS_ENCRYPTION_EXTRA_LENGTH;

    uint8_t nonce[crypto_box_NONCEBYTES];
    memcpy(nonce, ciphertext, crypto_box_NONCEBYTES);
    ciphertext += crypto_box_NONCEBYTES;

    /* decrypt the ciphertext */
    if (decrypt_data_symmetric(key->key, nonce, ciphertext, decrypt_length + crypto_box_MACBYTES, plaintext)
            != decrypt_length) {
        SET_ERROR_PARAMETER(error, TOX_ERR_DECRYPTION_FAILED);
        return false;
    }

    SET_ERROR_PARAMETER(error, TOX_ERR_DECRYPTION_OK);
    return true;
}

/**
 * Decrypts the given data with the given passphrase.
 *
 * The output array must be at least `ciphertext_len - TOX_PASS_ENCRYPTION_EXTRA_LENGTH`
 * bytes long. This delegates to tox_pass_key_decrypt.
 *
 * @param ciphertext A byte array of length `ciphertext_len`.
 * @param ciphertext_len The length of the cipher text array. At least TOX_PASS_ENCRYPTION_EXTRA_LENGTH.
 * @param passphrase The user-provided password. Can be empty.
 * @param passphrase_len The length of the password.
 * @param plaintext The plain text array to write the decrypted data to.
 *
 * @return true on success.
 */
bool tox_pass_decrypt(const uint8_t *ciphertext, size_t ciphertext_len, const uint8_t *passphrase,
                      size_t passphrase_len, uint8_t *plaintext, Tox_Err_Decryption *error)
{
    if (ciphertext_len <= TOX_PASS_ENCRYPTION_EXTRA_LENGTH) {
        SET_ERROR_PARAMETER(error, TOX_ERR_DECRYPTION_INVALID_LENGTH);
        return false;
    }

    if (ciphertext == nullptr || passphrase == nullptr || plaintext == nullptr) {
        SET_ERROR_PARAMETER(error, TOX_ERR_DECRYPTION_NULL);
        return false;
    }

    if (memcmp(ciphertext, TOX_ENC_SAVE_MAGIC_NUMBER, TOX_ENC_SAVE_MAGIC_LENGTH) != 0) {
        SET_ERROR_PARAMETER(error, TOX_ERR_DECRYPTION_BAD_FORMAT);
        return false;
    }

    uint8_t salt[crypto_pwhash_scryptsalsa208sha256_SALTBYTES];
    memcpy(salt, ciphertext + TOX_ENC_SAVE_MAGIC_LENGTH, crypto_pwhash_scryptsalsa208sha256_SALTBYTES);

    /* derive the key */
    Tox_Pass_Key *key = tox_pass_key_derive_with_salt(passphrase, passphrase_len, salt, nullptr);

    if (key == nullptr) {
        /* out of memory most likely */
        SET_ERROR_PARAMETER(error, TOX_ERR_DECRYPTION_KEY_DERIVATION_FAILED);
        return false;
    }

    const bool result = tox_pass_key_decrypt(key, ciphertext, ciphertext_len, plaintext, error);
    tox_pass_key_free(key);
    return result;
}

/**
 * Determines whether or not the given data is encrypted by this module.
 *
 * It does this check by verifying that the magic number is the one put in
 * place by the encryption functions.
 *
 * The data must be at least TOX_PASS_ENCRYPTION_EXTRA_LENGTH bytes in length.
 * If the passed byte array is smaller than required, the behaviour is
 * undefined.
 *
 * If the data pointer is NULL, the behaviour is undefined
 *
 * @return true if the data is encrypted by this module.
 */
bool tox_is_data_encrypted(const uint8_t *data)
{
    return memcmp(data, TOX_ENC_SAVE_MAGIC_NUMBER, TOX_ENC_SAVE_MAGIC_LENGTH) == 0;
}
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2018 The TokTok team.
 * Copyright © 2013-2015 Tox project.
 */
#ifdef HAVE_CONFIG_H
#endif /* HAVE_CONFIG_H */




extern bool global_do_not_sync_av;

static struct TSBuffer *jbuf_new(int size);
static void jbuf_free(struct TSBuffer *q);
static int jbuf_write(Logger *log, ACSession *ac, struct TSBuffer *q, struct RTPMessage *m);
static OpusEncoder *create_audio_encoder(const Logger *log, int32_t bit_rate, int32_t sampling_rate,
        int32_t channel_count);
static bool reconfigure_audio_encoder(const Logger *log, OpusEncoder **e, int32_t new_br, int32_t new_sr,
                                      uint8_t new_ch, int32_t *old_br, int32_t *old_sr, int32_t *old_ch);
static bool reconfigure_audio_decoder(ACSession *ac, int32_t sampling_rate, int8_t channels);



ACSession *ac_new(Mono_Time *mono_time, const Logger *log, ToxAV *av, Tox *tox, uint32_t friend_number,
                  toxav_audio_receive_frame_cb *cb, void *cb_data,
                  toxav_audio_receive_frame_pts_cb *cb_pts, void *cb_pts_data)
{
    ACSession *ac = (ACSession *)calloc(sizeof(ACSession), 1);

    if (!ac) {
        LOGGER_API_WARNING(tox, "Allocation failed! Application might misbehave!");
        return nullptr;
    }

    if (create_recursive_mutex(ac->queue_mutex) != 0) {
        LOGGER_API_WARNING(tox, "Failed to create recursive mutex!");
        free(ac);
        return nullptr;
    }

    int status;
    ac->decoder = opus_decoder_create(AUDIO_DECODER__START_SAMPLING_RATE, AUDIO_DECODER__START_CHANNEL_COUNT, &status);

    if (status != OPUS_OK) {
        LOGGER_API_ERROR(tox, "Error while starting audio decoder: %s", opus_strerror(status));
        goto BASE_CLEANUP;
    }

    if (!(ac->j_buf = jbuf_new(AUDIO_JITTERBUFFER_COUNT))) {
        LOGGER_API_WARNING(tox, "Jitter buffer creaton failed!");
        opus_decoder_destroy(ac->decoder);
        goto BASE_CLEANUP;
    }

    ac->mono_time = mono_time;

    /* Initialize encoders with default values */
    ac->encoder = create_audio_encoder(log, AUDIO_START_BITRATE_RATE, AUDIO_START_SAMPLING_RATE, AUDIO_START_CHANNEL_COUNT);

    if (ac->encoder == nullptr) {
        goto DECODER_CLEANUP;
    } else {
        LOGGER_API_INFO(tox, "audio encoder successfully created");
    }

    ac->le_bit_rate = AUDIO_START_BITRATE_RATE;
    ac->le_sample_rate = AUDIO_START_SAMPLING_RATE;
    ac->le_channel_count = AUDIO_START_CHANNEL_COUNT;

    ac->ld_channel_count = AUDIO_DECODER__START_SAMPLING_RATE;
    ac->ld_sample_rate = AUDIO_DECODER__START_CHANNEL_COUNT;
    ac->ldrts = 0; /* Make it possible to reconfigure straight away */

    ac->lp_seqnum_new = -1;

    ac->last_incoming_frame_ts = 0;
    ac->timestamp_difference_to_sender = 0; // no difference to sender as start value

    /* These need to be set in order to properly
     * do error correction with opus */
    ac->lp_frame_duration = AUDIO_MAX_FRAME_DURATION_MS;
    ac->lp_sampling_rate = AUDIO_DECODER__START_SAMPLING_RATE;
    ac->lp_channel_count = AUDIO_DECODER__START_CHANNEL_COUNT;

    ac->encoder_frame_has_record_timestamp = 1;
    ac->audio_received_first_frame = 0;

    ac->av = av;
    ac->tox = tox;
    ac->friend_number = friend_number;

    // set callback
    ac->acb = cb;
    ac->acb_user_data = cb_data;

    // set pts callback
    ac->acb_pts = cb_pts;
    ac->acb_pts_user_data = cb_pts_data;

    return ac;

DECODER_CLEANUP:
    opus_decoder_destroy(ac->decoder);

    jbuf_free((struct TSBuffer *)ac->j_buf);

BASE_CLEANUP:
    pthread_mutex_destroy(ac->queue_mutex);
    free(ac);
    return nullptr;
}

void ac_kill(ACSession *ac)
{
    if (!ac) {
        return;
    }

    opus_encoder_destroy(ac->encoder);
    opus_decoder_destroy(ac->decoder);

    jbuf_free((struct TSBuffer *)ac->j_buf);

    pthread_mutex_destroy(ac->queue_mutex);

    free(ac);
}

// static int global_last_aiterate_ts = 0;

static inline struct RTPMessage *jbuf_read(Logger *log, struct TSBuffer *q, int32_t *success,
        int64_t timestamp_difference_adjustment_for_audio2,
        int64_t timestamp_difference_to_sender_,
        uint8_t encoder_frame_has_record_timestamp,
        ACSession *ac,
        int video_send_cap,
        int32_t video_has_rountrip_time_ms)
{
#define AUDIO_CURRENT_TS_SPAN_MS 65

    void *ret = NULL;
    uint64_t lost_frame = 0;
    uint32_t timestamp_out_ = 0;


    /**
     * this is the magic value that gives the wanted timestamps:
     */
    int64_t want_remote_video_ts = (current_time_monotonic(ac->mono_time) +
                                    timestamp_difference_to_sender_ +
                                    timestamp_difference_adjustment_for_audio2);
    LOGGER_API_DEBUG(ac->tox, "want_remote_video_ts:a:002=%d, %d %d %d",
            (int)want_remote_video_ts,
            (int)current_time_monotonic(ac->mono_time),
            (int)timestamp_difference_to_sender_,
            (int)timestamp_difference_adjustment_for_audio2
            );
    /**
     *
     */

    *success = 0;
    uint16_t removed_entries;

    uint32_t tsb_range_ms = AUDIO_CURRENT_TS_SPAN_MS;

    // HINT: compensate for older clients ----------------
    //       or when only receiving audio (no incoming video)
    if ((encoder_frame_has_record_timestamp == 0) || (video_send_cap == 0)) {
        LOGGER_API_DEBUG(ac->tox, "old client:003");
        tsb_range_ms = UINT32_MAX;
        want_remote_video_ts = UINT32_MAX;
    }

    // HINT: compensate for older clients ----------------


#if 1

    uint32_t timestamp_min = 0;
    uint32_t timestamp_max = 0;
    tsb_get_range_in_buffer(ac->tox, q, &timestamp_min, &timestamp_max);

    if ((int)tsb_size(q) > 0) {
        LOGGER_API_DEBUG(ac->tox, "FC:%d min=%d max=%d want=%d diff=%d adj=%d",
                       (int)tsb_size(q),
                       timestamp_min,
                       timestamp_max,
                       (int)want_remote_video_ts,
                       (int)want_remote_video_ts - (int)timestamp_max,
                       (int)timestamp_difference_adjustment_for_audio2);
    }

#endif



    uint32_t tsb_range_ms_used = tsb_range_ms;
    uint32_t timestamp_want_get_used = want_remote_video_ts;

    if (
        (global_do_not_sync_av) ||
        (ac->audio_received_first_frame) == 0 ||
        (video_has_rountrip_time_ms == 0)
        )
    {
        LOGGER_API_DEBUG(ac->tox, "AA:%d %d", (int)ac->audio_received_first_frame, (int)video_has_rountrip_time_ms);
        tsb_range_ms_used = UINT32_MAX;
        timestamp_want_get_used = UINT32_MAX;
    }


    uint16_t is_skipping;
    bool res = tsb_read(q, &ret, &lost_frame,
                        &timestamp_out_,
                        timestamp_want_get_used,
                        tsb_range_ms_used,
                        &removed_entries,
                        &is_skipping);

    if (removed_entries > 0) {
        LOGGER_API_DEBUG(ac->tox, "removed entries=%d", (int)removed_entries);
    }

    if (res == true) {
        *success = 1;


        if (ac->audio_received_first_frame == 0) {
            ac->audio_received_first_frame = 1;
        }

        struct RTPMessage *m = (struct RTPMessage *)ret;
        LOGGER_API_DEBUG(ac->tox, "AudioFramesIN: header sequnum=%d", (int)m->header.sequnum);

        if (ac->lp_seqnum_new == -1) {
            ac->lp_seqnum_new = m->header.sequnum;
        } else {
            if (
                (
                    ((m->header.sequnum > 5) && (ac->lp_seqnum_new < (UINT16_MAX - 5)))
                ) &&
                (m->header.sequnum <= ac->lp_seqnum_new)
            ) {
                LOGGER_API_DEBUG(ac->tox, "AudioFramesIN: drop pkt num: %d", (int)m->header.sequnum);

                free(ret);
                ret = NULL;
            } else {

                LOGGER_API_DEBUG(ac->tox, "AudioFramesIN: using sequnum=%d", (int)m->header.sequnum);

                if (
                    ((m->header.sequnum > 8) && (ac->lp_seqnum_new < (UINT16_MAX - 7)))
                ) {
                    LOGGER_API_DEBUG(ac->tox, "AudioFramesIN:2: %d %d", (int)ac->lp_seqnum_new, (int)m->header.sequnum);
                    int64_t diff = (m->header.sequnum - ac->lp_seqnum_new);

                    if (diff > 1) {
                        LOGGER_API_DEBUG(ac->tox, "AudioFramesIN: missing %d audio frames sequnum missing=%d",
                                     (int)(diff - 1),
                                     (ac->lp_seqnum_new + 1));
                        lost_frame = 1;
                    }
                }

                ac->lp_seqnum_new = m->header.sequnum;
            }
        }
    }

    LOGGER_API_DEBUG(ac->tox, "jbuf_read:lost_frame=%d", (int)lost_frame);

    if (lost_frame == 1) {
        *success = AUDIO_LOST_FRAME_INDICATOR;
    }

    return (struct RTPMessage *)ret;
}

static inline bool jbuf_is_empty(struct TSBuffer *q)
{
    bool res = tsb_empty(q);
    return res;
}

uint8_t ac_iterate(ACSession *ac, uint64_t *a_r_timestamp, uint64_t *a_l_timestamp, uint64_t *v_r_timestamp,
                   uint64_t *v_l_timestamp,
                   int64_t *timestamp_difference_adjustment_for_audio,
                   int64_t *timestamp_difference_to_sender_,
                   int video_send_cap,
                   int32_t *video_has_rountrip_time_ms)
{
    if (!ac) {
        return 0;
    }

    uint8_t ret_value = 1;
    uint64_t header_pts_saved = 0;

    pthread_mutex_lock(ac->queue_mutex);

    struct TSBuffer *jbuffer = (struct TSBuffer *)ac->j_buf;

    if (jbuf_is_empty(jbuffer)) {
        pthread_mutex_unlock(ac->queue_mutex);
        return 0;
    }

    /* Enough space for the maximum frame size (120 ms 48 KHz stereo audio) */
    //int16_t temp_audio_buffer[AUDIO_MAX_BUFFER_SIZE_PCM16_FOR_FRAME_PER_CHANNEL *
    //                                                                            AUDIO_MAX_CHANNEL_COUNT];

    struct RTPMessage *msg = NULL;
    int rc = 0;


    while ((msg = jbuf_read(nullptr, jbuffer, &rc,
                            *timestamp_difference_adjustment_for_audio,
                            *timestamp_difference_to_sender_,
                            ac->encoder_frame_has_record_timestamp, ac,
                            video_send_cap,
                            *video_has_rountrip_time_ms))
            || rc == AUDIO_LOST_FRAME_INDICATOR) {
        pthread_mutex_unlock(ac->queue_mutex);

        LOGGER_API_DEBUG(ac->tox, "A:TSB:%d", (int)tsb_size(jbuffer));
        LOGGER_API_DEBUG(ac->tox, "TOXAV:A2V_DELAY:(pos==audio-before-video)%d", (int)(*a_r_timestamp - *v_r_timestamp));


        if (rc == AUDIO_LOST_FRAME_INDICATOR) {
            LOGGER_API_DEBUG(ac->tox, "OPUS correction for lost frame (3)");

            if (ac->lp_sampling_rate > 0) {
                int fs = (ac->lp_sampling_rate * ac->lp_frame_duration) / 1000;
                rc = opus_decode(ac->decoder, NULL, 0, ac->temp_audio_buffer, fs, 1);
            }

            free(msg);
            msg = NULL;
        } else {

            int use_fec = 0;
            /* TODO: check if we have the full data of this frame */

            /* Get values from packet and decode. */
            /* NOTE: This didn't work very well */

            /* Pick up sampling rate from packet */
            if (msg) {
                memcpy(&ac->lp_sampling_rate, msg->data, 4);
                ac->lp_sampling_rate = net_ntohl(ac->lp_sampling_rate);
                ac->lp_channel_count = opus_packet_get_nb_channels(msg->data + 4);
                /* TODO: msg->data + 4
                 * this should be defined, not hardcoded
                 */
            }


            /** NOTE: even though OPUS supports decoding mono frames with stereo decoder and vice versa,
              * it didn't work quite well.
              */
            if (!reconfigure_audio_decoder(ac, ac->lp_sampling_rate, ac->lp_channel_count)) {
                LOGGER_API_WARNING(ac->tox, "Failed to reconfigure decoder!");
                free(msg);
                msg = NULL;
                pthread_mutex_lock(ac->queue_mutex);
                continue;
            }

            /*
            frame_size = opus_decode(dec, packet, len, decoded, max_size, decode_fec);
              where
            packet is the byte array containing the compressed data
            len is the exact number of bytes contained in the packet
            decoded is the decoded audio data in opus_int16 (or float for opus_decode_float())
            max_size is the max duration of the frame in samples (per channel) that can fit
            into the decoded_frame array
            decode_fec: Flag (0 or 1) to request that any in-band forward error correction data be
            decoded. If no such data is available, the frame is decoded as if it were lost.
             */
            /* TODO: msg->data + 4, msg->len - 4
             * this should be defined, not hardcoded
             */

            rc = opus_decode(ac->decoder, msg->data + 4, msg->len - 4, ac->temp_audio_buffer, 5760, use_fec);

// -------- DEBUG:AUDIO/VIDEO DELAY/LATENCY --------
// -------- DEBUG:AUDIO/VIDEO DELAY/LATENCY --------
// -------- DEBUG:AUDIO/VIDEO DELAY/LATENCY --------
#if 1

            if (rc >= 0) {
                // what is the audio to video latency?
                const struct RTPHeader *header_v3 = (void *) & (msg->header);

                if (header_v3->frame_record_timestamp > 0) {
                    header_pts_saved = header_v3->frame_record_timestamp;
                    if (*a_r_timestamp < header_v3->frame_record_timestamp) {
                        *a_r_timestamp = header_v3->frame_record_timestamp;
                        *a_l_timestamp = current_time_monotonic(ac->mono_time);
                    } else {
                        // TODO: this should not happen here!
                        LOGGER_API_DEBUG(ac->tox, "AUDIO: remote timestamp older");
                    }
                }

                // what is the audio to video latency?
            }

#endif
// -------- DEBUG:AUDIO/VIDEO DELAY/LATENCY --------
// -------- DEBUG:AUDIO/VIDEO DELAY/LATENCY --------
// -------- DEBUG:AUDIO/VIDEO DELAY/LATENCY --------

            free(msg);
            msg = NULL;
        }

        if (rc < 0) {
            LOGGER_API_WARNING(ac->tox, "Decoding error: %s", opus_strerror(rc));
        } else {
            if (ac->acb_pts) {
                ac->lp_frame_duration = (rc * 1000) / ac->lp_sampling_rate;
                ac->acb_pts(ac->av, ac->friend_number, ac->temp_audio_buffer, rc, ac->lp_channel_count,
                        ac->lp_sampling_rate, ac->acb_pts_user_data, header_pts_saved);
                return ret_value;
            } else if (ac->acb) {
                ac->lp_frame_duration = (rc * 1000) / ac->lp_sampling_rate;
                ac->acb(ac->av, ac->friend_number, ac->temp_audio_buffer, rc, ac->lp_channel_count,
                        ac->lp_sampling_rate, ac->acb_user_data);
                return ret_value;
            }
        }

        return ret_value;
    }

    pthread_mutex_unlock(ac->queue_mutex);

    return ret_value;
}

int ac_queue_message(Mono_Time *mono_time, void *acp, struct RTPMessage *msg)
{
    if (!acp || !msg) {
        if (msg) {
            free(msg);
        }

        return -1;
    }

    ACSession *ac = (ACSession *)acp;

    if ((msg->header.pt & 0x7f) == (RTP_TYPE_AUDIO + 2) % 128) {
        LOGGER_API_WARNING(ac->tox, "Got dummy!");
        free(msg);
        return 0;
    }

    if ((msg->header.pt & 0x7f) != RTP_TYPE_AUDIO % 128) {
        LOGGER_API_WARNING(ac->tox, "Invalid payload type!");
        free(msg);
        return -1;
    }

    if (!ac->queue_mutex)
    {
        return 0;
    }
    pthread_mutex_lock(ac->queue_mutex);

    const struct RTPHeader *header_v3 = (void *) & (msg->header);

    // older clients do not send the frame record timestamp
    // compensate by using the frame sennt timestamp
    if (msg->header.frame_record_timestamp == 0) {
        msg->header.frame_record_timestamp = msg->header.timestamp;
    }

    jbuf_write(nullptr, ac, (struct TSBuffer *)ac->j_buf, msg);

    LOGGER_API_DEBUG(ac->tox, "AADEBUG:OK:seqnum=%d dt=%d ts:%d curts:%d", (int)header_v3->sequnum,
                 (int)((uint64_t)header_v3->frame_record_timestamp - (uint64_t)ac->last_incoming_frame_ts),
                 (int)header_v3->frame_record_timestamp,
                 (int)current_time_monotonic(ac->mono_time));

    ac->last_incoming_frame_ts = header_v3->frame_record_timestamp;

    pthread_mutex_unlock(ac->queue_mutex);

    return 0;
}

int ac_reconfigure_encoder(ACSession *ac, int32_t bit_rate, int32_t sampling_rate, uint8_t channels)
{
    if (!ac || !reconfigure_audio_encoder(nullptr, &ac->encoder, bit_rate,
                                          sampling_rate, channels,
                                          &ac->le_bit_rate,
                                          &ac->le_sample_rate,
                                          &ac->le_channel_count)) {
        return -1;
    }

    return 0;
}

static struct TSBuffer *jbuf_new(int size)
{
    TSBuffer *res = tsb_new(size);
    return res;
}

static void jbuf_free(struct TSBuffer *q)
{
    tsb_drain(q);
    tsb_kill(q);
}

static int jbuf_write(Logger *log, ACSession *ac, struct TSBuffer *q, struct RTPMessage *m)
{
    void *tmp_buf2 = tsb_write(q, (void *)m, 0, (uint32_t)m->header.frame_record_timestamp);

    if (tmp_buf2 != NULL) {
        LOGGER_API_WARNING(ac->tox, "AADEBUG:rb_write: error in rb_write:rb_size=%d", (int)tsb_size(q));
        free(tmp_buf2);
        return -1;
    }

    return 0;
}

static OpusEncoder *create_audio_encoder(const Logger *log, int32_t bit_rate, int32_t sampling_rate,
        int32_t channel_count)
{
    int status = OPUS_OK;

    /*
        OPUS_APPLICATION_VOIP Process signal for improved speech intelligibility
        OPUS_APPLICATION_AUDIO Favor faithfulness to the original input
        OPUS_APPLICATION_RESTRICTED_LOWDELAY Configure the minimum possible coding delay
    */
#ifdef RPIZEROW
    // OpusEncoder *rc = opus_encoder_create(sampling_rate, channel_count, OPUS_APPLICATION_RESTRICTED_LOWDELAY, &status);
    OpusEncoder *rc = opus_encoder_create(sampling_rate, channel_count, OPUS_APPLICATION_VOIP, &status);
#else
    OpusEncoder *rc = opus_encoder_create(sampling_rate, channel_count, OPUS_APPLICATION_VOIP, &status);
#endif

    if (status != OPUS_OK) {
        // LOGGER_ERROR(log, "Error while starting audio encoder: %s", opus_strerror(status));
        return nullptr;
    } else {
        // LOGGER_INFO(log, "starting audio encoder OK: %s", opus_strerror(status));
    }

    /*
     * Rates from 500 to 512000 bits per second are meaningful as well as the special
     * values OPUS_BITRATE_AUTO and OPUS_BITRATE_MAX. The value OPUS_BITRATE_MAX can
     * be used to cause the codec to use as much rate as it can, which is useful for
     * controlling the rate by adjusting the output buffer size.
     *
     * Parameters:
     *   `[in]`    `x`   `opus_int32`: bitrate in bits per second.
     */
    status = opus_encoder_ctl(rc, OPUS_SET_BITRATE(bit_rate));

    if (status != OPUS_OK) {
        // LOGGER_ERROR(log, "Error while setting encoder ctl: %s", opus_strerror(status));
        goto FAILURE;
    }


    /*
     * Configures the encoder's use of inband forward error correction.
     * Note:
     *   This is only applicable to the LPC layer
     * Parameters:
     *   `[in]`    `x`   `int`: FEC flag, 0 (disabled) is default
     */
    /* Enable in-band forward error correction in codec */
    status = opus_encoder_ctl(rc, OPUS_SET_INBAND_FEC(1));

    if (status != OPUS_OK) {
        // LOGGER_ERROR(log, "Error while setting encoder ctl: %s", opus_strerror(status));
        goto FAILURE;
    }


    /*
     * Configures the encoder's expected packet loss percentage.
     * Higher values with trigger progressively more loss resistant behavior in
     * the encoder at the expense of quality at a given bitrate in the lossless case,
     * but greater quality under loss.
     * Parameters:
     *     `[in]`    `x`   `int`: Loss percentage in the range 0-100, inclusive.
     */
    /* Make codec resistant to up to x% packet loss
     * NOTE This could also be adjusted on the fly, rather than hard-coded,
     *      with feedback from the receiving client.
     */
    status = opus_encoder_ctl(rc, OPUS_SET_PACKET_LOSS_PERC(AUDIO_OPUS_PACKET_LOSS_PERC));

    if (status != OPUS_OK) {
        // LOGGER_ERROR(log, "Error while setting encoder ctl: %s", opus_strerror(status));
        goto FAILURE;
    }

#if 1
    status = opus_encoder_ctl(rc, OPUS_SET_VBR(0));

    if (status != OPUS_OK) {
        printf("Error while setting encoder ctl (OPUS_SET_VBR off): %s\n", opus_strerror(status));
        // goto FAILURE;
    } else {
        printf("Setting encoder ctl (OPUS_SET_VBR off) OK: %s\n", opus_strerror(status));
    }

#endif

    /*
     * Configures the encoder's computational complexity.
     *
     * The supported range is 0-10 inclusive with 10 representing the highest complexity.
     * The default value is 10.
     *
     * Parameters:
     *   `[in]`    `x`   `int`: 0-10, inclusive
     */
    /* Set algorithm to the highest complexity, maximizing compression */
    // LOGGER_INFO(log, "starting audio encoder complexity: %d", (int)AUDIO_OPUS_COMPLEXITY);
    status = opus_encoder_ctl(rc, OPUS_SET_COMPLEXITY(AUDIO_OPUS_COMPLEXITY));

    if (status != OPUS_OK) {
        // LOGGER_ERROR(log, "Error while setting encoder ctl: %s", opus_strerror(status));
        goto FAILURE;
    }

    return rc;

FAILURE:
    opus_encoder_destroy(rc);
    return nullptr;
}

static bool reconfigure_audio_encoder(const Logger *log, OpusEncoder **e, int32_t new_br, int32_t new_sr,
                                      uint8_t new_ch, int32_t *old_br, int32_t *old_sr, int32_t *old_ch)
{
    /* Values are checked in toxav.c */
    if (*old_sr != new_sr || *old_ch != new_ch) {
        OpusEncoder *new_encoder = create_audio_encoder(log, new_br, new_sr, new_ch);

        if (new_encoder == nullptr) {
            return false;
        }

        opus_encoder_destroy(*e);
        *e = new_encoder;
    } else if (*old_br == new_br) {
        return true; /* Nothing changed */
    }

    int status = opus_encoder_ctl(*e, OPUS_SET_BITRATE(new_br));

    if (status != OPUS_OK) {
        // LOGGER_ERROR(log, "Error while setting encoder ctl: %s", opus_strerror(status));
        return false;
    }

    *old_br = new_br;
    *old_sr = new_sr;
    *old_ch = new_ch;

    // LOGGER_DEBUG(log, "Reconfigured audio encoder br: %d sr: %d cc:%d", new_br, new_sr, new_ch);
    return true;
}

static bool reconfigure_audio_decoder(ACSession *ac, int32_t sampling_rate, int8_t channels)
{
    if (sampling_rate <= 0) {
        return false;
    }

    if (sampling_rate != ac->ld_sample_rate || channels != ac->ld_channel_count) {
        if (current_time_monotonic(ac->mono_time) - ac->ldrts < 500) {
            return false;
        }

        int status;
        OpusDecoder *new_dec = opus_decoder_create(sampling_rate, channels, &status);

        if (status != OPUS_OK) {
            LOGGER_API_ERROR(ac->tox, "Error while starting audio decoder(%d %d): %s", sampling_rate, channels, opus_strerror(status));
            return false;
        }

        ac->ld_sample_rate = sampling_rate;
        ac->ld_channel_count = channels;
        ac->ldrts = current_time_monotonic(ac->mono_time);

        opus_decoder_destroy(ac->decoder);
        ac->decoder = new_dec;

        LOGGER_API_DEBUG(ac->tox, "Reconfigured audio decoder sr: %d cc: %d", sampling_rate, channels);
    }

    return true;
}

/*
 * Copyright © 2016-2018 The TokTok team.
 * Copyright © 2013-2015 Tox project.
 *
 * This file is part of Tox, the free peer to peer instant messenger.
 *
 * Tox is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Tox is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Tox.  If not, see <http://www.gnu.org/licenses/>.
 */
#ifdef HAVE_CONFIG_H
#endif /* HAVE_CONFIG_H */



#include <assert.h>
#include <errno.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <stdbool.h>

#define BWC_PACKET_ID (196)
#define BWC_SEND_INTERVAL_MS (200)     // in milliseconds

/**
 *
 */

typedef struct BWCCycle {
    uint32_t last_recv_timestamp; /* Last recv update time stamp */
    uint32_t last_sent_timestamp; /* Last sent update time stamp */
    uint32_t last_refresh_timestamp; /* Last refresh time stamp */

    uint32_t lost;
    uint32_t recv;
} BWCCycle;

struct BWController_s {
    m_cb *mcb;
    void *mcb_user_data;
    Tox *tox;
    uint32_t friend_number;
    BWCCycle cycle;
    Mono_Time *bwc_mono_time;
    uint32_t packet_loss_counted_cycles;
    bool bwc_receive_active;
};

struct BWCMessage {
    uint32_t lost;
    uint32_t recv;
};

static int bwc_send_custom_lossy_packet(Tox *tox, int32_t friendnumber, const uint8_t *data, uint32_t length);

void bwc_handle_data(Tox *tox, uint32_t friendnumber, const uint8_t *data, size_t length, void *dummy);
void send_update(BWController *bwc, bool force_update_now);

BWController *bwc_new(Tox *tox, Mono_Time *mono_time_given, uint32_t friendnumber, m_cb *mcb, void *mcb_user_data)
{
    int i = 0;
    BWController *retu = (BWController *)calloc(sizeof(struct BWController_s), 1);

    retu->mcb = mcb;
    retu->mcb_user_data = mcb_user_data;
    retu->friend_number = friendnumber;
    retu->bwc_mono_time = mono_time_given;
    uint64_t now = current_time_monotonic(retu->bwc_mono_time);
    retu->cycle.last_sent_timestamp = now;
    retu->cycle.last_refresh_timestamp = now;
    retu->tox = tox;
    retu->bwc_receive_active = true; /* default: true */

    retu->cycle.lost = 0;
    retu->cycle.recv = 0;
    retu->packet_loss_counted_cycles = 0;

    return retu;
}

void bwc_kill(BWController *bwc)
{
    if (!bwc) {
        return;
    }

    bwc->bwc_receive_active = false;
    free(bwc);
    bwc = nullptr;
}

void bwc_add_lost_v3(BWController *bwc, uint32_t bytes_lost, bool dummy)
{
    if (!bwc) {
        return;
    }

    bwc->cycle.lost = bwc->cycle.lost + bytes_lost;
    send_update(bwc, dummy);
}


void bwc_add_recv(BWController *bwc, uint32_t recv_bytes)
{
    if (!bwc) {
        return;
    }

    ++bwc->packet_loss_counted_cycles;
    bwc->cycle.recv = bwc->cycle.recv + recv_bytes;
    send_update(bwc, false);
}


void send_update(BWController *bwc, bool dummy)
{
    if (current_time_monotonic(bwc->bwc_mono_time) - bwc->cycle.last_sent_timestamp > BWC_SEND_INTERVAL_MS) {
        bwc->packet_loss_counted_cycles = 0;

        if ((bwc->cycle.recv + bwc->cycle.lost) > 0) {
            if (bwc->cycle.lost > 0) {
                LOGGER_API_DEBUG(bwc->tox, "%p Sent update rcv: %u lost: %u percent: %f %%",
                             (void *)bwc, bwc->cycle.recv, bwc->cycle.lost,
                             (double)(((float) bwc->cycle.lost / (bwc->cycle.recv + bwc->cycle.lost)) * 100.0f));
            }
        }

        uint8_t bwc_packet[sizeof(struct BWCMessage) + 1];
        size_t offset = 0;

        bwc_packet[offset] = BWC_PACKET_ID; // set packet ID
        ++offset;

        offset += net_pack_u32(bwc_packet + offset, bwc->cycle.lost);
        offset += net_pack_u32(bwc_packet + offset, bwc->cycle.recv);
        assert(offset == sizeof(bwc_packet));

        if (-1 == bwc_send_custom_lossy_packet(bwc->tox, bwc->friend_number, bwc_packet, sizeof(bwc_packet))) {
            LOGGER_API_WARNING(bwc->tox, "BWC send failed (len: %zu)! std error: %s", sizeof(bwc_packet), strerror(errno));
        } else {
            bwc->cycle.last_sent_timestamp = current_time_monotonic(bwc->bwc_mono_time);

            bwc->cycle.lost = 0;
            bwc->cycle.recv = 0;
        }
    }
}

inline __attribute__((always_inline)) static int on_update(BWController *bwc, const struct BWCMessage *msg)
{
    if (!bwc) {
        return -1;
    }

    if (!bwc->mcb) {
        return -1;
    }

    /* Peers sent update too soon */
    if ((bwc->cycle.last_recv_timestamp + (BWC_SEND_INTERVAL_MS / 2)) > current_time_monotonic(bwc->bwc_mono_time)) {
        return -1;
    }

    bwc->cycle.last_recv_timestamp = current_time_monotonic(bwc->bwc_mono_time);
    const uint32_t recv = msg->recv;
    const uint32_t lost = msg->lost;

    if ((bwc) && (bwc->mcb)) {
        if ((recv + lost) > 0) {
            bwc->mcb(bwc, bwc->friend_number,
                     ((float) lost / (recv + lost)),
                     bwc->mcb_user_data);
        } else {
            bwc->mcb(bwc, bwc->friend_number,
                     0,
                     bwc->mcb_user_data);
        }
    }

    return 0;
}


void bwc_handle_data(Tox *tox, uint32_t friendnumber, const uint8_t *data, size_t length, void *dummy)
{
    if (sizeof(struct BWCMessage) != (length - 1)) {
        return;
    }

    void *toxav = (void *)tox_get_av_object(tox);

    if (toxav == nullptr) {
        return;
    }

    pthread_mutex_t *endcall_mutex = NULL;
    endcall_mutex = (void *)endcall_mutex_get(toxav);

    if (!endcall_mutex) {
        return;
    }

    if (pthread_mutex_trylock(endcall_mutex) != 0) {
        LOGGER_API_DEBUG(tox, "could not lock mutex, we are ending a call");
        return;
    }

    void *call = NULL;
    call = (void *)call_get(toxav, friendnumber);

    if (!call) {
        LOGGER_API_INFO(tox, "No Call Object!");
        pthread_mutex_unlock(endcall_mutex);
        return;
    }

    /* get Call object from Tox */

    BWController *bwc = NULL;
    bwc = bwc_controller_get(call);

    if (!bwc) {
        LOGGER_API_INFO(tox, "No BWC Object!");
        pthread_mutex_unlock(endcall_mutex);
        return;
    }

    if (!bwc->bwc_receive_active) {
        LOGGER_API_INFO(tox, "receiving not allowed!");
        pthread_mutex_unlock(endcall_mutex);
        return;
    }

    size_t offset = 1;  // Ignore packet id.
    struct BWCMessage msg;
    offset += net_unpack_u32(data + offset, &msg.lost);
    offset += net_unpack_u32(data + offset, &msg.recv);
    assert(offset == length);

    if (bwc) {
        on_update(bwc, &msg);
    }

    pthread_mutex_unlock(endcall_mutex);
}

/*
 * return -1 on failure, 0 on success
 *
 */
static int bwc_send_custom_lossy_packet(Tox *tox, int32_t friendnumber, const uint8_t *data, uint32_t length)
{
    TOX_ERR_FRIEND_CUSTOM_PACKET error;
    tox_friend_send_lossy_packet(tox, friendnumber, data, (size_t)length, &error);

    if (error == TOX_ERR_FRIEND_CUSTOM_PACKET_OK) {
        return 0;
    }

    return -1;
}

void bwc_allow_receiving(Tox *tox)
{
    tox_callback_friend_lossy_packet_per_pktid(tox, bwc_handle_data, BWC_PACKET_ID);
}

void bwc_stop_receiving(Tox *tox)
{
    tox_callback_friend_lossy_packet_per_pktid(tox, NULL, BWC_PACKET_ID);
}
/*
 * Copyright © 2018 zoff@zoff.cc
 *
 * This file is part of Tox, the free peer to peer instant messenger.
 *
 * Tox is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Tox is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Tox.  If not, see <http://www.gnu.org/licenses/>.
 */

/*
 * NTP formula implementation
 */


#include <stdlib.h>
#include <stdio.h>

#define DRIFT_MILLIS    1

bool dntp_drift(int64_t *current_offset, const int64_t new_offset, const int64_t max_offset_for_drift, const uint32_t jitter)
{
    bool did_jump = false;

    if (current_offset == NULL) {
        // HINT: input param is NULL
        return did_jump;
    }

    int64_t abs_value;

    if (new_offset > *current_offset) {
        abs_value = new_offset - *current_offset;
    } else {
        abs_value =  *current_offset - new_offset;
    }

    if (abs_value > max_offset_for_drift) {
        // HINT: jump
        *current_offset = new_offset;

        did_jump = true;
        return did_jump;
    } else {
        // HINT: drift
        if (new_offset == *current_offset) {
            return did_jump;
        }

        if (abs_value > jitter)
        {
            int64_t delta = 1;

            if (new_offset < *current_offset) {
                delta = -1;
            }
            *current_offset = *current_offset + (delta * DRIFT_MILLIS);
        }
    }

    return did_jump;
}

int64_t dntp_calc_offset(uint32_t remote_tstart, uint32_t remote_tend,
                         uint32_t local_tstart, uint32_t local_tend)
{
    // output value is in milliseconds
    // accuracy:
    /* If the routes do not have a common nominal delay,
     * there will be a systematic bias of half the difference
     * between the forward and backward travel times
     */

    // see: https://en.wikipedia.org/wiki/Network_Time_Protocol
    /*
     * t0 .. local_tstart
     * t1 .. remote_tstart
     * t2 .. remote_tend
     * t3 .. local_tend
     */

    int64_t offset = (int64_t)(
                         ((int64_t)remote_tstart - (int64_t)local_tstart)
                         + ((int64_t)remote_tend - (int64_t)local_tend)
                     )
                     / 2;
    return offset;
}

uint32_t dntp_calc_roundtrip_delay(uint32_t remote_tstart, uint32_t remote_tend,
                                   uint32_t local_tstart, uint32_t local_tend)
{
    // output value is in milliseconds

    // see: https://en.wikipedia.org/wiki/Network_Time_Protocol
    /*
     * t0 .. local_tstart
     * t1 .. remote_tstart
     * t2 .. remote_tend
     * t3 .. local_tend
     */

    uint32_t roundtrip_delay = (local_tend - local_tstart)
                               - (remote_tend - remote_tstart);
    return roundtrip_delay;
}

#if 0

void unit_test()
{
#ifndef __MINGW32__
#include <time.h>
#endif

    printf("dummy_ntp:testing ...\n");

    int64_t res1;
    uint32_t res2;
    bool res3;
    uint32_t rs;
    uint32_t re;
    uint32_t ls;
    uint32_t le;
    uint32_t ls_r;
    uint16_t trip1_ms;
    uint16_t trip2_ms;
    int64_t current_offset;

    const uint16_t step = 5;
    int64_t diff;
    int64_t lstart;
    int64_t rstart;

#ifndef __MINGW32__
    srand(time(NULL));
#else
    // TODO: fixme ---
    srand(localtime());
    // TODO: fixme ---
#endif

    current_offset = 0;

    for (int j = 0; j < 10; j++) {
        // ---------------
        lstart = rand() % 9999999 + 10000;
        rstart = lstart + (rand() % 100);
        diff = rstart - lstart;
        trip1_ms = rand() % 210 + 4;
        trip2_ms = rand() % 210 + 4;
        // ---------------
        // printf("diff=%ld trip1=%d trip2=%d\n", diff, trip1_ms, trip2_ms);
        ls = lstart;
        ls_r = lstart + diff;
        rs = ls_r + trip1_ms;
        re = rs + step;
        le = ls + trip1_ms + step + trip2_ms;
        res1 = dntp_calc_offset(rs, re,
                                ls, le);
        printf("offset=%lld ms\n", res1);
        printf("ERROR=%lld ms\n", (res1 - diff));
        res2 = dntp_calc_roundtrip_delay(rs, re,
                                         ls, le);
        printf("round trip=%ld ms\n", res2);

        printf("current_offset=%lld offset=%lld ms\n", current_offset, res1);
        res3 = dntp_drift(&current_offset, res1, 50);
        printf("current_offset new=%lld ms bool res=%d\n", current_offset, (int)res3);
    }


    int64_t aaa;
    bool res4;
    aaa = 0;
    res4 = dntp_drift(&aaa, 163197, 300);
    printf("DNTP:B:res=%d offset new=%lld\n", (int)res4, aaa);

    res4 = dntp_drift(&aaa, 163197, 300);
    printf("DNTP:B:res=%d offset new=%lld\n", (int)res4, aaa);


}

#endif
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2018 The TokTok team.
 * Copyright © 2014 Tox project.
 */

#include <stdlib.h>
#include <string.h>


#define GROUP_JBUF_SIZE 6
#define GROUP_JBUF_DEAD_SECONDS 4

typedef struct Group_Audio_Packet {
    uint16_t sequnum;
    uint16_t length;
    uint8_t *data;
} Group_Audio_Packet;

typedef struct Group_JitterBuffer {
    Group_Audio_Packet **queue;
    uint32_t size;
    uint32_t capacity;
    uint16_t bottom;
    uint16_t top;
    uint64_t last_queued_time;
} Group_JitterBuffer;

static void free_audio_packet(Group_Audio_Packet *pk)
{
    if (pk == nullptr) {
        return;
    }

    free(pk->data);
    free(pk);
}

static Group_JitterBuffer *create_queue(unsigned int capacity)
{
    unsigned int size = 1;

    while (size <= capacity) {
        size *= 2;
    }

    Group_JitterBuffer *q = (Group_JitterBuffer *)calloc(1, sizeof(Group_JitterBuffer));

    if (q == nullptr) {
        return nullptr;
    }

    q->queue = (Group_Audio_Packet **)calloc(size, sizeof(Group_Audio_Packet *));

    if (q->queue == nullptr) {
        free(q);
        return nullptr;
    }

    q->size = size;
    q->capacity = capacity;
    return q;
}

static void clear_queue(Group_JitterBuffer *q)
{
    while (q->bottom != q->top) {
        const size_t idx = q->bottom % q->size;
        free_audio_packet(q->queue[idx]);
        q->queue[idx] = nullptr;
        ++q->bottom;
    }
}

static void terminate_queue(Group_JitterBuffer *q)
{
    if (q == nullptr) {
        return;
    }

    clear_queue(q);
    free(q->queue);
    free(q);
}

/** @retval 0 if packet was queued
 * @retval -1 if it wasn't.
 */
static int queue(Group_JitterBuffer *q, const Mono_Time *mono_time, Group_Audio_Packet *pk)
{
    const uint16_t sequnum = pk->sequnum;

    const unsigned int num = sequnum % q->size;

    if (!mono_time_is_timeout(mono_time, q->last_queued_time, GROUP_JBUF_DEAD_SECONDS)) {
        if ((uint32_t)(sequnum - q->bottom) > (1 << 15)) {
            /* Drop old packet. */
            return -1;
        }
    }

    if ((uint32_t)(sequnum - q->bottom) > q->size) {
        clear_queue(q);
        q->bottom = sequnum - q->capacity;
        q->queue[num] = pk;
        q->top = sequnum + 1;
        q->last_queued_time = mono_time_get(mono_time);
        return 0;
    }

    if (q->queue[num] != nullptr) {
        return -1;
    }

    q->queue[num] = pk;

    if ((sequnum - q->bottom) >= (q->top - q->bottom)) {
        q->top = sequnum + 1;
    }

    q->last_queued_time = mono_time_get(mono_time);
    return 0;
}

/**
 * success is:
 * - 0 when there is nothing to dequeue
 * - 1 when there's a good packet
 * - 2 when there's a lost packet
 */
static Group_Audio_Packet *dequeue(Group_JitterBuffer *q, int *success)
{
    if (q->top == q->bottom) {
        *success = 0;
        return nullptr;
    }

    const unsigned int num = q->bottom % q->size;

    if (q->queue[num] != nullptr) {
        Group_Audio_Packet *ret = q->queue[num];
        q->queue[num] = nullptr;
        ++q->bottom;
        *success = 1;
        return ret;
    }

    if ((uint32_t)(q->top - q->bottom) > q->capacity) {
        ++q->bottom;
        *success = 2;
        return nullptr;
    }

    *success = 0;
    return nullptr;
}

typedef struct Group_AV {
    const Logger *log;
    Tox *tox;
    Group_Chats *g_c;
    OpusEncoder *audio_encoder;

    unsigned int audio_channels;
    unsigned int audio_sample_rate;
    unsigned int audio_bitrate;

    uint16_t audio_sequnum;

    audio_data_cb *audio_data;
    void *userdata;
} Group_AV;

typedef struct Group_Peer_AV {
    const Mono_Time *mono_time;
    Group_JitterBuffer *buffer;

    OpusDecoder *audio_decoder;
    int decoder_channels;
    unsigned int last_packet_samples;
} Group_Peer_AV;

static void kill_group_av(Group_AV *group_av)
{
    if (group_av->audio_encoder != nullptr) {
        opus_encoder_destroy(group_av->audio_encoder);
    }

    free(group_av);
}

static int recreate_encoder(Group_AV *group_av)
{
    if (group_av->audio_encoder != nullptr) {
        opus_encoder_destroy(group_av->audio_encoder);
        group_av->audio_encoder = nullptr;
    }

    int rc = OPUS_OK;
    group_av->audio_encoder = opus_encoder_create(group_av->audio_sample_rate, group_av->audio_channels,
                              OPUS_APPLICATION_AUDIO, &rc);

    if (rc != OPUS_OK) {
        LOGGER_ERROR(group_av->log, "Error while starting audio encoder: %s", opus_strerror(rc));
        group_av->audio_encoder = nullptr;
        return -1;
    }

    rc = opus_encoder_ctl(group_av->audio_encoder, OPUS_SET_BITRATE(group_av->audio_bitrate));

    if (rc != OPUS_OK) {
        LOGGER_ERROR(group_av->log, "Error while setting encoder ctl: %s", opus_strerror(rc));
        opus_encoder_destroy(group_av->audio_encoder);
        group_av->audio_encoder = nullptr;
        return -1;
    }

    rc = opus_encoder_ctl(group_av->audio_encoder, OPUS_SET_COMPLEXITY(10));

    if (rc != OPUS_OK) {
        LOGGER_ERROR(group_av->log, "Error while setting encoder ctl: %s", opus_strerror(rc));
        opus_encoder_destroy(group_av->audio_encoder);
        group_av->audio_encoder = nullptr;
        return -1;
    }

    return 0;
}

static Group_AV *new_group_av(const Logger *log, Tox *tox, Group_Chats *g_c, audio_data_cb *audio_callback,
                              void *userdata)
{
    if (g_c == nullptr) {
        return nullptr;
    }

    Group_AV *group_av = (Group_AV *)calloc(1, sizeof(Group_AV));

    if (group_av == nullptr) {
        return nullptr;
    }

    group_av->log = log;
    group_av->tox = tox;
    group_av->g_c = g_c;

    group_av->audio_data = audio_callback;
    group_av->userdata = userdata;

    return group_av;
}

static void group_av_peer_new(void *object, uint32_t groupnumber, uint32_t friendgroupnumber)
{
    const Group_AV *group_av = (const Group_AV *)object;
    Group_Peer_AV *peer_av = (Group_Peer_AV *)calloc(1, sizeof(Group_Peer_AV));

    if (peer_av == nullptr) {
        return;
    }

    peer_av->mono_time = g_mono_time(group_av->g_c);
    peer_av->buffer = create_queue(GROUP_JBUF_SIZE);

    if (group_peer_set_object(group_av->g_c, groupnumber, friendgroupnumber, peer_av) == -1) {
        free(peer_av);
    }
}

static void group_av_peer_delete(void *object, uint32_t groupnumber, void *peer_object)
{
    Group_Peer_AV *peer_av = (Group_Peer_AV *)peer_object;

    if (peer_av == nullptr) {
        return;
    }

    if (peer_av->audio_decoder != nullptr) {
        opus_decoder_destroy(peer_av->audio_decoder);
    }

    terminate_queue(peer_av->buffer);
    free(peer_object);
}

static void group_av_groupchat_delete(void *object, uint32_t groupnumber)
{
    if (object != nullptr) {
        kill_group_av((Group_AV *)object);
    }
}

static int decode_audio_packet(Group_AV *group_av, Group_Peer_AV *peer_av, uint32_t groupnumber,
                               uint32_t friendgroupnumber)
{
    if (group_av == nullptr || peer_av == nullptr) {
        return -1;
    }

    int success;
    Group_Audio_Packet *pk = dequeue(peer_av->buffer, &success);

    if (success == 0) {
        return -1;
    }

    int16_t *out_audio = nullptr;
    int out_audio_samples = 0;

    const unsigned int sample_rate = 48000;

    if (success == 1) {
        const int channels = opus_packet_get_nb_channels(pk->data);

        if (channels == OPUS_INVALID_PACKET) {
            free_audio_packet(pk);
            return -1;
        }

        if (channels != 1 && channels != 2) {
            free_audio_packet(pk);
            return -1;
        }

        if (channels != peer_av->decoder_channels) {
            if (peer_av->audio_decoder != nullptr) {
                opus_decoder_destroy(peer_av->audio_decoder);
                peer_av->audio_decoder = nullptr;
            }

            int rc;
            peer_av->audio_decoder = opus_decoder_create(sample_rate, channels, &rc);

            if (rc != OPUS_OK) {
                LOGGER_ERROR(group_av->log, "Error while starting audio decoder: %s", opus_strerror(rc));
                free_audio_packet(pk);
                return -1;
            }

            peer_av->decoder_channels = channels;
        }

        const int num_samples = opus_decoder_get_nb_samples(peer_av->audio_decoder, pk->data, pk->length);

        out_audio = (int16_t *)malloc(num_samples * peer_av->decoder_channels * sizeof(int16_t));

        if (out_audio == nullptr) {
            free_audio_packet(pk);
            return -1;
        }

        out_audio_samples = opus_decode(peer_av->audio_decoder, pk->data, pk->length, out_audio, num_samples, 0);
        free_audio_packet(pk);

        if (out_audio_samples <= 0) {
            free(out_audio);
            return -1;
        }

        peer_av->last_packet_samples = out_audio_samples;
    } else {
        if (peer_av->audio_decoder == nullptr) {
            return -1;
        }

        if (peer_av->last_packet_samples == 0) {
            return -1;
        }

        out_audio = (int16_t *)malloc(peer_av->last_packet_samples * peer_av->decoder_channels * sizeof(int16_t));

        if (out_audio == nullptr) {
            free_audio_packet(pk);
            return -1;
        }

        out_audio_samples = opus_decode(peer_av->audio_decoder, nullptr, 0, out_audio, peer_av->last_packet_samples, 1);

        if (out_audio_samples <= 0) {
            free(out_audio);
            return -1;
        }
    }

    if (out_audio != nullptr) {

        if (group_av->audio_data != nullptr) {
            group_av->audio_data(group_av->tox, groupnumber, friendgroupnumber, out_audio, out_audio_samples,
                                 peer_av->decoder_channels, sample_rate, group_av->userdata);
        }

        free(out_audio);
        return 0;
    }

    return -1;
}

static int handle_group_audio_packet(void *object, uint32_t groupnumber, uint32_t friendgroupnumber, void *peer_object,
                                     const uint8_t *packet, uint16_t length)
{
    if (peer_object == nullptr || object == nullptr || length <= sizeof(uint16_t)) {
        return -1;
    }

    Group_Peer_AV *peer_av = (Group_Peer_AV *)peer_object;

    Group_Audio_Packet *pk = (Group_Audio_Packet *)calloc(1, sizeof(Group_Audio_Packet));

    if (pk == nullptr) {
        return -1;
    }

    net_unpack_u16(packet, &pk->sequnum);
    pk->length = length - sizeof(uint16_t);

    pk->data = (uint8_t *)malloc(pk->length);

    if (pk->data == nullptr) {
        free_audio_packet(pk);
        return -1;
    }

    memcpy(pk->data, packet + sizeof(uint16_t), pk->length);

    if (queue(peer_av->buffer, peer_av->mono_time, pk) == -1) {
        free_audio_packet(pk);
        return -1;
    }

    while (decode_audio_packet((Group_AV *)object, peer_av, groupnumber, friendgroupnumber) == 0) {
        continue;
    }

    return 0;
}

/** @brief Enable A/V in a groupchat.
 *
 * @retval 0 on success.
 * @retval -1 on failure.
 */
int groupchat_enable_av(const Logger *log, Tox *tox, Group_Chats *g_c, uint32_t groupnumber,
                        audio_data_cb *audio_callback, void *userdata)
{
    if (group_get_type(g_c, groupnumber) != GROUPCHAT_TYPE_AV
            || group_get_object(g_c, groupnumber) != nullptr) {
        return -1;
    }

    Group_AV *group_av = new_group_av(log, tox, g_c, audio_callback, userdata);

    if (group_av == nullptr) {
        return -1;
    }

    if (group_set_object(g_c, groupnumber, group_av) == -1
            || callback_groupchat_peer_new(g_c, groupnumber, group_av_peer_new) == -1
            || callback_groupchat_peer_delete(g_c, groupnumber, group_av_peer_delete) == -1
            || callback_groupchat_delete(g_c, groupnumber, group_av_groupchat_delete) == -1) {
        kill_group_av(group_av);
        return -1;
    }

    const int numpeers = group_number_peers(g_c, groupnumber, false);

    if (numpeers < 0) {
        kill_group_av(group_av);
        return -1;
    }

    for (uint32_t i = 0; i < numpeers; ++i) {
        group_av_peer_new(group_av, groupnumber, i);
    }

    group_lossy_packet_registerhandler(g_c, GROUP_AUDIO_PACKET_ID, &handle_group_audio_packet);
    return 0;
}

/** @brief Disable A/V in a groupchat.
 *
 * @retval 0 on success.
 * @retval -1 on failure.
 */
int groupchat_disable_av(const Group_Chats *g_c, uint32_t groupnumber)
{
    if (group_get_type(g_c, groupnumber) != GROUPCHAT_TYPE_AV) {
        return -1;
    }

    Group_AV *group_av = (Group_AV *)group_get_object(g_c, groupnumber);

    if (group_av == nullptr) {
        return -1;
    }

    const int numpeers = group_number_peers(g_c, groupnumber, false);

    if (numpeers < 0) {
        kill_group_av(group_av);
        return -1;
    }

    for (uint32_t i = 0; i < numpeers; ++i) {
        group_av_peer_delete(group_av, groupnumber, group_peer_get_object(g_c, groupnumber, i));
        group_peer_set_object(g_c, groupnumber, i, nullptr);
    }

    kill_group_av(group_av);

    if (group_set_object(g_c, groupnumber, nullptr) == -1
            || callback_groupchat_peer_new(g_c, groupnumber, nullptr) == -1
            || callback_groupchat_peer_delete(g_c, groupnumber, nullptr) == -1
            || callback_groupchat_delete(g_c, groupnumber, nullptr) == -1) {
        return -1;
    }

    return 0;
}

/** Return whether A/V is enabled in the groupchat. */
bool groupchat_av_enabled(const Group_Chats *g_c, uint32_t groupnumber)
{
    return group_get_object(g_c, groupnumber) != nullptr;
}

/** @brief Create and connect to a new toxav group.
 *
 * @return group number on success.
 * @retval -1 on failure.
 */
int add_av_groupchat(const Logger *log, Tox *tox, Group_Chats *g_c, audio_data_cb *audio_callback, void *userdata)
{
    const int groupnumber = add_groupchat(g_c, &tox->rng, GROUPCHAT_TYPE_AV);

    if (groupnumber == -1) {
        return -1;
    }

    if (groupchat_enable_av(log, tox, g_c, groupnumber, audio_callback, userdata) == -1) {
        del_groupchat(g_c, groupnumber, true);
        return -1;
    }

    return groupnumber;
}

/** @brief Join a AV group (you need to have been invited first).
 *
 * @return group number on success
 * @retval -1 on failure.
 */
int join_av_groupchat(const Logger *log, Tox *tox, Group_Chats *g_c, uint32_t friendnumber, const uint8_t *data,
                      uint16_t length, audio_data_cb *audio_callback, void *userdata)
{
    const int groupnumber = join_groupchat(g_c, friendnumber, GROUPCHAT_TYPE_AV, data, length);

    if (groupnumber == -1) {
        return -1;
    }

    if (groupchat_enable_av(log, tox, g_c, groupnumber, audio_callback, userdata) == -1) {
        del_groupchat(g_c, groupnumber, true);
        return -1;
    }

    return groupnumber;
}

/** @brief Send an encoded audio packet to the group chat.
 *
 * @retval 0 on success.
 * @retval -1 on failure.
 */
static int send_audio_packet(const Group_Chats *g_c, uint32_t groupnumber, const uint8_t *packet, uint16_t length)
{
    if (length == 0 || length > MAX_CRYPTO_DATA_SIZE - 1 - sizeof(uint16_t)) {
        return -1;
    }

    const uint16_t plen = 1 + sizeof(uint16_t) + length;

    Group_AV *const group_av = (Group_AV *)group_get_object(g_c, groupnumber);

    if (group_av == nullptr) {
        return -1;
    }

    uint8_t data[MAX_CRYPTO_DATA_SIZE];
    uint8_t *ptr = data;
    *ptr = GROUP_AUDIO_PACKET_ID;
    ++ptr;

    ptr += net_pack_u16(ptr, group_av->audio_sequnum);
    memcpy(ptr, packet, length);

    if (send_group_lossy_packet(g_c, groupnumber, data, plen) == -1) {
        return -1;
    }

    ++group_av->audio_sequnum;
    return 0;
}

/** @brief Send audio to the group chat.
 *
 * @retval 0 on success.
 * @retval -1 on failure.
 */
int group_send_audio(Group_Chats *g_c, uint32_t groupnumber, const int16_t *pcm, unsigned int samples, uint8_t channels,
                     uint32_t sample_rate)
{
    Group_AV *group_av = (Group_AV *)group_get_object(g_c, groupnumber);

    if (group_av == nullptr) {
        return -1;
    }

    if (channels != 1 && channels != 2) {
        return -1;
    }

    if (sample_rate != 8000 && sample_rate != 12000 && sample_rate != 16000 && sample_rate != 24000
            && sample_rate != 48000) {
        return -1;
    }

    if (group_av->audio_encoder == nullptr || group_av->audio_channels != channels
            || group_av->audio_sample_rate != sample_rate) {
        group_av->audio_channels = channels;
        group_av->audio_sample_rate = sample_rate;

        if (channels == 1) {
            group_av->audio_bitrate = 32000; // TODO(mannol): add way of adjusting bitrate
        } else {
            group_av->audio_bitrate = 64000; // TODO(mannol): add way of adjusting bitrate
        }

        if (recreate_encoder(group_av) == -1) {
            return -1;
        }
    }

    uint8_t encoded[1024];
    const int32_t size = opus_encode(group_av->audio_encoder, pcm, samples, encoded, sizeof(encoded));

    if (size <= 0) {
        return -1;
    }

    return send_audio_packet(g_c, groupnumber, encoded, size);
}
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2018 The TokTok team.
 * Copyright © 2013-2015 Tox project.
 */
#ifdef HAVE_CONFIG_H
#endif /* HAVE_CONFIG_H */



#include <assert.h>
#include <stdbool.h>
#include <stdlib.h>
#include <string.h>

#define MSI_MAXMSG_SIZE 256

/**
 * Protocol:
 *
 * `|id [1 byte]| |size [1 byte]| |data [$size bytes]| |...{repeat}| |0 {end byte}|`
 */

typedef enum MSIHeaderID {
    ID_REQUEST = 1,
    ID_ERROR,
    ID_CAPABILITIES,
} MSIHeaderID;


typedef enum MSIRequest {
    REQU_INIT,
    REQU_PUSH,
    REQU_POP,
} MSIRequest;


typedef struct MSIHeaderRequest {
    MSIRequest value;
    bool exists;
} MSIHeaderRequest;

typedef struct MSIHeaderError {
    MSIError value;
    bool exists;
} MSIHeaderError;

typedef struct MSIHeaderCapabilities {
    uint8_t value;
    bool exists;
} MSIHeaderCapabilities;


typedef struct MSIMessage {
    MSIHeaderRequest      request;
    MSIHeaderError        error;
    MSIHeaderCapabilities capabilities;
} MSIMessage;


static void msg_init(MSIMessage *dest, MSIRequest request);
static int msg_parse_in(Tox *tox, MSIMessage *dest, const uint8_t *data, uint16_t length);
static uint8_t *msg_parse_header_out(MSIHeaderID id, uint8_t *dest, const void *value, uint8_t value_len,
                                     uint16_t *length);
static int send_message(Tox *tox, uint32_t friend_number, const MSIMessage *msg);
static int send_error(Tox *tox, uint32_t friend_number, MSIError error);
static MSICall *get_call(MSISession *session, uint32_t friend_number);
static MSICall *new_call(MSISession *session, uint32_t friend_number);
static void handle_init(MSICall *call, const MSIMessage *msg);
static void handle_push(MSICall *call, const MSIMessage *msg);
static void handle_pop(MSICall *call, const MSIMessage *msg);
static void handle_msi_packet(Tox *tox, uint32_t friend_number, const uint8_t *data, size_t length2, void *object);

/**
 * Public functions
 */
void msi_register_callback(MSISession *session, msi_action_cb *callback, MSICallbackID id)
{
    if (!session) {
        return;
    }

    pthread_mutex_lock(session->mutex);
    session->callbacks[id] = callback;
    pthread_mutex_unlock(session->mutex);
}

MSISession *msi_new(Tox *tox)
{
    if (tox == nullptr) {
        return nullptr;
    }

    MSISession *retu = (MSISession *)calloc(sizeof(MSISession), 1);

    if (retu == nullptr) {
        LOGGER_API_ERROR(tox, "Allocation failed! Program might misbehave!");
        return nullptr;
    }

    if (create_recursive_mutex(retu->mutex) != 0) {
        LOGGER_API_ERROR(tox, "Failed to init mutex! Program might misbehave");
        free(retu);
        return nullptr;
    }

    retu->tox = tox;

    // register callback
    tox_callback_friend_lossless_packet_per_pktid(tox, handle_msi_packet, PACKET_ID_MSI);

    LOGGER_API_INFO(tox, "New msi session: %p ", (void *)retu);
    return retu;
}

int msi_kill(Tox *tox, MSISession *session, const Logger *log)
{
    if (session == nullptr) {
        LOGGER_API_ERROR(tox, "Tried to terminate non-existing session");
        return -1;
    }

    // UN-register callback
    tox_callback_friend_lossless_packet_per_pktid(tox, nullptr, PACKET_ID_MSI);

    if (pthread_mutex_trylock(session->mutex) != 0) {
        LOGGER_API_ERROR(tox, "Failed to acquire lock on msi mutex");
        return -1;
    }

    if (session->calls) {
        MSIMessage msg;
        msg_init(&msg, REQU_POP);

        MSICall *it = get_call(session, session->calls_head);

        while (it) {
            send_message(session->tox, it->friend_number, &msg);
            MSICall *temp_it = it;
            it = it->next;
            kill_call(temp_it); /* This will eventually free session->calls */
        }
    }

    pthread_mutex_unlock(session->mutex);
    pthread_mutex_destroy(session->mutex);

    LOGGER_API_INFO(tox, "Terminated session: %p", (void *)session);
    free(session);
    return 0;
}

/*
 * return true if friend was offline and the call was canceled
 */
bool check_peer_offline_status(Tox *tox, MSISession *session, uint32_t friend_number)
{
    if (!tox) {
        return false;
    }

    if (!session) {
        return false;
    }

    TOX_ERR_FRIEND_QUERY f_con_query_error;
    TOX_CONNECTION f_conn_status = tox_friend_get_connection_status(tox, friend_number, &f_con_query_error);

    if (f_conn_status == TOX_CONNECTION_NONE) {
        /* Friend is now offline */
        LOGGER_API_DEBUG(tox, "Friend %d is now offline", friend_number);

        pthread_mutex_lock(session->mutex);
        MSICall *call = get_call(session, friend_number);

        if (call == nullptr) {
            pthread_mutex_unlock(session->mutex);
            return true;
        }

        invoke_callback(call, MSI_ON_PEERTIMEOUT); /* Failure is ignored */
        kill_call(call);
        pthread_mutex_unlock(session->mutex);
        return true;
    }

    return false;
}

int msi_invite(MSISession *session, MSICall **call, uint32_t friend_number, uint8_t capabilities)
{
    if (!session) {
        return -1;
    }

    LOGGER_API_INFO(session->tox, "Session: %p Inviting friend: %u", (void *)session, friend_number);

    if (pthread_mutex_trylock(session->mutex) != 0) {
        LOGGER_API_ERROR(session->tox, "Failed to acquire lock on msi mutex");
        return -1;
    }

    if (get_call(session, friend_number) != nullptr) {
        LOGGER_API_ERROR(session->tox, "Already in a call");
        pthread_mutex_unlock(session->mutex);
        return -1;
    }

    MSICall *temp = new_call(session, friend_number);

    if (temp == nullptr) {
        pthread_mutex_unlock(session->mutex);
        return -1;
    }

    temp->self_capabilities = capabilities;

    MSIMessage msg;
    msg_init(&msg, REQU_INIT);

    msg.capabilities.exists = true;
    msg.capabilities.value = capabilities;

    send_message(temp->session->tox, temp->friend_number, &msg);

    temp->state = MSI_CALL_REQUESTING;

    *call = temp;

    LOGGER_API_INFO(session->tox, "Invite sent");
    pthread_mutex_unlock(session->mutex);
    return 0;
}

int msi_hangup(MSICall *call)
{
    if (!call) {
        return -1;
    }

    if (!call->session) {
        return -1;
    }

    MSISession *session = call->session;

    LOGGER_API_INFO(session->tox, "Session: %p Hanging up call with friend: %u", (void *)call->session,
                     call->friend_number);

    if (pthread_mutex_trylock(session->mutex) != 0) {
        // LOGGER_API_ERROR(session->tox, "Failed to acquire lock on msi mutex");
        return -1;
    }

    if (call->state == MSI_CALL_INACTIVE) {
        // LOGGER_API_ERROR(session->tox, "Call is in invalid state!");
        pthread_mutex_unlock(session->mutex);
        return -1;
    }

    MSIMessage msg;
    msg_init(&msg, REQU_POP);

    send_message(session->tox, call->friend_number, &msg);

    kill_call(call);
    pthread_mutex_unlock(session->mutex);
    return 0;
}

int msi_answer(MSICall *call, uint8_t capabilities)
{
    if (!call || !call->session) {
        return -1;
    }

    MSISession *session = call->session;

    LOGGER_API_INFO(session->tox, "Session: %p Answering call from: %u", (void *)call->session,
                     call->friend_number);

    if (pthread_mutex_trylock(session->mutex) != 0) {
        LOGGER_API_ERROR(session->tox, "Failed to acquire lock on msi mutex");
        return -1;
    }

    if (call->state != MSI_CALL_REQUESTED) {
        /* Though sending in invalid state will not cause anything weird
         * Its better to not do it like a maniac */
        LOGGER_API_ERROR(session->tox, "Call is in invalid state!");
        pthread_mutex_unlock(session->mutex);
        return -1;
    }

    call->self_capabilities = capabilities;

    MSIMessage msg;
    msg_init(&msg, REQU_PUSH);

    msg.capabilities.exists = true;
    msg.capabilities.value = capabilities;

    send_message(session->tox, call->friend_number, &msg);

    call->state = MSI_CALL_ACTIVE;
    pthread_mutex_unlock(session->mutex);

    return 0;
}

int msi_change_capabilities(MSICall *call, uint8_t capabilities)
{
    if (!call || !call->session) {
        return -1;
    }

    MSISession *session = call->session;

    LOGGER_API_INFO(session->tox, "Session: %p Trying to change capabilities to friend %u", (void *)call->session,
                     call->friend_number);

    if (pthread_mutex_trylock(session->mutex) != 0) {
        LOGGER_API_ERROR(session->tox, "Failed to acquire lock on msi mutex");
        return -1;
    }

    if (call->state != MSI_CALL_ACTIVE) {
        LOGGER_API_ERROR(session->tox, "Call is in invalid state!");
        pthread_mutex_unlock(session->mutex);
        return -1;
    }

    call->self_capabilities = capabilities;

    MSIMessage msg;
    msg_init(&msg, REQU_PUSH);

    msg.capabilities.exists = true;
    msg.capabilities.value = capabilities;

    send_message(call->session->tox, call->friend_number, &msg);

    pthread_mutex_unlock(session->mutex);
    return 0;
}


/**
 * Private functions
 */
static void msg_init(MSIMessage *dest, MSIRequest request)
{
    memset(dest, 0, sizeof(*dest));
    dest->request.exists = true;
    dest->request.value = request;
}

static bool check_size(Tox *tox, const uint8_t *bytes, int *constraint, uint8_t size)
{
    *constraint -= 2 + size;

    if (*constraint < 1) {
        LOGGER_API_ERROR(tox, "Read over length!");
        return false;
    }

    if (bytes[1] != size) {
        LOGGER_API_ERROR(tox, "Invalid data size!");
        return false;
    }

    return true;
}

/* Assumes size == 1 */
static bool check_enum_high(Tox *tox, const uint8_t *bytes, uint8_t enum_high)
{
    if (bytes[2] > enum_high) {
        LOGGER_API_ERROR(tox, "Failed enum high limit!");
        return false;
    }

    return true;
}

static int msg_parse_in(Tox *tox, MSIMessage *dest, const uint8_t *data, uint16_t length)
{
    /* Parse raw data received from socket into MSIMessage struct */
    assert(dest);

    if (length == 0 || data[length - 1]) { /* End byte must have value 0 */
        LOGGER_API_ERROR(tox, "Invalid end byte");
        return -1;
    }

    memset(dest, 0, sizeof(*dest));

    const uint8_t *it = data;
    int size_constraint = length;

    while (*it) {/* until end byte is hit */
        switch (*it) {
            case ID_REQUEST: {
                LOGGER_API_INFO(tox, "got:ID_REQUEST");
                if (!check_size(tox, it, &size_constraint, 1) ||
                        !check_enum_high(tox, it, REQU_POP)) {
                    return -1;
                }

                dest->request.value = (MSIRequest)it[2];
                dest->request.exists = true;
                it += 3;
                break;
            }

            case ID_ERROR: {
                LOGGER_API_INFO(tox, "got:ID_ERROR");
                if (!check_size(tox, it, &size_constraint, 1) ||
                        !check_enum_high(tox, it, MSI_E_UNDISCLOSED)) {
                    return -1;
                }

                dest->error.value = (MSIError)it[2];
                dest->error.exists = true;
                it += 3;
                break;
            }

            case ID_CAPABILITIES: {
                LOGGER_API_INFO(tox, "got:ID_CAPABILITIES");
                if (!check_size(tox, it, &size_constraint, 1)) {
                    return -1;
                }

                dest->capabilities.value = it[2];
                dest->capabilities.exists = true;
                it += 3;
                break;
            }

            default: {
                LOGGER_API_ERROR(tox, "Invalid id byte");
                return -1;
            }
        }
    }

    if (dest->request.exists == false) {
        LOGGER_API_ERROR(tox, "Invalid request field!");
        return -1;
    }

    return 0;
}

static uint8_t *msg_parse_header_out(MSIHeaderID id, uint8_t *dest, const void *value, uint8_t value_len,
                                     uint16_t *length)
{
    /* Parse a single header for sending */
    assert(dest);
    assert(value);
    assert(value_len);

    *dest = id;
    ++dest;
    *dest = value_len;
    ++dest;

    memcpy(dest, value, value_len);

    *length += (2 + value_len);

    return dest + value_len; /* Set to next position ready to be written */
}

/* Send an msi packet.
 *
 *  return 1 on success
 *  return 0 on failure
 */
static int m_msi_packet(Tox *tox, int32_t friendnumber, const uint8_t *data, uint16_t length)
{
    // TODO(Zoff): make this better later! -------------------
    /* we need to prepend 1 byte (packet id) to data
     * do this without calloc, memcpy and free in the future
     */
    size_t length_new = length + 1;
    uint8_t *data_new = (uint8_t *)calloc(length_new, sizeof(uint8_t));

    if (!data_new) {
        return 0;
    }

    data_new[0] = PACKET_ID_MSI;

    if (length != 0) {
        memcpy(data_new + 1, data, length);
    }

    TOX_ERR_FRIEND_CUSTOM_PACKET error;
    bool res1 = tox_friend_send_lossless_packet(tox, friendnumber, data_new, length_new, &error);
    LOGGER_API_INFO(tox, "tox_friend_send_lossless_packet:fnum=%d res1=%d error=%d", friendnumber, res1, error);

    free(data_new);

    if (error == TOX_ERR_FRIEND_CUSTOM_PACKET_OK) {
        return 1;
    }

    return 0;
}

static int send_message(Tox *tox, uint32_t friend_number, const MSIMessage *msg)
{
    assert(tox);

    /* Parse and send message */

    uint8_t parsed[MSI_MAXMSG_SIZE];

    uint8_t *it = parsed;
    uint16_t size = 0;

    if (msg->request.exists) {
        uint8_t cast = msg->request.value;
        it = msg_parse_header_out(ID_REQUEST, it, &cast,
                                  sizeof(cast), &size);
    } else {
        LOGGER_API_INFO(tox, "Must have request field");
        return -1;
    }

    if (msg->error.exists) {
        uint8_t cast = msg->error.value;
        it = msg_parse_header_out(ID_ERROR, it, &cast,
                                  sizeof(cast), &size);
    }

    if (msg->capabilities.exists) {
        it = msg_parse_header_out(ID_CAPABILITIES, it, &msg->capabilities.value,
                                  sizeof(msg->capabilities.value), &size);
    }

    if (it == parsed) {
        LOGGER_API_WARNING(tox, "Parsing message failed; empty message");
        return -1;
    }

    *it = 0;
    ++size;

    if (m_msi_packet(tox, friend_number, parsed, size)) {
        LOGGER_API_INFO(tox, "Sent message:fnum=%d", friend_number);
        return 0;
    }

    return -1;
}

static int send_error(Tox *tox, uint32_t friend_number, MSIError error)
{
    assert(tox);

    /* Send error message */

    LOGGER_API_INFO(tox, "Sending error: %d to friend: %d", error, friend_number);

    MSIMessage msg;
    msg_init(&msg, REQU_POP);

    msg.error.exists = true;
    msg.error.value = error;

    send_message(tox, friend_number, &msg);
    return 0;
}

int invoke_callback(MSICall *call, MSICallbackID cb)
{
    assert(call);

    if (call->session->callbacks[cb]) {
        LOGGER_API_INFO(call->session->tox, "Invoking callback function: %d", cb);

        if (call->session->callbacks[cb](call->session->av, call) != 0) {
            LOGGER_API_WARNING(call->session->tox,
                               "Callback state handling failed, sending error");
            goto FAILURE;
        }

        return 0;
    }

FAILURE:
    /* If no callback present or error happened while handling,
     * an error message will be sent to friend
     */

    if (call->error == MSI_E_NONE) {
        call->error = MSI_E_HANDLE;
    }

    return -1;
}

static MSICall *get_call(MSISession *session, uint32_t friend_number)
{
    assert(session);

    if (session->calls == nullptr || session->calls_tail < friend_number) {
        return nullptr;
    }

    return session->calls[friend_number];
}

static MSICall *new_call(MSISession *session, uint32_t friend_number)
{
    assert(session);

    LOGGER_API_INFO(session->tox, "new call:fnum=%d", friend_number);

    MSICall *rc = (MSICall *)calloc(1, sizeof(MSICall));

    if (rc == nullptr) {
        return nullptr;
    }

    rc->session = session;
    rc->friend_number = friend_number;

    if (session->calls == nullptr) { /* Creating */
        // TODO: this is totally broken
        session->calls = (MSICall **)calloc(friend_number + 1, sizeof(MSICall *));
        // TODO: this is totally broken


        if (session->calls == nullptr) {
            free(rc);
            return nullptr;
        }

        LOGGER_API_INFO(session->tox, "Creating:fnum=%d", friend_number);

        session->calls_tail = friend_number;
        session->calls_head = friend_number;

        LOGGER_API_INFO(session->tox, "Creating:fnum=%d h=%d t=%d bytes=%d",
                    friend_number,
                    session->calls_head,
                    session->calls_tail,
                    (int)((friend_number + 1) * sizeof(MSICall *)));

    } else if (friend_number > session->calls_tail) { /* Appending */
        // TODO: this is totally broken
        MSICall **tmp = (MSICall **)realloc(session->calls, sizeof(MSICall *) * (friend_number + 1));
        // TODO: this is totally broken

        if (tmp == nullptr) {
            free(rc);
            return nullptr;
        }

        session->calls = tmp;

        /* Set fields in between to null */
        for (uint32_t i = session->calls_tail + 1; i < friend_number; ++i) {
            session->calls[i] = nullptr;
        }

        LOGGER_API_INFO(session->tox, "Appending:fnum=%d", friend_number);

        rc->prev = session->calls[session->calls_tail];
        session->calls[session->calls_tail]->next = rc;

        session->calls_tail = friend_number;

        LOGGER_API_INFO(session->tox, "Appending:fnum=%d h=%d t=%d bytes=%d",
                    friend_number,
                    session->calls_head,
                    session->calls_tail,
                    (int)(sizeof(MSICall *) * (friend_number + 1)));        
        
    } else if (session->calls_head > friend_number) { /* Inserting at front */
        rc->next = session->calls[session->calls_head];

        LOGGER_API_INFO(session->tox, "Inserting at front:fnum=%d", friend_number);

        session->calls[session->calls_head]->prev = rc;
        session->calls_head = friend_number;

        LOGGER_API_INFO(session->tox, "Inserting at front:fnum=%d h=%d t=%d", friend_number, session->calls_head, session->calls_tail);        
    } else { /* right in the middle somewhere */
        // find the previous entry
        MSICall *found_prev_entry = nullptr;
        for (uint32_t i=session->calls_head;i<=session->calls_tail;i++)
        {
            if (session->calls[i])
            {
                if (i < friend_number)
                {
                    found_prev_entry = session->calls[i];
                }
                else
                {
                    break;
                }
            }
        }

        // find the next entry
        MSICall *found_next_entry = nullptr;
        for (uint32_t i=session->calls_head;i<=session->calls_tail;i++)
        {
            if (session->calls[i])
            {
                if (i > friend_number)
                {
                    found_next_entry = session->calls[i];
                    break;
                }
            }
        }

        // set chain-links correctly
        rc->prev = found_prev_entry;
        found_prev_entry->next = rc;
        //
        rc->next = found_next_entry;
        found_next_entry->prev = rc;

    }

    session->calls[friend_number] = rc;
    return rc;
}

void kill_call(MSICall *call)
{
    /* Assume that session mutex is locked */
    if (call == nullptr) {
        return;
    }

    MSISession *session = call->session;

    LOGGER_API_INFO(session->tox, "Killing call: %p", (void *)call);
    LOGGER_API_INFO(session->tox, "Killing call:session->calls[call->friend_number] NULL ...");
    session->calls[call->friend_number] = nullptr;

    MSICall *prev = call->prev;
    MSICall *next = call->next;

    if (prev) {
        prev->next = next;
    } else if (next) {
        session->calls_head = next->friend_number;
    } else {
        goto CLEAR_CONTAINER;
    }

    if (next) {
        next->prev = prev;
    } else if (prev) {
        session->calls_tail = prev->friend_number;
    } else {
        goto CLEAR_CONTAINER;
    }

    LOGGER_API_INFO(session->tox, "Killing call:1: free(call)");
    free(call);
    call = nullptr;
    return;

CLEAR_CONTAINER:
    session->calls_head = 0;
    session->calls_tail = 0;
    LOGGER_API_INFO(session->tox, "Killing call:2: free(session->calls)");
    free(session->calls);
    session->calls = nullptr;
    LOGGER_API_INFO(session->tox, "Killing call:2: free(call)");
    free(call);
    call = nullptr;
}


/*
 * INIT -> friend sent a message to us, and wants to initiate a call (e.g. friend is trying to call us)
 */
static void handle_init(MSICall *call, const MSIMessage *msg)
{
    assert(call);
    LOGGER_API_INFO(call->session->tox,
                     "Session: %p Handling 'init' friend: %d", (void *)call->session, call->friend_number);

    if (!msg->capabilities.exists) {
        LOGGER_API_WARNING(call->session->tox, "Session: %p Invalid capabilities on 'init'", (void *)call->session);
        call->error = MSI_E_INVALID_MESSAGE;
        goto FAILURE;
    }

    switch (call->state) {
        case MSI_CALL_INACTIVE: {
            /* Call requested */
            LOGGER_API_INFO(call->session->tox,"MSI_CALL_INACTIVE");
            call->peer_capabilities = msg->capabilities.value;
            call->state = MSI_CALL_REQUESTED;

            if (invoke_callback(call, MSI_ON_INVITE) == -1) {
                goto FAILURE;
            }
        }
        break;

        case MSI_CALL_REQUESTING: {
            /* Call starting */
            LOGGER_API_INFO(call->session->tox,"MSI_CALL_REQUESTING:Friend sent an invite, but we are waiting for an call answer to our call");

            /* if 2 friends call each other at the same time */
#if 1
            call->peer_capabilities = msg->capabilities.value;
            call->state = MSI_CALL_ACTIVE;

            if (invoke_callback(call, MSI_ON_START) == -1) {
                goto FAILURE;
            }

            // send the correct answer to the other friend
            MSIMessage out_msg;
            msg_init(&out_msg, REQU_PUSH);
            out_msg.capabilities.exists = true;
            out_msg.capabilities.value = call->self_capabilities;
            send_message(call->session->tox, call->friend_number, &out_msg);
#endif
        }
        break;

        case MSI_CALL_ACTIVE: {
            /* If peer sent init while the call is already
             * active it's probable that he is trying to
             * re-call us while the call is not terminated
             * on our side. We can assume that in this case
             * we can automatically answer the re-call.
             */

            LOGGER_API_INFO(call->session->tox, "MSI_CALL_ACTIVE:Friend is recalling us");

            MSIMessage out_msg;
            msg_init(&out_msg, REQU_PUSH);

            out_msg.capabilities.exists = true;
            out_msg.capabilities.value = call->self_capabilities;

            send_message(call->session->tox, call->friend_number, &out_msg);

            /* If peer changed capabilities during re-call they will
             * be handled accordingly during the next step
             */
        }
        break;

        case MSI_CALL_REQUESTED: {
            LOGGER_API_WARNING(call->session->tox, "MSI_CALL_REQUESTED:Session: %p Invalid state on 'init'", (void *)call->session);
            call->error = MSI_E_INVALID_STATE;
            goto FAILURE;
        }
    }

    return;
FAILURE:
    send_error(call->session->tox, call->friend_number, call->error);
    kill_call(call);
}

/*
 * PUSH -> friend sent a message to us (friend is sending some info, or answering our request to call him)
 */
static void handle_push(MSICall *call, const MSIMessage *msg)
{
    assert(call);

    LOGGER_API_INFO(call->session->tox, "Session: %p Handling 'push' friend: %d", (void *)call->session,
                     call->friend_number);

    if (!msg->capabilities.exists) {
        LOGGER_API_WARNING(call->session->tox, "Session: %p Invalid capabilities on 'push'", (void *)call->session);
        call->error = MSI_E_INVALID_MESSAGE;
        goto FAILURE;
    }

    switch (call->state) {
        case MSI_CALL_ACTIVE: {
            /* Only act if capabilities changed */
            if (call->peer_capabilities != msg->capabilities.value) {
                LOGGER_API_INFO(call->session->tox, "MSI_CALL_ACTIVE:Friend is changing capabilities to: %u", msg->capabilities.value);

                call->peer_capabilities = msg->capabilities.value;

                if (invoke_callback(call, MSI_ON_CAPABILITIES) == -1) {
                    goto FAILURE;
                }
            }
        }
        break;

        case MSI_CALL_REQUESTING: {
            LOGGER_API_INFO(call->session->tox, "MSI_CALL_REQUESTING:Friend answered our call");

            /* Call started */
            call->peer_capabilities = msg->capabilities.value;
            call->state = MSI_CALL_ACTIVE;

            if (invoke_callback(call, MSI_ON_START) == -1) {
                goto FAILURE;
            }
        }
        break;

        /* Pushes during initialization state are ignored */
        case MSI_CALL_INACTIVE: {
            LOGGER_API_WARNING(call->session->tox, "MSI_CALL_INACTIVE:Ignoring invalid push");
        }
        break;

        case MSI_CALL_REQUESTED: {
            LOGGER_API_WARNING(call->session->tox, "MSI_CALL_REQUESTED:Ignoring invalid push");
        }
        break;
    }

    return;

FAILURE:
    send_error(call->session->tox, call->friend_number, call->error);
    kill_call(call);
}

static void handle_pop(MSICall *call, const MSIMessage *msg)
{
    assert(call);

    LOGGER_API_INFO(call->session->tox, "Session: %p Handling 'pop', friend id: %d", (void *)call->session,
                     call->friend_number);

    /* callback errors are ignored */

    if (msg->error.exists) {
        LOGGER_API_WARNING(call->session->tox, "Friend detected an error: %d", msg->error.value);
        call->error = msg->error.value;
        invoke_callback(call, MSI_ON_ERROR);
    } else {
        switch (call->state) {
            case MSI_CALL_INACTIVE: {
                LOGGER_API_ERROR(call->session->tox, "MSI_CALL_INACTIVE:Handling what should be impossible case");
                abort();
            }

            case MSI_CALL_ACTIVE: {
                /* Hangup */
                LOGGER_API_INFO(call->session->tox, "MSI_CALL_ACTIVE:Friend hung up on us");
                invoke_callback(call, MSI_ON_END);
            }
            break;

            case MSI_CALL_REQUESTING: {
                /* Reject */
                LOGGER_API_INFO(call->session->tox, "MSI_CALL_REQUESTING:Friend rejected our call");
                invoke_callback(call, MSI_ON_END);
            }
            break;

            case MSI_CALL_REQUESTED: {
                /* Cancel */
                LOGGER_API_INFO(call->session->tox, "MSI_CALL_REQUESTED:Friend canceled call invite");
                invoke_callback(call, MSI_ON_END);
            }
            break;
        }
    }

    kill_call(call);
}

/* !!hack!! */
MSISession *tox_av_msi_get(ToxAV *av);

static void handle_msi_packet(Tox *tox, uint32_t friend_number, const uint8_t *data, size_t length2, void *object)
{
    if (length2 < 2) {
        // we need more than the ID byte for MSI messages
        return;
    }

    // Zoff: is this correct?
    uint16_t length = (uint16_t)(length2 - 1);

    // Zoff: do not show the first byte, its always "PACKET_ID_MSI"
    const uint8_t *data_strip_id_byte = (const uint8_t *)(data + 1);

    LOGGER_API_INFO(tox, "Got msi message:fnum=%d", friend_number);

    ToxAV *toxav = tox_get_av_object(tox);

    if (toxav == nullptr) {
        return;
    }

    MSISession *session = tox_av_msi_get(toxav);

    if (!session) {
        return;
    }

    MSIMessage msg;

    if (msg_parse_in(session->tox, &msg, data_strip_id_byte, length) == -1) {
        LOGGER_API_WARNING(tox, "Error parsing message");
        send_error(tox, friend_number, MSI_E_INVALID_MESSAGE);
        return;
    }

    LOGGER_API_INFO(tox, "Successfully parsed message:msg.request.value=%d", (int)msg.request.value);

    pthread_mutex_lock(session->mutex);
    MSICall *call = get_call(session, friend_number);

    if (call == nullptr) {
        if (msg.request.value != REQU_INIT) {
            // send_error(tox, friend_number, MSI_E_STRAY_MESSAGE); // MSI_E_STRAY_MESSAGE is never handled anywhere, so dont send it
            pthread_mutex_unlock(session->mutex);
            return;
        }

        call = new_call(session, friend_number);

        if (call == nullptr) {
            send_error(tox, friend_number, MSI_E_SYSTEM);
            pthread_mutex_unlock(session->mutex);
            return;
        }
    }

    switch (msg.request.value) {
        case REQU_INIT:
            handle_init(call, &msg);
            break;

        case REQU_PUSH:
            handle_push(call, &msg);
            break;

        case REQU_POP:
            handle_pop(call, &msg); /* always kills the call */
            break;
    }

    pthread_mutex_unlock(session->mutex);
}
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2018 The TokTok team.
 * Copyright © 2013 Tox project.
 * Copyright © 2013 plutooo
 */

#include <stdlib.h>

struct RingBuffer {
    uint16_t  size; /* Max size */
    uint16_t  start;
    uint16_t  end;
    uint64_t  *type;
    void    **data;
};

bool rb_full(const RingBuffer *b)
{
    return (b->end + 1) % b->size == b->start;
}

bool rb_empty(const RingBuffer *b)
{
    return b->end == b->start;
}

/*
 * returns: NULL on success
 *          oldest element on FAILURE -> caller must free it on failed rb_write
 */
void *rb_write(RingBuffer *b, void *p, uint64_t data_type_)
{
    void *rc = nullptr;

    if ((b->end + 1) % b->size == b->start) { /* full */
        rc = b->data[b->start];
    }

    b->data[b->end] = p;
    b->type[b->end] = data_type_;
    b->end = (b->end + 1) % b->size;

    if (b->end == b->start) {
        b->start = (b->start + 1) % b->size;
    }

    return rc;
}

bool rb_read(RingBuffer *b, void **p, uint64_t *data_type_)
{
    if (b->end == b->start) { /* Empty */
        *p = nullptr;
        return false;
    }

    *p = b->data[b->start];
    *data_type_ = b->type[b->start];

    b->start = (b->start + 1) % b->size;
    return true;
}

RingBuffer *rb_new(int size)
{
    RingBuffer *buf = (RingBuffer *)calloc(sizeof(RingBuffer), 1);

    if (!buf) {
        return nullptr;
    }

    buf->size = size + 1; /* include empty elem */
    buf->data = (void **)calloc(buf->size, sizeof(void *));

    if (!buf->data) {
        free(buf);
        return nullptr;
    }

    if (!(buf->type = (uint64_t *)calloc(buf->size, sizeof(uint64_t)))) {
        free(buf->data);
        free(buf);
        return nullptr;
    }

    return buf;
}

void rb_kill(RingBuffer *b)
{
    if (b) {
        free(b->data);
        free(b->type);
        free(b);
    }
}

uint16_t rb_size(const RingBuffer *b)
{
    if (rb_empty(b)) {
        return 0;
    }

    return
        b->end > b->start ?
        b->end - b->start :
        (b->size - b->start) + b->end;
}

uint16_t rb_data(const RingBuffer *b, void **dest)
{
    uint16_t i = 0;

    for (; i < rb_size(b); ++i) {
        dest[i] = b->data[(b->start + i) % b->size];
    }

    return i;
}
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2018 The TokTok team.
 * Copyright © 2013-2015 Tox project.
 */
#ifdef HAVE_CONFIG_H
#endif /* HAVE_CONFIG_H */


#include <assert.h>
#include <errno.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>



Mono_Time *toxav_get_av_mono_time(ToxAV *toxav);
int rtp_send_custom_lossy_packet(Tox *tox, int32_t friendnumber, const uint8_t *data, uint32_t length);
int rtp_send_custom_lossless_packet(Tox *tox, int32_t friendnumber, const uint8_t *data, uint32_t length);

#ifdef __cplusplus
extern "C" {
#endif
// for H264 ----------
#include <libavcodec/avcodec.h>
// for H264 ----------
#ifdef __cplusplus
}
#endif

#define DISABLE_H264_ENCODER_FEATURE    0

/*
 * return -1 on failure, 0 on success
 *
 */
int rtp_send_custom_lossy_packet(Tox *tox, int32_t friendnumber, const uint8_t *data, uint32_t length)
{
    TOX_ERR_FRIEND_CUSTOM_PACKET error;
    tox_friend_send_lossy_packet(tox, friendnumber, data, (size_t)length, &error);

    if (error == TOX_ERR_FRIEND_CUSTOM_PACKET_OK) {
        return 0;
    }

    return -1;
}

/*
 * return -1 on failure, 0 on success
 *
 */
int rtp_send_custom_lossless_packet(Tox *tox, int32_t friendnumber, const uint8_t *data, uint32_t length)
{
    TOX_ERR_FRIEND_CUSTOM_PACKET error;
    tox_friend_send_lossless_packet(tox, friendnumber, data, (size_t)length, &error);

    if (error == TOX_ERR_FRIEND_CUSTOM_PACKET_OK) {
        return 0;
    }

    return -1;
}

// allocate_len is NOT including header!
static struct RTPMessage *new_message(Tox *tox, const struct RTPHeader *header, size_t allocate_len,
                                      const uint8_t *data,
                                      uint16_t data_length)
{
    assert(allocate_len >= data_length);
    // AV_INPUT_BUFFER_PADDING_SIZE --> is needed later if we give it to ffmpeg!
    struct RTPMessage *msg = (struct RTPMessage *)calloc(1,
                             sizeof(struct RTPMessage) + allocate_len + AV_INPUT_BUFFER_PADDING_SIZE);

    if (msg == nullptr) {
        return nullptr;
    }

    msg->len = data_length; // result without header
    msg->header = *header;
    memcpy(msg->data, data, msg->len);
    return msg;
}

/**
 * Instruct the caller to clear slot 0.
 */
#define GET_SLOT_RESULT_DROP_OLDEST_SLOT (-1)

/**
 * Instruct the caller to drop the incoming packet.
 */
#define GET_SLOT_RESULT_DROP_INCOMING (-2)

/**
 * Find the next free slot in work_buffer for the incoming data packet.
 *
 * - If the data packet belongs to a frame that's already in the work_buffer then
 *   use that slot.
 * - If there is no free slot return GET_SLOT_RESULT_DROP_OLDEST_SLOT.
 * - If the data packet is too old return GET_SLOT_RESULT_DROP_INCOMING.
 *
 * If there is a keyframe being assembled in slot 0, keep it a bit longer and
 * do not kick it out right away if all slots are full instead kick out the new
 * incoming interframe.
 */
static int8_t get_slot(Tox *tox, struct RTPWorkBufferList *wkbl, bool is_keyframe,
                       const struct RTPHeader *header, bool is_multipart)
{

    if (wkbl->next_free_entry == 0) {
        // the work buffer is completely empty
        // just return the first slot then
        LOGGER_API_DEBUG(tox, "get_slot:work buffer empty");
        return 0;
    }

    if (is_multipart) {
        // This RTP message is part of a multipart frame, so we try to find an
        // existing slot with the previous parts of the frame in it.
        for (uint8_t i = 0; i < wkbl->next_free_entry; ++i) {
            const struct RTPWorkBuffer *slot = &wkbl->work_buffer[i];

            if ((slot->buf->header.sequnum == header->sequnum) && (slot->buf->header.timestamp == header->timestamp)) {
                // Sequence number and timestamp match, so this slot belongs to
                // the same frame.
                //
                // In reality, these will almost certainly either both match or
                // both not match. Only if somehow there were 65535 frames
                // between, the timestamp will matter.
                LOGGER_API_DEBUG(tox, "get_slot:found slot num %d", (int)i);
                return i;
            }
        }
    }

    // The message may or may not be part of a multipart frame.
    //
    // If it is part of a multipart frame, then this is an entirely new frame
    // for which we did not have a slot *or* the frame is so old that its slot
    // has been evicted by now.
    //
    //        |----------- time ----------->
    //        _________________
    // slot 0 |               |
    //        -----------------
    //                     _________________
    // slot 1              |               |
    //                     -----------------
    //                ____________
    // slot 2         |          | -> frame too old, drop
    //                ------------
    //
    //
    //
    //        |----------- time ----------->
    //        _________________
    // slot 0 |               |
    //        -----------------
    //                     _________________
    // slot 1              |               |
    //                     -----------------
    //                              ____________
    // slot 2                       |          | -> ok, start filling in a new slot
    //                              ------------

    // If there is a free slot:
    if (wkbl->next_free_entry < USED_RTP_WORKBUFFER_COUNT) {
        // If there is at least one filled slot:
        if (wkbl->next_free_entry > 0) {
            // Get the most recently filled slot.
            const struct RTPWorkBuffer *slot = &wkbl->work_buffer[wkbl->next_free_entry - 1];
        }

        // Not all slots are filled, and the packet is newer than our most
        // recent slot, so it's a new frame we want to start assembling. This is
        // the second situation in the above diagram.
        LOGGER_API_DEBUG(tox, "get_slot:slot=%d", (int)wkbl->next_free_entry);
        return wkbl->next_free_entry;
    }

    LOGGER_API_DEBUG(tox, "get_slot:slot=GET_SLOT_RESULT_DROP_OLDEST_SLOT");
    return GET_SLOT_RESULT_DROP_OLDEST_SLOT;
}

/**
 * Returns an assembled frame (as much data as we currently have for this frame,
 * some pieces may be missing)
 *
 * If there are no frames ready, we return NULL. If this function returns
 * non-NULL, it transfers ownership of the message to the caller, i.e. the
 * caller is responsible for storing it elsewhere or calling free().
 */
static struct RTPMessage *process_frame(Tox *tox, struct RTPWorkBufferList *wkbl, uint8_t slot_id)
{
    assert(wkbl->next_free_entry >= 0);
    LOGGER_API_DEBUG(tox, "process_frame:slot_id=%d", (int)slot_id);

    if (wkbl->next_free_entry == 0) {
        // There are no frames in any slot.
        LOGGER_API_DEBUG(tox, "process_frame:workbuffer empty");
        return nullptr;
    }

    // Either slot_id is 0 and slot 0 is a key frame, or there is no key frame
    // in slot 0 (and slot_id is anything).
    struct RTPWorkBuffer *const slot = &wkbl->work_buffer[slot_id];

    // Move ownership of the frame out of the slot into m_new.
    struct RTPMessage *const m_new = slot->buf;

    slot->buf = nullptr;
    assert(wkbl->next_free_entry >= 1);

    if (slot_id != wkbl->next_free_entry - 1) {
        // The slot is not the last slot, so we created a gap. We move all the
        // entries after it one step up.
        for (uint8_t i = slot_id; i < wkbl->next_free_entry - 1; ++i) {
            // Move entry (i+1) into entry (i).
            wkbl->work_buffer[i] = wkbl->work_buffer[i + 1];
        }
    }

    // We now have a free entry at the end of the array.
    --wkbl->next_free_entry;

    // Clear the newly freed entry.
    const struct RTPWorkBuffer empty = {0};
    wkbl->work_buffer[wkbl->next_free_entry] = empty;

    // Move ownership of the frame to the caller.
    return m_new;
}

/**
 * @param tox pointer to Tox
 * @param wkbl The list of in-progress frames, i.e. all the slots.
 * @param slot_id The slot we want to fill the data into.
 * @param is_keyframe Whether the data is part of a key frame.
 * @param header The RTP header from the incoming packet.
 * @param incoming_data The pure payload without header.
 * @param incoming_data_length The length in bytes of the incoming data payload.
 */
static bool fill_data_into_slot(Tox *tox, struct RTPWorkBufferList *wkbl, const uint8_t slot_id, bool is_keyframe,
                                const struct RTPHeader *header, const uint8_t *incoming_data, uint16_t incoming_data_length)
{
    // We're either filling the data into an existing slot, or in a new one that
    // is the next free entry.
    assert(slot_id <= wkbl->next_free_entry);
    struct RTPWorkBuffer *const slot = &wkbl->work_buffer[slot_id];

    assert(header != nullptr);

    if (slot->received_len == 0) {
        assert(slot->buf == nullptr);

        // No data for this slot has been received, yet, so we create a new
        // message for it with enough memory for the entire frame.
        // AV_INPUT_BUFFER_PADDING_SIZE --> is needed later if we give it to ffmpeg!
        struct RTPMessage *msg = (struct RTPMessage *)calloc(1,
                                 sizeof(struct RTPMessage) + header->data_length_full + AV_INPUT_BUFFER_PADDING_SIZE);

        if (msg == nullptr) {
            LOGGER_API_DEBUG(tox, "Out of memory while trying to allocate for frame of size %u\n",
                         (unsigned)header->data_length_full);
            // Out of memory: throw away the incoming data.
            return false;
        }

        // Unused in the new video receiving code, as it's 16 bit and can't hold
        // the full length of large frames. Instead, we use slot->received_len.
        msg->len = 0;
        msg->header = *header;

        slot->buf = msg;
        slot->is_keyframe = is_keyframe;
        slot->received_len = 0;

        assert(wkbl->next_free_entry < USED_RTP_WORKBUFFER_COUNT);
        ++wkbl->next_free_entry;
    }

    // Copy the incoming chunk of data into the correct position in the full
    // frame data array.
    memcpy(
        slot->buf->data + header->offset_full,
        incoming_data,
        incoming_data_length
    );

    // Update the total received length of this slot.
    slot->received_len += incoming_data_length;

    // Update received length also in the header of the message, for later use.
    slot->buf->header.received_length_full = slot->received_len;

    LOGGER_API_DEBUG(tox, "FPATH:slot num=%d:VSEQ:%d %d/%d", slot_id, (int)header->sequnum,
                 (int)slot->received_len, (int)header->data_length_full);

    return slot->received_len == header->data_length_full;
}

static Mono_Time *rtp_get_mono_time_from_rtpsession(RTPSession *session)
{
    if (!session) {
        return NULL;
    }

    if (!session->toxav) {
        return NULL;
    }

    return toxav_get_av_mono_time(session->toxav);
}

/**
 * Handle a single RTP video packet.
 *
 * The packet may or may not be part of a multipart frame. This function will
 * find out and handle it appropriately.
 *
 * @param session The current RTP session with:
 *   <code>
 *   session->mcb == vc_queue_message() // this function is called from here
 *   session->mp == struct RTPMessage *
 *   session->cs == call->video.second // == VCSession created by vc_new() call
 *   </code>
 * @param header The RTP header deserialised from the packet.
 * @param incoming_data The packet data *not* header, i.e. this is the actual
 *   payload.
 * @param incoming_data_length The packet length *not* including header, i.e.
 *   this is the actual payload length.
 *
 * @return -1 on error, 0 on success.
 */
static int handle_video_packet(RTPSession *session, const struct RTPHeader *header,
                               const uint8_t *incoming_data, uint16_t incoming_data_length, const Logger *log)
{
    // Full frame length in bytes. The frame may be split into multiple packets,
    // but this value is the complete assembled frame size.
    const uint32_t full_frame_length = header->data_length_full;

    // Current offset in the frame. If this is the first packet of a multipart
    // frame or it's not a multipart frame, then this value is 0.
    const uint32_t offset = header->offset_full; // without header

    if (!session) {
        return -1;
    }

    LOGGER_API_DEBUG(session->tox, "FPATH:%d", (int)header->sequnum);

    // sanity checks ---------------
    if (full_frame_length == 0) {
        return -1;
    }

    if (offset == full_frame_length) {
        return -1;
    }

    if (offset > full_frame_length) {
        return -1;
    }
    // sanity checks ---------------

    const bool is_keyframe = 0;
    const bool is_multipart = (full_frame_length != incoming_data_length);

    /* The message was sent in single part */
    int8_t slot_id = get_slot(session->tox, session->work_buffer_list, is_keyframe, header, is_multipart);

    // get_slot told us to drop the packet, so we ignore it.
    if (slot_id == GET_SLOT_RESULT_DROP_INCOMING) {
        return -1;
    }

    // get_slot said there is no free slot.
    if (slot_id == GET_SLOT_RESULT_DROP_OLDEST_SLOT) {
        // We now own the frame.
        struct RTPMessage *m_new = process_frame(session->tox, session->work_buffer_list, 0);

        // The process_frame function returns NULL if there is no slot 0, i.e.
        // the work buffer list is completely empty. It can't be empty, because
        // get_slot just told us it's full, so process_frame must return non-null.
        assert(m_new != nullptr);

        // Pass ownership of m_new to the callback.
        session->mcb(rtp_get_mono_time_from_rtpsession(session), session->cs, m_new);
        // Now we no longer own m_new.
        m_new = nullptr;

        // Now we must have a free slot, so we either get that slot, i.e. >= 0,
        // or get told to drop the incoming packet if it's too old.
        slot_id = get_slot(session->tox, session->work_buffer_list, is_keyframe, header, /* is_multipart */false);

        if (slot_id == GET_SLOT_RESULT_DROP_INCOMING) {
            // The incoming frame is too old, so we drop it.
            return -1;
        }
    }

    // We must have a valid slot here.
    assert(slot_id >= 0);

    // fill in this part into the slot buffer at the correct offset
    if (!fill_data_into_slot(
                session->tox,
                session->work_buffer_list,
                slot_id,
                is_keyframe,
                header,
                incoming_data,
                incoming_data_length)) {

        return -1;
    }

    if (slot_id > 0) {
        // check if there are old messages lingering in the buffer
        struct RTPWorkBufferList *wkbl = session->work_buffer_list;
        struct RTPWorkBuffer *const slot0 = &wkbl->work_buffer[0];
        struct RTPMessage *const m_new0 = slot0->buf;
        struct RTPWorkBuffer *const slot2 = &wkbl->work_buffer[slot_id];
        struct RTPMessage *const m_new2 = slot2->buf;

        if ((m_new0) && (m_new2)) {
            if ((m_new0->header.sequnum + 2) < m_new2->header.sequnum) {
                // change slot_id to "0" to process oldest frame in buffer instead of current one
                struct RTPMessage *m_new = process_frame(session->tox, session->work_buffer_list, slot_id);

                if (m_new) {
                    session->mcb(rtp_get_mono_time_from_rtpsession(session), session->cs, m_new);
                    m_new = NULL;
                }

                slot_id = 0;
            }
        }
    }

    struct RTPMessage *m_new = process_frame(session->tox, session->work_buffer_list, slot_id);

    if (m_new) {
        session->mcb(rtp_get_mono_time_from_rtpsession(session), session->cs, m_new);
        m_new = nullptr;
    }

    return 0;
}

/**
 * receive custom lossypackets and process them. they can be incoming audio or video packets
 *
 *   <code>
 *   session->mcb == vc_queue_message() // this function is called from here
 *   session->mp == struct RTPMessage *
 *   session->cs == call->video.second // == VCSession created by vc_new() call
 *   </code>
 *
 */
void handle_rtp_packet(Tox *tox, uint32_t friendnumber, const uint8_t *data, size_t length, void *dummy)
{
    if (!data) {
        return;
    }

    if (length < 1) {
        return;
    }

    // Get the packet type.
    uint8_t packet_type = data[0];

    // only check data length on audio or video pakets
    // PACKET_TOXAV_COMM_CHANNEL pakets do not have an RTP header
    if (packet_type != PACKET_TOXAV_COMM_CHANNEL) {
        if (length < RTP_HEADER_SIZE + 1) {
            LOGGER_API_DEBUG(tox, "Invalid length of received buffer! length=%d RTP_HEADER_SIZE=%d", (int)length, RTP_HEADER_SIZE);
            return;
        }
    }

    ToxAV *toxav = tox_get_av_object(tox);

    if (toxav == nullptr) {
        return;
    }

    pthread_mutex_t *endcall_mutex = NULL;
    endcall_mutex = (void *)endcall_mutex_get(toxav);

    if (!endcall_mutex) {
        return;
    }


    if (pthread_mutex_trylock(endcall_mutex) != 0) {
        LOGGER_API_DEBUG(tox, "could not lock mutex, we are ending a call");
        return;
    }

    void *call = NULL;
    call = (void *)call_get(toxav, friendnumber);

    if (!call) {
        pthread_mutex_unlock(endcall_mutex);
        return;
    }

    RTPSession *session = NULL;

    if (packet_type == PACKET_TOXAV_COMM_CHANNEL) {
        // for PACKET_TOXAV_COMM_CHANNEL we need the video session
        session = rtp_session_get(call, RTP_TYPE_VIDEO);
    } else {
        session = rtp_session_get(call, packet_type);
    }

    if (!session) {
        LOGGER_API_ERROR(tox, "No session!");
        pthread_mutex_unlock(endcall_mutex);
        return;
    }

    if ((!session) && (!session->rtp_receive_active)) {
        LOGGER_API_WARNING(tox, "receiving not allowed!");
        pthread_mutex_unlock(endcall_mutex);
        return;
    }


    // ========== PACKET_TOXAV_COMM_CHANNEL paket handling ==========
    // ========== PACKET_TOXAV_COMM_CHANNEL paket handling ==========
    if (packet_type == PACKET_TOXAV_COMM_CHANNEL) {
        pthread_mutex_lock(call_mutex_get(call));

        if (length >= 2) {
            if (data[1] == PACKET_TOXAV_COMM_CHANNEL_REQUEST_KEYFRAME) {
                if (session->cs) {
                    ((VCSession *)(session->cs))->send_keyframe_request_received = 1;
                }
            } else if (data[1] == PACKET_TOXAV_COMM_CHANNEL_HAVE_H264_VIDEO) {
                if (session->cs) {
                    if (DISABLE_H264_ENCODER_FEATURE == 0) {
                        ((VCSession *)(session->cs))->h264_video_capabilities_received = 1;
                    }
                }
            } else if ((data[1] == PACKET_TOXAV_COMM_CHANNEL_DUMMY_NTP_REQUEST) && (length == 14)) {

                uint32_t pkg_buf_len = (sizeof(uint32_t) * 3) + 2;
                uint8_t pkg_buf[pkg_buf_len];
                pkg_buf[0] = PACKET_TOXAV_COMM_CHANNEL;
                pkg_buf[1] = PACKET_TOXAV_COMM_CHANNEL_DUMMY_NTP_ANSWER;
                uint32_t tmp = current_time_monotonic(rtp_get_mono_time_from_rtpsession(session));
                pkg_buf[2] = data[2];
                pkg_buf[3] = data[3];
                pkg_buf[4] = data[4];
                pkg_buf[5] = data[5];
                //
                pkg_buf[6] = tmp >> 24 & 0xFF;
                pkg_buf[7] = tmp >> 16 & 0xFF;
                pkg_buf[8] = tmp >> 8  & 0xFF;
                pkg_buf[9] = tmp       & 0xFF;
                tmp = tmp + 1; // add 1 ms delay between receiving answer and sending response
                pkg_buf[10] = tmp >> 24 & 0xFF;
                pkg_buf[11] = tmp >> 16 & 0xFF;
                pkg_buf[12] = tmp >> 8  & 0xFF;
                pkg_buf[13] = tmp       & 0xFF;

                int result = rtp_send_custom_lossless_packet(tox, friendnumber, pkg_buf, pkg_buf_len);
                LOGGER_API_DEBUG(tox, "TTTTTR:002:result=%d pkg_buf_len=%d", result, pkg_buf_len);

            } else if ((data[1] == PACKET_TOXAV_COMM_CHANNEL_DUMMY_NTP_ANSWER) && (length == 14)) {

                ((VCSession *)(session->cs))->dummy_ntp_local_start =
                    ((uint32_t)(data[2]) << 24)
                    +
                    ((uint32_t)(data[3]) << 16)
                    +
                    ((uint32_t)(data[4]) << 8)
                    +
                    (data[5]);

                ((VCSession *)(session->cs))->dummy_ntp_remote_start =
                    ((uint32_t)data[6] << 24)
                    +
                    ((uint32_t)data[7] << 16)
                    +
                    ((uint32_t)data[8] << 8)
                    +
                    (data[9]);

                ((VCSession *)(session->cs))->dummy_ntp_remote_end =
                    ((uint32_t)data[10] << 24)
                    +
                    ((uint32_t)data[11] << 16)
                    +
                    ((uint32_t)data[12] << 8)
                    +
                    (data[13]);

                ((VCSession *)(session->cs))->dummy_ntp_local_end = current_time_monotonic(rtp_get_mono_time_from_rtpsession(session));

#define NETWORK_ROUND_TRIP_MAX_VALID_MS 2000

                LOGGER_API_DEBUG(tox, "TTTTTR:data:le:%d ls:%d delta=%d",
                    (int32_t)((VCSession *)(session->cs))->dummy_ntp_local_end,
                    (int32_t)((VCSession *)(session->cs))->dummy_ntp_local_start,
                    ( (int32_t)((VCSession *)(session->cs))->dummy_ntp_local_end - (int32_t)((VCSession *)(session->cs))->dummy_ntp_local_start )
                    );

                if (
                    (( (int32_t)((VCSession *)(session->cs))->dummy_ntp_local_end - (int32_t)((VCSession *)(session->cs))->dummy_ntp_local_start ) > NETWORK_ROUND_TRIP_MAX_VALID_MS)
                     ||
                    (( (int32_t)((VCSession *)(session->cs))->dummy_ntp_local_end - (int32_t)((VCSession *)(session->cs))->dummy_ntp_local_start ) < 1)
                   )
                {
                    uint32_t roundtrip_too_long = dntp_calc_roundtrip_delay(((VCSession *)(session->cs))->dummy_ntp_remote_start,
                                          ((VCSession *)(session->cs))->dummy_ntp_remote_end,
                                          ((VCSession *)(session->cs))->dummy_ntp_local_start,
                                          ((VCSession *)(session->cs))->dummy_ntp_local_end);
                    LOGGER_API_DEBUG(tox, "TTTTTR:too long: %d", roundtrip_too_long);
                }
                else
                {
                    int64_t offset_ = dntp_calc_offset(((VCSession *)(session->cs))->dummy_ntp_remote_start,
                                                       ((VCSession *)(session->cs))->dummy_ntp_remote_end,
                                                       ((VCSession *)(session->cs))->dummy_ntp_local_start,
                                                       ((VCSession *)(session->cs))->dummy_ntp_local_end);

                    uint32_t roundtrip_ = dntp_calc_roundtrip_delay(((VCSession *)(session->cs))->dummy_ntp_remote_start,
                                          ((VCSession *)(session->cs))->dummy_ntp_remote_end,
                                          ((VCSession *)(session->cs))->dummy_ntp_local_start,
                                          ((VCSession *)(session->cs))->dummy_ntp_local_end);

#define NETWORK_ROUND_TRIP_CHANGE_THRESHOLD_MS 10
#define NETWORK_ROUND_TRIP_FUZZ_THRESHOLD_MS 150
#define NETWORK_NTP_JUMP_MS 100

                    if (roundtrip_ > (((VCSession *)(session->cs))->rountrip_time_ms + NETWORK_ROUND_TRIP_CHANGE_THRESHOLD_MS)) {
                        if (roundtrip_ > ((((VCSession *)(session->cs))->rountrip_time_ms) + NETWORK_ROUND_TRIP_FUZZ_THRESHOLD_MS)) {
                            ((VCSession *)(session->cs))->rountrip_time_ms = ((VCSession *)(session->cs))->rountrip_time_ms + 40;
                        } else {
                            ((VCSession *)(session->cs))->rountrip_time_ms++;
                        }
                    } else if ((roundtrip_ + NETWORK_ROUND_TRIP_CHANGE_THRESHOLD_MS) < ((VCSession *)(session->cs))->rountrip_time_ms) {
                        if ((roundtrip_ + NETWORK_ROUND_TRIP_FUZZ_THRESHOLD_MS) < ((VCSession *)(session->cs))->rountrip_time_ms) {
                            ((VCSession *)(session->cs))->rountrip_time_ms = ((VCSession *)(session->cs))->rountrip_time_ms - 40;
                        } else {
                            ((VCSession *)(session->cs))->rountrip_time_ms--;
                        }
                    }

                    ((VCSession *)(session->cs))->has_rountrip_time_ms = 1;
                    LOGGER_API_DEBUG(tox, "TTTTTR:ok__:value=%d", (int)((VCSession *)(session->cs))->rountrip_time_ms);
                    int64_t *ptmp = &(((VCSession *)(session->cs))->timestamp_difference_to_sender__for_video);
                    bool res4 = dntp_drift(ptmp, offset_, (int64_t)NETWORK_NTP_JUMP_MS, (int)NETWORK_ROUND_TRIP_CHANGE_THRESHOLD_MS);
                }
            }
        }

        pthread_mutex_unlock(call_mutex_get(call));
        pthread_mutex_unlock(endcall_mutex);
        return;
    }
    // ========== PACKET_TOXAV_COMM_CHANNEL paket handling ==========
    // ========== PACKET_TOXAV_COMM_CHANNEL paket handling ==========

    ++data;
    --length;

    // Unpack the header.
    struct RTPHeader header;
    rtp_header_unpack(data, &header);

    if (header.pt != packet_type % 128) {
        LOGGER_API_WARNING(tox, "RTPHeader packet type and Tox protocol packet type did not agree: %d != %d",
                         header.pt, packet_type % 128);
        pthread_mutex_unlock(endcall_mutex);
        return;
    }

    if (header.pt != session->payload_type % 128) {
        LOGGER_API_WARNING(tox, "RTPHeader packet type does not match this session's payload type: %d != %d",
                         header.pt, session->payload_type % 128);
        pthread_mutex_unlock(endcall_mutex);
        return;
    }

    if (header.offset_full >= header.data_length_full
            && (header.offset_full != 0 || header.data_length_full != 0)) {
        LOGGER_API_ERROR(tox, "Invalid video packet: frame offset (%u) >= full frame length (%u)",
                         (unsigned)header.offset_full, (unsigned)header.data_length_full);
        pthread_mutex_unlock(endcall_mutex);
        return;
    }

    if (!(header.flags & RTP_LARGE_FRAME)) {
        if (header.offset_lower >= header.data_length_lower) {
            LOGGER_API_ERROR(tox, "Invalid old protocol video packet: frame offset (%u) >= full frame length (%u)",
                             (unsigned)header.offset_lower, (unsigned)header.data_length_lower);
            pthread_mutex_unlock(endcall_mutex);
            return;
        }
    }

    LOGGER_API_DEBUG(tox, "header.pt %d, video %d sequnum %d", (uint8_t)header.pt, (RTP_TYPE_VIDEO % 128), (int)header.sequnum);
    LOGGER_API_DEBUG(tox, "rtp packet record time: %lu", (unsigned long)header.frame_record_timestamp);
    LOGGER_API_DEBUG(tox, "RTP_ENCODER_HAS_RECORD_TIMESTAMP:fl=%d %d", (int)header.flags, (int)RTP_ENCODER_HAS_RECORD_TIMESTAMP);

    // check flag indicating that we have real record-timestamps for frames ---
    if (!(header.flags & RTP_ENCODER_HAS_RECORD_TIMESTAMP)) {
        if (header.pt == (RTP_TYPE_VIDEO % 128)) {
            pthread_mutex_lock(call_mutex_get(call));
            ((VCSession *)(session->cs))->encoder_frame_has_record_timestamp = 0;
            pthread_mutex_unlock(call_mutex_get(call));
        } else if (header.pt == (RTP_TYPE_AUDIO % 128)) {
            pthread_mutex_lock(call_mutex_get(call));
            ((ACSession *)(session->cs))->encoder_frame_has_record_timestamp = 0;
            pthread_mutex_unlock(call_mutex_get(call));
        }
    }

    if (header.pt == (RTP_TYPE_VIDEO % 128)) {
        pthread_mutex_lock(call_mutex_get(call));
        ((VCSession *)(session->cs))->remote_client_video_capture_delay_ms = header.client_video_capture_delay_ms;
        pthread_mutex_unlock(call_mutex_get(call));
    }


    // HINT: ask sender for dummy ntp values -------------
    if (
        (
            ((header.sequnum % 60) == 0)
            ||
            (header.sequnum < 10)
        )
        && (header.offset_lower == 0)) {
        uint32_t pkg_buf_len = (sizeof(uint32_t) * 3) + 2;
        uint8_t pkg_buf[pkg_buf_len];
        pkg_buf[0] = PACKET_TOXAV_COMM_CHANNEL;
        pkg_buf[1] = PACKET_TOXAV_COMM_CHANNEL_DUMMY_NTP_REQUEST;
        if (session) {
            pthread_mutex_lock(call_mutex_get(call));
            uint32_t tmp = current_time_monotonic(rtp_get_mono_time_from_rtpsession(session));
            pthread_mutex_unlock(call_mutex_get(call));
            pkg_buf[2] = tmp >> 24 & 0xFF;
            pkg_buf[3] = tmp >> 16 & 0xFF;
            pkg_buf[4] = tmp >> 8  & 0xFF;
            pkg_buf[5] = tmp       & 0xFF;

            int result = rtp_send_custom_lossless_packet(tox, friendnumber, pkg_buf, pkg_buf_len);
            LOGGER_API_DEBUG(tox, "TTTTTR:DUMMY_NTP_REQUEST sent: res=%d", result);
        }
    }
    // HINT: ask sender for dummy ntp values -------------


    // The sender uses the new large-frame capable protocol and is sending a
    // video packet.
    if ((header.flags & RTP_LARGE_FRAME) && (header.pt == (RTP_TYPE_VIDEO % 128))) {

        pthread_mutex_lock(call_mutex_get(call));

        if (session->incoming_packets_ts_last_ts == -1) {
            session->incoming_packets_ts[session->incoming_packets_ts_index] = 0;
            session->incoming_packets_ts_average = 0;
        } else {
            session->incoming_packets_ts[session->incoming_packets_ts_index] = current_time_monotonic(
                        rtp_get_mono_time_from_rtpsession(session)) -
                    session->incoming_packets_ts_last_ts;
        }

        session->incoming_packets_ts_last_ts = current_time_monotonic(rtp_get_mono_time_from_rtpsession(session));
        session->incoming_packets_ts_index++;

        if (session->incoming_packets_ts_index >= INCOMING_PACKETS_TS_ENTRIES) {
            session->incoming_packets_ts_index = 0;
        }

        uint32_t incoming_rtp_packets_delta_average = 0;

        for (int ii = 0; ii < INCOMING_PACKETS_TS_ENTRIES; ii++) {
            incoming_rtp_packets_delta_average = incoming_rtp_packets_delta_average + session->incoming_packets_ts[ii];
        }

        incoming_rtp_packets_delta_average = incoming_rtp_packets_delta_average / INCOMING_PACKETS_TS_ENTRIES;
        session->incoming_packets_ts_average = incoming_rtp_packets_delta_average;
        pthread_mutex_unlock(call_mutex_get(call));

        handle_video_packet(session, &header, data + RTP_HEADER_SIZE, length - RTP_HEADER_SIZE, nullptr);
        pthread_mutex_unlock(endcall_mutex);
        return;
    }

    // everything below here is for the old 16 bit protocol ------------------


    /*
     * just process any incoming audio packets ----
     */
    if (header.data_length_lower == length - RTP_HEADER_SIZE) {
        /* The message is sent in single part */

        /*
         *   session->mcb == ac_queue_message() // this function is called from here
         *   session->mp  == struct RTPMessage *
         *   session->cs  == call->audio.second // == ACSession
         */

        session->rsequnum = header.sequnum;
        session->rtimestamp = header.timestamp;

        /* Invoke processing of active multiparted message */
        if (session->mp) {
            session->mcb(rtp_get_mono_time_from_rtpsession(session), session->cs, session->mp);
            session->mp = nullptr;
        }

        /* The message came in the allowed time;
         */

        session->mp = new_message(tox, &header, length - RTP_HEADER_SIZE, data + RTP_HEADER_SIZE, length - RTP_HEADER_SIZE);
        session->mcb(rtp_get_mono_time_from_rtpsession(session), session->cs, session->mp);
        session->mp = nullptr;
        pthread_mutex_unlock(endcall_mutex);
        return;
    }

    /*
     * just process any incoming audio packets ----
     */

    /* The message is sent in multiple parts */

    if (session->mp) {
        /* There are 2 possible situations in this case:
         *      1) being that we got the part of already processing message.
         *      2) being that we got the part of a new/old message.
         *
         * We handle them differently as we only allow a single multiparted
         * processing message
         */
        if (session->mp->header.sequnum == header.sequnum &&
                session->mp->header.timestamp == header.timestamp) {
            /* First case */

            /* Make sure we have enough allocated memory */
            if (session->mp->header.data_length_lower - session->mp->len < (int)(length - RTP_HEADER_SIZE) ||
                    session->mp->header.data_length_lower <= header.offset_lower) {
                /* There happened to be some corruption on the stream;
                 * continue wihtout this part
                 */
                pthread_mutex_unlock(endcall_mutex);
                return;
            }

            memcpy(session->mp->data + header.offset_lower, data + RTP_HEADER_SIZE,
                   length - RTP_HEADER_SIZE);
            session->mp->len += length - RTP_HEADER_SIZE;

            if (session->mp->len == session->mp->header.data_length_lower) {
                /* Received a full message; now push it for the further
                 * processing.
                 */
                session->mcb(rtp_get_mono_time_from_rtpsession(session), session->cs, session->mp);
                session->mp = nullptr;
            }
        } else {
            /* Second case */
            if (session->mp->header.timestamp > header.timestamp) {
                /* The received message part is from the old message;
                 * discard it.
                 */
                pthread_mutex_unlock(endcall_mutex);
                return;
            }

            /* Push the previous message for processing */
            session->mcb(rtp_get_mono_time_from_rtpsession(session), session->cs, session->mp);
            session->mp = nullptr;

            goto NEW_MULTIPARTED;
        }
    } else {
        /* In this case treat the message as if it was received in order
         */
        /* This is also a point for new multiparted messages */
NEW_MULTIPARTED:

        /* Message is not late; pick up the latest parameters */
        session->rsequnum = header.sequnum;
        session->rtimestamp = header.timestamp;

        /* Store message.
         */
        session->mp = new_message(tox, &header, header.data_length_lower, data + RTP_HEADER_SIZE, length - RTP_HEADER_SIZE);
        memmove(session->mp->data + header.offset_lower, session->mp->data, session->mp->len);
    }

    pthread_mutex_unlock(endcall_mutex);
}

size_t rtp_header_pack(uint8_t *const rdata, const struct RTPHeader *header)
{
    uint8_t *p = rdata;
    *p = (header->ve & 3) << 6
         | (header->pe & 1) << 5
         | (header->xe & 1) << 4
         | (header->cc & 0xf);
    ++p;
    *p = (header->ma & 1) << 7
         | (header->pt & 0x7f);
    ++p;

    p += net_pack_u16(p, header->sequnum);
    p += net_pack_u32(p, header->timestamp);
    p += net_pack_u32(p, header->ssrc);
    p += net_pack_u64(p, header->flags);
    p += net_pack_u32(p, header->offset_full);
    p += net_pack_u32(p, header->data_length_full);
    p += net_pack_u32(p, header->received_length_full);

    // ---------------------------- //
    //      custom fields here      //
    // ---------------------------- //
    p += net_pack_u64(p, header->frame_record_timestamp);
    p += net_pack_u32(p, header->fragment_num);
    p += net_pack_u32(p, header->real_frame_num);
    p += net_pack_u32(p, header->encoder_bit_rate_used);
    p += net_pack_u32(p, header->client_video_capture_delay_ms);
    p += net_pack_u32(p, header->rtp_packet_number);
    // ---------------------------- //
    //      custom fields here      //
    // ---------------------------- //

    for (size_t i = 0; i < RTP_PADDING_FIELDS; ++i) {
        p += net_pack_u32(p, 0);
    }

    p += net_pack_u16(p, header->offset_lower);
    p += net_pack_u16(p, header->data_length_lower);
    assert(p == rdata + RTP_HEADER_SIZE);
    return p - rdata;
}

size_t rtp_header_unpack(const uint8_t *data, struct RTPHeader *header)
{
    const uint8_t *p = data;
    header->ve = (*p >> 6) & 3;
    header->pe = (*p >> 5) & 1;
    header->xe = (*p >> 4) & 1;
    header->cc = *p & 0xf;
    ++p;

    header->ma = (*p >> 7) & 1;
    header->pt = *p & 0x7f;
    ++p;

    p += net_unpack_u16(p, &header->sequnum);
    p += net_unpack_u32(p, &header->timestamp);
    p += net_unpack_u32(p, &header->ssrc);
    p += net_unpack_u64(p, &header->flags);
    p += net_unpack_u32(p, &header->offset_full);
    p += net_unpack_u32(p, &header->data_length_full);
    p += net_unpack_u32(p, &header->received_length_full);

    // ---------------------------- //
    //      custom fields here      //
    // ---------------------------- //
    p += net_unpack_u64(p, &header->frame_record_timestamp);
    p += net_unpack_u32(p, (uint32_t *)&header->fragment_num);
    p += net_unpack_u32(p, &header->real_frame_num);
    p += net_unpack_u32(p, &header->encoder_bit_rate_used);
    p += net_unpack_u32(p, &header->client_video_capture_delay_ms);
    p += net_unpack_u32(p, &header->rtp_packet_number);
    // ---------------------------- //
    //      custom fields here      //
    // ---------------------------- //

    p += sizeof(uint32_t) * RTP_PADDING_FIELDS;

    p += net_unpack_u16(p, &header->offset_lower);
    p += net_unpack_u16(p, &header->data_length_lower);
    assert(p == data + RTP_HEADER_SIZE);
    return p - data;
}

RTPSession *rtp_new(int payload_type, Tox *tox, ToxAV *toxav, uint32_t friendnumber,
                    BWController *bwc, void *cs, rtp_m_cb *mcb)
{
    assert(mcb != nullptr);
    assert(cs != nullptr);

    RTPSession *session = (RTPSession *)calloc(1, sizeof(RTPSession));

    if (!session) {
        LOGGER_API_WARNING(tox, "Alloc failed! Program might misbehave!");
        return nullptr;
    }

    session->work_buffer_list = (struct RTPWorkBufferList *)calloc(1, sizeof(struct RTPWorkBufferList));

    if (session->work_buffer_list == nullptr) {
        LOGGER_API_ERROR(tox, "out of memory while allocating work buffer list");
        free(session);
        return nullptr;
    }

    // First entry is free.
    session->work_buffer_list->next_free_entry = 0;

    session->ssrc = payload_type == RTP_TYPE_VIDEO ? 0 : random_u32(&tox->rng); // Zoff: what is this??
    session->payload_type = payload_type;
    session->tox = tox;
    session->toxav = toxav;
    session->friend_number = friendnumber;
    session->rtp_receive_active = true; /* default: true */

    // set NULL just in case
    session->mp = nullptr;
    session->first_packets_counter = 1;

    /* Also set payload type as prefix */
    session->bwc = bwc;
    session->cs = cs;
    session->mcb = mcb;

    for (int ii = 0; ii < INCOMING_PACKETS_TS_ENTRIES; ii++) {
        session->incoming_packets_ts[ii] = 0;
    }

    session->incoming_packets_ts_index = 0;
    session->incoming_packets_ts_last_ts = -1;
    session->incoming_packets_ts_average = 0;

    return session;
}

void rtp_kill(Tox *tox, RTPSession *session)
{
    if (!session) {
        return;
    }

    session->rtp_receive_active = false;

    LOGGER_API_DEBUG(session->tox, "Terminated RTP session: %p", (void *)session);
    LOGGER_API_DEBUG(session->tox, "Terminated RTP session V3 work_buffer_list->next_free_entry: %d",
                     (int)session->work_buffer_list->next_free_entry);

    for (int8_t i = 0; i < session->work_buffer_list->next_free_entry; ++i) {
        free(session->work_buffer_list->work_buffer[i].buf);
    }
    free(session->work_buffer_list);
    free(session);
}

void rtp_allow_receiving_mark(Tox *tox, RTPSession *session)
{
    if (session) {
        session->rtp_receive_active = true;
    }
}

void rtp_stop_receiving_mark(Tox *tox, RTPSession *session)
{
    if (session) {
        session->rtp_receive_active = false;
    }
}

void rtp_allow_receiving(Tox *tox)
{
    // register callback
    tox_callback_friend_lossy_packet_per_pktid(tox, handle_rtp_packet, RTP_TYPE_AUDIO);
    tox_callback_friend_lossy_packet_per_pktid(tox, handle_rtp_packet, RTP_TYPE_VIDEO);

    tox_callback_friend_lossless_packet_per_pktid(tox, handle_rtp_packet, PACKET_TOXAV_COMM_CHANNEL);
    LOGGER_API_DEBUG(tox, "rtp_allow_receiving:register PACKET_TOXAV_COMM_CHANNEL:%d",
                     (int)PACKET_TOXAV_COMM_CHANNEL);
}

void rtp_stop_receiving(Tox *tox)
{
    // UN-register callback
    tox_callback_friend_lossless_packet_per_pktid(tox, nullptr, PACKET_TOXAV_COMM_CHANNEL);
    LOGGER_API_DEBUG(tox, "rtp_stop_receiving:UNregister PACKET_TOXAV_COMM_CHANNEL:%d",
                     (int)PACKET_TOXAV_COMM_CHANNEL);

    tox_callback_friend_lossy_packet_per_pktid(tox, nullptr, RTP_TYPE_AUDIO);
    tox_callback_friend_lossy_packet_per_pktid(tox, nullptr, RTP_TYPE_VIDEO);
}

/**
 * @param data is raw vpx data (or H264 data).
 * @param length is the length of the raw data.
 */
int rtp_send_data(RTPSession *session, const uint8_t *data, uint32_t length, bool is_keyframe,
                  uint64_t frame_record_timestamp, int32_t fragment_num,
                  uint32_t codec_used, uint32_t bit_rate_used,
                  uint32_t client_capture_delay_ms,
                  uint32_t video_frame_orientation_angle,
                  Logger *log)
{
    if (!session) {
        return -1;
    }

    uint8_t is_video_payload = 0;

    if (session->payload_type == RTP_TYPE_VIDEO) {
        is_video_payload = 1;
    }

    struct RTPHeader header = {0};
    header.ve = 2;  // this is unused in toxav
    header.pe = 0;
    header.xe = 0;
    header.cc = 0;
    header.ma = 0;
    header.pt = session->payload_type % 128;
    LOGGER_API_DEBUG(session->tox, "session->sequnum:%d send", (int)session->sequnum);
    header.sequnum = session->sequnum;
    header.timestamp = frame_record_timestamp; // current_time_monotonic(session->m->mono_time);
    header.ssrc = session->ssrc;
    header.offset_lower = 0;
    header.data_length_lower = length;
    header.flags = RTP_LARGE_FRAME | RTP_ENCODER_HAS_RECORD_TIMESTAMP;

    LOGGER_API_DEBUG(session->tox, "RTP:send_ts:%lu %d", (unsigned long)frame_record_timestamp, (int)session->sequnum);

    if ((codec_used == TOXAV_ENCODER_CODEC_USED_H264) &&
            (is_video_payload == 1)) {
        header.flags = header.flags | RTP_ENCODER_IS_H264;
    }

    if ((codec_used == TOXAV_ENCODER_CODEC_USED_H265) &&
            (is_video_payload == 1)) {
        header.flags = header.flags | RTP_ENCODER_IS_H265;
    }

    if (video_frame_orientation_angle == TOXAV_CLIENT_INPUT_VIDEO_ORIENTATION_90) {
        header.flags = header.flags | RTP_ENCODER_VIDEO_ROTATION_ANGLE_BIT0;
    } else if (video_frame_orientation_angle == TOXAV_CLIENT_INPUT_VIDEO_ORIENTATION_180) {
        header.flags = header.flags | RTP_ENCODER_VIDEO_ROTATION_ANGLE_BIT1;
    } else if (video_frame_orientation_angle == TOXAV_CLIENT_INPUT_VIDEO_ORIENTATION_270) {
        header.flags = header.flags | RTP_ENCODER_VIDEO_ROTATION_ANGLE_BIT0;
        header.flags = header.flags | RTP_ENCODER_VIDEO_ROTATION_ANGLE_BIT1;
    }

    LOGGER_API_DEBUG(session->tox, "FRAMEFLAGS:%d angle=%d", (int)header.flags, video_frame_orientation_angle);

    header.frame_record_timestamp = frame_record_timestamp;
    header.fragment_num = fragment_num;
    header.real_frame_num = 0; // not yet used
    header.encoder_bit_rate_used = bit_rate_used;
    header.client_video_capture_delay_ms = client_capture_delay_ms;
    uint16_t length_safe = (uint16_t)length;

    if (length > UINT16_MAX) {
        length_safe = UINT16_MAX;
    }

    header.data_length_lower = length_safe;
    header.data_length_full = length; // without header
    header.offset_lower = 0;
    header.offset_full = 0;

    if (is_keyframe) {
        header.flags |= RTP_KEY_FRAME;
    }

    uint8_t rdata_buf[MAX_CRYPTO_DATA_SIZE];
    memset(rdata_buf, 0, MAX_CRYPTO_DATA_SIZE);

    rdata_buf[0] = session->payload_type;  // packet id == payload_type
    LOGGER_API_DEBUG(session->tox, "check encoded video packet:length=%d MAX_CRYPTO_DATA_SIZE=%d", length, MAX_CRYPTO_DATA_SIZE);

    if ((length + RTP_HEADER_SIZE + 1) <= MAX_CRYPTO_DATA_SIZE) {
        /**
         * The length is less or equal than the maximum allowed length (including header)
         * Send the packet in single piece.
         */
        header.rtp_packet_number = session->rtp_packet_num;
        session->rtp_packet_num++;
        rtp_header_pack(rdata_buf + 1, &header);
        memcpy(rdata_buf + 1 + RTP_HEADER_SIZE, data, length);

        if (rtp_send_custom_lossy_packet(session->tox, session->friend_number, rdata_buf, length + RTP_HEADER_SIZE + 1) == -1) {
            LOGGER_API_DEBUG(session->tox, "RTP send failed (len: %d)! std error: %s", (length + RTP_HEADER_SIZE + 1), strerror(errno));
        }
    } else {
        /**
         * The length is greater than the maximum allowed length (including header)
         * Send the packet in multiple pieces.
         */
        uint32_t sent = 0;
        uint16_t piece = MAX_CRYPTO_DATA_SIZE - (RTP_HEADER_SIZE + 1);

        while (((length - sent) + RTP_HEADER_SIZE + 1) > MAX_CRYPTO_DATA_SIZE) {
            header.rtp_packet_number = session->rtp_packet_num;
            session->rtp_packet_num++;
            rtp_header_pack(rdata_buf + 1, &header);
            memcpy(rdata_buf + 1 + RTP_HEADER_SIZE, data + sent, piece);

            if (rtp_send_custom_lossy_packet(session->tox, session->friend_number,
                                                   rdata_buf, piece + RTP_HEADER_SIZE + 1) == -1) {
                LOGGER_API_DEBUG(session->tox, "RTP send failed (len: %d)! std error: %s",
                                   piece + RTP_HEADER_SIZE + 1, strerror(errno));
            }
            sent += piece;
            header.offset_lower = sent;
            header.offset_full = sent; // raw data offset, without any header
        }

        /* Send remaining */
        piece = length - sent;

        if (piece) {
            memset(rdata_buf, 0, MAX_CRYPTO_DATA_SIZE);
            header.rtp_packet_number = session->rtp_packet_num;
            session->rtp_packet_num++;
            rtp_header_pack(rdata_buf + 1, &header);
            memcpy(rdata_buf + 1 + RTP_HEADER_SIZE, data + sent, piece);

            if (rtp_send_custom_lossy_packet(session->tox, session->friend_number, rdata_buf,
                                                   piece + RTP_HEADER_SIZE + 1) == -1) {
                LOGGER_API_DEBUG(session->tox, "RTP send failed (len: %d)! std error: %s",
                                   piece + RTP_HEADER_SIZE + 1, strerror(errno));
            }
        }
    }

    ++session->sequnum;
    LOGGER_API_DEBUG(session->tox, "session->sequnum:%d", (int)session->sequnum);
    return 0;
}
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2018 The TokTok team.
 * Copyright © 2013-2015 Tox project.
 */
#ifdef HAVE_CONFIG_H
#endif /* HAVE_CONFIG_H */








#include <assert.h>
#include <errno.h>
#include <limits.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>
#include <unistd.h>


#if defined(AUDIO_DEBUGGING_SKIP_FRAMES)
uint32_t _debug_count_sent_audio_frames = 0;
uint32_t _debug_skip_every_x_audio_frame = 10;
#endif

// #define AUDIO_ITERATATIONS_WHILE_VIDEO (5)
#define VIDEO_MIN_SEND_KEYFRAME_INTERVAL 6000

void callback_bwc(BWController *bwc, uint32_t friend_number, float loss, void *user_data);

static int callback_invite(void *toxav_inst, MSICall *call);
static int callback_start(void *toxav_inst, MSICall *call);
static int callback_end(void *toxav_inst, MSICall *call);
static int callback_error(void *toxav_inst, MSICall *call);
static int callback_capabilites(void *toxav_inst, MSICall *call);

static bool audio_bit_rate_invalid(uint32_t bit_rate);
static bool video_bit_rate_invalid(uint32_t bit_rate);
static bool invoke_call_state_callback(ToxAV *av, uint32_t friend_number, uint32_t state);
static ToxAVCall *call_new(ToxAV *av, uint32_t friend_number, TOXAV_ERR_CALL *error);
static ToxAVCall *call_remove(ToxAVCall *call);
static bool call_prepare_transmission(ToxAVCall *call);
static void call_kill_transmission(ToxAVCall *call);

MSISession *tox_av_msi_get(ToxAV *av);
int toxav_friend_exists(const Tox *tox, int32_t friendnumber);
Mono_Time *toxav_get_av_mono_time(ToxAV *toxav);
pthread_mutex_t *call_mutex_get(ToxAVCall *call);


MSISession *tox_av_msi_get(ToxAV *av)
{
    if (av == nullptr) {
        return nullptr;
    }

    return av->msi;
}

ToxAVCall *call_get(ToxAV *av, uint32_t friend_number)
{
    if (av == nullptr) {
        return nullptr;
    }

    /* Assumes mutex locked */
    if (av->calls == nullptr || av->calls_tail < friend_number) {
        return nullptr;
    }

    return av->calls[friend_number];
}

RTPSession *rtp_session_get(ToxAVCall *call, int payload_type)
{
    if (call == nullptr) {
        return nullptr;
    }

    if (payload_type == RTP_TYPE_VIDEO) {
        return call->video_rtp;
    } else if (payload_type == RTP_TYPE_AUDIO) {
        return call->audio_rtp;
    }

    return nullptr;
}

pthread_mutex_t *call_mutex_get(ToxAVCall *call)
{
    if (call == nullptr) {
        return nullptr;
    }

    return call->toxav_call_mutex;
}

pthread_mutex_t *endcall_mutex_get(ToxAV *av)
{
    if (av == nullptr) {
        return nullptr;
    }

    return av->toxav_endcall_mutex;
}

BWController *bwc_controller_get(ToxAVCall *call)
{
    if (call == nullptr) {
        return nullptr;
    }

    return call->bwc;
}

ToxAV *toxav_new(Tox *tox, Toxav_Err_New *error)
{
    Toxav_Err_New rc = TOXAV_ERR_NEW_OK;
    ToxAV *av = nullptr;

    if (tox == nullptr) {
        rc = TOXAV_ERR_NEW_NULL;
        goto RETURN;
    }

    av = (ToxAV *)calloc(sizeof(ToxAV), 1);

    if (av == nullptr) {
        rc = TOXAV_ERR_NEW_MALLOC;
        goto RETURN;
    }

    if (create_recursive_mutex(av->mutex) != 0) {
        LOGGER_API_WARNING(tox, "Mutex creation failed!");
        rc = TOXAV_ERR_NEW_MALLOC;
        goto RETURN;
    }

    if (create_recursive_mutex(av->toxav_endcall_mutex) != 0) {
        pthread_mutex_destroy(av->mutex);
        LOGGER_API_WARNING(tox, "Mutex creation failed!");
        rc = TOXAV_ERR_NEW_MALLOC;
        goto RETURN;
    }

    av->toxav_mono_time = mono_time_new(nullptr, nullptr);
    av->tox = tox;
    av->msi = msi_new(av->tox);

    if (av->msi == nullptr) {
        pthread_mutex_destroy(av->mutex);
        pthread_mutex_destroy(av->toxav_endcall_mutex);
        rc = TOXAV_ERR_NEW_MALLOC;
        goto RETURN;
    }

    av->interval = 200;
    av->msi->av = av;

    // save Tox object into toxcore
    tox_set_av_object(av->tox, (void *)av);

    rtp_allow_receiving(av->tox);
    bwc_allow_receiving(av->tox);

    msi_register_callback(av->msi, callback_invite, MSI_ON_INVITE);
    msi_register_callback(av->msi, callback_start, MSI_ON_START);
    msi_register_callback(av->msi, callback_end, MSI_ON_END);
    msi_register_callback(av->msi, callback_error, MSI_ON_ERROR);
    msi_register_callback(av->msi, callback_error, MSI_ON_PEERTIMEOUT);
    msi_register_callback(av->msi, callback_capabilites, MSI_ON_CAPABILITIES);

RETURN:

    if (error) {
        *error = rc;
    }

    if (rc != TOXAV_ERR_NEW_OK) {
        free(av);
        av = nullptr;
    }

    return av;
}

void toxav_kill(ToxAV *av)
{
    if (av == nullptr) {
        return;
    }

    pthread_mutex_lock(av->mutex);

    // unregister callbacks
    for (uint8_t i = PACKET_ID_RANGE_LOSSY_AV_START; i <= PACKET_ID_RANGE_LOSSY_AV_END; ++i) {
        tox_callback_friend_lossy_packet_per_pktid(av->tox, nullptr, i);
    }

    rtp_stop_receiving(av->tox);
    bwc_stop_receiving(av->tox);

    /* To avoid possible deadlocks */
    while (av->msi && msi_kill(av->tox, av->msi, nullptr) != 0) {
        pthread_mutex_unlock(av->mutex);
        pthread_mutex_lock(av->mutex);
    }

    /* Msi kill will hang up all calls so just clean these calls */
    if (av->calls) {
        ToxAVCall *it = call_get(av, av->calls_head);

        while (it) {
            call_kill_transmission(it);
            it->msi_call = nullptr; /* msi_kill() frees the call's msi_call handle; which causes #278 */
            it = call_remove(it); /* This will eventually free av->calls */
        }
    }

    // set ToxAV object to NULL in toxcore, to signal ToxAV has been shutdown
    tox_set_av_object(av->tox, nullptr);

    mono_time_free(av->toxav_mono_time);

    pthread_mutex_unlock(av->mutex);
    pthread_mutex_destroy(av->mutex);

    pthread_mutex_lock(av->toxav_endcall_mutex);
    pthread_mutex_unlock(av->toxav_endcall_mutex);
    pthread_mutex_destroy(av->toxav_endcall_mutex);

#ifdef HAVE_H265_ENCODER
    // HINT: to prevent leaks, cleanup x265
    x265_cleanup();
#endif

    free(av);
    av = nullptr;
}

Tox *toxav_get_tox(const ToxAV *av)
{
    return av->tox;
}

uint32_t toxav_iteration_interval(const ToxAV *av)
{
    /* If no call is active interval is 200 */
    return av->calls ? av->interval : 200;
}

void toxav_audio_iterate_seperation(ToxAV *av, bool active)
{
    if (av) {
        pthread_mutex_lock(av->mutex);
        av->toxav_audio_iterate_seperation_active = active;
        pthread_mutex_unlock(av->mutex);
    }
}

void toxav_audio_iterate(ToxAV *av)
{
    pthread_mutex_lock(av->mutex);

    if (av->calls == nullptr) {
        pthread_mutex_unlock(av->mutex);
        return;
    }

    // TODO: this works, but is not future proof
    uint32_t num_friends = (uint32_t)tox_self_get_friend_list_size(av->tox);

    for (uint32_t fid = 0; fid < num_friends; ++fid) {

        ToxAVCall *i = call_get(av,  fid);

        if (i) {
            if (i->active) {

                pthread_mutex_unlock(av->mutex);
                pthread_mutex_lock(i->toxav_call_mutex);
                if ((!i->msi_call) || (i->active == 0))
                {
                    // this call has ended
                }
                else
                {
                    int64_t copy_of_value = i->call_timestamp_difference_to_sender;
                    int video_cap_copy = (int)(i->msi_call->self_capabilities & MSI_CAP_S_VIDEO);

                    uint8_t res_ac = ac_iterate(i->audio,
                                                &(i->last_incoming_audio_frame_rtimestamp),
                                                &(i->last_incoming_audio_frame_ltimestamp),
                                                &(i->last_incoming_video_frame_rtimestamp),
                                                &(i->last_incoming_video_frame_ltimestamp),
                                                &(i->call_timestamp_difference_adjustment),
                                                &(copy_of_value),
                                                video_cap_copy,
                                                &(i->call_video_has_rountrip_time_ms)
                                               );
                }
                pthread_mutex_unlock(i->toxav_call_mutex);
                pthread_mutex_lock(av->mutex);
            }
        }
    }

    pthread_mutex_unlock(av->mutex);
}

void toxav_iterate(ToxAV *av)
{
    pthread_mutex_lock(av->mutex);

    if (av->calls == nullptr) {
        pthread_mutex_unlock(av->mutex);
        return;
    }

    uint64_t start = current_time_monotonic(av->toxav_mono_time);
    int32_t rc = 500;
    uint32_t audio_iterations = 0;

    ToxAVCall *i = av->calls[av->calls_head];

    LOGGER_API_DEBUG(av->tox, "iterate:000:START:h=%d t=%d i=%p", av->calls_head, av->calls_tail, (void *)i);
    uint32_t dummy_counter = 0;
    for (; i; i = i->next) {
        dummy_counter++;

        audio_iterations = 0;

        LOGGER_API_DEBUG(av->tox, "iterate:001:%d:i->active=%d i=%p", dummy_counter, (int)i->active, (void *)i);

        if (i->active) {

            bool audio_iterate_seperation_active = av->toxav_audio_iterate_seperation_active;

            pthread_mutex_lock(i->toxav_call_mutex);
            pthread_mutex_unlock(av->mutex);

            uint32_t fid = i->friend_number;
            LOGGER_API_DEBUG(av->tox, "iterate:002:%d:fnum=%d i=%p", dummy_counter, fid, (void *)i);

            if ((!i->msi_call) || (i->active == 0))
            {
                // call has ended
                LOGGER_API_DEBUG(av->tox, "iterate:003:%d:fnum=%d:call has ended", dummy_counter, fid);
                pthread_mutex_unlock(i->toxav_call_mutex);
                pthread_mutex_lock(av->mutex);
                break;
            }

            bool is_offline = check_peer_offline_status(av->tox, i->msi_call->session, fid);

            if (is_offline) {
                LOGGER_API_DEBUG(av->tox, "iterate:004:%d:fnum=%d:is_offline=%d", dummy_counter, fid, is_offline);
                pthread_mutex_unlock(i->toxav_call_mutex);
                pthread_mutex_lock(av->mutex);
                break;
            }

            // ------- ac_iterate for audio -------
            if (!audio_iterate_seperation_active) {
                uint8_t res_ac = ac_iterate(i->audio,
                                            &(i->last_incoming_audio_frame_rtimestamp),
                                            &(i->last_incoming_audio_frame_ltimestamp),
                                            &(i->last_incoming_video_frame_rtimestamp),
                                            &(i->last_incoming_video_frame_ltimestamp),
                                            &(i->call_timestamp_difference_adjustment),
                                            &(i->call_timestamp_difference_to_sender),
                                            (int)(i->msi_call->self_capabilities & MSI_CAP_S_VIDEO),
                                            &(i->call_video_has_rountrip_time_ms)
                                           );

                i->skip_video_flag = 0;
            }

            // ------- ac_iterate for audio -------

            // ------- av_iterate for VIDEO -------

            LOGGER_API_DEBUG(av->tox, "iterate:005:%d:fnum=%d:call->vc_iterate", dummy_counter, fid);
            uint8_t got_video_frame = vc_iterate(i->video, i->av->tox, i->skip_video_flag,
                                                 &(i->last_incoming_audio_frame_rtimestamp),
                                                 &(i->last_incoming_audio_frame_ltimestamp),
                                                 &(i->last_incoming_video_frame_rtimestamp),
                                                 &(i->last_incoming_video_frame_ltimestamp),
                                                 i->bwc,
                                                 &(i->call_timestamp_difference_adjustment),
                                                 &(i->call_timestamp_difference_to_sender),
                                                 &(i->call_video_has_rountrip_time_ms)
                                                );
            // ------- av_iterate for VIDEO -------

#define MIN(a,b) (((a)<(b))?(a):(b))

            if (i->msi_call->self_capabilities & MSI_CAP_R_AUDIO &&
                    i->msi_call->peer_capabilities & MSI_CAP_S_AUDIO) {
                rc = MIN((i->audio->lp_frame_duration - 4), rc);
            }

            if (i->msi_call->self_capabilities & MSI_CAP_R_VIDEO &&
                    i->msi_call->peer_capabilities & MSI_CAP_S_VIDEO) {

                pthread_mutex_lock(i->video->queue_mutex);
                rc = MIN(i->video->lcfd, (uint32_t) rc);
                pthread_mutex_unlock(i->video->queue_mutex);

            }

            pthread_mutex_unlock(i->toxav_call_mutex);
            pthread_mutex_lock(av->mutex);

            /* In case this call is popped from container stop iteration */
            if (call_get(av, fid) != i) {
                LOGGER_API_DEBUG(av->tox, "iterate:077:pop:fnum=%d:h=%d t=%d", fid, av->calls_head, av->calls_tail);
                break;
            }

        }
    }

    av->interval = rc < av->dmssa ? 0 : (rc - av->dmssa);
    av->dmsst += current_time_monotonic(av->toxav_mono_time) - start;

    if (++av->dmssc == 3) {
        av->dmssa = av->dmsst / 3 + 5; /* NOTE Magic Offset 5 for precision */
        av->dmssc = 0;
        av->dmsst = 0;
    }

    LOGGER_API_DEBUG(av->tox, "iterate:099:END:h=%d t=%d", av->calls_head, av->calls_tail);

    pthread_mutex_unlock(av->mutex);
}

bool toxav_call(ToxAV *av, uint32_t friend_number, uint32_t audio_bit_rate, uint32_t video_bit_rate,
                Toxav_Err_Call *error)
{
    Toxav_Err_Call rc = TOXAV_ERR_CALL_OK;
    ToxAVCall *call;

    pthread_mutex_lock(av->mutex);

    if ((audio_bit_rate && audio_bit_rate_invalid(audio_bit_rate))
            || (video_bit_rate && video_bit_rate_invalid(video_bit_rate))) {
        rc = TOXAV_ERR_CALL_INVALID_BIT_RATE;
        goto RETURN;
    }

    call = call_new(av, friend_number, &rc);

    if (call == nullptr) {
        goto RETURN;
    }

    call->audio_bit_rate = audio_bit_rate;
    call->video_bit_rate = video_bit_rate;

    call->video_bit_rate_not_yet_set = call->video_bit_rate;

    call->previous_self_capabilities = MSI_CAP_R_AUDIO | MSI_CAP_R_VIDEO;
    call->previous_self_capabilities |= audio_bit_rate > 0 ? MSI_CAP_S_AUDIO : 0;
    call->previous_self_capabilities |= video_bit_rate > 0 ? MSI_CAP_S_VIDEO : 0;

    if (msi_invite(av->msi, &call->msi_call, friend_number, call->previous_self_capabilities) != 0) {
        call_remove(call);
        rc = TOXAV_ERR_CALL_SYNC;
        goto RETURN;
    }

    call->msi_call->av_call = call;

RETURN:
    pthread_mutex_unlock(av->mutex);

    if (error) {
        *error = rc;
    }

    return rc == TOXAV_ERR_CALL_OK;
}

void toxav_callback_call(ToxAV *av, toxav_call_cb *callback, void *user_data)
{
    pthread_mutex_lock(av->mutex);
    av->ccb = callback;
    av->ccb_user_data = user_data;
    pthread_mutex_unlock(av->mutex);
}

int toxav_friend_exists(const Tox *tox, int32_t friendnumber)
{
    if (tox) {
        bool res = tox_friend_exists(tox, friendnumber);

        if (res) {
            return 1;
        } else {
            return 0;
        }
    }

    return 0;
}

void toxav_callback_call_comm(ToxAV *av, toxav_call_comm_cb *callback, void *user_data)
{
    pthread_mutex_lock(av->mutex);
    av->call_comm_cb = callback;
    av->call_comm_cb_user_data = user_data;
    pthread_mutex_unlock(av->mutex);
}

bool toxav_answer(ToxAV *av, uint32_t friend_number, uint32_t audio_bit_rate, uint32_t video_bit_rate,
                  Toxav_Err_Answer *error)
{
    pthread_mutex_lock(av->mutex);

    Toxav_Err_Answer rc = TOXAV_ERR_ANSWER_OK;
    ToxAVCall *call;

    LOGGER_API_DEBUG(av->tox, "answer:fnum=%d", friend_number);

    if (toxav_friend_exists(av->tox, friend_number) == 0) {
        LOGGER_API_WARNING(av->tox, "answer:fnum=%d:TOXAV_ERR_ANSWER_FRIEND_NOT_FOUND", friend_number);
        rc = TOXAV_ERR_ANSWER_FRIEND_NOT_FOUND;
        goto RETURN;
    }

    if ((audio_bit_rate && audio_bit_rate_invalid(audio_bit_rate))
            || (video_bit_rate && video_bit_rate_invalid(video_bit_rate))
       ) {
        LOGGER_API_WARNING(av->tox, "answer:fnum=%d:TOXAV_ERR_ANSWER_INVALID_BIT_RATE", friend_number);
        rc = TOXAV_ERR_ANSWER_INVALID_BIT_RATE;
        goto RETURN;
    }

    call = call_get(av, friend_number);

    if (call == nullptr) {
        LOGGER_API_WARNING(av->tox, "answer:fnum=%d:TOXAV_ERR_ANSWER_FRIEND_NOT_CALLING", friend_number);
        rc = TOXAV_ERR_ANSWER_FRIEND_NOT_CALLING;
        goto RETURN;
    }

    if (!call_prepare_transmission(call)) {
        LOGGER_API_WARNING(av->tox, "answer:fnum=%d:TOXAV_ERR_ANSWER_CODEC_INITIALIZATION", friend_number);
        rc = TOXAV_ERR_ANSWER_CODEC_INITIALIZATION;
        goto RETURN;
    }

    call->audio_bit_rate = audio_bit_rate;
    call->video_bit_rate = video_bit_rate;
    call->video_bit_rate_not_yet_set = call->video_bit_rate;

    call->previous_self_capabilities = MSI_CAP_R_AUDIO | MSI_CAP_R_VIDEO;

    call->previous_self_capabilities |= audio_bit_rate > 0 ? MSI_CAP_S_AUDIO : 0;
    call->previous_self_capabilities |= video_bit_rate > 0 ? MSI_CAP_S_VIDEO : 0;

    if (msi_answer(call->msi_call, call->previous_self_capabilities) != 0) {
        LOGGER_API_WARNING(av->tox, "answer:fnum=%d:TOXAV_ERR_ANSWER_SYNC", friend_number);
        rc = TOXAV_ERR_ANSWER_SYNC;
    }

RETURN:
    pthread_mutex_unlock(av->mutex);

    if (error) {
        *error = rc;
    }

    return rc == TOXAV_ERR_ANSWER_OK;
}

void toxav_callback_call_state(ToxAV *av, toxav_call_state_cb *callback, void *user_data)
{
    pthread_mutex_lock(av->mutex);
    av->scb = callback;
    av->scb_user_data = user_data;
    pthread_mutex_unlock(av->mutex);
}

bool toxav_call_control(ToxAV *av, uint32_t friend_number, Toxav_Call_Control control, Toxav_Err_Call_Control *error)
{
    // HINT: avoid a crash
    if (!av)
    {
        Toxav_Err_Call_Control rc2 = TOXAV_ERR_CALL_CONTROL_FRIEND_NOT_IN_CALL;
        if (error) {
            *error = rc2;
        }

        return rc2 == TOXAV_ERR_CALL_CONTROL_OK;
    }
    // HINT: avoid a crash

    pthread_mutex_lock(av->mutex);
    Toxav_Err_Call_Control rc = TOXAV_ERR_CALL_CONTROL_OK;
    ToxAVCall *call;

    if (toxav_friend_exists(av->tox, friend_number) == 0) {
        rc = TOXAV_ERR_CALL_CONTROL_FRIEND_NOT_FOUND;
        goto RETURN;
    }

    call = call_get(av, friend_number);

    if (call == nullptr || (!call->active && control != TOXAV_CALL_CONTROL_CANCEL)) {
        rc = TOXAV_ERR_CALL_CONTROL_FRIEND_NOT_IN_CALL;
        goto RETURN;
    }

    switch (control) {
        case TOXAV_CALL_CONTROL_RESUME: {
            /* Only act if paused and had media transfer active before */
            if (call->msi_call->self_capabilities == 0 &&
                    call->previous_self_capabilities) {

                if (msi_change_capabilities(call->msi_call,
                                            call->previous_self_capabilities) == -1) {
                    rc = TOXAV_ERR_CALL_CONTROL_SYNC;
                    goto RETURN;
                }

                rtp_allow_receiving_mark(av->tox, call->audio_rtp);
                rtp_allow_receiving_mark(av->tox, call->video_rtp);
            } else {
                rc = TOXAV_ERR_CALL_CONTROL_INVALID_TRANSITION;
                goto RETURN;
            }
        }
        break;

        case TOXAV_CALL_CONTROL_PAUSE: {
            /* Only act if not already paused */
            if (call->msi_call->self_capabilities) {
                call->previous_self_capabilities = call->msi_call->self_capabilities;

                if (msi_change_capabilities(call->msi_call, 0) == -1) {
                    rc = TOXAV_ERR_CALL_CONTROL_SYNC;
                    goto RETURN;
                }

                rtp_stop_receiving_mark(av->tox, call->audio_rtp);
                rtp_stop_receiving_mark(av->tox, call->video_rtp);
            } else {
                rc = TOXAV_ERR_CALL_CONTROL_INVALID_TRANSITION;
                goto RETURN;
            }
        }
        break;

        case TOXAV_CALL_CONTROL_CANCEL: {
            /* Hang up */
            pthread_mutex_lock(call->toxav_call_mutex);

            if (msi_hangup(call->msi_call) != 0) {
                rc = TOXAV_ERR_CALL_CONTROL_SYNC;
                pthread_mutex_unlock(call->toxav_call_mutex);
                goto RETURN;
            }

            call->msi_call = nullptr;
            pthread_mutex_unlock(call->toxav_call_mutex);

            /* No mather the case, terminate the call */
            call_kill_transmission(call);
            call_remove(call);
        }
        break;

        case TOXAV_CALL_CONTROL_MUTE_AUDIO: {
            if (call->msi_call->self_capabilities & MSI_CAP_R_AUDIO) {
                if (msi_change_capabilities(call->msi_call, call->
                                            msi_call->self_capabilities ^ MSI_CAP_R_AUDIO) == -1) {
                    rc = TOXAV_ERR_CALL_CONTROL_SYNC;
                    goto RETURN;
                }

                rtp_stop_receiving_mark(av->tox, call->audio_rtp);
            } else {
                rc = TOXAV_ERR_CALL_CONTROL_INVALID_TRANSITION;
                goto RETURN;
            }
        }
        break;

        case TOXAV_CALL_CONTROL_UNMUTE_AUDIO: {
            if (call->msi_call->self_capabilities ^ MSI_CAP_R_AUDIO) {
                if (msi_change_capabilities(call->msi_call, call->
                                            msi_call->self_capabilities | MSI_CAP_R_AUDIO) == -1) {
                    rc = TOXAV_ERR_CALL_CONTROL_SYNC;
                    goto RETURN;
                }

                rtp_allow_receiving_mark(av->tox, call->audio_rtp);
            } else {
                rc = TOXAV_ERR_CALL_CONTROL_INVALID_TRANSITION;
                goto RETURN;
            }
        }
        break;

        case TOXAV_CALL_CONTROL_HIDE_VIDEO: {
            if (call->msi_call->self_capabilities & MSI_CAP_R_VIDEO) {
                if (msi_change_capabilities(call->msi_call, call->
                                            msi_call->self_capabilities ^ MSI_CAP_R_VIDEO) == -1) {
                    rc = TOXAV_ERR_CALL_CONTROL_SYNC;
                    goto RETURN;
                }

                rtp_stop_receiving_mark(av->tox, call->video_rtp);
            } else {
                rc = TOXAV_ERR_CALL_CONTROL_INVALID_TRANSITION;
                goto RETURN;
            }
        }
        break;

        case TOXAV_CALL_CONTROL_SHOW_VIDEO: {
            if (call->msi_call->self_capabilities ^ MSI_CAP_R_VIDEO) {
                if (msi_change_capabilities(call->msi_call, call->
                                            msi_call->self_capabilities | MSI_CAP_R_VIDEO) == -1) {
                    rc = TOXAV_ERR_CALL_CONTROL_SYNC;
                    goto RETURN;
                }

                rtp_allow_receiving_mark(av->tox, call->video_rtp);
            } else {
                rc = TOXAV_ERR_CALL_CONTROL_INVALID_TRANSITION;
                goto RETURN;
            }
        }
        break;
    }

RETURN:
    pthread_mutex_unlock(av->mutex);

    if (error) {
        *error = rc;
    }

    return rc == TOXAV_ERR_CALL_CONTROL_OK;
}

bool toxav_option_set(ToxAV *av, uint32_t friend_number, TOXAV_OPTIONS_OPTION option, int32_t value,
                      TOXAV_ERR_OPTION_SET *error)
{
    TOXAV_ERR_OPTION_SET rc = TOXAV_ERR_OPTION_SET_OK;

    ToxAVCall *call;

    LOGGER_API_DEBUG(av->tox, "toxav_option_set:1 %d %d", (int)option, (int)value);

    if (toxav_friend_exists(av->tox, friend_number) == 0) {
        LOGGER_API_DEBUG(av->tox, "toxav_friend_exists:NO");
        rc = TOXAV_ERR_OPTION_SET_OTHER_ERROR;
        goto END;
    }

    pthread_mutex_lock(av->mutex);
    call = call_get(av, friend_number);

    if (call == NULL || !call->active || call->msi_call->state != MSI_CALL_ACTIVE) {
        pthread_mutex_unlock(av->mutex);
        LOGGER_API_DEBUG(av->tox, "NO active call");
        rc = TOXAV_ERR_OPTION_SET_OTHER_ERROR;
        goto END;
    }

    if (pthread_mutex_trylock(call->toxav_call_mutex) != 0) {
        pthread_mutex_unlock(av->mutex);
        LOGGER_API_DEBUG(av->tox, "pthread_mutex_trylock failed");
        rc = TOXAV_ERR_OPTION_SET_OTHER_ERROR;
        goto END;
    }

    LOGGER_API_DEBUG(av->tox, "toxav_option_set:2 %d %d", (int)option, (int)value);

    if (option == TOXAV_ENCODER_CPU_USED) {
        VCSession *vc = (VCSession *)call->video;

        if (vc->video_encoder_cpu_used == (int32_t)value) {
            LOGGER_API_WARNING(av->tox, "video encoder cpu_used already set to: %d", (int)value);
        } else {
            vc->video_encoder_cpu_used_prev = vc->video_encoder_cpu_used;
            vc->video_encoder_cpu_used = (int32_t)value;
            LOGGER_API_WARNING(av->tox, "video encoder setting cpu_used to: %d", (int)value);
        }
    } else if (option == TOXAV_CLIENT_VIDEO_CAPTURE_DELAY_MS) {
        VCSession *vc = (VCSession *)call->video;

        if (((int32_t)value >= 0)
                && ((int32_t)value <= 10000)) {
            vc->client_video_capture_delay_ms = (int32_t)value;
        }
    } else if (option == TOXAV_ENCODER_CODEC_USED) {
        VCSession *vc = (VCSession *)call->video;

        if (((int32_t)value >= TOXAV_ENCODER_CODEC_USED_VP8)
                && ((int32_t)value <= TOXAV_ENCODER_CODEC_USED_H265)) {

#ifndef HAVE_H265_ENCODER
            if ((int32_t)value == TOXAV_ENCODER_CODEC_USED_H265) {

                pthread_mutex_unlock(call->toxav_call_mutex);
                pthread_mutex_unlock(av->mutex);
                LOGGER_API_WARNING(av->tox, "trying to set H265 encoder when no H265 encoder is available in this toxcore library");
                rc = TOXAV_ERR_OPTION_SET_OTHER_ERROR;
                goto END;
            }
#endif

            if (vc->video_encoder_coded_used == (int32_t)value) {
                LOGGER_API_WARNING(av->tox, "video video_encoder_coded_used already set to: %d", (int)value);
            } else {
                vc->video_encoder_coded_used_prev = vc->video_encoder_coded_used;
                vc->video_encoder_coded_used = (int32_t)value;
                LOGGER_API_WARNING(av->tox, "video video_encoder_coded_used to: %d", (int)value);
            }
        }
    } else if (option == TOXAV_CLIENT_INPUT_VIDEO_ORIENTATION) {
        VCSession *vc = (VCSession *)call->video;

        if (((int32_t)value >= TOXAV_CLIENT_INPUT_VIDEO_ORIENTATION_0)
                && ((int32_t)value <= TOXAV_CLIENT_INPUT_VIDEO_ORIENTATION_270)) {

            if (vc->video_encoder_frame_orientation_angle == (int32_t)value) {
                LOGGER_API_WARNING(av->tox, "video video_encoder_frame_orientation_angle already set to: %d", (int)value);
            } else {
                vc->video_encoder_frame_orientation_angle = (int32_t)value;
                LOGGER_API_WARNING(av->tox, "video video_encoder_frame_orientation_angle to: %d", (int)value);
            }
        }
    } else if (option == TOXAV_ENCODER_VP8_QUALITY) {
        VCSession *vc = (VCSession *)call->video;

        if (vc->video_encoder_vp8_quality == (int32_t)value) {
            LOGGER_API_WARNING(av->tox, "video encoder vp8_quality already set to: %d", (int)value);
        } else {
            vc->video_encoder_vp8_quality_prev = vc->video_encoder_vp8_quality;
            vc->video_encoder_vp8_quality = (int32_t)value;

            if (vc->video_encoder_vp8_quality == TOXAV_ENCODER_VP8_QUALITY_HIGH) {
                vc->video_rc_max_quantizer_prev = vc->video_rc_max_quantizer;
                vc->video_rc_min_quantizer_prev = vc->video_rc_min_quantizer;
                vc->video_rc_max_quantizer = TOXAV_ENCODER_VP8_RC_MAX_QUANTIZER_HIGH;
                vc->video_rc_min_quantizer = TOXAV_ENCODER_VP8_RC_MIN_QUANTIZER_HIGH;
            } else {
                vc->video_rc_max_quantizer_prev = vc->video_rc_max_quantizer;
                vc->video_rc_min_quantizer_prev = vc->video_rc_min_quantizer;
                vc->video_rc_max_quantizer = TOXAV_ENCODER_VP8_RC_MAX_QUANTIZER_NORMAL;
                vc->video_rc_min_quantizer = TOXAV_ENCODER_VP8_RC_MIN_QUANTIZER_NORMAL;
            }

            LOGGER_API_WARNING(av->tox, "video encoder setting vp8_quality to: %d", (int)value);
        }
    } else if (option == TOXAV_ENCODER_RC_MAX_QUANTIZER) {
        VCSession *vc = (VCSession *)call->video;

        if (vc->video_rc_max_quantizer == (int32_t)value) {
            LOGGER_API_WARNING(av->tox, "video encoder rc_max_quantizer already set to: %d", (int)value);
        } else {
            if ((value >= AV_BUFFERING_MS_MIN) && (value <= AV_BUFFERING_MS_MAX)) {
                vc->video_rc_max_quantizer_prev = vc->video_rc_max_quantizer;
                vc->video_rc_max_quantizer = (int32_t)value;
                LOGGER_API_WARNING(av->tox, "video encoder setting rc_max_quantizer to: %d", (int)value);
            }
        }
    } else if (option == TOXAV_DECODER_VIDEO_ADD_DELAY_MS) {
        VCSession *vc = (VCSession *)call->video;

        if (vc->video_decoder_add_delay_ms == (int32_t)value) {
            LOGGER_API_DEBUG(av->tox, "video decoder video_decoder_add_delay_ms already set to: %d", (int)value);
        } else {

            if (((int32_t)value < -650) || ((int32_t)value > 350)) {
                LOGGER_API_DEBUG(av->tox, "video decoder video_decoder_add_delay_ms value outside of valid range: %d", (int)value);
            } else {
                vc->video_decoder_add_delay_ms = (int32_t)value;
            }
        }
    } else if (option == TOXAV_DECODER_VIDEO_BUFFER_MS) {
        VCSession *vc = (VCSession *)call->video;

        if (vc->video_decoder_buffer_ms == (int32_t)value) {
            LOGGER_API_DEBUG(av->tox, "video decoder video_decoder_buffer_ms already set to: %d", (int)value);
        } else {
            if (((int32_t)value < 0) || ((int32_t)value > 2000)) {
                LOGGER_API_DEBUG(av->tox, "video decoder video_decoder_buffer_ms value outside of valid range: %d", (int)value);
            } else {
                vc->video_decoder_buffer_ms = (int32_t)value;
            }

            LOGGER_API_WARNING(av->tox, "video decoder setting video_decoder_buffer_ms to: %d", (int)value);
        }
    } else if (option == TOXAV_ENCODER_VIDEO_MAX_BITRATE) {
        VCSession *vc = (VCSession *)call->video;

        if (vc->video_max_bitrate == (int32_t)value) {
            LOGGER_API_WARNING(av->tox, "video encoder video_max_bitrate already set to: %d", (int)value);
        } else {
            vc->video_max_bitrate = (int32_t)value;

            if (call->video_bit_rate > (uint32_t)vc->video_max_bitrate) {
                call->video_bit_rate = (uint32_t)vc->video_max_bitrate;
                call->video_bit_rate_not_yet_set = call->video_bit_rate;
            }

            LOGGER_API_WARNING(av->tox, "video encoder setting video_max_bitrate to: %d", (int)value);
        }
    } else if (option == TOXAV_ENCODER_VIDEO_MIN_BITRATE) {
        VCSession *vc = (VCSession *)call->video;

        if (vc->video_min_bitrate == (int32_t)value) {
                    LOGGER_API_WARNING(av->tox, "video encoder video_min_bitrate already set to: %d", (int)value);
        } else {
            vc->video_min_bitrate = (int32_t)value;

            if (call->video_bit_rate < (uint32_t)vc->video_min_bitrate) {
                call->video_bit_rate = (uint32_t)vc->video_min_bitrate;
                call->video_bit_rate_not_yet_set = call->video_bit_rate;
            }

            LOGGER_API_WARNING(av->tox, "video encoder setting video_min_bitrate to: %d", (int)value);
        }
    } else if (option == TOXAV_ENCODER_VIDEO_BITRATE_AUTOSET) {
        VCSession *vc = (VCSession *)call->video;

        if (vc->video_bitrate_autoset == (uint8_t)value) {
            LOGGER_API_WARNING(av->tox, "video encoder video_bitrate_autoset already set to: %d", (int)value);
        } else {
            vc->video_bitrate_autoset = (uint8_t)value;
            LOGGER_API_WARNING(av->tox, "video encoder setting video_bitrate_autoset to: %d", (int)value);
        }
    } else if (option == TOXAV_ENCODER_KF_METHOD) {
        VCSession *vc = (VCSession *)call->video;

        if (vc->video_keyframe_method == (int32_t)value) {
            LOGGER_API_WARNING(av->tox, "video encoder keyframe_method already set to: %d", (int)value);
        } else {
            vc->video_keyframe_method_prev = vc->video_keyframe_method;
            vc->video_keyframe_method = (int32_t)value;
            LOGGER_API_WARNING(av->tox, "video encoder setting keyframe_method to: %d", (int)value);
        }
    } else if (option == TOXAV_ENCODER_RC_MIN_QUANTIZER) {
        VCSession *vc = (VCSession *)call->video;

        if (vc->video_rc_min_quantizer == (int32_t)value) {
            LOGGER_API_WARNING(av->tox, "video encoder video_rc_min_quantizer already set to: %d", (int)value);
        } else {
            vc->video_rc_min_quantizer_prev = vc->video_rc_min_quantizer;
            vc->video_rc_min_quantizer = (int32_t)value;
            LOGGER_API_WARNING(av->tox, "video encoder setting video_rc_min_quantizer to: %d", (int)value);
        }
    } else if (option == TOXAV_DECODER_ERROR_CONCEALMENT) {
        VCSession *vc = (VCSession *)call->video;

        if (vc->video_decoder_error_concealment == (int32_t)value) {
            LOGGER_API_WARNING(av->tox, "video encoder video_decoder_error_concealment already set to: %d", (int)value);
        } else {
            vc->video_decoder_error_concealment_prev = vc->video_decoder_error_concealment;
            vc->video_decoder_error_concealment = (int32_t)value;
            LOGGER_API_WARNING(av->tox, "video encoder setting video_decoder_error_concealment to: %d", (int)value);
        }
    }

    pthread_mutex_unlock(call->toxav_call_mutex);
    pthread_mutex_unlock(av->mutex);
END:

    if (error) {
        *error = rc;
    }

    return rc == TOXAV_ERR_OPTION_SET_OK;
}

bool toxav_video_set_bit_rate(ToxAV *av, uint32_t friend_number, uint32_t video_bit_rate,
                              Toxav_Err_Bit_Rate_Set *error)
{
    Toxav_Err_Bit_Rate_Set rc = TOXAV_ERR_BIT_RATE_SET_OK;
    ToxAVCall *call;

    if (toxav_friend_exists(av->tox, friend_number) == 0) {
        rc = TOXAV_ERR_BIT_RATE_SET_FRIEND_NOT_FOUND;
        goto RETURN;
    }

    if (video_bit_rate > 0 && video_bit_rate_invalid(video_bit_rate)) {
        rc = TOXAV_ERR_BIT_RATE_SET_INVALID_BIT_RATE;
        goto RETURN;
    }

    pthread_mutex_lock(av->mutex);
    call = call_get(av, friend_number);

    if (call == nullptr || !call->active || call->msi_call->state != MSI_CALL_ACTIVE) {
        pthread_mutex_unlock(av->mutex);
        rc = TOXAV_ERR_BIT_RATE_SET_FRIEND_NOT_IN_CALL;
        goto RETURN;
    }

    LOGGER_API_DEBUG(av->tox, "Setting new video bitrate to: %d", video_bit_rate);

    if (call->video_bit_rate == video_bit_rate) {
        LOGGER_API_DEBUG(av->tox, "Video bitrate already set to: %d", video_bit_rate);
    } else if (video_bit_rate == 0) {
        LOGGER_API_DEBUG(av->tox, "Turned off video sending");

        /* Video sending is turned off; notify peer */
        if (msi_change_capabilities(call->msi_call, call->msi_call->
                                    self_capabilities ^ MSI_CAP_S_VIDEO) != 0) {
            pthread_mutex_unlock(av->mutex);
            rc = TOXAV_ERR_BIT_RATE_SET_SYNC;
            goto RETURN;
        }

        call->video_bit_rate = 0;
        call->video_bit_rate_not_yet_set = call->video_bit_rate;
    } else {
        pthread_mutex_lock(call->toxav_call_mutex);

        if (call->video_bit_rate == 0) {
            LOGGER_API_DEBUG(av->tox, "Turned on video sending");

            /* The video has been turned off before this */
            if (msi_change_capabilities(call->msi_call, call->
                                        msi_call->self_capabilities | MSI_CAP_S_VIDEO) != 0) {
                pthread_mutex_unlock(call->toxav_call_mutex);
                pthread_mutex_unlock(av->mutex);
                rc = TOXAV_ERR_BIT_RATE_SET_SYNC;
                goto RETURN;
            }
        } else {
            LOGGER_API_DEBUG(av->tox, "Set new video bit rate %d", video_bit_rate);
        }

        call->video_bit_rate = video_bit_rate;
        call->video_bit_rate_not_yet_set = call->video_bit_rate;
        pthread_mutex_unlock(call->toxav_call_mutex);
    }

    pthread_mutex_unlock(av->mutex);
RETURN:

    if (error) {
        *error = rc;
    }

    return rc == TOXAV_ERR_BIT_RATE_SET_OK;
}

bool toxav_audio_set_bit_rate(ToxAV *av, uint32_t friend_number, uint32_t audio_bit_rate,
                              Toxav_Err_Bit_Rate_Set *error)
{
    Toxav_Err_Bit_Rate_Set rc = TOXAV_ERR_BIT_RATE_SET_OK;
    ToxAVCall *call;

    if (toxav_friend_exists(av->tox, friend_number) == 0) {
        rc = TOXAV_ERR_BIT_RATE_SET_FRIEND_NOT_FOUND;
        goto RETURN;
    }

    if (audio_bit_rate > 0 && audio_bit_rate_invalid(audio_bit_rate)) {
        rc = TOXAV_ERR_BIT_RATE_SET_INVALID_BIT_RATE;
        goto RETURN;
    }

    pthread_mutex_lock(av->mutex);
    call = call_get(av, friend_number);

    if (call == nullptr || !call->active || call->msi_call->state != MSI_CALL_ACTIVE) {
        pthread_mutex_unlock(av->mutex);
        rc = TOXAV_ERR_BIT_RATE_SET_FRIEND_NOT_IN_CALL;
        goto RETURN;
    }

    LOGGER_API_DEBUG(av->tox, "Setting new audio bitrate to: %d", audio_bit_rate);

    if (call->audio_bit_rate == audio_bit_rate) {
        LOGGER_API_DEBUG(av->tox, "Audio bitrate already set to: %d", audio_bit_rate);
    } else if (audio_bit_rate == 0) {
        LOGGER_API_DEBUG(av->tox, "Turned off audio sending");

        if (msi_change_capabilities(call->msi_call, call->msi_call->
                                    self_capabilities ^ MSI_CAP_S_AUDIO) != 0) {
            pthread_mutex_unlock(av->mutex);
            rc = TOXAV_ERR_BIT_RATE_SET_SYNC;
            goto RETURN;
        }

        /* Audio sending is turned off; notify peer */
        call->audio_bit_rate = 0;
    } else {
        pthread_mutex_lock(call->toxav_call_mutex);

        if (call->audio_bit_rate == 0) {
            LOGGER_API_DEBUG(av->tox, "Turned on audio sending");

            /* The audio has been turned off before this */
            if (msi_change_capabilities(call->msi_call, call->
                                        msi_call->self_capabilities | MSI_CAP_S_AUDIO) != 0) {
                pthread_mutex_unlock(call->toxav_call_mutex);
                pthread_mutex_unlock(av->mutex);
                rc = TOXAV_ERR_BIT_RATE_SET_SYNC;
                goto RETURN;
            }
        } else {
            LOGGER_API_DEBUG(av->tox, "Set new audio bit rate %d", audio_bit_rate);
        }

        call->audio_bit_rate = audio_bit_rate;
        pthread_mutex_unlock(call->toxav_call_mutex);
    }

    pthread_mutex_unlock(av->mutex);
RETURN:

    if (error) {
        *error = rc;
    }

    return rc == TOXAV_ERR_BIT_RATE_SET_OK;
}

bool toxav_bit_rate_set(ToxAV *av, uint32_t friend_number, int32_t audio_bit_rate,
                        int32_t video_bit_rate, TOXAV_ERR_BIT_RATE_SET *error)
{
    TOXAV_ERR_BIT_RATE_SET rc = TOXAV_ERR_BIT_RATE_SET_OK;
    ToxAVCall *call;

    if (toxav_friend_exists(av->tox, friend_number) == 0) {
        rc = TOXAV_ERR_BIT_RATE_SET_FRIEND_NOT_FOUND;
        goto END;
    }

    if (audio_bit_rate > 0 && audio_bit_rate_invalid(audio_bit_rate)) {
        rc = TOXAV_ERR_BIT_RATE_SET_INVALID_BIT_RATE;
        goto END;
    }

    if (video_bit_rate > 0 && video_bit_rate_invalid(video_bit_rate)) {
        rc = TOXAV_ERR_BIT_RATE_SET_INVALID_BIT_RATE;
        goto END;
    }

    pthread_mutex_lock(av->mutex);
    call = call_get(av, friend_number);

    if (call == NULL || !call->active || call->msi_call->state != MSI_CALL_ACTIVE) {
        pthread_mutex_unlock(av->mutex);
        rc = TOXAV_ERR_BIT_RATE_SET_FRIEND_NOT_IN_CALL;
        goto END;
    }

    if (audio_bit_rate >= 0) {
        LOGGER_API_DEBUG(av->tox, "Setting new audio bitrate to: %d", audio_bit_rate);

        if (call->audio_bit_rate == (uint32_t)audio_bit_rate) {
            LOGGER_API_DEBUG(av->tox, "Audio bitrate already set to: %d", audio_bit_rate);
        } else if (audio_bit_rate == 0) {
            LOGGER_API_DEBUG(av->tox, "Turned off audio sending");

            if (msi_change_capabilities(call->msi_call, call->msi_call->
                                        self_capabilities ^ MSI_CAP_S_AUDIO) != 0) {
                pthread_mutex_unlock(av->mutex);
                rc = TOXAV_ERR_BIT_RATE_SET_SYNC;
                goto END;
            }

            /* Audio sending is turned off; notify peer */
            call->audio_bit_rate = 0;
        } else {
            pthread_mutex_lock(call->toxav_call_mutex);

            if (call->audio_bit_rate == 0) {
                LOGGER_API_DEBUG(av->tox, "Turned on audio sending");

                /* The audio has been turned off before this */
                if (msi_change_capabilities(call->msi_call, call->
                                            msi_call->self_capabilities | MSI_CAP_S_AUDIO) != 0) {
                    pthread_mutex_unlock(call->toxav_call_mutex);
                    pthread_mutex_unlock(av->mutex);
                    rc = TOXAV_ERR_BIT_RATE_SET_SYNC;
                    goto END;
                }
            } else {
                LOGGER_API_DEBUG(av->tox, "Set new audio bit rate %d", audio_bit_rate);
            }

            call->audio_bit_rate = audio_bit_rate;
            pthread_mutex_unlock(call->toxav_call_mutex);
        }
    }

    if (video_bit_rate >= 0) {
        LOGGER_API_DEBUG(av->tox, "Setting new video bitrate to: %d", video_bit_rate);

        if (call->video_bit_rate == (uint32_t)video_bit_rate) {
            LOGGER_API_DEBUG(av->tox, "Video bitrate already set to: %d", video_bit_rate);
        } else if (video_bit_rate == 0) {
            LOGGER_API_DEBUG(av->tox, "Turned off video sending");

            /* Video sending is turned off; notify peer */
            if (msi_change_capabilities(call->msi_call, call->msi_call->
                                        self_capabilities ^ MSI_CAP_S_VIDEO) != 0) {
                pthread_mutex_unlock(av->mutex);
                rc = TOXAV_ERR_BIT_RATE_SET_SYNC;
                goto END;
            }

            call->video_bit_rate = 0;
            call->video_bit_rate_not_yet_set = call->video_bit_rate;
        } else {
            pthread_mutex_lock(call->toxav_call_mutex);

            if (call->video_bit_rate == 0) {
                LOGGER_API_DEBUG(av->tox, "Turned on video sending");

                /* The video has been turned off before this */
                if (msi_change_capabilities(call->msi_call, call->
                                            msi_call->self_capabilities | MSI_CAP_S_VIDEO) != 0) {
                    pthread_mutex_unlock(call->toxav_call_mutex);
                    pthread_mutex_unlock(av->mutex);
                    rc = TOXAV_ERR_BIT_RATE_SET_SYNC;
                    goto END;
                }
            } else {
                LOGGER_API_DEBUG(av->tox, "Set new video bit rate %d", video_bit_rate);
            }

            call->video_bit_rate = video_bit_rate;
            call->video_bit_rate_not_yet_set = call->video_bit_rate;

            LOGGER_API_ERROR(av->tox, "toxav_bit_rate_set:vb=%d", (int)video_bit_rate);

            pthread_mutex_unlock(call->toxav_call_mutex);
        }
    }

    pthread_mutex_unlock(av->mutex);
END:

    if (error) {
        *error = rc;
    }

    return rc == TOXAV_ERR_BIT_RATE_SET_OK;
}

void toxav_callback_bit_rate_status(ToxAV *av, toxav_bit_rate_status_cb *callback, void *user_data)
{
    pthread_mutex_lock(av->mutex);
    av->bcb = callback;
    av->bcb_user_data = user_data;
    pthread_mutex_unlock(av->mutex);
}


void toxav_callback_audio_bit_rate(ToxAV *av, toxav_audio_bit_rate_cb *callback, void *user_data)
{
    pthread_mutex_lock(av->mutex);
    av->abcb = callback;
    av->abcb_user_data = user_data;
    pthread_mutex_unlock(av->mutex);
}

void toxav_callback_video_bit_rate(ToxAV *av, toxav_video_bit_rate_cb *callback, void *user_data)
{
    pthread_mutex_lock(av->mutex);
    av->vbcb = callback;
    av->vbcb_user_data = user_data;
    pthread_mutex_unlock(av->mutex);
}

bool toxav_audio_send_frame(ToxAV *av, uint32_t friend_number, const int16_t *pcm, size_t sample_count,
                            uint8_t channels, uint32_t sampling_rate, Toxav_Err_Send_Frame *error)
{
    return toxav_audio_send_frame_age(av, friend_number, pcm, sample_count, channels, sampling_rate, error, 0);
}

bool toxav_audio_send_frame_age(ToxAV *av, uint32_t friend_number, const int16_t *pcm, size_t sample_count,
                            uint8_t channels, uint32_t sampling_rate, Toxav_Err_Send_Frame *error, int32_t age_ms)
{
    Toxav_Err_Send_Frame rc = TOXAV_ERR_SEND_FRAME_OK;
    ToxAVCall *call;

    // add the time the data has already aged (in the client)
    uint64_t audio_frame_record_timestamp = 0;
    uint64_t mono_now = current_time_monotonic(av->toxav_mono_time);
    if (age_ms <= 0)
    {
        audio_frame_record_timestamp = mono_now - age_ms;
    }
    else
    {
        if (mono_now <= age_ms)
        {
            audio_frame_record_timestamp = mono_now;
        }
        else
        {
            audio_frame_record_timestamp = mono_now - age_ms;
        }
    }

    if (toxav_friend_exists(av->tox, friend_number) == 0) {
        rc = TOXAV_ERR_SEND_FRAME_FRIEND_NOT_FOUND;
        goto RETURN;
    }

    if (pthread_mutex_trylock(av->mutex) != 0) {
        rc = TOXAV_ERR_SEND_FRAME_SYNC;
        goto RETURN;
    }

    call = call_get(av, friend_number);

    if (call == nullptr || !call->active || call->msi_call->state != MSI_CALL_ACTIVE) {
        pthread_mutex_unlock(av->mutex);
        rc = TOXAV_ERR_SEND_FRAME_FRIEND_NOT_IN_CALL;
        goto RETURN;
    }

    if (call->audio_bit_rate == 0 ||
            !(call->msi_call->self_capabilities & MSI_CAP_S_AUDIO) ||
            !(call->msi_call->peer_capabilities & MSI_CAP_R_AUDIO)) {
        pthread_mutex_unlock(av->mutex);
        rc = TOXAV_ERR_SEND_FRAME_PAYLOAD_TYPE_DISABLED;
        goto RETURN;
    }

    pthread_mutex_lock(call->mutex_audio);
    pthread_mutex_unlock(av->mutex);

    if (pcm == nullptr) {
        pthread_mutex_unlock(call->mutex_audio);
        rc = TOXAV_ERR_SEND_FRAME_NULL;
        goto RETURN;
    }

    if (channels > 2) {
        pthread_mutex_unlock(call->mutex_audio);
        rc = TOXAV_ERR_SEND_FRAME_INVALID;
        goto RETURN;
    }

    { /* Encode and send */
        if (ac_reconfigure_encoder(call->audio, call->audio_bit_rate * 1000, sampling_rate, channels) != 0) {
            pthread_mutex_unlock(call->mutex_audio);
            LOGGER_API_WARNING(av->tox, "Failed reconfigure audio encoder");
            rc = TOXAV_ERR_SEND_FRAME_INVALID;
            goto RETURN;
        }

        VLA(uint8_t, dest, sample_count + sizeof(sampling_rate)); /* This is more than enough always */

        sampling_rate = net_htonl(sampling_rate);

        memcpy(dest, &sampling_rate, sizeof(sampling_rate));
        int vrc = opus_encode(call->audio->encoder, pcm, sample_count,
                              dest + sizeof(sampling_rate), SIZEOF_VLA(dest) - sizeof(sampling_rate));

        if (vrc < 0) {
            LOGGER_API_DEBUG(av->tox, "Failed to encode frame %s", opus_strerror(vrc));
            pthread_mutex_unlock(call->mutex_audio);
            rc = TOXAV_ERR_SEND_FRAME_INVALID;
            goto RETURN;
        }

#if defined(AUDIO_DEBUGGING_SIMULATE_SOME_DATA_LOSS)
        // set last part of audio frame to all zeros
        size_t ten_percent_size = ((size_t)vrc / 10);
        size_t start_offset = ((size_t)vrc - ten_percent_size - 1);
        memset((dest + 4 + start_offset), (int)0, ten_percent_size);
        LOGGER_API_WARNING(av->tox, "* audio packet set some ZERO data at the end *");
#endif

#if defined(AUDIO_DEBUGGING_SKIP_FRAMES)
        // skip sending some audio frames
        _debug_count_sent_audio_frames++;

        if (_debug_count_sent_audio_frames > _debug_skip_every_x_audio_frame) {
            call->audio_rtp->sequnum++;
            LOGGER_API_WARNING(av->tox, "* audio packet sending SKIPPED * %d", (int)call->audio_rtp->sequnum);
            _debug_count_sent_audio_frames = 0;
        } else {
#endif
            LOGGER_API_DEBUG(av->tox, "audio packet record time: seqnum=%d %d", (int)call->audio_rtp->sequnum,
                         (int)audio_frame_record_timestamp);

            uint16_t seq_num_save = call->audio_rtp->sequnum;

            if (rtp_send_data(call->audio_rtp, dest,
                              vrc + sizeof(sampling_rate),
                              false,
                              audio_frame_record_timestamp,
                              VIDEO_FRAGMENT_NUM_NO_FRAG,
                              0,
                              call->audio_bit_rate,
                              0,
                              0,
                              nullptr) != 0) {
                LOGGER_API_DEBUG(av->tox, "Failed to send audio packet");
                rc = TOXAV_ERR_SEND_FRAME_RTP_FAILED;
            }

#if defined(AUDIO_DEBUGGING_SKIP_FRAMES)
        }
#endif

    }

    pthread_mutex_unlock(call->mutex_audio);

RETURN:

    if (error) {
        *error = rc;
    }

    return rc == TOXAV_ERR_SEND_FRAME_OK;
}


/* --- VIDEO EN-CODING happens here --- */
/* --- VIDEO EN-CODING happens here --- */
/* --- VIDEO EN-CODING happens here --- */
bool toxav_video_send_frame(ToxAV *av, uint32_t friend_number, uint16_t width, uint16_t height, const uint8_t *y,
                            const uint8_t *u, const uint8_t *v, TOXAV_ERR_SEND_FRAME *error)
{
    return toxav_video_send_frame_age(av, friend_number, width, height, y, u, v, error, 0);
}

bool toxav_video_send_frame_age(ToxAV *av, uint32_t friend_number, uint16_t width, uint16_t height, const uint8_t *y,
                                const uint8_t *u, const uint8_t *v, TOXAV_ERR_SEND_FRAME *error, int32_t age_ms)
{
    TOXAV_ERR_SEND_FRAME rc = TOXAV_ERR_SEND_FRAME_OK;
    ToxAVCall *call;

    // add the time the data has already aged (in the client)
    uint64_t video_frame_record_timestamp = 0;
    uint64_t mono_now = current_time_monotonic(av->toxav_mono_time);
    if (age_ms <= 0)
    {
        video_frame_record_timestamp = mono_now - age_ms;
    }
    else
    {
        if (mono_now <= age_ms)
        {
            video_frame_record_timestamp = mono_now;
        }
        else
        {
            video_frame_record_timestamp = mono_now - age_ms;
        }
    }

    if (toxav_friend_exists(av->tox, friend_number) == 0) {
        rc = TOXAV_ERR_SEND_FRAME_FRIEND_NOT_FOUND;
        goto END;
    }

    if (pthread_mutex_trylock(av->mutex) != 0) {
        rc = TOXAV_ERR_SEND_FRAME_SYNC;
        goto END;
    }

    call = call_get(av, friend_number);

    if (call == NULL || !call->active || call->msi_call->state != MSI_CALL_ACTIVE) {
        pthread_mutex_unlock(av->mutex);
        rc = TOXAV_ERR_SEND_FRAME_FRIEND_NOT_IN_CALL;
        goto END;
    }

    if (call->video_bit_rate == 0 ||
            !(call->msi_call->self_capabilities & MSI_CAP_S_VIDEO) ||
            !(call->msi_call->peer_capabilities & MSI_CAP_R_VIDEO)) {
        pthread_mutex_unlock(av->mutex);
        rc = TOXAV_ERR_SEND_FRAME_PAYLOAD_TYPE_DISABLED;
        goto END;
    }

    pthread_mutex_lock(call->mutex_video);
    pthread_mutex_unlock(av->mutex);

    if (y == NULL || u == NULL || v == NULL) {
        pthread_mutex_unlock(call->mutex_video);
        rc = TOXAV_ERR_SEND_FRAME_NULL;
        goto END;
    }

    uint64_t ms_to_last_frame = 1;

    if (call->video) {
        ms_to_last_frame = current_time_monotonic(av->toxav_mono_time) - call->video->last_encoded_frame_ts;

        if (call->video->last_encoded_frame_ts == 0) {
            ms_to_last_frame = 1;
        }
    }

    int16_t force_reinit_encoder = -1;

    pthread_mutex_lock(call->toxav_call_mutex);
    // HINT: auto switch encoder, if we got capabilities packet from friend ------
    if ((call->video->video_encoder_coded_used != TOXAV_ENCODER_CODEC_USED_H264) &&
        (call->video->video_encoder_coded_used != TOXAV_ENCODER_CODEC_USED_H265)) {
        const uint64_t friend_caps = tox_friend_get_capabilities(av->tox, friend_number);
        LOGGER_API_DEBUG(av->tox, "-------> CCCCCC:%ld", (long)friend_caps);
        if ((friend_caps & TOX_CAPABILITY_TOXAV_H264) != 0) {
            LOGGER_API_DEBUG(av->tox, "-------> HHH___: * set *");
            call->video->h264_video_capabilities_received = 1;
        }
    }

    if ((call->video->h264_video_capabilities_received == 1)
            &&
            (call->video->video_encoder_coded_used != TOXAV_ENCODER_CODEC_USED_H264)
            &&
            (call->video->video_encoder_coded_used != TOXAV_ENCODER_CODEC_USED_H265)
            ) {
        // when switching to H264 set default video bitrate

        if (call->video_bit_rate > 0) {
            call->video_bit_rate = VIDEO_BITRATE_INITIAL_VALUE_H264;
            if (call->video_bit_rate < (uint32_t)call->video->video_min_bitrate) {
                call->video_bit_rate = (uint32_t)call->video->video_min_bitrate;
            }
            call->video_bit_rate_not_yet_set = call->video_bit_rate;
        }

        call->video->video_encoder_coded_used = TOXAV_ENCODER_CODEC_USED_H264;
        force_reinit_encoder = -2;

        if (av->call_comm_cb) {

            TOXAV_CALL_COMM_INFO cmi;
            cmi = TOXAV_CALL_COMM_ENCODER_IN_USE_H264;

            if (call->video->video_encoder_coded_used_hw_accel == TOXAV_ENCODER_CODEC_HW_ACCEL_OMX_PI) {
                cmi = TOXAV_CALL_COMM_ENCODER_IN_USE_H264_OMX_PI;
            }

            av->call_comm_cb(av, friend_number, cmi,
                             0, av->call_comm_cb_user_data);
        }

        // reset flag again
        call->video->h264_video_capabilities_received = 0;

    }
    pthread_mutex_unlock(call->toxav_call_mutex);


    pthread_mutex_lock(call->toxav_call_mutex);
    if (call->video->video_encoder_coded_used != TOXAV_ENCODER_CODEC_USED_VP8)
    {
        // HINT: x264 encoder needs even width and height
        if ((width % 2) != 0)
        {
            pthread_mutex_unlock(call->toxav_call_mutex);
            pthread_mutex_unlock(call->mutex_video);
            rc = TOXAV_ERR_SEND_FRAME_INVALID;
            goto END;
        }

        if ((height % 2) != 0)
        {
            pthread_mutex_unlock(call->toxav_call_mutex);
            pthread_mutex_unlock(call->mutex_video);
            rc = TOXAV_ERR_SEND_FRAME_INVALID;
            goto END;
        }
    }
    pthread_mutex_unlock(call->toxav_call_mutex);

    pthread_mutex_lock(call->toxav_call_mutex);
    // HINT: auto switch encoder, if we got capabilities packet from friend ------
    if ((call->video->video_encoder_coded_used == TOXAV_ENCODER_CODEC_USED_VP8)
            || (call->video->video_encoder_coded_used == TOXAV_ENCODER_CODEC_USED_VP9)) {

        if (vc_reconfigure_encoder(nullptr, call->video, call->video_bit_rate * 1000,
                                   width, height, -1) != 0) {
            pthread_mutex_unlock(call->toxav_call_mutex);
            pthread_mutex_unlock(call->mutex_video);
            rc = TOXAV_ERR_SEND_FRAME_INVALID;
            goto END;
        }
    } else {
        // HINT: H264 (and H265)
        if (vc_reconfigure_encoder(nullptr, call->video, call->video_bit_rate * 1000,
                                   width, height, force_reinit_encoder) != 0) {
            pthread_mutex_unlock(call->toxav_call_mutex);
            pthread_mutex_unlock(call->mutex_video);
            rc = TOXAV_ERR_SEND_FRAME_INVALID;
            goto END;
        }
    }

    if ((call->video_bit_rate_last_last_changed_cb_ts + 500) < current_time_monotonic(av->toxav_mono_time)) {
        if (call->video_bit_rate_last_last_changed != call->video_bit_rate) {
            if (av->call_comm_cb) {
                int64_t bitrate_copy = (int64_t)call->video_bit_rate;
                pthread_mutex_unlock(call->toxav_call_mutex);
                av->call_comm_cb(av, friend_number,
                                 TOXAV_CALL_COMM_ENCODER_CURRENT_BITRATE,
                                 bitrate_copy,
                                 av->call_comm_cb_user_data);
                pthread_mutex_lock(call->toxav_call_mutex);
            }

            call->video_bit_rate_last_last_changed = call->video_bit_rate;
        }

        call->video_bit_rate_last_last_changed_cb_ts = current_time_monotonic(av->toxav_mono_time);
    }
    pthread_mutex_unlock(call->toxav_call_mutex);

    int vpx_encode_flags = 0;
    unsigned long max_encode_time_in_us = MAX_ENCODE_TIME_US;

    int h264_iframe_factor = 1;

    if (call->video->video_encoder_coded_used == TOXAV_ENCODER_CODEC_USED_H264) {
        h264_iframe_factor = 1;
    }

    if (call->video->video_keyframe_method == TOXAV_ENCODER_KF_METHOD_NORMAL) {
        if (call->video_rtp->ssrc < (uint32_t)(VIDEO_SEND_X_KEYFRAMES_FIRST * h264_iframe_factor)) {

            if (call->video->video_encoder_coded_used != TOXAV_ENCODER_CODEC_USED_VP9) {
                // Key frame flag for first frames
                vpx_encode_flags = VPX_EFLAG_FORCE_KF;
                vpx_encode_flags |= VP8_EFLAG_FORCE_GF;
                max_encode_time_in_us = VPX_DL_REALTIME;
            }

            call->video_rtp->ssrc++;
        } else if (call->video_rtp->ssrc == (uint32_t)(VIDEO_SEND_X_KEYFRAMES_FIRST * h264_iframe_factor)) {
            if (call->video->video_encoder_coded_used != TOXAV_ENCODER_CODEC_USED_VP9) {
                // normal keyframe placement
                vpx_encode_flags = 0;
                max_encode_time_in_us = MAX_ENCODE_TIME_US;
                LOGGER_API_INFO(av->tox, "I_FRAME_FLAG:%d normal mode", call->video_rtp->ssrc);
            }

            call->video_rtp->ssrc++;
        }
    }


    // we start with I-frames (full frames) and then switch to normal mode later
    call->video->last_encoded_frame_ts = current_time_monotonic(av->toxav_mono_time);

    if (call->video->send_keyframe_request_received == 1) {
        vpx_encode_flags = VPX_EFLAG_FORCE_KF;
        vpx_encode_flags |= VP8_EFLAG_FORCE_GF;
        call->video->send_keyframe_request_received = 0;
    } else {
        if ((call->video->last_sent_keyframe_ts + VIDEO_MIN_SEND_KEYFRAME_INTERVAL)
                < current_time_monotonic(av->toxav_mono_time)) {
            // it's been x seconds without a keyframe, send one now
            vpx_encode_flags = VPX_EFLAG_FORCE_KF;
            vpx_encode_flags |= VP8_EFLAG_FORCE_GF;
        }
    }

    // for the H264 encoder -------
    x264_nal_t *nal = NULL;
    int i_frame_size = 0;
    // for the H264 encoder -------

#ifdef HAVE_H265_ENCODER
    // for the H265 encoder -------
    x265_nal* h265_nals = NULL;
    // for the H265 encoder -------
#endif

    int h265_num_nals = 0;

    { /* Encode */

        if ((call->video->video_encoder_coded_used == TOXAV_ENCODER_CODEC_USED_VP8)
                || (call->video->video_encoder_coded_used == TOXAV_ENCODER_CODEC_USED_VP9)) {

            LOGGER_API_DEBUG(av->tox, "++++++ encoding VP8 frame ++++++");
            uint32_t result = encode_frame_vpx(av, friend_number, width, height,
                                               y, u, v, call,
                                               &video_frame_record_timestamp,
                                               vpx_encode_flags,
                                               &nal,
                                               &i_frame_size);

            if (result != 0) {
                pthread_mutex_unlock(call->mutex_video);
                rc = TOXAV_ERR_SEND_FRAME_INVALID;
                goto END;
            }
        } else {

#ifdef HAVE_H265_ENCODER
            if (call->video->video_encoder_coded_used == TOXAV_ENCODER_CODEC_USED_H265)
            {
                LOGGER_API_DEBUG(av->tox, "**__** encoding H265 frame **__**");
                uint32_t result = encode_frame_h265(av, friend_number, width, height,
                                           y, u, v, call,
                                           &video_frame_record_timestamp,
                                           vpx_encode_flags,
                                           &h265_num_nals,
                                           &nal,
                                           &i_frame_size, &h265_nals);
                if (result != 0) {
                    pthread_mutex_unlock(call->mutex_video);
                    rc = TOXAV_ERR_SEND_FRAME_INVALID;
                    goto END;
                }
            }
#endif

            if (call->video->video_encoder_coded_used == TOXAV_ENCODER_CODEC_USED_H264)
            {
                LOGGER_API_DEBUG(av->tox, "**##** encoding H264 frame **##**");
                uint32_t result = encode_frame_h264(av, friend_number, width, height,
                                                    y, u, v, call,
                                                    &video_frame_record_timestamp,
                                                    vpx_encode_flags,
                                                    &nal,
                                                    &i_frame_size);
                if (result != 0) {
                    pthread_mutex_unlock(call->mutex_video);
                    rc = TOXAV_ERR_SEND_FRAME_INVALID;
                    goto END;
                }
            }
        }
    }


    ++call->video->frame_counter;

    LOGGER_API_DEBUG(av->tox, "VPXENC:======================\n");
    LOGGER_API_DEBUG(av->tox, "VPXENC:frame num=%ld\n", (long)call->video->frame_counter);

    { /* Send frames */


        if ((call->video->video_encoder_coded_used == TOXAV_ENCODER_CODEC_USED_VP8)
                || (call->video->video_encoder_coded_used == TOXAV_ENCODER_CODEC_USED_VP9)) {

            uint32_t result = send_frames_vpx(av, friend_number, width, height,
                                              y, u, v, call,
                                              &video_frame_record_timestamp,
                                              vpx_encode_flags,
                                              &nal,
                                              &i_frame_size,
                                              &rc);

            if (result != 0) {
                pthread_mutex_unlock(call->mutex_video);
                goto END;
            }

        } else {

#ifdef HAVE_H265_ENCODER
            if (call->video->video_encoder_coded_used == TOXAV_ENCODER_CODEC_USED_H265) {
                uint32_t result = send_frames_h265(av, friend_number, width, height,
                                                   y, u, v, call,
                                                   &video_frame_record_timestamp,
                                                   vpx_encode_flags,
                                                   &nal,
                                                   &i_frame_size,
                                                   h265_num_nals,
                                                   &h265_nals,
                                                   &rc);
                if (result != 0) {
                    pthread_mutex_unlock(call->mutex_video);
                    goto END;
                }
            }
#endif

            if (call->video->video_encoder_coded_used == TOXAV_ENCODER_CODEC_USED_H264) {
                uint32_t result = send_frames_h264(av, friend_number, width, height,
                                                   y, u, v, call,
                                                   &video_frame_record_timestamp,
                                                   vpx_encode_flags,
                                                   &nal,
                                                   &i_frame_size,
                                                   &rc);

                if (result != 0) {
                    pthread_mutex_unlock(call->mutex_video);
                    goto END;
                }
            }
        }
    }

    pthread_mutex_unlock(call->mutex_video);

END:

    if (error) {
        *error = rc;
    }

    return rc == TOXAV_ERR_SEND_FRAME_OK;
}
/* --- VIDEO EN-CODING happens here --- */
/* --- VIDEO EN-CODING happens here --- */
/* --- VIDEO EN-CODING happens here --- */

bool toxav_video_send_frame_h264(ToxAV *av, uint32_t friend_number, uint16_t width, uint16_t height, const uint8_t *buf,
                                 uint32_t data_len, TOXAV_ERR_SEND_FRAME *error)
{
    return toxav_video_send_frame_h264_age(av, friend_number, width, height, buf, data_len, error, 0);
}

bool toxav_video_send_frame_h264_age(ToxAV *av, uint32_t friend_number, uint16_t width, uint16_t height,
                                     const uint8_t *buf,
                                     uint32_t data_len, TOXAV_ERR_SEND_FRAME *error, int32_t age_ms)
{
    TOXAV_ERR_SEND_FRAME rc = TOXAV_ERR_SEND_FRAME_OK;
    ToxAVCall *call;

    // add the time the data has already aged (in the client)
    uint64_t video_frame_record_timestamp;
    uint64_t mono_now = current_time_monotonic(av->toxav_mono_time);
    if (age_ms < 0)
    {
        video_frame_record_timestamp = mono_now - age_ms;
    }
    else
    {
        if (mono_now <= age_ms)
        {
            video_frame_record_timestamp = mono_now;
        }
        else
        {
            video_frame_record_timestamp = mono_now - age_ms;
            LOGGER_API_DEBUG(av->tox, "toxav_video_send_frame_h264_age:age_ms=%d", age_ms);
        }
    }

    if (toxav_friend_exists(av->tox, friend_number) == 0) {
        rc = TOXAV_ERR_SEND_FRAME_FRIEND_NOT_FOUND;
        goto RETURN;
    }

    if (pthread_mutex_trylock(av->mutex) != 0) {
        rc = TOXAV_ERR_SEND_FRAME_SYNC;
        goto RETURN;
    }

    call = call_get(av, friend_number);

    if (call == nullptr || !call->active || call->msi_call->state != MSI_CALL_ACTIVE) {
        pthread_mutex_unlock(av->mutex);
        rc = TOXAV_ERR_SEND_FRAME_FRIEND_NOT_IN_CALL;
        goto RETURN;
    }

    uint64_t ms_to_last_frame = 1;

    if (call->video) {
        ms_to_last_frame = current_time_monotonic(av->toxav_mono_time) - call->video->last_encoded_frame_ts;

        if (call->video->last_encoded_frame_ts == 0) {
            ms_to_last_frame = 1;
        }
    }

    if (call->video_bit_rate == 0 ||
            !(call->msi_call->self_capabilities & MSI_CAP_S_VIDEO) ||
            !(call->msi_call->peer_capabilities & MSI_CAP_R_VIDEO)) {
        pthread_mutex_unlock(av->mutex);
        rc = TOXAV_ERR_SEND_FRAME_PAYLOAD_TYPE_DISABLED;
        goto RETURN;
    }

    pthread_mutex_lock(call->mutex_video);
    pthread_mutex_unlock(av->mutex);

    if (buf == NULL) {
        pthread_mutex_unlock(call->mutex_video);
        rc = TOXAV_ERR_SEND_FRAME_NULL;
        goto RETURN;
    }

    int16_t force_reinit_encoder = -1;

    // HINT: auto switch encoder, if we got capabilities packet from friend ------
    if (call->video->video_encoder_coded_used != TOXAV_ENCODER_CODEC_USED_H264) {
        const uint64_t friend_caps = tox_friend_get_capabilities(av->tox, friend_number);
        LOGGER_API_DEBUG(av->tox, "-------> CCCCCC:%ld", (long)friend_caps);
        if ((friend_caps & TOX_CAPABILITY_TOXAV_H264) != 0) {
            LOGGER_API_DEBUG(av->tox, "-------> HHH___: * set *");
            call->video->h264_video_capabilities_received = 1;
        }
    }

    if ((call->video->h264_video_capabilities_received == 1)
            &&
            (call->video->video_encoder_coded_used != TOXAV_ENCODER_CODEC_USED_H264)) {
        // when switching to H264 set default video bitrate

        if (call->video_bit_rate > 0) {
            call->video_bit_rate = VIDEO_BITRATE_INITIAL_VALUE_H264;
            if (call->video_bit_rate < (uint32_t)call->video->video_min_bitrate) {
                call->video_bit_rate = (uint32_t)call->video->video_min_bitrate;
            }
            call->video_bit_rate_not_yet_set = call->video_bit_rate;
        }

        call->video->video_encoder_coded_used = TOXAV_ENCODER_CODEC_USED_H264;
        // LOGGER_API_ERROR(av->tox, "TOXAV_ENCODER_CODEC_USED_H264");
        force_reinit_encoder = -2;

        if (av->call_comm_cb) {

            TOXAV_CALL_COMM_INFO cmi;
            cmi = TOXAV_CALL_COMM_ENCODER_IN_USE_H264;

            if (call->video->video_encoder_coded_used_hw_accel == TOXAV_ENCODER_CODEC_HW_ACCEL_OMX_PI) {
                cmi = TOXAV_CALL_COMM_ENCODER_IN_USE_H264_OMX_PI;
            }

            av->call_comm_cb(av, friend_number, cmi,
                             0, av->call_comm_cb_user_data);
        }

        // reset flag again
        call->video->h264_video_capabilities_received = 0;
    }

    // HINT: auto switch encoder, if we got capabilities packet from friend ------


    if ((call->video_bit_rate_last_last_changed_cb_ts + 500) < current_time_monotonic(av->toxav_mono_time)) {
        if (call->video_bit_rate_last_last_changed != call->video_bit_rate) {
            if (av->call_comm_cb) {
                av->call_comm_cb(av, friend_number,
                                 TOXAV_CALL_COMM_ENCODER_CURRENT_BITRATE,
                                 (int64_t)call->video_bit_rate,
                                 av->call_comm_cb_user_data);
            }

            call->video_bit_rate_last_last_changed = call->video_bit_rate;
        }

        call->video_bit_rate_last_last_changed_cb_ts = current_time_monotonic(av->toxav_mono_time);
    }

    call->video->last_encoded_frame_ts = current_time_monotonic(av->toxav_mono_time);

    ++call->video->frame_counter;

    LOGGER_API_DEBUG(av->tox, "VPXENC:======================\n");
    LOGGER_API_DEBUG(av->tox, "VPXENC:frame num=%ld\n", (long)call->video->frame_counter);


    { /* Send frames */
        uint32_t result = 0;
        const uint32_t frame_length_in_bytes = data_len;
        const int keyframe = (int)0; // TODO: use the actual value!

        LOGGER_API_DEBUG(av->tox, "video packet record time: %d", (int)(video_frame_record_timestamp));
        int res = rtp_send_data
                  (
                      call->video_rtp,
                      (const uint8_t *)buf,
                      frame_length_in_bytes,
                      keyframe,
                      video_frame_record_timestamp,
                      (int32_t)0,
                      TOXAV_ENCODER_CODEC_USED_H264,
                      call->video_bit_rate,
                      call->video->client_video_capture_delay_ms,
                      call->video->video_encoder_frame_orientation_angle,
                      nullptr
                  );

        video_frame_record_timestamp++;

        if (res < 0) {
            LOGGER_API_WARNING(av->tox, "Could not send video frame: %s", strerror(errno));
            rc = TOXAV_ERR_SEND_FRAME_RTP_FAILED;
            result = 1;
        } else {
            result = 0;
        }

        if (result != 0) {
            pthread_mutex_unlock(call->mutex_video);
            goto RETURN;
        }
    }

    pthread_mutex_unlock(call->mutex_video);

RETURN:

    if (error) {
        *error = rc;
    }

    return rc == TOXAV_ERR_SEND_FRAME_OK;
}

void toxav_callback_audio_receive_frame(ToxAV *av, toxav_audio_receive_frame_cb *callback, void *user_data)
{
    pthread_mutex_lock(av->mutex);
    av->acb = callback;
    av->acb_user_data = user_data;
    pthread_mutex_unlock(av->mutex);
}

void toxav_callback_audio_receive_frame_pts(ToxAV *av, toxav_audio_receive_frame_pts_cb *callback, void *user_data)
{
    pthread_mutex_lock(av->mutex);
    av->acb_pts = callback;
    av->acb_pts_user_data = user_data;
    pthread_mutex_unlock(av->mutex);
}

void toxav_callback_video_receive_frame(ToxAV *av, toxav_video_receive_frame_cb *callback, void *user_data)
{
    pthread_mutex_lock(av->mutex);
    av->vcb = callback;
    av->vcb_user_data = user_data;
    pthread_mutex_unlock(av->mutex);
}

void toxav_callback_video_receive_frame_pts(ToxAV *av, toxav_video_receive_frame_pts_cb *callback, void *user_data)
{
    pthread_mutex_lock(av->mutex);
    av->vcb_pts = callback;
    av->vcb_pts_user_data = user_data;
    pthread_mutex_unlock(av->mutex);
}

void toxav_callback_video_receive_frame_h264(ToxAV *av, toxav_video_receive_frame_h264_cb *callback, void *user_data)
{
    pthread_mutex_lock(av->mutex);
    av->vcb_h264 = callback;
    av->vcb_h264_user_data = user_data;
    pthread_mutex_unlock(av->mutex);
}


/*******************************************************************************
 *
 * :: Internal
 *
 ******************************************************************************/
void callback_bwc(BWController *bwc, uint32_t friend_number, float loss, void *user_data)
{
    if (!user_data)
    {
        return;
    }

    ToxAVCall *call = (ToxAVCall *)user_data;

    if (!call) {
        return;
    }

    if (!call->av) {
        return;
    }

    pthread_mutex_lock(call->toxav_call_mutex);
    if (call->active == 0) {
        pthread_mutex_unlock(call->toxav_call_mutex);
        return;
    }
    pthread_mutex_unlock(call->toxav_call_mutex);


    if (pthread_mutex_trylock(call->av->mutex) != 0) {
        LOGGER_API_DEBUG(call->av->tox, "could not lock call->av->mutex, returning without processing BWC data");
        return;
    }

    if (pthread_mutex_trylock(call->mutex_video) != 0) {
        pthread_mutex_unlock(call->av->mutex);
        LOGGER_API_DEBUG(call->av->tox, "could not lock call->mutex_video, returning without processing BWC data");
        return;
    }


    pthread_mutex_lock(call->toxav_call_mutex);
    if (call->active == 0) {
        pthread_mutex_unlock(call->toxav_call_mutex);
        pthread_mutex_unlock(call->mutex_video);
        pthread_mutex_unlock(call->av->mutex);
        return;
    }

    if (call->video_bit_rate == 0) {
        // HINT: video is turned off -> just do nothing
        pthread_mutex_unlock(call->toxav_call_mutex);
        pthread_mutex_unlock(call->mutex_video);
        pthread_mutex_unlock(call->av->mutex);
        return;
    }

    if (!call->video) {
        pthread_mutex_unlock(call->toxav_call_mutex);
        pthread_mutex_unlock(call->mutex_video);
        pthread_mutex_unlock(call->av->mutex);
        return;
    }

    if (call->video->video_bitrate_autoset == 0) {
        // HINT: client does not want bitrate autoset
        pthread_mutex_unlock(call->toxav_call_mutex);
        pthread_mutex_unlock(call->mutex_video);
        pthread_mutex_unlock(call->av->mutex);
        return;
    }

    if ((int)(loss * 100) < (int)VIDEO_BITRATE_AUTO_INC_THRESHOLD) {
        if (call->video_bit_rate < VIDEO_BITRATE_MAX_AUTO_VALUE_H264) {

            int64_t tmp = (uint32_t)call->video_bit_rate_not_yet_set;

            if (tmp < VIDEO_BITRATE_SCALAR_AUTO_VALUE_H264) {
                tmp = tmp + VIDEO_BITRATE_SCALAR_INC_BY_AUTO_VALUE_H264;
            } else if (tmp > VIDEO_BITRATE_SCALAR2_AUTO_VALUE_H264) {
                tmp = tmp + VIDEO_BITRATE_SCALAR2_INC_BY_AUTO_VALUE_H264;
            } else {
                tmp = (uint32_t)((float)tmp * (float)VIDEO_BITRATE_AUTO_INC_TO);
            }

            // HINT: sanity check --------------
            if ((uint32_t)tmp < VIDEO_BITRATE_MIN_AUTO_VALUE_H264) {
                tmp = VIDEO_BITRATE_MIN_AUTO_VALUE_H264;
            } else if ((uint32_t)tmp > VIDEO_BITRATE_MAX_AUTO_VALUE_H264) {
                tmp = VIDEO_BITRATE_MAX_AUTO_VALUE_H264;
            }

            if ((uint32_t)tmp > (uint32_t)call->video->video_max_bitrate) {
                tmp = (uint32_t)call->video->video_max_bitrate;
            }

            call->video_bit_rate_not_yet_set = (uint32_t)tmp;
            // HINT: sanity check --------------

            LOGGER_API_DEBUG(call->av->tox, "callback_bwc:INC:vb=%d loss=%d", (int)call->video_bit_rate_not_yet_set,
                         (int)(loss * 100));
            call->video_bit_rate = (uint32_t)call->video_bit_rate_not_yet_set;
        }
    } else if ((int)(loss * 100) > (int)VIDEO_BITRATE_AUTO_DEC_THRESHOLD) {
        if (call->video_bit_rate > VIDEO_BITRATE_MIN_AUTO_VALUE_H264) {

            int64_t tmp = (int64_t)call->video_bit_rate - (VIDEO_BITRATE_SCALAR_DEC_BY_AUTO_VALUE_H264 * (int)(loss * 100));

            // HINT: sanity check --------------
            if (tmp < VIDEO_BITRATE_MIN_AUTO_VALUE_H264) {
                tmp = VIDEO_BITRATE_MIN_AUTO_VALUE_H264;
            } else if (tmp > VIDEO_BITRATE_MAX_AUTO_VALUE_H264) {
                tmp = VIDEO_BITRATE_MAX_AUTO_VALUE_H264;
            }

            if (tmp > (uint32_t)call->video->video_max_bitrate) {
                tmp = (uint32_t)call->video->video_max_bitrate;
            }
            // HINT: sanity check --------------

            call->video_bit_rate = (uint32_t)tmp;
            call->video_bit_rate_not_yet_set = call->video_bit_rate;
        }
    }

    // HINT: sanity check --------------
    if ((call->video->video_encoder_coded_used == TOXAV_ENCODER_CODEC_USED_H264) ||
        (call->video->video_encoder_coded_used == TOXAV_ENCODER_CODEC_USED_H265)) {
        if (call->video_bit_rate < VIDEO_BITRATE_MIN_AUTO_VALUE_H264) {
            call->video_bit_rate = VIDEO_BITRATE_MIN_AUTO_VALUE_H264;
        } else if (call->video_bit_rate > VIDEO_BITRATE_MAX_AUTO_VALUE_H264) {
            call->video_bit_rate = VIDEO_BITRATE_MAX_AUTO_VALUE_H264;
        }
    } else {
        if (call->video_bit_rate < VIDEO_BITRATE_MIN_AUTO_VALUE_VP8) {
            call->video_bit_rate = VIDEO_BITRATE_MIN_AUTO_VALUE_VP8;
        } else if (call->video_bit_rate > VIDEO_BITRATE_MAX_AUTO_VALUE_VP8) {
            call->video_bit_rate = VIDEO_BITRATE_MAX_AUTO_VALUE_VP8;
        }
        call->video_bit_rate = (uint32_t)((float)call->video_bit_rate * VIDEO_BITRATE_CORRECTION_FACTOR_VP8);
        if (call->video_bit_rate < VIDEO_BITRATE_MIN_AUTO_VALUE_VP8) {
            call->video_bit_rate = VIDEO_BITRATE_MIN_AUTO_VALUE_VP8;
        }
    }

    if (call->video_bit_rate > (uint32_t)call->video->video_max_bitrate) {
        call->video_bit_rate = (uint32_t)call->video->video_max_bitrate;
    }

    if (call->video_bit_rate < (uint32_t)call->video->video_min_bitrate) {
        call->video_bit_rate = (uint32_t)call->video->video_min_bitrate;
    }
    // HINT: sanity check --------------

    pthread_mutex_unlock(call->toxav_call_mutex);
    pthread_mutex_unlock(call->mutex_video);
    pthread_mutex_unlock(call->av->mutex);
}

// ------------ MSI callback function ------------
// ------------ MSI callback function ------------
// ------------ MSI callback function ------------
static int callback_invite(void *toxav_inst, MSICall *call)
{
    ToxAV *toxav = (ToxAV *)toxav_inst;
    pthread_mutex_lock(toxav->mutex);

    ToxAVCall *av_call = call_new(toxav, call->friend_number, nullptr);

    if (av_call == nullptr) {
        LOGGER_API_WARNING(toxav->tox, "Failed to initialize call...");
        pthread_mutex_unlock(toxav->mutex);
        return -1;
    }

    call->av_call = av_call;
    av_call->msi_call = call;

    if (toxav->ccb) {
        toxav->ccb(toxav, call->friend_number, call->peer_capabilities & MSI_CAP_S_AUDIO,
                   call->peer_capabilities & MSI_CAP_S_VIDEO, toxav->ccb_user_data);
    } else {
        /* No handler to capture the call request, send failure */
        pthread_mutex_unlock(toxav->mutex);
        return -1;
    }

    pthread_mutex_unlock(toxav->mutex);
    return 0;
}

static int callback_start(void *toxav_inst, MSICall *call)
{
    ToxAV *toxav = (ToxAV *)toxav_inst;
    pthread_mutex_lock(toxav->mutex);

    ToxAVCall *av_call = call_get(toxav, call->friend_number);

    if (av_call == nullptr) {
        /* Should this ever happen? */
        pthread_mutex_unlock(toxav->mutex);
        return -1;
    }

    if (!call_prepare_transmission(av_call)) {
        callback_error(toxav_inst, call);
        pthread_mutex_unlock(toxav->mutex);
        return -1;
    }

    if (!invoke_call_state_callback(toxav, call->friend_number, call->peer_capabilities)) {
        callback_error(toxav_inst, call);
        pthread_mutex_unlock(toxav->mutex);
        return -1;
    }

    pthread_mutex_unlock(toxav->mutex);
    return 0;
}

static int callback_end(void *toxav_inst, MSICall *call)
{
    ToxAV *toxav = (ToxAV *)toxav_inst;
    pthread_mutex_lock(toxav->mutex);

    invoke_call_state_callback(toxav, call->friend_number, TOXAV_FRIEND_CALL_STATE_FINISHED);

    if (call->av_call) {
        call_kill_transmission(call->av_call);
        call_remove(call->av_call);
    }

    pthread_mutex_unlock(toxav->mutex);
    return 0;
}

static int callback_error(void *toxav_inst, MSICall *call)
{
    ToxAV *toxav = (ToxAV *)toxav_inst;
    pthread_mutex_lock(toxav->mutex);

    invoke_call_state_callback(toxav, call->friend_number, TOXAV_FRIEND_CALL_STATE_ERROR);

    if (call->av_call) {
        call_kill_transmission(call->av_call);
        call_remove(call->av_call);
    }

    pthread_mutex_unlock(toxav->mutex);
    return 0;
}

static int callback_capabilites(void *toxav_inst, MSICall *call)
{
    ToxAV *toxav = (ToxAV *)toxav_inst;
    pthread_mutex_lock(toxav->mutex);

    if (call->peer_capabilities & MSI_CAP_S_AUDIO) {
        rtp_allow_receiving_mark(toxav->tox, call->av_call->audio_rtp);
    } else {
        rtp_stop_receiving_mark(toxav->tox, call->av_call->audio_rtp);
    }

    if (call->peer_capabilities & MSI_CAP_S_VIDEO) {
        rtp_allow_receiving_mark(toxav->tox, call->av_call->video_rtp);
    } else {
        rtp_stop_receiving_mark(toxav->tox, call->av_call->video_rtp);
    }

    invoke_call_state_callback(toxav, call->friend_number, call->peer_capabilities);

    pthread_mutex_unlock(toxav->mutex);
    return 0;
}
// ------------ MSI callback function ------------
// ------------ MSI callback function ------------
// ------------ MSI callback function ------------

static bool audio_bit_rate_invalid(uint32_t bit_rate)
{
    /* Opus RFC 6716 section-2.1.1 dictates the following:
     * Opus supports all bit rates from 6 kbit/s to 510 kbit/s.
     */
    return bit_rate < 6 || bit_rate > 510;
}

static bool video_bit_rate_invalid(uint32_t bit_rate)
{
    (void) bit_rate;
    // TODO: remove this, its useless
    return false;
}

static bool invoke_call_state_callback(ToxAV *av, uint32_t friend_number, uint32_t state)
{
    if (av->scb) {
        av->scb(av, friend_number, state, av->scb_user_data);
    } else {
        return false;
    }

    return true;
}

static ToxAVCall *call_new(ToxAV *av, uint32_t friend_number, Toxav_Err_Call *error)
{
    /* Assumes mutex locked */
    Toxav_Err_Call rc = TOXAV_ERR_CALL_OK;
    ToxAVCall *call = nullptr;

    LOGGER_API_INFO(av->tox, "enter ...:fnum=%d", friend_number);

    if (toxav_friend_exists(av->tox, friend_number) == 0) {
        rc = TOXAV_ERR_CALL_FRIEND_NOT_FOUND;
        LOGGER_API_WARNING(av->tox, "TOXAV_ERR_CALL_FRIEND_NOT_FOUND:fnum=%d", friend_number);
        goto RETURN;
    }

    TOX_ERR_FRIEND_QUERY f_con_query_error;
    TOX_CONNECTION f_conn_status = tox_friend_get_connection_status(av->tox, friend_number, &f_con_query_error);

    if (f_conn_status == TOX_CONNECTION_NONE) {
        rc = TOXAV_ERR_CALL_FRIEND_NOT_CONNECTED;
        LOGGER_API_WARNING(av->tox, "TOXAV_ERR_CALL_FRIEND_NOT_CONNECTED:fnum=%d", friend_number);
        goto RETURN;
    }

    if (call_get(av, friend_number) != nullptr) {
        LOGGER_API_WARNING(av->tox, "TOXAV_ERR_CALL_FRIEND_ALREADY_IN_CALL:fnum=%d", friend_number);
        rc = TOXAV_ERR_CALL_FRIEND_ALREADY_IN_CALL;
        goto RETURN;
    }

    call = (ToxAVCall *)calloc(sizeof(ToxAVCall), 1);

    if (call == nullptr) {
        LOGGER_API_WARNING(av->tox, "TOXAV_ERR_CALL_MALLOC:fnum=%d", friend_number);
        rc = TOXAV_ERR_CALL_MALLOC;
        goto RETURN;
    }

    call->last_incoming_video_frame_rtimestamp = 0;
    call->last_incoming_video_frame_ltimestamp = 0;

    call->last_incoming_audio_frame_rtimestamp = 0;
    call->last_incoming_audio_frame_ltimestamp = 0;

    call->reference_rtimestamp = 0;
    call->reference_ltimestamp = 0;
    call->reference_diff_timestamp = 0;
    call->reference_diff_timestamp_set = 0;
    call->call_video_has_rountrip_time_ms = 0;

    call->av = av;
    call->friend_number = friend_number;

    if (create_recursive_mutex(call->toxav_call_mutex)) {
        free(call);
        call = nullptr;
        LOGGER_API_WARNING(av->tox, "TOXAV_ERR_CALL_MALLOC:2:fnum=%d", friend_number);
        rc = TOXAV_ERR_CALL_MALLOC;
        goto RETURN;
    }

    if (av->calls == nullptr) { /* Creating */
        av->calls = (ToxAVCall **)calloc((friend_number + 1), sizeof(ToxAVCall *));

        LOGGER_API_INFO(av->tox, "Creating:fnum=%d bytes=%d", friend_number, (int)((friend_number + 1) * sizeof(ToxAVCall *)));

        if (av->calls == nullptr) {
            pthread_mutex_destroy(call->toxav_call_mutex);
            free(call);
            call = nullptr;
            LOGGER_API_WARNING(av->tox, "TOXAV_ERR_CALL_MALLOC:3:fnum=%d", friend_number);
            rc = TOXAV_ERR_CALL_MALLOC;
            goto RETURN;
        }

        av->calls_tail = friend_number;
        av->calls_head = friend_number;

        LOGGER_API_INFO(av->tox, "Creating:fnum=%d h=%d t=%d", friend_number, av->calls_head, av->calls_tail);

    } else if (friend_number > av->calls_tail) { /* Appending */
        ToxAVCall **tmp = (ToxAVCall **)realloc(av->calls, (friend_number + 1) * sizeof(ToxAVCall *));

        LOGGER_API_INFO(av->tox, "Appending:fnum=%d bytes=%d", friend_number, (int)((friend_number + 1) * sizeof(ToxAVCall *)));

        if (tmp == nullptr) {
            pthread_mutex_destroy(call->toxav_call_mutex);
            free(call);
            call = nullptr;
            LOGGER_API_WARNING(av->tox, "TOXAV_ERR_CALL_MALLOC:4:fnum=%d", friend_number);
            rc = TOXAV_ERR_CALL_MALLOC;
            goto RETURN;
        }

        av->calls = tmp;

        /* Set fields in between to null */
        for (uint32_t i = av->calls_tail + 1; i < friend_number; ++i) {
            av->calls[i] = nullptr;
        }

        call->prev = av->calls[av->calls_tail];
        av->calls[av->calls_tail]->next = call;

        av->calls_tail = friend_number;

        LOGGER_API_INFO(av->tox, "Appending:fnum=%d h=%d t=%d", friend_number, av->calls_head, av->calls_tail);

    } else if (av->calls_head > friend_number) { /* Inserting at front */

        LOGGER_API_INFO(av->tox, "Inserting at front:fnum=%d", friend_number);

        call->next = av->calls[av->calls_head];
        av->calls[av->calls_head]->prev = call;
        av->calls_head = friend_number;

        LOGGER_API_INFO(av->tox, "Inserting at front:fnum=%d h=%d t=%d", friend_number, av->calls_head, av->calls_tail);
    } else { /* right in the middle somewhere */
        // find the previous entry
        ToxAVCall *found_prev_entry = nullptr;
        for (uint32_t i=av->calls_head;i<=av->calls_tail;i++)
        {
            if (av->calls[i])
            {
                if (i < friend_number)
                {
                    found_prev_entry = av->calls[i];
                }
                else
                {
                    break;
                }
            }
        }

        // find the next entry
        ToxAVCall *found_next_entry = nullptr;
        for (uint32_t i=av->calls_head;i<=av->calls_tail;i++)
        {
            if (av->calls[i])
            {
                if (i > friend_number)
                {
                    found_next_entry = av->calls[i];
                    break;
                }
            }
        }

        // set chain-links correctly
        call->prev = found_prev_entry;
        if (found_prev_entry)
        {
            found_prev_entry->next = call;
        }
        //
        call->next = found_next_entry;
        if (found_next_entry)
        {
            found_next_entry->prev = call;
        }
    }


    av->calls[friend_number] = call;

RETURN:

    if (error) {
        *error = rc;
    }

    return call;
}

static ToxAVCall *call_remove(ToxAVCall *call)
{
    if (call == nullptr) {
        return nullptr;
    }

    uint32_t friend_number = call->friend_number;
    ToxAV *av = call->av;

    LOGGER_API_INFO(av->tox, "call:remove:fnum=%d", friend_number);
    LOGGER_API_INFO(av->tox, "call:remove:fnum=%d before:h=%d t=%d", friend_number, av->calls_head, av->calls_tail);

    ToxAVCall *prev = call->prev;
    ToxAVCall *next = call->next;

    /* Set av call in msi to NULL in order to know if call in ToxAVCall is
     * removed from the msi call.
     */
    if (call->msi_call) {
        call->msi_call->av_call = nullptr;
    }

    pthread_mutex_lock(call->toxav_call_mutex);
    LOGGER_API_DEBUG(av->tox, "call:calls[friend_number] NULL ...");
    av->calls[friend_number] = nullptr;
    pthread_mutex_unlock(call->toxav_call_mutex);

    LOGGER_API_WARNING(av->tox, "call:freeing ...");
    pthread_mutex_destroy(call->toxav_call_mutex);
    free(call);
    call = nullptr;
    LOGGER_API_WARNING(av->tox, "call:freed");

    if (prev) {
        prev->next = next;
    } else if (next) {
        av->calls_head = next->friend_number;
    } else {
        goto CLEAR;
    }

    if (next) {
        next->prev = prev;
    } else if (prev) {
        av->calls_tail = prev->friend_number;
    } else {
        goto CLEAR;
    }

    LOGGER_API_INFO(av->tox, "call:remove:fnum=%d after_01:h=%d t=%d", friend_number, av->calls_head, av->calls_tail);

    return next;

CLEAR:
    av->calls_head = 0;
    av->calls_tail = 0;
    free(av->calls);
    av->calls = nullptr;

    LOGGER_API_INFO(av->tox, "call:remove:fnum=%d after_02:h=%d t=%d", friend_number, av->calls_head, av->calls_tail);

    return nullptr;
}

static bool call_prepare_transmission(ToxAVCall *call)
{
    /* Assumes mutex locked */

    if (call == nullptr) {
        return false;
    }

    ToxAV *av = call->av;

    LOGGER_API_INFO(av->tox, "prepare_transmissio:fnum=%d", call->friend_number);

    if (!av->acb && !av->vcb) {
        /* It makes no sense to have CSession without callbacks */
        return false;
    }

    if (call->active) {
        LOGGER_API_WARNING(av->tox, "Call already active!");
        return true;
    }

    if (create_recursive_mutex(call->mutex_audio) != 0) {
        return false;
    }

    if (create_recursive_mutex(call->mutex_video) != 0) {
        goto FAILURE_2;
    }

    /* Prepare bwc */
    call->bwc = bwc_new(av->tox, av->toxav_mono_time, call->friend_number, callback_bwc, call);

    { /* Prepare audio */
        call->audio = ac_new(av->toxav_mono_time, nullptr, av, av->tox, call->friend_number,
                                av->acb, av->acb_user_data,
                                av->acb_pts, av->acb_pts_user_data);

        if (!call->audio) {
            LOGGER_API_ERROR(av->tox, "Failed to create audio codec session");
            goto FAILURE;
        }

        call->audio_rtp = rtp_new(RTP_TYPE_AUDIO, av->tox, av, call->friend_number, call->bwc,
                                  call->audio, ac_queue_message);

        if (!call->audio_rtp) {
            LOGGER_API_ERROR(av->tox, "Failed to create audio rtp session");
            goto FAILURE;
        }
    }

    { /* Prepare video */
        call->video = vc_new(av->toxav_mono_time, nullptr, av, call->friend_number, av->vcb, av->vcb_user_data);

        if (!call->video) {
            LOGGER_API_ERROR(av->tox, "Failed to create video codec session");
            goto FAILURE;
        }

        call->video_rtp = rtp_new(RTP_TYPE_VIDEO, av->tox, av, call->friend_number, call->bwc,
                                  call->video, vc_queue_message);

        if (!call->video_rtp) {
            LOGGER_API_ERROR(av->tox, "Failed to create video rtp session");
            goto FAILURE;
        }
    }

    call->active = 1;
    return true;

FAILURE:
    bwc_kill(call->bwc);
    call->bwc = nullptr;
    rtp_kill(av->tox, call->audio_rtp);
    ac_kill(call->audio);
    call->audio_rtp = nullptr;
    call->audio = nullptr;
    rtp_kill(av->tox, call->video_rtp);
    vc_kill(call->video);
    call->video_rtp = nullptr;
    call->video = nullptr;
    pthread_mutex_destroy(call->mutex_video);
FAILURE_2:
    pthread_mutex_destroy(call->mutex_audio);
    return false;
}

static void call_kill_transmission(ToxAVCall *call)
{
    if (call == nullptr) {
        return;
    }

    pthread_mutex_lock(call->toxav_call_mutex);
    if (call->active == 0) {
        pthread_mutex_unlock(call->toxav_call_mutex);
        return;
    }
    call->active = 0;
    pthread_mutex_unlock(call->toxav_call_mutex);

    pthread_mutex_lock(call->mutex_audio);
    pthread_mutex_unlock(call->mutex_audio);
    pthread_mutex_lock(call->mutex_video);
    pthread_mutex_unlock(call->mutex_video);

    pthread_mutex_lock(call->toxav_call_mutex);
    bwc_kill(call->bwc);
    call->bwc = nullptr;
    pthread_mutex_unlock(call->toxav_call_mutex);

    ToxAV *av = call->av;

    pthread_mutex_lock(av->toxav_endcall_mutex);

    pthread_mutex_lock(call->toxav_call_mutex);
    RTPSession *audio_rtp_copy = call->audio_rtp;
    call->audio_rtp = nullptr;
    rtp_kill(av->tox, audio_rtp_copy);
    pthread_mutex_unlock(call->toxav_call_mutex);

    pthread_mutex_lock(call->toxav_call_mutex);
    ac_kill(call->audio);
    call->audio = nullptr;
    pthread_mutex_unlock(call->toxav_call_mutex);

    pthread_mutex_lock(call->toxav_call_mutex);
    RTPSession *video_rtp_copy = call->video_rtp;
    call->video_rtp = nullptr;
    rtp_kill(av->tox, video_rtp_copy);
    pthread_mutex_unlock(call->toxav_call_mutex);

    pthread_mutex_lock(call->toxav_call_mutex);
    VCSession *vc_copy = (VCSession *)call->video;
    call->video = nullptr;
    vc_kill(vc_copy);
    pthread_mutex_unlock(call->toxav_call_mutex);

    pthread_mutex_destroy(call->mutex_audio);
    pthread_mutex_destroy(call->mutex_video);

    pthread_mutex_unlock(av->toxav_endcall_mutex);
}

Mono_Time *toxav_get_av_mono_time(ToxAV *toxav)
{
    if (!toxav) {
        return nullptr;
    }

    return toxav->toxav_mono_time;
}


#ifdef __cplusplus
extern "C" {
#endif
// for H264 ----------
#include <libavutil/opt.h>
// for H264 ----------
#ifdef __cplusplus
}
#endif

#define NGC__X264_ENCODER_THREADS 4
#define NGC__X264_ENCODER_SLICES 4

#define NGC__VIDEO_F_RATE_TOLERANCE_H264 1.3
#define NGC__VIDEO_BUF_FACTOR_H264 1
#define NGC__VIDEO_MAX_KF_H264 30 // index frame every x frames, sadly also SPS and PPS gets sent only every x frames :-(

#define NGC__H264_DECODER_THREADS 4
#define NGC__H264_DECODER_THREAD_FRAME_ACTIVE 1

// #define NGC___TRIFA_CODEC_DECODER_ 1
#define NGC__H264_WANT_DECODER_NAME "h264_mediacodec"

struct ToxAV_NGC_vcoders {
    x264_picture_t ngc__h264_in_pic;
    x264_picture_t ngc__h264_out_pic;
    x264_t *ngc__h264_encoder;
    uint32_t ngc__v_encoder_bitrate;
    uint32_t ngc__v_encoder_max_quantizer;
    uint16_t ngc__v_width;
    uint16_t ngc__v_height;
    AVCodecContext *ngc__h264_decoder;
};

static void toxav_ngc_video_init_encoder_only(struct ToxAV_NGC_vcoders *ngc_video_coders,
            const uint16_t v_bitrate, const uint16_t max_quantizer)
{
    // ENCODER -------
    x264_param_t param;
    if (x264_param_default_preset(&param, "ultrafast", "zerolatency,fastdecode") < 0) {
        // log warning
    }

    //if (x264_param_default_preset(&param, "superfast", "zerolatency,fastdecode") < 0) {
    //    // log warning
    //}

    /* Configure non-default params */
    param.i_csp = X264_CSP_I420;
    param.i_width  = 480; // 240;
    param.i_height = 640; // 320;

    param.i_threads = NGC__X264_ENCODER_THREADS;
    param.b_sliced_threads = true;
    param.i_slice_count = NGC__X264_ENCODER_SLICES;

    param.b_deterministic = false;
    param.b_intra_refresh = 16;
    param.rc.i_lookahead = 0;
    param.i_bframe = 0;
    param.i_keyint_max = NGC__VIDEO_MAX_KF_H264;
    param.b_vfr_input = 1; /* VFR input.  If 1, use timebase and timestamps for ratecontrol purposes.
                            * If 0, use fps only. */
    param.i_timebase_num = 1;       // 1 ms = timebase units = (1/1000)s
    param.i_timebase_den = 1000;   // 1 ms = timebase units = (1/1000)s
    param.b_repeat_headers = 1;
    param.b_annexb = 1;

    uint16_t NGC__VIDEO_BITRATE_INITIAL_VALUE_H264 = v_bitrate;
    if ((v_bitrate < 90) || (v_bitrate > 2000))
    {
        NGC__VIDEO_BITRATE_INITIAL_VALUE_H264 = 200;
    }

    param.rc.f_rate_tolerance = NGC__VIDEO_BITRATE_INITIAL_VALUE_H264;
    param.rc.i_vbv_buffer_size = NGC__VIDEO_BITRATE_INITIAL_VALUE_H264 * NGC__VIDEO_BUF_FACTOR_H264;
    param.rc.i_vbv_max_bitrate = NGC__VIDEO_BITRATE_INITIAL_VALUE_H264 * 1;

    // max quantizer for x264
    if ((max_quantizer < 20) || (max_quantizer > 51))
    {
        param.rc.i_qp_max = 49;
    }
    else
    {
        param.rc.i_qp_max = max_quantizer;
    }

    if (param.rc.i_qp_max == 51) {
        param.rc.i_qp_min = 45;
    } else {
        param.rc.i_qp_min = 3;
    }

    ngc_video_coders->ngc__v_encoder_max_quantizer = param.rc.i_qp_max;
    ngc_video_coders->ngc__v_encoder_bitrate = NGC__VIDEO_BITRATE_INITIAL_VALUE_H264;

    param.rc.b_stat_read = 0;
    param.rc.b_stat_write = 0;

    param.i_log_level = X264_LOG_ERROR; // X264_LOG_ERROR; // X264_LOG_NONE;

    if (x264_param_apply_profile(&param, "baseline") < 0) { // "baseline", "main", "high", "high10", "high422", "high444"
        // log warning
    }

    //if (x264_param_apply_profile(&param, "high") < 0) {
        // log warning
    //}

    if (x264_picture_alloc(&(ngc_video_coders->ngc__h264_in_pic), param.i_csp, param.i_width, param.i_height) < 0) {
        // log error
    }

    // vc->h264_in_pic.img.plane[0] --> Y
    // vc->h264_in_pic.img.plane[1] --> U
    // vc->h264_in_pic.img.plane[2] --> V

    ngc_video_coders->ngc__h264_encoder = x264_encoder_open(&param);

    // ENCODER -------
}

void* toxav_ngc_video_init(const uint16_t v_bitrate, const uint16_t max_quantizer)
{
    struct ToxAV_NGC_vcoders *ngc_video_coders = calloc(1, sizeof(struct ToxAV_NGC_vcoders));

    // ENCODER -------
    toxav_ngc_video_init_encoder_only(ngc_video_coders,
            ngc_video_coders->ngc__v_encoder_bitrate,
            ngc_video_coders->ngc__v_encoder_max_quantizer);
    // ENCODER -------


    // DECODER -------

    const AVCodec *codec = NULL;
    ngc_video_coders->ngc__h264_decoder = NULL;

// https://github.com/FFmpeg/FFmpeg/blob/70d25268c21cbee5f08304da95be1f647c630c15/doc/APIchanges#L86
// Deprecate use of av_register_all()
#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(58, 9, 100)
    avcodec_register_all();
#endif


#ifdef NGC___TRIFA_CODEC_DECODER_
    codec = avcodec_find_decoder_by_name(NGC__H264_WANT_DECODER_NAME);
    if (!codec) {
        printf("codec not found HW Accel H264 on decoder, trying software decoder ...\n");
        codec = avcodec_find_decoder(AV_CODEC_ID_H264);
    } else {
        printf("FOUND: *HW Accel* H264 on decoder\n");
    }
#else
    codec = avcodec_find_decoder(AV_CODEC_ID_H264);
#endif

    if (!codec) {
        // log error: codec not found H264 on decoder
    }

    ngc_video_coders->ngc__h264_decoder = avcodec_alloc_context3(codec);

#if LIBAVCODEC_VERSION_MAJOR < 60
    if (codec->capabilities & AV_CODEC_CAP_TRUNCATED) {
        ngc_video_coders->ngc__h264_decoder->flags |= AV_CODEC_FLAG_TRUNCATED; /* we do not send complete frames */
    }
#endif
    if (codec->capabilities & AV_CODEC_FLAG_LOW_DELAY) {
        ngc_video_coders->ngc__h264_decoder->flags |= AV_CODEC_FLAG_LOW_DELAY;
    }

#ifdef AV_CODEC_FLAG2_SHOW_ALL
    ngc_video_coders->ngc__h264_decoder->flags |= AV_CODEC_FLAG2_SHOW_ALL;
#endif

    if (NGC__H264_DECODER_THREADS > 0) {
        if (codec->capabilities & AV_CODEC_CAP_SLICE_THREADS) {
            ngc_video_coders->ngc__h264_decoder->thread_count = NGC__H264_DECODER_THREADS;
            ngc_video_coders->ngc__h264_decoder->thread_type = FF_THREAD_SLICE;
            ngc_video_coders->ngc__h264_decoder->active_thread_type = FF_THREAD_SLICE;
        }

        if (NGC__H264_DECODER_THREAD_FRAME_ACTIVE == 1) {
            if (codec->capabilities & AV_CODEC_CAP_FRAME_THREADS) {
                ngc_video_coders->ngc__h264_decoder->thread_count = NGC__H264_DECODER_THREADS;
                ngc_video_coders->ngc__h264_decoder->thread_type |= FF_THREAD_FRAME;
                ngc_video_coders->ngc__h264_decoder->active_thread_type |= FF_THREAD_FRAME;
            }
        }
    }

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(59, 0, 0)
    ngc_video_coders->ngc__h264_decoder->refcounted_frames = 0;
#endif
    /*   When AVCodecContext.refcounted_frames is set to 0, the returned
    *             reference belongs to the decoder and is valid only until the
    *             next call to this function or until closing or flushing the
    *             decoder. The caller may not write to it.
    */
#pragma GCC diagnostic pop

    ngc_video_coders->ngc__h264_decoder->delay = 0;
#define NGC__AV_OPT_SEARCH_CHILDREN   (1 << 0)
    av_opt_set_int(ngc_video_coders->ngc__h264_decoder->priv_data, "delay", 0, NGC__AV_OPT_SEARCH_CHILDREN);

    ngc_video_coders->ngc__h264_decoder->time_base = (AVRational) {
        1, 15
    };
    ngc_video_coders->ngc__h264_decoder->framerate = (AVRational) {
        15, 1
    };

#ifdef NGC___TRIFA_CODEC_DECODER_
        printf("setting up h264_mediacodec decoder ...\n");
        const uint8_t sps[] = {0x00, 0x00, 0x00, 0x01,      0x67, 0x42, 0xC0, 0x1E, 0xA6, 0x81, 0xE0, 0x51, 0xA1};
        // const uint8_t sps[] = {0x00, 0x00, 0x00, 0x01,      0x67, 0x42, 0x80, 0x0C, 0xE4, 0x40, 0xA0, 0xFD, 0x00, 0xDA, 0x14, 0x26, 0xA0};
        const uint8_t pps[] = {0x00, 0x00, 0x00, 0x01,      0x68, 0xCE, 0x38, 0x80};
        const size_t sps_pps_size = sizeof(sps) + sizeof(pps);

        ngc_video_coders->ngc__h264_decoder->extradata = (uint8_t *)av_mallocz(sps_pps_size + AV_INPUT_BUFFER_PADDING_SIZE);
        ngc_video_coders->ngc__h264_decoder->extradata_size = sps_pps_size;
        memset(&ngc_video_coders->ngc__h264_decoder->extradata[ngc_video_coders->ngc__h264_decoder->extradata_size],
            0, AV_INPUT_BUFFER_PADDING_SIZE);
        memcpy(ngc_video_coders->ngc__h264_decoder->extradata, sps, sizeof(sps));
        memcpy(ngc_video_coders->ngc__h264_decoder->extradata + sizeof(sps), pps, sizeof(pps));

        ngc_video_coders->ngc__h264_decoder->codec_type = AVMEDIA_TYPE_VIDEO;
        ngc_video_coders->ngc__h264_decoder->codec_id   = AV_CODEC_ID_H264;

        ngc_video_coders->ngc__h264_decoder->pix_fmt                = AV_PIX_FMT_YUV420P;
        ngc_video_coders->ngc__h264_decoder->width                  = 480;
        ngc_video_coders->ngc__h264_decoder->height                 = 640;
        printf("setting up h264_mediacodec decoder ... DONE\n");
        // av_log_set_level(AV_LOG_ERROR);
        av_log_set_level(AV_LOG_TRACE);
#endif

    if (avcodec_open2(ngc_video_coders->ngc__h264_decoder, codec, NULL) < 0) {
        // log error: could not open codec H264 on decoder
    }

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(59, 0, 0)
    ngc_video_coders->ngc__h264_decoder->refcounted_frames = 0;
#endif
#pragma GCC diagnostic pop
    /*   When AVCodecContext.refcounted_frames is set to 0, the returned
    *             reference belongs to the decoder and is valid only until the
    *             next call to this function or until closing or flushing the
    *             decoder. The caller may not write to it.
    */

    // DECODER -------

    return (void*)ngc_video_coders;
}

static void toxav_ngc_video_reconfigure_encoder(struct ToxAV_NGC_vcoders *ngc_video_coders)
{
    if (ngc_video_coders->ngc__h264_encoder) {
        x264_encoder_close(ngc_video_coders->ngc__h264_encoder);
        x264_picture_clean(&(ngc_video_coders->ngc__h264_in_pic));
        ngc_video_coders->ngc__h264_encoder = nullptr;

        toxav_ngc_video_init_encoder_only(ngc_video_coders,
                ngc_video_coders->ngc__v_encoder_bitrate,
                ngc_video_coders->ngc__v_encoder_max_quantizer);
    }
}

void toxav_ngc_video_kill(void *vngc)
{
    struct ToxAV_NGC_vcoders *ngc_video_coders = (struct ToxAV_NGC_vcoders*)vngc;
    if (ngc_video_coders) {
        // encoder
        if (ngc_video_coders->ngc__h264_encoder) {
            x264_encoder_close(ngc_video_coders->ngc__h264_encoder);
            x264_picture_clean(&(ngc_video_coders->ngc__h264_in_pic));
            ngc_video_coders->ngc__h264_encoder = nullptr;
        }
        // decoder
        if (ngc_video_coders->ngc__h264_decoder->extradata) {
            av_free(ngc_video_coders->ngc__h264_decoder->extradata);
            ngc_video_coders->ngc__h264_decoder->extradata = NULL;
        }
        avcodec_free_context(&ngc_video_coders->ngc__h264_decoder);
        free(ngc_video_coders);
    }
}

bool toxav_ngc_video_encode(void *vngc, const uint16_t vbitrate, const uint32_t max_quantizer,
                            const uint16_t width, const uint16_t height,
                            const uint8_t *y, const uint8_t *u, const uint8_t *v,
                            uint8_t *encoded_frame_bytes, uint32_t *encoded_frame_size_bytes)
{
    if ((vngc == nullptr) || (encoded_frame_size_bytes == nullptr)) {
        return false;
    }

    struct ToxAV_NGC_vcoders *ngc_video_coders = (struct ToxAV_NGC_vcoders*)vngc;

    bool need_reconfigure_encoder = false;
    if (ngc_video_coders->ngc__v_encoder_bitrate != vbitrate)
    {
        if ((vbitrate < 90) || (vbitrate > 2000))
        {
            ngc_video_coders->ngc__v_encoder_bitrate = 200;
        }
        else
        {
            ngc_video_coders->ngc__v_encoder_bitrate = vbitrate;
        }
        need_reconfigure_encoder = true;
    }

    if (ngc_video_coders->ngc__v_encoder_max_quantizer != max_quantizer)
    {
        if ((max_quantizer < 20) || (max_quantizer > 51))
        {
            ngc_video_coders->ngc__v_encoder_max_quantizer = 49;
        }
        else
        {
            ngc_video_coders->ngc__v_encoder_max_quantizer = max_quantizer;
        }
        need_reconfigure_encoder = true;
    }

    if (need_reconfigure_encoder) {
        toxav_ngc_video_reconfigure_encoder(ngc_video_coders);
    }


    memcpy(ngc_video_coders->ngc__h264_in_pic.img.plane[0], y, width * height);
    memcpy(ngc_video_coders->ngc__h264_in_pic.img.plane[1], u, (width / 2) * (height / 2));
    memcpy(ngc_video_coders->ngc__h264_in_pic.img.plane[2], v, (width / 2) * (height / 2));

    ngc_video_coders->ngc__h264_in_pic.i_type = X264_TYPE_AUTO;

    x264_nal_t *nal = nullptr;
    int i_nal;
    int i_frame_size = x264_encoder_encode(ngc_video_coders->ngc__h264_encoder,
                                        &nal,
                                        &i_nal,
                                        &(ngc_video_coders->ngc__h264_in_pic),
                                        &(ngc_video_coders->ngc__h264_out_pic));

    if (i_frame_size < 0) {
        return false;
    } else if (i_frame_size == 0) {
        return false;
    }
    if (nal == NULL) {
        return false;
    }
    if (nal->p_payload == nullptr) {
        return false;
    }

    if (i_frame_size > 36989) {
        // log error: encoded frame does not fit in NGC custom packet
        return false;
    }

    *encoded_frame_size_bytes = i_frame_size;
    memcpy(encoded_frame_bytes, (const uint8_t *)(nal->p_payload), i_frame_size);
    return true;
}

static void toxav_ngc_video_flush_decoder(struct ToxAV_NGC_vcoders *ngc_video_coders)
{
    if (ngc_video_coders->ngc__h264_decoder) {
        // Receive and discard frames
        AVFrame *frame = av_frame_alloc();
        if (frame != nullptr) {
            while (avcodec_receive_frame(ngc_video_coders->ngc__h264_decoder, frame) == 0) {
                av_frame_unref(frame);
            }
            av_frame_free(&frame);
        }
    }
}

static bool toxav_is_h264_sps(const uint8_t *data, const uint32_t data_len)
{
    if (data_len > 7) {
        //dbg(9, "SPS:len=%d bytes:%d %d %d %d %d %d %d %d\n", data_len, data[0], data[1], data[2], data[3], data[4],
        //             data[5], data[6], data[7]);

        if (
            (data[0] == 0x00)
            &&
            (data[1] == 0x00)
            &&
            (data[2] == 0x00)
            &&
            (data[3] == 0x01)
            &&
            (((data[4] & 0x1F) == 7) || ((data[4] & 0x1F) == 8)) // only the lower 5bits of the 4th byte denote the NAL type
            // 7 --> SPS
            // 8 --> PPS
            // (data[4] == 0x67)
        ) {

            // we found a NAL unit containing the SPS
            if ((data[4] & 0x1F) == 7)
            {
                uint8_t h264_profile = data[5];
                uint8_t h264_constraint_set0_flag = ((data[6] >> 3)  & 0x01);
                uint8_t h264_constraint_set3_flag = (data[6]  & 0x01);
                uint8_t h264_level = data[7];

                if ((h264_profile == 66) && (h264_constraint_set3_flag = 0)) {
                    printf("profile=%s level=%d\n", "baseline", h264_level);
                } else if ((h264_profile == 66) && (h264_constraint_set3_flag = 1)) {
                    printf("profile=%s level=%d\n", "contrained baseline", h264_level);
                } else if ((h264_profile == 77) && (h264_constraint_set0_flag = 0)) {
                    printf("profile=%s level=%d\n", "main", h264_level);
                } else if ((h264_profile == 77) && (h264_constraint_set0_flag = 1)) {
                    printf("profile=%s level=%d\n", "extended", h264_level);
                } else if (h264_profile == 100) {
                    printf("profile=%s level=%d\n", "high", h264_level);
                } else if (h264_profile == 110) {
                    printf("profile=%s level=%d\n", "high10", h264_level);
                } else if (h264_profile == 122) {
                    printf("profile=%s level=%d\n", "high422", h264_level);
                } else if (h264_profile == 244) {
                    printf("profile=%s level=%d\n", "high444", h264_level);
                } else {
                    printf("profile=%s level=%d\n", "unkwn", h264_level);
                }
            }

            if ((data[4] & 0x1F) == 7)
            {
                printf("SPS:");
            }
            else
            {
                printf("PPS:");
            }
            printf(" len=%d", data_len);
            for(int j=0;j<data_len;j++)
            {
                printf(" 0x%02hhX", data[j]);
            }
            printf("\n");

            return true;
        }
    }

    return false;
}

bool toxav_ngc_video_decode(void *vngc, uint8_t *encoded_frame_bytes, uint32_t encoded_frame_size_bytes,
                            uint16_t width, uint16_t height,
                            uint8_t *y, uint8_t *u, uint8_t *v,
                            int32_t *ystride, int32_t *ustride, int32_t *vstride,
                            uint8_t flush_decoder)
{
    if (vngc == nullptr) {
        return false;
    }

    struct ToxAV_NGC_vcoders *ngc_video_coders = (struct ToxAV_NGC_vcoders*)vngc;

    if ((y == nullptr) || (u == nullptr) || (v == nullptr)) {
        return false;
    }
    if ((ystride == nullptr) || (ustride == nullptr) || (vstride == nullptr)) {
        return false;
    }
    if (encoded_frame_bytes == nullptr) {
        return false;
    }
    if (encoded_frame_size_bytes < 1) {
        return false;
    }

    // flush decoder
    if (flush_decoder == 1) {
        toxav_ngc_video_flush_decoder(ngc_video_coders);
    }

    AVPacket *compr_data = av_packet_alloc();
    if (compr_data == NULL) {
        return false;
    }

    compr_data->data = encoded_frame_bytes;
    compr_data->size = (int)encoded_frame_size_bytes; // hmm, "int" again

    // DEBUG // toxav_is_h264_sps(compr_data->data, compr_data->size);

    compr_data->dts = 1;
    compr_data->pts = 2;
    compr_data->duration = 0;

    int result_send_packet = avcodec_send_packet(ngc_video_coders->ngc__h264_decoder, compr_data);
    if (result_send_packet != 0) {
        av_packet_free(&compr_data);
        //printf("toxav_ngc_video_decode:error:007:res=%d (%d) (%d) (%d) (%d)\n", result_send_packet, AVERROR(EAGAIN), AVERROR_EOF, AVERROR(EINVAL), AVERROR(ENOMEM));
        return false;
    }

    int ret_ = 0;
    int result = false;
    while (ret_ >= 0) {
        AVFrame *frame = av_frame_alloc();
        if (frame == NULL) {
            //printf("toxav_ngc_video_decode:error:008\n");
            break;
        }
        ret_ = avcodec_receive_frame(ngc_video_coders->ngc__h264_decoder, frame);
        if (ret_ == AVERROR(EAGAIN) || ret_ == AVERROR_EOF) {
            //printf("toxav_ngc_video_decode:error:009\n");
            av_frame_free(&frame);
            break;
        } else if (ret_ < 0) {
            //printf("toxav_ngc_video_decode:error:010\n");
            av_frame_free(&frame);
            break;
        } else if (ret_ == 0) {
            //printf("toxav_ngc_video_decode:FRAME:011\n");
            if ((frame->data[0] != NULL) && (frame->data[1] != NULL) && (frame->data[2] != NULL)) {
                // ------ GOT a VIDEO FRAME ------
                if ((width < frame->linesize[0]) || (height != frame->height)) {
                    // log error: video frame stride and height do no match input buffer stride and height
                    //printf("toxav_ngc_video_decode:error:012\n");
                    av_frame_free(&frame);
                    continue;
                } else {
                    *ystride = frame->linesize[0];
                    *ustride = frame->linesize[1];
                    *vstride = frame->linesize[2];
                    memcpy(y, (const uint8_t *)frame->data[0], frame->height * frame->linesize[0]);
                    memcpy(u, (const uint8_t *)frame->data[1], (frame->height / 2) * frame->linesize[1]);
                    memcpy(v, (const uint8_t *)frame->data[2], (frame->height / 2) * frame->linesize[2]);
                    result = true;
                    //printf("toxav_ngc_video_decode:FRAME:013a:OK\n");
                    av_frame_free(&frame);
                    continue;
                }
                // ------ GOT a VIDEO FRAME ------
            } else if ((frame->format == 23) && (frame->linesize[0] > 1)
                    && (frame->linesize[1] > 1) && (frame->data[0]) && (frame->data[1])) {
                    *ystride = frame->linesize[0];
                    *ustride = frame->linesize[1] / 2;
                    *vstride = frame->linesize[1] / 2;
                    memcpy(y, (const uint8_t *)frame->data[0], frame->height * frame->linesize[0]);
                    const uint8_t *u_c = (const uint8_t *)frame->data[1];
                    const uint8_t *v_c = (const uint8_t *)frame->data[1];
                    uint8_t *u_p = u;
                    uint8_t *v_p = v;
                    v_p++;
                    for (int yy=0;yy<(frame->height/2);yy++) {
                        for (int x=0;x<(*ustride);x++) {
                            *u_p=*u_c;
                            *v_p=*v_c;
                            u_c=u_c+2;
                            v_c=v_c+2;
                            u_p++;
                            v_p++;
                        }
                    }
                    result = true;
                    //printf("toxav_ngc_video_decode:FRAME:013b:OK\n");
                    av_frame_free(&frame);
                    continue;
            } else {
                // log error: no frame data
                //printf("toxav_ngc_video_decode:error:014:frame:w=%d h=%d format=%d\n", frame->width, frame->height, frame->format);
                //for (int i=0; i<AV_NUM_DATA_POINTERS; i++)
                //{
                //    printf("toxav_ngc_video_decode:error:014:i=%d:stride=%d p=%p\n", i, frame->linesize[i], frame->data[i]);
                //}
            }
        } else {
            // log error: some other error
            //printf("toxav_ngc_video_decode:error:015\n");
        }
        av_frame_free(&frame);
    }
    av_packet_free(&compr_data);

    return result;
}

#define NGC__AUDIO_OPUS_COMPLEXITY (10)
#define NGC__AUDIO_OPUS_PACKET_LOSS_PERC (4)
#define NGC__AUDIO_MAX_ENCODED_DATA_BYTES (TOX_MAX_CUSTOM_PACKET_SIZE - 1 - 10) // 10 bytes for NGC audio packet header
#define NGC__AUDIO_MAX_PCM_DATA_BYTES (5760)

struct ToxAV_NGC_acoders {
    OpusEncoder *ngc__opus_encoder;
    OpusDecoder *ngc__opus_decoder;
    int32_t ngc__a_encoder_bitrate;
    int32_t ngc__a_encoder_sampling_rate;
    int32_t ngc__a_encoder_channel_count;
};

void* toxav_ngc_audio_init(const int32_t bit_rate, const int32_t sampling_rate, const int32_t channel_count)
{
    struct ToxAV_NGC_acoders *ngc_audio_coders = calloc(1, sizeof(struct ToxAV_NGC_acoders));

    // ENCODER -------
    int status_enc = OPUS_OK;
    OpusEncoder *opus_encoder = opus_encoder_create(sampling_rate, channel_count, OPUS_APPLICATION_VOIP, &status_enc);

    if (status_enc != OPUS_OK) {
        printf("Error while starting audio encoder: %s\n", opus_strerror(status_enc));
        ngc_audio_coders->ngc__opus_encoder = nullptr;
    } else {
        printf("starting audio encoder OK: %s\n", opus_strerror(status_enc));
        ngc_audio_coders->ngc__opus_encoder = opus_encoder;
    }

    ngc_audio_coders->ngc__a_encoder_sampling_rate = sampling_rate;
    ngc_audio_coders->ngc__a_encoder_channel_count = channel_count;
    ngc_audio_coders->ngc__a_encoder_bitrate = bit_rate;

    // bitrate in bits per second !!
    // Rates from 500 to 512000 bits per second are meaningful
    status_enc = opus_encoder_ctl(opus_encoder, OPUS_SET_BITRATE(bit_rate));
    if (status_enc != OPUS_OK) {
        printf("Error while setting encoder ctl: %s\n", opus_strerror(status_enc));
        opus_encoder_destroy(opus_encoder);
        ngc_audio_coders->ngc__opus_encoder = nullptr;
    }

    status_enc = opus_encoder_ctl(opus_encoder, OPUS_SET_VBR(1));
    if (status_enc != OPUS_OK) {
        printf("Error while setting encoder ctl: %s\n", opus_strerror(status_enc));
        opus_encoder_destroy(opus_encoder);
        ngc_audio_coders->ngc__opus_encoder = nullptr;
    }

    status_enc = opus_encoder_ctl(opus_encoder, OPUS_SET_INBAND_FEC(1));
    status_enc = opus_encoder_ctl(opus_encoder, OPUS_SET_PACKET_LOSS_PERC(NGC__AUDIO_OPUS_PACKET_LOSS_PERC));

    printf("starting audio encoder complexity: %d\n", (int)NGC__AUDIO_OPUS_COMPLEXITY);
    status_enc = opus_encoder_ctl(opus_encoder, OPUS_SET_COMPLEXITY(NGC__AUDIO_OPUS_COMPLEXITY));

    if (status_enc != OPUS_OK) {
        printf("Error while setting encoder ctl: %s\n", opus_strerror(status_enc));
        opus_encoder_destroy(opus_encoder);
        ngc_audio_coders->ngc__opus_encoder = nullptr;
    }
    // ENCODER -------

    // DECODER -------
    int status_dec;
    ngc_audio_coders->ngc__opus_decoder = opus_decoder_create(sampling_rate, channel_count, &status_dec);

    if (status_dec != OPUS_OK) {
        printf("Error while starting audio decoder: %s\n", opus_strerror(status_dec));
        opus_decoder_destroy(ngc_audio_coders->ngc__opus_decoder);
        ngc_audio_coders->ngc__opus_decoder = nullptr;
    }
    // DECODER -------

    return (void*)ngc_audio_coders;
}

void toxav_ngc_audio_kill(void *angc)
{
    struct ToxAV_NGC_acoders *ngc_audio_coders = (struct ToxAV_NGC_acoders*)angc;
    if (ngc_audio_coders) {
        if (ngc_audio_coders->ngc__opus_encoder) {
            opus_encoder_destroy(ngc_audio_coders->ngc__opus_encoder);
            ngc_audio_coders->ngc__opus_encoder = nullptr;
        }

        if (ngc_audio_coders->ngc__opus_decoder) {
            opus_decoder_destroy(ngc_audio_coders->ngc__opus_decoder);
            ngc_audio_coders->ngc__opus_decoder = nullptr;
        }
        free(ngc_audio_coders);
    }
}

bool toxav_ngc_audio_encode(void *angc, const int16_t *pcm, const int32_t sample_count_per_frame,
                        uint8_t *encoded_frame_bytes, uint32_t *encoded_frame_size_bytes)
{
    if (!pcm) {
        return false;
    }

    if (sample_count_per_frame <= 0) {
        return false;
    }

    if (!encoded_frame_bytes) {
        return false;
    }

    if (!encoded_frame_size_bytes) {
        return false;
    }

    struct ToxAV_NGC_acoders *ngc_audio_coders = (struct ToxAV_NGC_acoders*)angc;
    if ((ngc_audio_coders) && (ngc_audio_coders->ngc__opus_encoder)) {

        const int max_data_bytes = NGC__AUDIO_MAX_ENCODED_DATA_BYTES;
        const int encoded_bytes = opus_encode(ngc_audio_coders->ngc__opus_encoder,
                pcm,
                sample_count_per_frame,
                encoded_frame_bytes,
                max_data_bytes);

        if (encoded_bytes <= 0) {
            printf("Failed to encode frame %s\n", opus_strerror(encoded_bytes));
        } else {
            *encoded_frame_size_bytes = encoded_bytes;
            return true;
        }
    }

    return false;
}

int32_t toxav_ngc_audio_decode(void *angc, const uint8_t *encoded_frame_bytes,
                        const uint32_t encoded_frame_size_bytes,
                        int16_t *pcm_decoded)
{
    if (!pcm_decoded) {
        return -1;
    }

    if (!encoded_frame_bytes) {
        return -1;
    }

    if (encoded_frame_size_bytes < 1) {
        return -1;
    }

    struct ToxAV_NGC_acoders *ngc_audio_coders = (struct ToxAV_NGC_acoders*)angc;
    if ((ngc_audio_coders) && (ngc_audio_coders->ngc__opus_decoder)) {
        //
        // Number of samples per channel of available space in *pcm, if less than
        // the maximum frame size (120ms) some frames can not be decoded
        const int max_frame_size = NGC__AUDIO_MAX_PCM_DATA_BYTES;
        //
        const int samples_decoded = opus_decode(ngc_audio_coders->ngc__opus_decoder,
                encoded_frame_bytes, encoded_frame_size_bytes,
                pcm_decoded, max_frame_size, 0);

        if (samples_decoded <= 0) {
            printf("Decoding error: %s\n", opus_strerror(samples_decoded));
        } else {
            // const int frame_duration = (samples_decoded * 1000) / ngc_audio_coders->ngc__a_encoder_sampling_rate;
            // printf("Decoding frame_duration=%d samples_decoded=%d sampling_rate=%d\n",
            //    frame_duration, samples_decoded, ngc_audio_coders->ngc__a_encoder_sampling_rate);
            return samples_decoded;
        }
    }
    return -1;
}

/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2018 The TokTok team.
 * Copyright © 2013-2015 Tox project.
 */

/**
 * This file contains the group chats code for the backwards compatibility.
 */



/* Create a new toxav group.
 *
 * return group number on success.
 * return -1 on failure.
 *
 * Audio data callback format:
 *   `audio_callback(Tox *tox, int groupnumber, int peernumber, const int16_t *pcm, unsigned int samples, uint8_t channels, unsigned int sample_rate, void *userdata)`
 *
 * Note that total size of pcm in bytes is equal to `(samples * channels * sizeof(int16_t))`.
 */
int toxav_add_av_groupchat(Tox *tox, audio_data_cb *audio_callback, void *userdata)
{
    // TODO(iphydf): Don't rely on toxcore internals.
    //!TOKSTYLE-
    Messenger *m = *(Messenger **)tox;
    //!TOKSTYLE+
    return add_av_groupchat(m->log, tox, m->conferences_object, audio_callback, userdata);
}

/* Join a AV group (you need to have been invited first.)
 *
 * returns group number on success
 * returns -1 on failure.
 *
 * Audio data callback format (same as the one for `toxav_add_av_groupchat()`):
 *   `audio_callback(Tox *tox, int groupnumber, int peernumber, const int16_t *pcm, unsigned int samples, uint8_t channels, unsigned int sample_rate, void *userdata)`
 *
 * Note that total size of pcm in bytes is equal to `(samples * channels * sizeof(int16_t))`.
 */
int toxav_join_av_groupchat(Tox *tox, uint32_t friendnumber, const uint8_t *data, uint16_t length,
                            audio_data_cb *audio_callback, void *userdata)
{
    // TODO(iphydf): Don't rely on toxcore internals.
    //!TOKSTYLE-
    Messenger *m = *(Messenger **)tox;
    //!TOKSTYLE+
    return join_av_groupchat(m->log, tox, m->conferences_object, friendnumber, data, length, audio_callback, userdata);
}

/* Send audio to the group chat.
 *
 * return 0 on success.
 * return -1 on failure.
 *
 * Note that total size of pcm in bytes is equal to `(samples * channels * sizeof(int16_t))`.
 *
 * Valid number of samples are `((sample rate) * (audio length) / 1000)` (Valid values for audio length: 2.5, 5, 10, 20, 40 or 60 ms)
 * Valid number of channels are 1 or 2.
 * Valid sample rates are 8000, 12000, 16000, 24000, or 48000.
 *
 * Recommended values are: samples = 960, channels = 1, sample_rate = 48000
 */
int toxav_group_send_audio(Tox *tox, uint32_t groupnumber, const int16_t *pcm, unsigned int samples, uint8_t channels,
                           uint32_t sample_rate)
{
    // TODO(iphydf): Don't rely on toxcore internals.
    //!TOKSTYLE-
    Messenger *m = *(Messenger **)tox;
    //!TOKSTYLE+
    return group_send_audio(m->conferences_object, groupnumber, pcm, samples, channels, sample_rate);
}

/* Enable A/V in a groupchat.
 *
 * A/V must be enabled on a groupchat for audio to be sent to it and for
 * received audio to be handled.
 *
 * An A/V group created with toxav_add_av_groupchat or toxav_join_av_groupchat
 * will start with A/V enabled.
 *
 * An A/V group loaded from a savefile will start with A/V disabled.
 *
 * return 0 on success.
 * return -1 on failure.
 *
 * Audio data callback format (same as the one for toxav_add_av_groupchat()):
 *   `audio_callback(Tox *tox, uint32_t groupnumber, uint32_t peernumber, const int16_t *pcm, unsigned int samples, uint8_t channels, uint32_t sample_rate, void *userdata)`
 *
 * Note that total size of pcm in bytes is equal to `(samples * channels * sizeof(int16_t))`.
 */
int toxav_groupchat_enable_av(Tox *tox, uint32_t groupnumber, audio_data_cb *audio_callback, void *userdata)
{
    // TODO(iphydf): Don't rely on toxcore internals.
    //!TOKSTYLE-
    Messenger *m = *(Messenger **)tox;
    //!TOKSTYLE+
    return groupchat_enable_av(m->log, tox, m->conferences_object, groupnumber, audio_callback, userdata);
}

/* Disable A/V in a groupchat.
 *
 * return 0 on success.
 * return -1 on failure.
 */
int toxav_groupchat_disable_av(Tox *tox, uint32_t groupnumber)
{
    // TODO(iphydf): Don't rely on toxcore internals.
    //!TOKSTYLE-
    Messenger *m = *(Messenger **)tox;
    //!TOKSTYLE+
    return groupchat_disable_av(m->conferences_object, groupnumber);
}

/* Return whether A/V is enabled in the groupchat.
 */
bool toxav_groupchat_av_enabled(Tox *tox, uint32_t groupnumber)
{
    // TODO(iphydf): Don't rely on toxcore internals.
    //!TOKSTYLE-
    Messenger *m = *(Messenger **)tox;
    //!TOKSTYLE+
    return groupchat_av_enabled(m->conferences_object, groupnumber);
}
/*
 * Copyright © 2018 zoff@zoff.cc
 *
 * This file is part of Tox, the free peer to peer instant messenger.
 *
 * Tox is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Tox is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Tox.  If not, see <http://www.gnu.org/licenses/>.
 */

/*
 * TimeStamp Buffer implementation
 */


#include <stdlib.h>
#include <stdio.h>

struct TSBuffer {
    uint16_t  size; /* max. number of elements in buffer [ MAX ALLOWED = (UINT16MAX - 1) !! ] */
    uint16_t  start;
    uint16_t  end;
    uint64_t  *type; /* used by caller anyway the caller wants, or dont use it at all */
    uint32_t  *timestamp; /* these dont need to be unix timestamp, they can be numbers of a counter */
    uint32_t  last_timestamp_out; /* timestamp of the last read entry */
    void    **data;
};

bool tsb_full(const TSBuffer *b)
{
    return (b->end + 1) % b->size == b->start;
}

bool tsb_empty(const TSBuffer *b)
{
    return b->end == b->start;
}

/*
 * returns: NULL on success
 *          oldest element on FAILURE -> caller must free it after tsb_write() call
 */
void *tsb_write(TSBuffer *b, void *p, const uint64_t data_type, const uint32_t timestamp)
{
    void *rc = NULL;

    if (tsb_full(b) == true) {
        rc = b->data[b->start]; // return oldest element -> TODO: this is not actually the oldest
        // element. --> search for the element with the oldest timestamp and return that!
        b->start = (b->start + 1) % b->size; // include empty element if buffer would be empty now
    }

    b->data[b->end] = p;
    b->type[b->end] = data_type;
    b->timestamp[b->end] = timestamp;
    b->end = (b->end + 1) % b->size;

    // printf("tsb_write:%p size=%d start=%d end=%d\n", (void *)b, b->size, b->start, b->end);
    // tsb_debug_print_entries(b);

    return rc;
}

static void tsb_move_delete_entry(TSBuffer *b, uint16_t src_index, uint16_t dst_index)
{
    free(b->data[dst_index]);

    b->data[dst_index] = b->data[src_index];
    b->type[dst_index] = b->type[src_index];
    b->timestamp[dst_index] = b->timestamp[src_index];

    // just to be safe ---
    b->data[src_index] = NULL;
    b->type[src_index] = 0;
    b->timestamp[src_index] = 0;
    // just to be safe ---
}

static void tsb_close_hole(TSBuffer *b, uint16_t start_index, uint16_t hole_index)
{
    int32_t current_index = (int32_t)hole_index;

    while (true) {
        // delete current index by moving the previous entry into it
        // don't change start element pointer in this function!
        if (current_index < 1) {
            tsb_move_delete_entry(b, (b->size - 1), current_index);
        } else {
            tsb_move_delete_entry(b, (uint16_t)(current_index - 1), current_index);
        }

        if (current_index == (int32_t)start_index) {
            return;
        }

        current_index = current_index - 1;

        if (current_index < 0) {
            current_index = (int32_t)(b->size - 1);
        }
    }
}

static uint16_t tsb_delete_old_entries(TSBuffer *b, const uint64_t timestamp_threshold)
{
    // buffer empty, nothing to delete
    if (tsb_empty(b) == true) {
        return 0;
    }

    uint16_t removed_entries = 0;
    uint16_t removed_entries_before_last_out =
        0; /* entries removed discarding those between threshold and last read entry */
    uint16_t start_entry = b->start;
    uint16_t current_element;
    // iterate all entries

    for (int i = 0; i < tsb_size(b); i++) {
        current_element = (start_entry + i) % b->size;

        if ((uint64_t)b->timestamp[current_element] < (uint64_t)timestamp_threshold) {
            tsb_close_hole(b, start_entry, current_element);

            if ((uint64_t)b->timestamp[current_element] < (uint64_t)b->last_timestamp_out) {
                removed_entries_before_last_out++;
            }

            removed_entries++;
        }
    }

    b->start = (b->start + removed_entries) % b->size;

    return removed_entries_before_last_out;
}

void tsb_get_range_in_buffer(Tox *tox, TSBuffer *b, uint32_t *timestamp_min, uint32_t *timestamp_max)
{
    uint16_t current_element;
    uint16_t start_entry = b->start;
    *timestamp_min = UINT32_MAX;
    *timestamp_max = 0;

    for (int i = 0; i < tsb_size(b); i++) {
        current_element = (start_entry + i) % b->size;

        if ((uint64_t)b->timestamp[current_element] >= (uint64_t)*timestamp_max) {
            *timestamp_max = b->timestamp[current_element];
        }

        if ((uint64_t)b->timestamp[current_element] <= (uint64_t)*timestamp_min) {
            *timestamp_min = b->timestamp[current_element];
        }
    }
}

static bool tsb_return_oldest_entry_in_range(TSBuffer *b, void **p, uint64_t *data_type,
        uint32_t *timestamp_out,
        const uint32_t timestamp_in, const uint32_t timestamp_range)
{
    int32_t found_element = -1;
    uint32_t found_timestamp = UINT32_MAX;
    uint16_t start_entry = b->start;
    uint16_t current_element;

    for (int i = 0; i < tsb_size(b); i++) {
        current_element = (start_entry + i) % b->size;

        if ((((int64_t)b->timestamp[current_element]) >= ((int64_t)timestamp_in - (int64_t)timestamp_range))
                &&
                ((int64_t)b->timestamp[current_element] <= ((int64_t)timestamp_in + (int64_t)1))) {
            // printf("tsb_return_oldest_entry_in_range:1:%p data=%p\n", (void *)b, (void *)b->data[current_element]);
            // timestamp of entry is in range
            if ((int64_t)b->timestamp[current_element] < (int64_t)found_timestamp) {
                // printf("tsb_return_oldest_entry_in_range:2:%p data=%p\n", (void *)b, (void *)b->data[current_element]);
                // entry is older than previous found entry, or is the first found entry
                found_timestamp = (uint32_t)b->timestamp[current_element];
                found_element = (int32_t)current_element;
            }
        }
    }

    if (found_element > -1) {

        // printf("tsb_return_oldest_entry_in_range:%p found_element=%u\n", (void *)b, found_element);

        // swap element with element in "start" position
        if (found_element != (int32_t)b->start) {
            void *p_save = b->data[found_element];
            uint64_t data_type_save = b->type[found_element];
            uint32_t timestamp_save = b->timestamp[found_element];

            b->data[found_element] = b->data[b->start];
            b->type[found_element] = b->type[b->start];
            b->timestamp[found_element] = b->timestamp[b->start];

            b->data[b->start] = p_save;
            b->type[b->start] = data_type_save;
            b->timestamp[b->start] = timestamp_save;
        }

        // fill data to return to caller
        *p = b->data[b->start];
        *data_type = b->type[b->start];
        *timestamp_out = b->timestamp[b->start];

        b->data[b->start] = NULL;
        b->timestamp[b->start] = 0;
        b->type[b->start] = 0;

        // change start element pointer
        b->start = (b->start + 1) % b->size;
        return true;
    }

    *p = NULL;
    return false;
}

#if 0
static bool tsb_return_newest_entry_in_range(TSBuffer *b, void **p, uint64_t *data_type,
        uint32_t *timestamp_out,
        const uint32_t timestamp_in, const uint32_t timestamp_range)
{
    int32_t found_element = -1;
    uint32_t found_timestamp = 0;
    uint16_t start_entry = b->start;
    uint16_t current_element;

    for (int i = 0; i < tsb_size(b); i++) {
        current_element = (start_entry + i) % b->size;

        if ((((int64_t)b->timestamp[current_element]) >= ((int64_t)timestamp_in - (int64_t)timestamp_range))
                &&
                ((int64_t)b->timestamp[current_element] <= ((int64_t)timestamp_in + (int64_t)1))) {

            // timestamp of entry is in range
            if ((int64_t)b->timestamp[current_element] > (int64_t)found_timestamp) {

                // entry is newer than previous found entry, or is the first found entry
                found_timestamp = (uint32_t)b->timestamp[current_element];
                found_element = (int32_t)current_element;
            }
        }
    }

    if (found_element > -1) {

        // swap element with element in "start" position
        if (found_element != (int32_t)b->start) {
            void *p_save = b->data[found_element];
            uint64_t data_type_save = b->type[found_element];
            uint32_t timestamp_save = b->timestamp[found_element];

            b->data[found_element] = b->data[b->start];
            b->type[found_element] = b->type[b->start];
            b->timestamp[found_element] = b->timestamp[b->start];

            b->data[b->start] = p_save;
            b->type[b->start] = data_type_save;
            b->timestamp[b->start] = timestamp_save;
        }

        // fill data to return to caller
        *p = b->data[b->start];
        *data_type = b->type[b->start];
        *timestamp_out = b->timestamp[b->start];

        b->data[b->start] = NULL;
        b->timestamp[b->start] = 0;
        b->type[b->start] = 0;

        // change start element pointer
        b->start = (b->start + 1) % b->size;
        return true;
    }

    *p = NULL;
    return false;
}
#endif

bool tsb_read(TSBuffer *b, void **p, uint64_t *data_type, uint32_t *timestamp_out,
              const uint32_t timestamp_in, const uint32_t timestamp_range,
              uint16_t *removed_entries_back, uint16_t *is_skipping)
{
    *is_skipping = 0;

    // printf("tsb_read:000:%p size=%d st=%d end=%d tsin=%d tsrange=%d\n",
    //       (void *)b, b->size, b->start, b->end, timestamp_in, timestamp_range);

    if (tsb_empty(b) == true) {
        // printf("tsb_read:EMPTY:%p size=%d st=%d end=%d\n", (void *)b, b->size, b->start, b->end);
        *removed_entries_back = 0;
        *p = NULL;
        return false;
    }

    if ((int64_t)b->last_timestamp_out < ((int64_t)timestamp_in - (int64_t)timestamp_range)) {
        /* caller is missing a time range, either call more often, or increase range */
        *is_skipping = (timestamp_in - timestamp_range) - b->last_timestamp_out;
    }

    bool have_found_element = tsb_return_oldest_entry_in_range(b, p, data_type,
                              timestamp_out,
                              timestamp_in,
                              timestamp_range);

    // printf("tsb_read:%p size=%d st=%d end=%d have_found_element=%d\n", (void *)b, b->size, b->start, b->end,
    //       (int)have_found_element);

    if (have_found_element == true) {
        // only delete old entries if we found a "wanted" entry
        uint16_t removed_entries = tsb_delete_old_entries(b, ((int64_t)timestamp_in - (int64_t)timestamp_range));

        // printf("tsb_read:%p size=%d st=%d end=%d removed_entries=%d\n", (void *)b, b->size, b->start, b->end,
        //       (int)removed_entries);

        *removed_entries_back = removed_entries;

        // save the timestamp of the last read entry
        b->last_timestamp_out = *timestamp_out;
    } else {
        *removed_entries_back = 0;
    }

    return have_found_element;
}

TSBuffer *tsb_new(const int size)
{
    TSBuffer *buf = (TSBuffer *)calloc(sizeof(TSBuffer), 1);

    if (!buf) {
        return NULL;
    }

    buf->size = size + 1; /* include empty elem */
    buf->start = 0;
    buf->end = 0;

    if (!(buf->data = (void **)calloc(buf->size, sizeof(void *)))) {
        free(buf);
        return NULL;
    }

    if (!(buf->type = (uint64_t *)calloc(buf->size, sizeof(uint64_t)))) {
        free(buf->data);
        free(buf);
        return NULL;
    }

    if (!(buf->timestamp = (uint32_t *)calloc(buf->size, sizeof(uint32_t)))) {
        free(buf->data);
        free(buf->type);
        free(buf);
        return NULL;
    }

    buf->last_timestamp_out = 0;

    // printf("tsb_new:%p size=%d st=%d end=%d\n", (void *)buf, buf->size, buf->start, buf->end);
    // tsb_debug_print_entries(buf);

    return buf;
}

void tsb_drain(TSBuffer *b)
{
    if (b) {
        // printf("tsb_drain:%p size=%d\n", (void *)b, tsb_size(b));
        // tsb_debug_print_entries(b);

        void *dummy = NULL;
        uint64_t dt;
        uint32_t to;
        uint16_t reb;
        uint16_t skip;

        while (tsb_read(b, &dummy, &dt, &to, UINT32_MAX, UINT32_MAX, &reb, &skip) == true) {
            // printf("tsb_drain:XX:%p data:%p\n", (void *)b, (void *)dummy);
            free(dummy);
        }

        // tsb_debug_print_entries(b);

        b->last_timestamp_out = 0;
    }
}

void tsb_kill(TSBuffer *b)
{
    if (b) {
        tsb_drain(b);

        free(b->data);
        free(b->type);
        free(b->timestamp);
        free(b);
    }
}

uint16_t tsb_size(const TSBuffer *b)
{
    if (tsb_empty(b) == true) {
        return 0;
    }

    return
        b->end > b->start ?
        b->end - b->start :
        (b->size - b->start) + b->end;
}




#if 0
static void tsb_debug_print_entries(const TSBuffer *b)
{
    uint16_t current_element;

    printf("tsb_debug_print_entries:---------------------\n");

    for (int i = 0; i < tsb_size(b); i++) {
        current_element = (b->start + i) % b->size;
        printf("tsb_debug_print_entries:loop=%d val=%d buf=%p\n",
               current_element, b->timestamp[current_element], (void *)b->data[current_element]);
    }

    printf("tsb_debug_print_entries:---------------------\n");
}

void unit_test()
{
#ifndef __MINGW32__
#include <time.h>
#endif

    printf("ts_buffer:testing ...\n");
    const int size = 5;
    const int bytes_per_entry = 200;

    TSBuffer *b1 = tsb_new(size);
    printf("b1=%p\n", b1);

    uint16_t size_ = tsb_size(b1);
    printf("size_:1=%d\n", size_);

#ifndef __MINGW32__
    srand(time(NULL));
#else
    // TODO: fixme ---
    srand(localtime());
    // TODO: fixme ---
#endif

    for (int j = 0; j < size + 0; j++) {
        void *tmp_b = calloc(1, bytes_per_entry);

        int val = rand() % 4999 + 1000;
        void *ret_p = tsb_write(b1, tmp_b, 1, val);
        printf("loop=%d val=%d\n", j, val);

        if (ret_p) {
            printf("kick oldest\n");
            free(ret_p);
        }

        size_ = tsb_size(b1);
        printf("size_:2=%d\n", size_);

    }

    size_ = tsb_size(b1);
    printf("size_:3=%d\n", size_);

    void *ptr;
    uint64_t dt;
    uint32_t to;
    uint32_t ti = 3000;
    uint32_t tr = 400;
    uint16_t reb = 0;
    uint16_t skip = 0;
    bool res1;

    bool loop = true;

    while (loop) {
        loop = false;
        ti = rand() % 4999 + 1000;
        tr = rand() % 100 + 1;
        res1 = tsb_read(b1, &ptr, &dt, &to, ti, tr, &reb, &skip);
        printf("ti=%d,tr=%d\n", (int)ti, (int)tr);

        if (res1 == true) {
            printf("found:ti=%d,tr=%d,TO=%d\n", (int)ti, (int)tr, (int)to);
            free(ptr);
            tsb_debug_print_entries(b1);
            break;
        } else if (tsb_size(b1) == 0) {
            break;
        }

        size_ = tsb_size(b1);
        printf("size_:4=%d\n", size_);
    }

    tsb_drain(b1);
    printf("drain\n");

    size_ = tsb_size(b1);
    printf("size_:99=%d\n", size_);

    tsb_kill(b1);
    b1 = NULL;
    printf("kill=%p\n", b1);
}

#endif
/* SPDX-License-Identifier: GPL-3.0-or-later
 * Copyright © 2016-2018 The TokTok team.
 * Copyright © 2013-2015 Tox project.
 */
#ifdef HAVE_CONFIG_H
#endif /* HAVE_CONFIG_H */






#include <stdio.h>
#include <assert.h>
#include <stdlib.h>

/*
 * return -1 on failure, 0 on success
 *
 */

extern bool global_do_not_sync_av;

int video_send_custom_lossless_packet(Tox *tox, int32_t friendnumber, const uint8_t *data, uint32_t length);

int video_send_custom_lossless_packet(Tox *tox, int32_t friendnumber, const uint8_t *data, uint32_t length)
{
    TOX_ERR_FRIEND_CUSTOM_PACKET error;
    tox_friend_send_lossless_packet(tox, friendnumber, data, (size_t)length, &error);

    if (error == TOX_ERR_FRIEND_CUSTOM_PACKET_OK) {
        return 0;
    }

    return -1;
}

VCSession *vc_new(Mono_Time *mono_time, const Logger *log, ToxAV *av, uint32_t friend_number,
                  toxav_video_receive_frame_cb *cb, void *cb_data)
{
    VCSession *vc = (VCSession *)calloc(sizeof(VCSession), 1);

    if (!vc) {
        LOGGER_API_WARNING(av->tox, "Allocation failed! Application might misbehave!");
        return NULL;
    }

    if (create_recursive_mutex(vc->queue_mutex) != 0) {
        LOGGER_API_WARNING(av->tox, "Failed to create recursive mutex!");
        free(vc);
        return NULL;
    }

    LOGGER_API_DEBUG(av->tox, "vc_new ...");

    // options ---
    vc->video_encoder_cpu_used = VP8E_SET_CPUUSED_VALUE;
    vc->video_encoder_cpu_used_prev = vc->video_encoder_cpu_used;
    vc->video_encoder_vp8_quality = TOXAV_ENCODER_VP8_QUALITY_NORMAL;
    vc->video_encoder_vp8_quality_prev = vc->video_encoder_vp8_quality;
    vc->video_rc_max_quantizer = TOXAV_ENCODER_VP8_RC_MAX_QUANTIZER_NORMAL;
    vc->video_rc_max_quantizer_prev = vc->video_rc_max_quantizer;
    vc->video_rc_min_quantizer = TOXAV_ENCODER_VP8_RC_MIN_QUANTIZER_NORMAL;
    vc->video_rc_min_quantizer_prev = vc->video_rc_min_quantizer;
    vc->video_encoder_coded_used = TOXAV_ENCODER_CODEC_USED_VP8; // DEFAULT: VP8 !!
    vc->video_encoder_frame_orientation_angle = TOXAV_CLIENT_INPUT_VIDEO_ORIENTATION_0;
    vc->video_encoder_coded_used_prev = vc->video_encoder_coded_used;
    vc->video_encoder_coded_used_hw_accel = TOXAV_ENCODER_CODEC_HW_ACCEL_NONE;
    vc->video_keyframe_method = TOXAV_ENCODER_KF_METHOD_NORMAL;
    vc->video_keyframe_method_prev = vc->video_keyframe_method;
    vc->video_decoder_error_concealment = VIDEO__VP8_DECODER_ERROR_CONCEALMENT;
    vc->video_decoder_error_concealment_prev = vc->video_decoder_error_concealment;
    vc->video_decoder_codec_used = TOXAV_ENCODER_CODEC_USED_VP8; // DEFAULT: VP8 !!
    vc->send_keyframe_request_received = 0;
    vc->h264_video_capabilities_received = 0; // WARNING: always set to zero (0) !!
    vc->show_own_video = 0; // WARNING: always set to zero (0) !!
    vc->video_bitrate_autoset = 1;

    vc->dummy_ntp_local_start = 0;
    vc->dummy_ntp_local_end = 0;
    vc->dummy_ntp_remote_start = 0;
    vc->dummy_ntp_remote_end = 0;
    vc->rountrip_time_ms = 300; // set xxx ms rountrip network time, before we get an actual value calculated
    vc->has_rountrip_time_ms = 0;
    vc->pinned_to_rountrip_time_ms = 0;
    vc->video_play_delay = 0;
    vc->video_play_delay_real = 0;
    vc->video_frame_buffer_entries = 0;
    vc->parsed_h264_sps_profile_i = 0;
    vc->parsed_h264_sps_level_i = 0;
    vc->last_sent_keyframe_ts = 0;
    vc->video_incoming_frame_orientation = TOXAV_CLIENT_INPUT_VIDEO_ORIENTATION_0;

    vc->last_incoming_frame_ts = 0;
    vc->last_parsed_h264_sps_ts = 0;
    vc->timestamp_difference_to_sender__for_video = 0;
    vc->timestamp_difference_adjustment = -450;
    vc->video_received_first_frame = 0;
    vc->tsb_range_ms = 90; // video frames played with have this much jitter (in ms) to the time they should be played
    vc->startup_video_timespan = 8000;
    vc->incoming_video_bitrate_last_changed = 0;
    vc->network_round_trip_time_last_cb_ts = 0;
    vc->network_round_trip_adjustment = 0;
    vc->incoming_video_bitrate_last_cb_ts = 0;
    vc->last_requested_lower_fps_ts = 0;
    vc->encoder_frame_has_record_timestamp = 1;
    vc->video_max_bitrate = VIDEO_BITRATE_MAX_AUTO_VALUE_H264;
    vc->video_min_bitrate = 0;
    // -----------------------------------
    vc->video_decoder_buffer_ms = 0;
    vc->video_decoder_add_delay_ms = 0;
    // -----------------------------------
    vc->video_decoder_caused_delay_ms = 0;
    vc->client_video_capture_delay_ms = 0;
    vc->remote_client_video_capture_delay_ms = 0;
    vc->global_decode_first_frame_delayed_by = 0;
    vc->global_decode_first_frame_delayed_ms = 0;
    vc->global_decode_first_frame_got = 0;
    // options ---

    vc->incoming_video_frames_gap_ms_index = 0;
    vc->incoming_video_frames_gap_last_ts = 0;
    vc->incoming_video_frames_gap_ms_mean_value = 0;

    vc->video_decoder_caused_delay_ms_array_index = 0;
    vc->video_decoder_caused_delay_ms_mean_value = 0;

    vc->video_buf_ms_array_index = 0;
    vc->video_buf_ms_mean_value = 0;

    vc->video_buf_ms_array_index_long = 0;
    vc->video_buf_ms_mean_value_long = 0;

    vc->encoder_codec_used_name = calloc(1, 500);
    vc->x264_software_encoder_used = 1;

    // set h264 callback
    vc->vcb_h264 = av->vcb_h264;
    vc->vcb_h264_user_data = av->vcb_h264_user_data;

    // set pts callback
    vc->vcb_pts = av->vcb_pts;
    vc->vcb_pts_user_data = av->vcb_pts_user_data;


    for (int i = 0; i < VIDEO_INCOMING_FRAMES_GAP_MS_ENTRIES; i++) {
        vc->incoming_video_frames_gap_ms[i] = 0;
    }

    if (!(vc->vbuf_raw = tsb_new(VIDEO_RINGBUFFER_BUFFER_ELEMENTS))) {
        LOGGER_API_WARNING(av->tox, "vc_new:rb_new FAILED");
        vc->vbuf_raw = NULL;
        goto BASE_CLEANUP;
    }

    LOGGER_API_DEBUG(av->tox, "vc_new:rb_new OK");

    // HINT: tell client what encoder and decoder are in use now -----------
    if (av->call_comm_cb) {

        TOXAV_CALL_COMM_INFO cmi;
        cmi = TOXAV_CALL_COMM_DECODER_IN_USE_VP8;

        if (vc->video_decoder_codec_used == TOXAV_ENCODER_CODEC_USED_H264) {
            cmi = TOXAV_CALL_COMM_DECODER_IN_USE_H264;
        }
        if (vc->video_decoder_codec_used == TOXAV_ENCODER_CODEC_USED_H265) {
            cmi = TOXAV_CALL_COMM_DECODER_IN_USE_H265;
        }

        av->call_comm_cb(av, friend_number, cmi, 0, av->call_comm_cb_user_data);

        cmi = TOXAV_CALL_COMM_ENCODER_IN_USE_VP8;

        if (vc->video_encoder_coded_used == TOXAV_ENCODER_CODEC_USED_H264) {
            if (vc->video_encoder_coded_used_hw_accel == TOXAV_ENCODER_CODEC_HW_ACCEL_OMX_PI) {
                cmi = TOXAV_CALL_COMM_ENCODER_IN_USE_H264_OMX_PI;
            } else {
                cmi = TOXAV_CALL_COMM_ENCODER_IN_USE_H264;
            }
        }
        if (vc->video_encoder_coded_used == TOXAV_ENCODER_CODEC_USED_H265) {
            cmi = TOXAV_CALL_COMM_ENCODER_IN_USE_H265;
        }

        av->call_comm_cb(av, friend_number, cmi, 0, av->call_comm_cb_user_data);
    }
    // HINT: tell client what encoder and decoder are in use now -----------

    // HINT: initialize the H264 encoder

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wcast-qual"
    // HINT: initialize H264 encoder and decoder
    vc = vc_new_h264((Logger *)log, av, friend_number, cb, cb_data, vc);
    // HINT: initialize H265 encoder and decoder
    vc = vc_new_h265((Logger *)log, av, friend_number, cb, cb_data, vc);
    // HINT: initialize VP8 encoder and decoder
    vc = vc_new_vpx((Logger *)log, av, friend_number, cb, cb_data, vc);
    return vc;
#pragma GCC diagnostic pop

BASE_CLEANUP:
    pthread_mutex_destroy(vc->queue_mutex);

    tsb_drain((TSBuffer *)vc->vbuf_raw);
    tsb_kill((TSBuffer *)vc->vbuf_raw);
    vc->vbuf_raw = NULL;
    free(vc);
    return NULL;
}

void vc_kill(VCSession *vc)
{
    if (!vc) {
        return;
    }

    vc_kill_h264(vc);
    vc_kill_h265(vc);
    vc_kill_vpx(vc);

    if (vc->encoder_codec_used_name)
    {
        free(vc->encoder_codec_used_name);
        vc->encoder_codec_used_name = NULL;
    }

    void *p;
    uint64_t dummy;

    tsb_drain((TSBuffer *)vc->vbuf_raw);
    tsb_kill((TSBuffer *)vc->vbuf_raw);
    vc->vbuf_raw = NULL;

    pthread_mutex_destroy(vc->queue_mutex);

    free(vc);
}

void video_switch_decoder(VCSession *vc, TOXAV_ENCODER_CODEC_USED_VALUE decoder_to_use);

void video_switch_decoder(VCSession *vc, TOXAV_ENCODER_CODEC_USED_VALUE decoder_to_use)
{
    if (vc->video_decoder_codec_used != (int32_t)decoder_to_use) {
        if ((decoder_to_use == TOXAV_ENCODER_CODEC_USED_VP8)
                || (decoder_to_use == TOXAV_ENCODER_CODEC_USED_VP9)
                || (decoder_to_use == TOXAV_ENCODER_CODEC_USED_H265)
                || (decoder_to_use == TOXAV_ENCODER_CODEC_USED_H264)) {

            vc->video_decoder_codec_used = decoder_to_use;
            LOGGER_API_DEBUG(vc->av->tox, "**switching DECODER to **:%d",
                         (int)vc->video_decoder_codec_used);

            if (vc->av) {
                if (vc->av->call_comm_cb) {

                    TOXAV_CALL_COMM_INFO cmi;
                    cmi = TOXAV_CALL_COMM_DECODER_IN_USE_VP8;

                    if (vc->video_decoder_codec_used == TOXAV_ENCODER_CODEC_USED_H264) {
                        cmi = TOXAV_CALL_COMM_DECODER_IN_USE_H264;
                    }
                    if (vc->video_decoder_codec_used == TOXAV_ENCODER_CODEC_USED_H265) {
                        cmi = TOXAV_CALL_COMM_DECODER_IN_USE_H265;
                    }

                    vc->av->call_comm_cb(vc->av, vc->friend_number,
                                         cmi, 0, vc->av->call_comm_cb_user_data);
                }
            }


        }
    }
}

/* --- VIDEO DECODING happens here --- */
/* --- VIDEO DECODING happens here --- */
/* --- VIDEO DECODING happens here --- */
uint8_t vc_iterate(VCSession *vc, Tox *tox, uint8_t skip_video_flag, uint64_t *a_r_timestamp,
                   uint64_t *a_l_timestamp,
                   uint64_t *v_r_timestamp, uint64_t *v_l_timestamp, BWController *bwc,
                   int64_t *timestamp_difference_adjustment_for_audio,
                   int64_t *timestamp_difference_to_sender_,
                   int32_t *video_has_rountrip_time_ms)
{
    if (!vc) {
        return 0;
    }

    uint8_t ret_value = 0;
    struct RTPMessage *p;
    bool have_requested_index_frame = false;
    vpx_codec_err_t rc = 0;

    LOGGER_API_DEBUG(tox, "vc_iterate:enter:fnum=%d", vc->friend_number);

    LOGGER_API_DEBUG(tox, "try_lock");
    if (pthread_mutex_trylock(vc->queue_mutex) != 0) {
        LOGGER_API_DEBUG(tox, "NO_lock");
        return 0;
    }
    LOGGER_API_DEBUG(tox, "got_lock");

    uint64_t frame_flags = 0;
    uint8_t data_type = 0;
    uint8_t h264_encoded_video_frame = 0;
    uint8_t h265_encoded_video_frame = 0;
    uint32_t full_data_len = 0;
    uint32_t timestamp_out_ = 0;
    uint32_t timestamp_min = 0;
    uint32_t timestamp_max = 0;

    *timestamp_difference_to_sender_ = vc->timestamp_difference_to_sender__for_video;

    tsb_get_range_in_buffer(tox, (TSBuffer *)vc->vbuf_raw, &timestamp_min, &timestamp_max);

    /**
     * this is the magic value that drifts with network delay changes:
     * vc->timestamp_difference_adjustment
     */
    int want_remote_video_ts = ((int)current_time_monotonic(vc->av->toxav_mono_time) +
                                (int)vc->timestamp_difference_to_sender__for_video +
                                (int)vc->timestamp_difference_adjustment -
                                (int)vc->video_decoder_buffer_ms);
    LOGGER_API_DEBUG(tox, "want_remote_video_ts:v:002=%d, %d %d %d %d",
            (int)want_remote_video_ts,
            (int)current_time_monotonic(vc->av->toxav_mono_time),
            (int)vc->timestamp_difference_to_sender__for_video,
            (int)vc->timestamp_difference_adjustment,
            (int)vc->video_decoder_buffer_ms
            );

    LOGGER_API_DEBUG(tox, "VC_TS_CALC:01:%d %d %d %d",
                     (int)want_remote_video_ts,
                     (int)(current_time_monotonic(vc->av->toxav_mono_time)),
                     (int)vc->timestamp_difference_to_sender__for_video,
                     (int)vc->timestamp_difference_adjustment
                    );

    uint32_t timestamp_want_get = (int)want_remote_video_ts;

    // HINT: compensate for older clients ----------------
    if (vc->encoder_frame_has_record_timestamp == 0) {
        LOGGER_API_DEBUG(tox, "old client:002");
        vc->tsb_range_ms = UINT32_MAX;
        timestamp_want_get = UINT32_MAX;
        vc->startup_video_timespan = 0;
    }
    // HINT: compensate for older clients ----------------

    LOGGER_API_DEBUG(tox, "FC:%d min=%d max=%d want=%d diff=%d adj=%d roundtrip=%d",
                 (int)tsb_size((TSBuffer *)vc->vbuf_raw),
                 timestamp_min,
                 timestamp_max,
                 (int)timestamp_want_get,
                 (int)timestamp_want_get - (int)timestamp_max,
                 (int)vc->timestamp_difference_adjustment,
                 (int)vc->rountrip_time_ms);


    int32_t video_frame_diff = (int)timestamp_want_get - (int)timestamp_max;
    int has_adjusted = 0;

    // ------- calc mean value -------
    if ((video_frame_diff > -800) && (video_frame_diff < 3000))
    {
        vc->video_buf_ms_array[vc->video_buf_ms_array_index] = video_frame_diff + 1000;
        vc->video_buf_ms_array_index = (vc->video_buf_ms_array_index + 1) %
                VIDEO_BUF_MS_ENTRIES;

        int32_t mean_value = 0;
        for (int k = 0; k < VIDEO_BUF_MS_ENTRIES; k++) {
            mean_value = mean_value + vc->video_buf_ms_array[k];
        }

        if (mean_value != 0) {
            vc->video_buf_ms_mean_value = (mean_value / VIDEO_BUF_MS_ENTRIES) - 1000;
        }
    }
    // ------- calc mean value -------


    // ------- calc mean value -------
    if ((video_frame_diff > -3000) && (video_frame_diff < 20000))
    {
        vc->video_buf_ms_array_long[vc->video_buf_ms_array_index_long] = video_frame_diff + 4000;
        vc->video_buf_ms_array_index_long = (vc->video_buf_ms_array_index_long + 1) %
                VIDEO_BUF_MS_ENTRIES_LONG;

        int32_t mean_value = 0;

        for (int k = 0; k < VIDEO_BUF_MS_ENTRIES_LONG; k++) {
            mean_value = mean_value + vc->video_buf_ms_array_long[k];
        }

        if (mean_value != 0) {
            vc->video_buf_ms_mean_value_long = (mean_value / VIDEO_BUF_MS_ENTRIES_LONG) - 4000;
        }
    }
    // ------- calc mean value -------


    LOGGER_API_DEBUG(tox, "rtt:drift:vfd:a:rtt=%d adj=%d cur=%d m=%d ml=%d",
                    (int32_t)vc->rountrip_time_ms,
                    (int)(vc->timestamp_difference_adjustment),
                    video_frame_diff,
                    vc->video_buf_ms_mean_value,
                    vc->video_buf_ms_mean_value_long);

    if ((vc->pinned_to_rountrip_time_ms == 0) && (vc->has_rountrip_time_ms == 1))
    {
        // ------------ pin play out timestamps to (RTT/2 + "GUESS_REMOTE_ENCODER_DELAY_MS" ms)
        vc->timestamp_difference_adjustment = -(int)((vc->rountrip_time_ms/2) + GUESS_REMOTE_ENCODER_DELAY_MS);
        vc->network_round_trip_adjustment = vc->rountrip_time_ms;
        LOGGER_API_DEBUG(tox, "adj:drift:5a:jmp:%d video_frame_diff=%d rtt_adj=%d", (int)(vc->timestamp_difference_adjustment), video_frame_diff, vc->network_round_trip_adjustment);
        vc->pinned_to_rountrip_time_ms = 1;
    }

    LOGGER_API_DEBUG(tox, "adj:xxxx:9:%d video_frame_diff=%d rtt_adj=%d", (int)(vc->timestamp_difference_adjustment), video_frame_diff, vc->network_round_trip_adjustment);

    if (vc->has_rountrip_time_ms == 1)
    {
        // im RTT changed by 2ms in either direction then drift network_round_trip_adjustment in that way by 1ms
        if (vc->network_round_trip_adjustment > ((int32_t)vc->rountrip_time_ms + 1))
        {
            vc->network_round_trip_adjustment--;
            vc->network_round_trip_adjustment--;
            vc->timestamp_difference_adjustment++;
            LOGGER_API_DEBUG(tox, "adj:drift:aa++");
        }
        else if (vc->network_round_trip_adjustment < ((int32_t)vc->rountrip_time_ms - 1))
        {
            vc->network_round_trip_adjustment++;
            vc->network_round_trip_adjustment++;
            vc->timestamp_difference_adjustment--;
            LOGGER_API_DEBUG(tox, "adj:drift:aa-----");
        }
    }

    uint16_t removed_entries;
    uint16_t is_skipping = 0;

    uint32_t tsb_range_ms_used = vc->tsb_range_ms + vc->startup_video_timespan;
    uint32_t timestamp_want_get_used = timestamp_want_get;
    LOGGER_API_DEBUG(tox,"timestamp_want_get_used:001=%d", (int)timestamp_want_get_used);

    int use_range_all = 0;

    if (
        (global_do_not_sync_av) ||
        (vc->video_received_first_frame == 0) ||
        (vc->has_rountrip_time_ms == 0) ||
        (
            (video_frame_diff > 1000) && (video_frame_diff < 10000))
        )
    {
        tsb_range_ms_used = UINT32_MAX;
        timestamp_want_get_used = UINT32_MAX;
        use_range_all = 1;
        LOGGER_API_DEBUG(tox,"first_frame:001a: %d %d %d %d",
                (int)global_do_not_sync_av,
                (int)vc->video_received_first_frame,
                (int)vc->has_rountrip_time_ms,
                (int)video_frame_diff
                );
        LOGGER_API_DEBUG(tox,"first_frame:001b:timestamp_want_get_used:002=%d", (int)timestamp_want_get_used);
    }

    if (use_range_all == 1)
    {
        // this will force audio stream to play anything that comes in without timestamps
        *video_has_rountrip_time_ms = 0;
        LOGGER_API_DEBUG(tox,"force_audio");
    }
    else
    {
        *video_has_rountrip_time_ms = vc->has_rountrip_time_ms;
    }


    if ((video_frame_diff > 1000) && (video_frame_diff < 10000))
    {
        LOGGER_API_DEBUG(tox, "video frames are delayed[a] for more than 1000ms (%d ms), turn down bandwidth fast", (int)video_frame_diff);
        bwc_add_lost_v3(bwc, 199999, true);
    }
    else if ((video_frame_diff > 800) && (video_frame_diff < 10000))
    {
        LOGGER_API_DEBUG(tox, "video frames are delayed[b] for more than 800ms (%d ms), turn down bandwidth", (int)video_frame_diff);
        bwc_add_lost_v3(bwc, 60, true);
    }
    else if ((vc->has_rountrip_time_ms == 1) && (video_frame_diff > 1) && (video_frame_diff > (((int32_t)vc->rountrip_time_ms) + 100)) && (video_frame_diff < 10000))
    {
        if ((vc->rountrip_time_ms > 300) && (vc->rountrip_time_ms < 1000))
        {
            LOGGER_API_DEBUG(tox, "video frames are delayed[c] (%d ms, RTT=%d ms), turn down bandwidth", (int)video_frame_diff, (int)vc->rountrip_time_ms);
            bwc_add_lost_v3(bwc, 3, true);
        }
    }

    if ((video_frame_diff > ((int)vc->video_buf_ms_mean_value_long + 300)) && (video_frame_diff < 100000))
    {
        bwc_add_lost_v3(bwc, 70, true);
        LOGGER_API_DEBUG(tox, "video frames are delayed[e], (vdf=%d RTT=%d ml=%d) turn down bandwidth",
            (int)video_frame_diff,
            (int)vc->rountrip_time_ms,
            (int)vc->video_buf_ms_mean_value_long);
    }

    LOGGER_API_DEBUG(tox, "tsb_read got: want=%d (%d %d) %d %d %d %d",
                     (int)timestamp_want_get_used,
                     (int)timestamp_min,
                     (int)timestamp_max,
                     (int)(vc->tsb_range_ms),
                     (int)(vc->startup_video_timespan),
                     (int)(tsb_range_ms_used),
                     (int)tsb_size((TSBuffer *)vc->vbuf_raw)
                    );


    // HINT: give me video frames that happend "now" minus some diff
    //       get a videoframe for timestamp [timestamp_want_get_used]
    if (tsb_read((TSBuffer *)vc->vbuf_raw, (void **)&p, &frame_flags,
                 &timestamp_out_,
                 timestamp_want_get_used,
                 tsb_range_ms_used,
                 &removed_entries,
                 &is_skipping)) {

        if (vc->video_received_first_frame == 0) {
            vc->video_received_first_frame = 1;
        }

        const struct RTPHeader *header_v3_0 = (void *) &(p->header);

        LOGGER_API_DEBUG(tox, "XLS01:%d,%d, diff_got=%d",
                         (int)(timestamp_want_get - current_time_monotonic(vc->av->toxav_mono_time)),
                         (int)(timestamp_out_ - current_time_monotonic(vc->av->toxav_mono_time)),
                         (int)(timestamp_want_get - timestamp_out_)
                        );

        vc->video_play_delay = ((current_time_monotonic(vc->av->toxav_mono_time) +
                                 vc->timestamp_difference_to_sender__for_video) - timestamp_out_);
        vc->video_play_delay_real = vc->video_play_delay + vc->video_decoder_caused_delay_ms;

        vc->video_frame_buffer_entries = (uint32_t)tsb_size((TSBuffer *)vc->vbuf_raw);

        if (removed_entries > 0) {

            LOGGER_API_DEBUG(tox,
                             "seq:%d FC:%d min=%d max=%d want=%d hgot=%d got=%d diff=%d rm=%d pdelay=%d pdelayr=%d adj=%d dts=%d rtt=%d decoder_delay=%d",
                             (int)header_v3_0->sequnum,
                             (int)tsb_size((TSBuffer *)vc->vbuf_raw),
                             timestamp_min,
                             timestamp_max,
                             (int)timestamp_want_get,
                             (int)header_v3_0->frame_record_timestamp,
                             (int)timestamp_out_,
                             ((int)timestamp_want_get - (int)timestamp_out_),
                             (int)removed_entries,
                             (int)vc->video_play_delay,
                             (int)vc->video_play_delay_real,
                             (int)vc->timestamp_difference_adjustment,
                             (int)vc->timestamp_difference_to_sender__for_video,
                             (int)vc->rountrip_time_ms,
                             (int)vc->video_decoder_caused_delay_ms);
        }

        uint16_t buf_size = tsb_size((TSBuffer *)vc->vbuf_raw);
        int32_t diff_want_to_got = (int)timestamp_want_get - (int)timestamp_out_;

        LOGGER_API_DEBUG(tox, "values:diff_to_sender=%d adj=%d tsb_range=%d bufsize=%d",
                         (int)vc->timestamp_difference_to_sender__for_video, (int)vc->timestamp_difference_adjustment,
                         (int)vc->tsb_range_ms,
                         (int)buf_size);


        if (vc->startup_video_timespan > 0) {
            vc->startup_video_timespan = 0;
        }

        // TODO: calculate the delay for the audio stream, and pass it back
        // bad hack -> make better!
        // ----------------------------------------
        // ----------------------------------------
        // ----------------------------------------
        int32_t delay_audio_stream_relative_to_video_stream = (vc->video_decoder_buffer_ms + vc->video_decoder_add_delay_ms);
        uint32_t video_decoder_caused_delay_ms_mean_value_used = vc->video_decoder_caused_delay_ms_mean_value;
        if (video_decoder_caused_delay_ms_mean_value_used > 300)
        {
            video_decoder_caused_delay_ms_mean_value_used = 300;
        }

        *timestamp_difference_adjustment_for_audio = vc->timestamp_difference_adjustment -
                delay_audio_stream_relative_to_video_stream -
                vc->video_decoder_caused_delay_ms_mean_value;
        LOGGER_API_DEBUG(tox, "want_remote_video_ts:v:003=%d", (int)*timestamp_difference_adjustment_for_audio);
        LOGGER_API_DEBUG(tox, "VV:01:%d", (int)vc->video_decoder_buffer_ms);
        LOGGER_API_DEBUG(tox, "VV:02:%d %d", (int)*timestamp_difference_adjustment_for_audio, (int)vc->timestamp_difference_adjustment);
        LOGGER_API_DEBUG(tox, "VV:03:%d %d", (int)vc->video_decoder_add_delay_ms, (int)vc->video_decoder_caused_delay_ms_mean_value);
        LOGGER_API_DEBUG(tox, "VV:04:%d %d", (int)delay_audio_stream_relative_to_video_stream, (int)vc->video_decoder_buffer_ms);
        // ----------------------------------------
        // ----------------------------------------
        // ----------------------------------------


        LOGGER_API_DEBUG(tox, "--VSEQ:%d", (int)header_v3_0->sequnum);

        data_type = (uint8_t)((frame_flags & RTP_KEY_FRAME) != 0);
        h264_encoded_video_frame = (uint8_t)((frame_flags & RTP_ENCODER_IS_H264) != 0);
        h265_encoded_video_frame = (uint8_t)((frame_flags & RTP_ENCODER_IS_H265) != 0);

        uint8_t video_orientation_bit0 = (uint8_t)((frame_flags & RTP_ENCODER_VIDEO_ROTATION_ANGLE_BIT0) != 0);
        uint8_t video_orientation_bit1 = (uint8_t)((frame_flags & RTP_ENCODER_VIDEO_ROTATION_ANGLE_BIT1) != 0);
        if ((video_orientation_bit0 == 0) && (video_orientation_bit1 == 0)) {
            vc->video_incoming_frame_orientation = TOXAV_CLIENT_INPUT_VIDEO_ORIENTATION_0;
        } else if ((video_orientation_bit0 == 1) && (video_orientation_bit1 == 0)) {
            vc->video_incoming_frame_orientation = TOXAV_CLIENT_INPUT_VIDEO_ORIENTATION_90;
        } else if ((video_orientation_bit0 == 0) && (video_orientation_bit1 == 1)) {
            vc->video_incoming_frame_orientation = TOXAV_CLIENT_INPUT_VIDEO_ORIENTATION_180;
        } else if ((video_orientation_bit0 == 1) && (video_orientation_bit1 == 1)) {
            vc->video_incoming_frame_orientation = TOXAV_CLIENT_INPUT_VIDEO_ORIENTATION_270;
        }

        bwc_add_recv(bwc, header_v3_0->data_length_full);

        if ((int32_t)header_v3_0->sequnum < (int32_t)vc->last_seen_fragment_seqnum) {
            // drop frame with too old sequence number
            LOGGER_API_DEBUG(tox, "skipping incoming video frame (0) with sn=%d lastseen=%d old_frames_count=%d",
                           (int)header_v3_0->sequnum,
                           (int)vc->last_seen_fragment_seqnum,
                           (int)vc->count_old_video_frames_seen);

            vc->count_old_video_frames_seen++;

            if ((int32_t)(header_v3_0->sequnum + 1) != (int32_t)vc->last_seen_fragment_seqnum) {
                // TODO: check why we often get exactly the previous video frame here?!?!
                LOGGER_API_DEBUG(tox, "got previous seq number");
            }

            if (vc->count_old_video_frames_seen > 6) {
                // if we see more than 6 old video frames in a row, then either there was
                // a seqnum rollover or something else. just play those frames then
                vc->last_seen_fragment_seqnum = (int32_t)header_v3_0->sequnum;
                vc->count_old_video_frames_seen = 0;
                LOGGER_API_DEBUG(tox, "count_old_video_frames_seen > 6");
            }

            free(p);
            pthread_mutex_unlock(vc->queue_mutex);
            LOGGER_API_DEBUG(tox, "un_lock");
            return 0;
        }

        if ((int32_t)header_v3_0->sequnum != (int32_t)(vc->last_seen_fragment_seqnum + 1)) {
            int32_t missing_frames_count = (int32_t)header_v3_0->sequnum -
                                           (int32_t)(vc->last_seen_fragment_seqnum + 1);

            LOGGER_API_DEBUG(tox, "missing some video frames: missing count=%d", (int)missing_frames_count);

#define NORMAL_MISSING_FRAME_COUNT_TOLERANCE 1
#define WHEN_SKIPPING_MISSING_FRAME_COUNT_TOLERANCE 2

            int32_t missing_frame_tolerance = NORMAL_MISSING_FRAME_COUNT_TOLERANCE;

            if (is_skipping > 0) {
                // HINT: workaround, if we are skipping frames because client is too slow
                //       we assume the missing frames here are the skipped ones
                missing_frame_tolerance = WHEN_SKIPPING_MISSING_FRAME_COUNT_TOLERANCE;
            }

            if (missing_frames_count > missing_frame_tolerance) {

                // HINT: if whole video frames are missing here, they most likely have been
                //       kicked out of the ringbuffer because the sender is sending at too much FPS
                //       which out client cant handle. so in the future signal sender to send less FPS!

#ifndef RPIZEROW
                LOGGER_API_WARNING(tox, "missing? sn=%d lastseen=%d",
                               (int)header_v3_0->sequnum,
                               (int)vc->last_seen_fragment_seqnum);


                LOGGER_API_WARNING(tox, "missing %d video frames (m1)", (int)missing_frames_count);
#endif

                if ((vc->video_decoder_codec_used != TOXAV_ENCODER_CODEC_USED_H264) &&
                    (vc->video_decoder_codec_used != TOXAV_ENCODER_CODEC_USED_H265))
                {
                    rc = vpx_codec_decode(vc->decoder, NULL, 0, NULL, VPX_DL_REALTIME);
                }

                // HINT: give feedback that we lost some bytes (based on the size of this frame)
                bwc_add_lost_v3(bwc, (uint32_t)(header_v3_0->data_length_full * missing_frames_count), true);
#ifndef RPIZEROW
                LOGGER_API_WARNING(tox, "BWC:lost:002:missing count=%d", (int)missing_frames_count);
#endif
            }
        }


        // TODO: check for seqnum rollover!!
        vc->count_old_video_frames_seen = 0;
        vc->last_seen_fragment_seqnum = header_v3_0->sequnum;

        //* PREVIOUS UNLOCK *//
        // pthread_mutex_unlock(vc->queue_mutex);
        // LOGGER_API_DEBUG(tox, "un_lock");

        const struct RTPHeader *header_v3 = (void *) & (p->header);

        if (header_v3->flags & RTP_LARGE_FRAME) {
            full_data_len = header_v3->data_length_full;
            LOGGER_API_DEBUG(tox, "vc_iterate:001:full_data_len=%d", (int)full_data_len);
        } else {
            full_data_len = p->len;
            LOGGER_API_DEBUG(tox, "vc_iterate:002");
        }

        // HINT: give feedback that we lost some bytes
        if (header_v3->received_length_full < full_data_len) {
            bwc_add_lost_v3(bwc, (full_data_len - header_v3->received_length_full), false);
            float percent_lost = 0.0f;

            if (header_v3->received_length_full > 0) {
                percent_lost = 100.0f * (1.0f - ((float)header_v3->received_length_full / (float)full_data_len));
            }

            LOGGER_API_WARNING(tox, "BWC:lost:004:seq=%d,lost bytes=%d recevied=%d full=%d per=%.3f",
                         (int)header_v3->sequnum,
                         (int)(full_data_len - header_v3->received_length_full),
                         (int)header_v3->received_length_full,
                         (int)full_data_len,
                         (double)percent_lost);
        }


        if ((int)data_type == (int)video_frame_type_KEYFRAME) {
            int percent_recvd = 100;

            if (full_data_len > 0) {
                percent_recvd = (int)(((float)header_v3->received_length_full / (float)full_data_len) * 100.0f);
            }
        } else {
            LOGGER_API_DEBUG(tox, "RTP_RECV:sn=%ld fn=%ld pct=%d%% len=%ld recv_len=%ld",
                         (long)header_v3->sequnum,
                         (long)header_v3->fragment_num,
                         (int)(((float)header_v3->received_length_full / (float)full_data_len) * 100.0f),
                         (long)full_data_len,
                         (long)header_v3->received_length_full);
        }


        if (DISABLE_H264_DECODER_FEATURE == 0) {

            if ((vc->video_decoder_codec_used != TOXAV_ENCODER_CODEC_USED_H264)
                    && (h264_encoded_video_frame == 1)) {
                LOGGER_API_WARNING(tox, "h264_encoded_video_frame:AA");
                video_switch_decoder(vc, TOXAV_ENCODER_CODEC_USED_H264);
            } else if ((vc->video_decoder_codec_used != TOXAV_ENCODER_CODEC_USED_H265)
                    && (h265_encoded_video_frame == 1)) {
                LOGGER_API_WARNING(tox, "h265_encoded_video_frame:AA");
                video_switch_decoder(vc, TOXAV_ENCODER_CODEC_USED_H265);
            } else if (
                       ((vc->video_decoder_codec_used == TOXAV_ENCODER_CODEC_USED_H264) ||
                       (vc->video_decoder_codec_used == TOXAV_ENCODER_CODEC_USED_H265))
                       && ((h264_encoded_video_frame == 0) && (h265_encoded_video_frame == 0))
                       )
            {
                LOGGER_API_WARNING(tox, "h26(4|5)_encoded_video_frame:BB");
                // HINT: once we switched to H264 (or H265) never switch back to VP8 until this call ends
            }
        }

        // HINT: sometimes the singaling of H264 capability does not work
        //       as workaround send it again on the first 30 frames

        if (DISABLE_H264_DECODER_FEATURE != 1) {
            if (
                 ((vc->video_decoder_codec_used != TOXAV_ENCODER_CODEC_USED_H264) &&
                 (vc->video_decoder_codec_used != TOXAV_ENCODER_CODEC_USED_H265))
                    && ((long)header_v3->sequnum < 30))
            {

                // HINT: tell friend that we have H264 decoder capabilities (3) -------
                uint32_t pkg_buf_len = 2;
                uint8_t pkg_buf[pkg_buf_len];
                pkg_buf[0] = PACKET_TOXAV_COMM_CHANNEL;
                pkg_buf[1] = PACKET_TOXAV_COMM_CHANNEL_HAVE_H264_VIDEO;

                int result = video_send_custom_lossless_packet(tox, vc->friend_number, pkg_buf, pkg_buf_len);
                LOGGER_API_WARNING(tox, "PACKET_TOXAV_COMM_CHANNEL_HAVE_H264_VIDEO=%d", (int)result);
                // HINT: tell friend that we have H264 decoder capabilities -------

            }
        }

        //* MID UNLOCK *//
        // pthread_mutex_unlock(vc->queue_mutex);

        if ((vc->video_decoder_codec_used != TOXAV_ENCODER_CODEC_USED_H264) && (vc->video_decoder_codec_used != TOXAV_ENCODER_CODEC_USED_H265)) {
            decode_frame_vpx(vc, tox, skip_video_flag, a_r_timestamp,
                             a_l_timestamp,
                             v_r_timestamp, v_l_timestamp,
                             header_v3, p,
                             rc, full_data_len,
                             &ret_value);
        } else {
            if (vc->video_decoder_codec_used == TOXAV_ENCODER_CODEC_USED_H265)
            {
                decode_frame_h265(vc, tox, skip_video_flag, a_r_timestamp,
                                  a_l_timestamp,
                                  v_r_timestamp, v_l_timestamp,
                                  header_v3, p,
                                  rc, full_data_len,
                                  &ret_value);
            }
            else
            {
                decode_frame_h264(vc, tox, skip_video_flag, a_r_timestamp,
                                  a_l_timestamp,
                                  v_r_timestamp, v_l_timestamp,
                                  header_v3, p,
                                  rc, full_data_len,
                                  &ret_value);
            }
        }

        //* NEW UNLOCK *//
        pthread_mutex_unlock(vc->queue_mutex);

        return ret_value;
    } else {
        // no frame data available
        if (removed_entries > 0) {
            LOGGER_API_WARNING(tox, "no frame read, but removed entries=%d", (int)removed_entries);
        }
    }

    pthread_mutex_unlock(vc->queue_mutex);
    return ret_value;
}
/* --- VIDEO DECODING happens here --- */
/* --- VIDEO DECODING happens here --- */
/* --- VIDEO DECODING happens here --- */


int vc_queue_message(Mono_Time *mono_time, void *vcp, struct RTPMessage *msg)
{
    /* This function is called with complete messages
     * they have already been assembled. but not yet decoded
     * (data is still compressed by video codec)
     * this function gets called from handle_rtp_packet()
     */
    if (!vcp || !msg) {
        if (msg) {
            free(msg);
        }

        return -1;
    }

    VCSession *vc = (VCSession *)vcp;

    const struct RTPHeader *header_v3 = (void *) & (msg->header);
    const struct RTPHeader *header = &msg->header;

    if (msg->header.pt == (RTP_TYPE_VIDEO + 2) % 128) {
        free(msg);
        return 0;
    }

    if (msg->header.pt != RTP_TYPE_VIDEO % 128) {
        LOGGER_API_WARNING(vc->av->tox, "Invalid payload type! pt=%d", (int)msg->header.pt);
        free(msg);
        return -1;
    }


    LOGGER_API_DEBUG(vc->av->tox, "want_lock");
    pthread_mutex_lock(vc->queue_mutex);
    LOGGER_API_DEBUG(vc->av->tox, "got_lock");


    // calculate mean "frame incoming every x milliseconds" --------------
    if (vc->incoming_video_frames_gap_last_ts > 0) {
        uint32_t curent_gap = current_time_monotonic(mono_time) - vc->incoming_video_frames_gap_last_ts;

        vc->incoming_video_frames_gap_ms[vc->incoming_video_frames_gap_ms_index] = curent_gap;
        vc->incoming_video_frames_gap_ms_index = (vc->incoming_video_frames_gap_ms_index + 1) %
                VIDEO_INCOMING_FRAMES_GAP_MS_ENTRIES;

        uint32_t mean_value = 0;

        for (int k = 0; k < VIDEO_INCOMING_FRAMES_GAP_MS_ENTRIES; k++) {
            mean_value = mean_value + vc->incoming_video_frames_gap_ms[k];
        }

        if (mean_value == 0) {
            vc->incoming_video_frames_gap_ms_mean_value = 0;
        } else {
            vc->incoming_video_frames_gap_ms_mean_value = (mean_value * 10) / (VIDEO_INCOMING_FRAMES_GAP_MS_ENTRIES * 10);
        }
    }

    vc->incoming_video_frames_gap_last_ts = current_time_monotonic(mono_time);
    // calculate mean "frame incoming every x milliseconds" --------------

    LOGGER_API_DEBUG(vc->av->tox, "TT:queue:V:fragnum=%ld", (long)header_v3->fragment_num);

    // older clients do not send the frame record timestamp
    // compensate by using the frame sennt timestamp
    if (msg->header.frame_record_timestamp == 0) {
        LOGGER_API_DEBUG(vc->av->tox, "old client:001");
        msg->header.frame_record_timestamp = msg->header.timestamp;
    }

    if ((header->flags & RTP_LARGE_FRAME) && header->pt == RTP_TYPE_VIDEO % 128) {

        vc->last_incoming_frame_ts = header_v3->frame_record_timestamp;

        // give COMM data to client -------
        if ((vc->network_round_trip_time_last_cb_ts + 2000) < current_time_monotonic(mono_time)) {
            if (vc->av) {
                if (vc->av->call_comm_cb) {
                    vc->av->call_comm_cb(vc->av, vc->friend_number,
                                         TOXAV_CALL_COMM_NETWORK_ROUND_TRIP_MS,
                                         (int64_t)vc->rountrip_time_ms,
                                         vc->av->call_comm_cb_user_data);

                    vc->av->call_comm_cb(vc->av, vc->friend_number,
                                         TOXAV_CALL_COMM_PLAY_DELAY,
                                         (int64_t)vc->video_play_delay_real,
                                         vc->av->call_comm_cb_user_data);

                    vc->av->call_comm_cb(vc->av, vc->friend_number,
                                         TOXAV_CALL_COMM_REMOTE_RECORD_DELAY,
                                         (int64_t)vc->remote_client_video_capture_delay_ms,
                                         vc->av->call_comm_cb_user_data);

                    vc->av->call_comm_cb(vc->av, vc->friend_number,
                                         TOXAV_CALL_COMM_PLAY_BUFFER_ENTRIES,
                                         (int64_t)vc->video_frame_buffer_entries,
                                         vc->av->call_comm_cb_user_data);

                    vc->av->call_comm_cb(vc->av, vc->friend_number,
                                         TOXAV_CALL_COMM_DECODER_H264_PROFILE,
                                         (int64_t)vc->parsed_h264_sps_profile_i,
                                         vc->av->call_comm_cb_user_data);

                    vc->av->call_comm_cb(vc->av, vc->friend_number,
                                         TOXAV_CALL_COMM_DECODER_H264_LEVEL,
                                         (int64_t)vc->parsed_h264_sps_level_i,
                                         vc->av->call_comm_cb_user_data);

                    vc->av->call_comm_cb(vc->av, vc->friend_number,
                                         TOXAV_CALL_COMM_PLAY_VIDEO_ORIENTATION,
                                         (int64_t)vc->video_incoming_frame_orientation,
                                         vc->av->call_comm_cb_user_data);

                    if (vc->incoming_video_frames_gap_ms_mean_value == 0) {
                        vc->av->call_comm_cb(vc->av, vc->friend_number,
                                             TOXAV_CALL_COMM_INCOMING_FPS,
                                             (int64_t)(9999),
                                             vc->av->call_comm_cb_user_data);
                    } else {
                        vc->av->call_comm_cb(vc->av, vc->friend_number,
                                             TOXAV_CALL_COMM_INCOMING_FPS,
                                             (int64_t)(1000 / vc->incoming_video_frames_gap_ms_mean_value),
                                             vc->av->call_comm_cb_user_data);
                    }
                }

            }

            vc->network_round_trip_time_last_cb_ts = current_time_monotonic(mono_time);
        }
        // give COMM data to client -------

        if (vc->show_own_video == 0) {

            if ((vc->incoming_video_bitrate_last_cb_ts + 2000) < current_time_monotonic(mono_time)) {
                if (vc->incoming_video_bitrate_last_changed != header->encoder_bit_rate_used) {
                    if (vc->av) {
                        if (vc->av->call_comm_cb) {
                            vc->av->call_comm_cb(vc->av, vc->friend_number,
                                                 TOXAV_CALL_COMM_DECODER_CURRENT_BITRATE,
                                                 (int64_t)header->encoder_bit_rate_used,
                                                 vc->av->call_comm_cb_user_data);
                        }
                    }

                    vc->incoming_video_bitrate_last_changed = header->encoder_bit_rate_used;
                }

                vc->incoming_video_bitrate_last_cb_ts = current_time_monotonic(mono_time);
            }

            LOGGER_API_DEBUG(vc->av->tox, "vc_queue_msg:tsb_write : %d", (uint32_t)header->frame_record_timestamp);

            struct RTPMessage *msg_old = tsb_write((TSBuffer *)vc->vbuf_raw, msg,
                                                   (uint64_t)header->flags,
                                                   (uint32_t)header->frame_record_timestamp);

            if (msg_old) {
                LOGGER_API_WARNING(vc->av->tox, "FPATH:%d kicked out", (int)msg_old->header.sequnum);
                free(msg_old);
            }
        } else {
            // discard incoming frame, we want to see our outgoing frames instead
            if (msg) {
                free(msg);
            }
        }
    } else {
        free(tsb_write((TSBuffer *)vc->vbuf_raw, msg, 0, current_time_monotonic(mono_time)));
    }


    /* Calculate time since we received the last video frame */
    // use 5ms less than the actual time, to give some free room
    uint32_t t_lcfd = (current_time_monotonic(mono_time) - vc->linfts) - 5;
    vc->lcfd = t_lcfd > 100 ? vc->lcfd : t_lcfd;

#ifdef VIDEO_DECODER_SOFT_DEADLINE_AUTOTUNE
    // Autotune decoder softdeadline here ----------
    if (vc->last_decoded_frame_ts > 0) {
        long decode_time_auto_tune = (current_time_monotonic(mono_time) - vc->last_decoded_frame_ts) * 1000;

        if (decode_time_auto_tune == 0) {
            decode_time_auto_tune = 1; // 0 means infinite long softdeadline!
        }

        vc->decoder_soft_deadline[vc->decoder_soft_deadline_index] = decode_time_auto_tune;
        vc->decoder_soft_deadline_index = (vc->decoder_soft_deadline_index + 1) % VIDEO_DECODER_SOFT_DEADLINE_AUTOTUNE_ENTRIES;
    }

    vc->last_decoded_frame_ts = current_time_monotonic(mono_time);
    // Autotune decoder softdeadline here ----------
#endif

    vc->linfts = current_time_monotonic(mono_time);

    pthread_mutex_unlock(vc->queue_mutex);
    LOGGER_API_DEBUG(vc->av->tox, "un_lock");

    return 0;
}



int vc_reconfigure_encoder(Logger *log, VCSession *vc, uint32_t bit_rate, uint16_t width, uint16_t height,
                           int16_t kf_max_dist)
{
    int ret = 0;
    
    if (vc->video_encoder_coded_used == TOXAV_ENCODER_CODEC_USED_VP8) {
        ret = vc_reconfigure_encoder_vpx(log, vc, bit_rate, width, height, kf_max_dist);
    } else {
#ifdef HAVE_H265_ENCODER
        if (vc->video_encoder_coded_used == TOXAV_ENCODER_CODEC_USED_H265) {
            vc_reconfigure_encoder_h265(log, vc, bit_rate, width, height, kf_max_dist);
        }
#endif
        if (vc->video_encoder_coded_used == TOXAV_ENCODER_CODEC_USED_H264) {
            ret = vc_reconfigure_encoder_h264(log, vc, bit_rate, width, height, kf_max_dist);
        }
    }

    vc->video_encoder_coded_used_prev = vc->video_encoder_coded_used;
    return ret;
}

/*
 * Copyright © 2018 zoff@zoff.cc and mail@strfry.org
 *
 * This file is part of Tox, the free peer to peer instant messenger.
 *
 * Tox is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Tox is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Tox.  If not, see <http://www.gnu.org/licenses/>.
 */


#include <assert.h>


#ifdef __cplusplus
extern "C" {
#endif
// for H264 ----------
#include <libavcodec/avcodec.h>
#include <libavutil/opt.h>
// for H264 ----------
#ifdef __cplusplus
}
#endif

// HINT: cant get the loglevel enum here for some reason. so here is the workaround.
#ifndef LOGGER_LEVEL_TRACE
#define LOGGER_LEVEL_TRACE 0
#endif
#ifndef LOGGER_LEVEL_DEBUG
#define LOGGER_LEVEL_DEBUG 1
#endif
#ifndef LOGGER_LEVEL_INFO
#define LOGGER_LEVEL_INFO 2
#endif
#ifndef LOGGER_LEVEL_WARNING
#define LOGGER_LEVEL_WARNING 3
#endif
#ifndef LOGGER_LEVEL_ERROR
#define LOGGER_LEVEL_ERROR 4
#endif
// HINT: cant get the loglevel enum here for some reason. so here is the workaround.

/* ---------------------------------------------------
 *
 * Hardware specific defines for encoders and decoder
 * use -DXXXXXX to enable at compile time, otherwise defaults will be used
 *
 * ---------------------------------------------------
 */


/* ---------------------------------------------------
 * DEFAULT
 */
#define ACTIVE_HW_CODEC_CONFIG_NAME "_DEFAULT_"
#define H264_WANT_ENCODER_NAME "not used with x264"
#define H264_WANT_DECODER_NAME "h264"
#define X264_ENCODE_USED 1
// #define RAPI_HWACCEL_ENC 1
// #define RAPI_HWACCEL_DEC 1
/* !!multithreaded H264 decoding adds about 80ms of delay!! (0 .. disable, 1 .. disable also?) */
#define H264_DECODER_THREADS 4
#define H264_DECODER_THREAD_FRAME_ACTIVE 1
/* multithreaded encoding seems to add less delay (0 .. disable) */
#define X264_ENCODER_THREADS 4
#define X264_ENCODER_SLICES 4
#define H264_ENCODE_MAX_BITRATE_OVER_ALLOW 1.3
#define H264_ENCODER_STARTWITH_PROFILE_HIGH 0
/* ---------------------------------------------------
 * DEFAULT
 */


#ifdef HW_CODEC_CONFIG_ACCELDEFAULT
/* ---------------------------------------------------
 * default with possible HW accel
 */
#undef ACTIVE_HW_CODEC_CONFIG_NAME
#undef RAPI_HWACCEL_ENC
#undef X264_ENCODE_USED
// --
#define ACTIVE_HW_CODEC_CONFIG_NAME "HW_CODEC_CONFIG_ACCELDEFAULT"
#define RAPI_HWACCEL_ENC 1
/* ---------------------------------------------------
 * default with possible HW accel
 */
#endif


#ifdef HW_CODEC_CONFIG_TRIFA
/* ---------------------------------------------------
 * TRIfA
 */
#undef ACTIVE_HW_CODEC_CONFIG_NAME
#undef H264_WANT_ENCODER_NAME
#undef H264_WANT_DECODER_NAME
#undef X264_ENCODE_USED
#undef RAPI_HWACCEL_ENC
#undef RAPI_HWACCEL_DEC
#undef H264_DECODER_THREADS
#undef H264_DECODER_THREAD_FRAME_ACTIVE
#undef X264_ENCODER_THREADS
#undef X264_ENCODER_SLICES
#undef H264_ENCODER_STARTWITH_PROFILE_HIGH
// --
#define ACTIVE_HW_CODEC_CONFIG_NAME "HW_CODEC_CONFIG_TRIFA"
#define _TRIFA_CODEC_DECODER_ 1
#define H264_WANT_DECODER_NAME "h264_mediacodec"
// #define H264_WANT_DECODER_NAME "h264"
#define X264_ENCODE_USED 1
// #define RAPI_HWACCEL_DEC 1
#define H264_DECODER_THREADS 3
#define H264_DECODER_THREAD_FRAME_ACTIVE 0
#define X264_ENCODER_THREADS 3
#define X264_ENCODER_SLICES 3
#define H264_ENCODER_STARTWITH_PROFILE_HIGH 0
/* ---------------------------------------------------
 * TRIfA
 */
#endif

#ifdef HW_CODEC_CONFIG_RPI3_TBW_BIDI
/* ---------------------------------------------------
 * RPI3 tbw-bidi
 */
#undef ACTIVE_HW_CODEC_CONFIG_NAME
#undef H264_WANT_ENCODER_NAME
#undef H264_WANT_DECODER_NAME
#undef X264_ENCODE_USED
#undef RAPI_HWACCEL_ENC
#undef RAPI_HWACCEL_DEC
#undef H264_DECODER_THREADS
#undef H264_DECODER_THREAD_FRAME_ACTIVE
#undef X264_ENCODER_THREADS
#undef X264_ENCODER_SLICES
#undef H264_ENCODER_STARTWITH_PROFILE_HIGH
// --
#define ACTIVE_HW_CODEC_CONFIG_NAME "HW_CODEC_CONFIG_RPI3_TBW_BIDI"
#define H264_WANT_ENCODER_NAME "h264_omx"
#define H264_WANT_DECODER_NAME "h264_mmal"
#define X264_ENCODE_USED 1
// #define RAPI_HWACCEL_ENC 1
#define RAPI_HWACCEL_DEC 1
#define H264_DECODER_THREADS 0
#define H264_DECODER_THREAD_FRAME_ACTIVE 0
#define X264_ENCODER_THREADS 1
#define X264_ENCODER_SLICES 1
#define H264_ENCODER_STARTWITH_PROFILE_HIGH 1
/* ---------------------------------------------------
 * RPI3 bidi
 */
#endif

#ifdef HW_CODEC_CONFIG_RPI3_TBW_TV
/* ---------------------------------------------------
 * RPI3 tbw-TV
 */
#undef ACTIVE_HW_CODEC_CONFIG_NAME
#undef H264_WANT_ENCODER_NAME
#undef H264_WANT_DECODER_NAME
#undef X264_ENCODE_USED
#undef RAPI_HWACCEL_ENC
#undef RAPI_HWACCEL_DEC
#undef H264_DECODER_THREADS
#undef H264_DECODER_THREAD_FRAME_ACTIVE
#undef X264_ENCODER_THREADS
#undef X264_ENCODER_SLICES
#undef H264_ENCODER_STARTWITH_PROFILE_HIGH
// --
#define ACTIVE_HW_CODEC_CONFIG_NAME "HW_CODEC_CONFIG_RPI3_TBW_TV"
#define H264_WANT_DECODER_NAME "h264_mmal"
//#define H264_WANT_DECODER_NAME "h264"
#define X264_ENCODE_USED 1
#define RAPI_HWACCEL_DEC 1
#define H264_DECODER_THREADS 0
#define H264_DECODER_THREAD_FRAME_ACTIVE 0
#define X264_ENCODER_THREADS 0
#define X264_ENCODER_SLICES 0
#define H264_ENCODER_STARTWITH_PROFILE_HIGH 0
/* ---------------------------------------------------
 * RPI3 tbw-TV
 */
#endif

#ifdef HW_CODEC_CONFIG_UTOX_LINNVENC
/* ---------------------------------------------------
 * UTOX linux
 */
#undef ACTIVE_HW_CODEC_CONFIG_NAME
#undef H264_WANT_ENCODER_NAME
#undef H264_WANT_DECODER_NAME
#undef X264_ENCODE_USED
#undef RAPI_HWACCEL_ENC
#undef RAPI_HWACCEL_DEC
#undef H264_DECODER_THREADS
#undef H264_DECODER_THREAD_FRAME_ACTIVE
#undef X264_ENCODER_THREADS
#undef X264_ENCODER_SLICES
#undef H264_ENCODER_STARTWITH_PROFILE_HIGH
// --
#define ACTIVE_HW_CODEC_CONFIG_NAME "HW_CODEC_CONFIG_UTOX_LINNVENC"
#define H264_WANT_ENCODER_NAME "h264_nvenc"
#define H264_WANT_DECODER_NAME "h264"
// #define X264_ENCODE_USED 1
#define RAPI_HWACCEL_ENC 1
#define H264_DECODER_THREADS 4
#define H264_DECODER_THREAD_FRAME_ACTIVE 0
#define X264_ENCODER_THREADS 4
#define X264_ENCODER_SLICES 4
#define H264_ENCODER_STARTWITH_PROFILE_HIGH 1
/* ---------------------------------------------------
 * UTOX linux
 */
#endif

#ifdef HW_CODEC_CONFIG_TBW_LINNVENC
/* ---------------------------------------------------
 * tbw usb linux
 */
#undef ACTIVE_HW_CODEC_CONFIG_NAME
#undef H264_WANT_ENCODER_NAME
#undef H264_WANT_DECODER_NAME
#undef X264_ENCODE_USED
#undef RAPI_HWACCEL_ENC
#undef RAPI_HWACCEL_DEC
#undef H264_DECODER_THREADS
#undef H264_DECODER_THREAD_FRAME_ACTIVE
#undef X264_ENCODER_THREADS
#undef X264_ENCODER_SLICES
#undef H264_ENCODER_STARTWITH_PROFILE_HIGH
// --
#define ACTIVE_HW_CODEC_CONFIG_NAME "HW_CODEC_CONFIG_TBW_LINNVENC"
#define H264_WANT_ENCODER_NAME "h264_nvenc"
#define H264_WANT_DECODER_NAME "h264" // "h264_cuvid"
// #define X264_ENCODE_USED 1
#define RAPI_HWACCEL_ENC 1
// #define RAPI_HWACCEL_DEC 1
#define H264_DECODER_THREADS 4
#define H264_DECODER_THREAD_FRAME_ACTIVE 0
#define X264_ENCODER_THREADS 4
#define X264_ENCODER_SLICES 4
#define H264_ENCODER_STARTWITH_PROFILE_HIGH 1
/* ---------------------------------------------------
 * tbw usb linux
 */
#endif

#ifdef HW_CODEC_CONFIG_UTOX_WIN7
/* ---------------------------------------------------
 * UTOX win7
 */
#undef ACTIVE_HW_CODEC_CONFIG_NAME
#undef H264_WANT_ENCODER_NAME
#undef H264_WANT_DECODER_NAME
#undef X264_ENCODE_USED
#undef RAPI_HWACCEL_ENC
#undef RAPI_HWACCEL_DEC
#undef H264_DECODER_THREADS
#undef H264_DECODER_THREAD_FRAME_ACTIVE
#undef X264_ENCODER_THREADS
#undef X264_ENCODER_SLICES
#undef H264_ENCODER_STARTWITH_PROFILE_HIGH
// --
#define ACTIVE_HW_CODEC_CONFIG_NAME "HW_CODEC_CONFIG_UTOX_WIN7"
#define H264_WANT_ENCODER_NAME "h264_nvenc"
#define H264_WANT_DECODER_NAME "h264"
// #define X264_ENCODE_USED 1
#define RAPI_HWACCEL_ENC 1
// #define RAPI_HWACCEL_DEC 1
#define H264_DECODER_THREADS 2
#define H264_DECODER_THREAD_FRAME_ACTIVE 1
#define X264_ENCODER_THREADS 6
#define X264_ENCODER_SLICES 6
#define H264_ENCODER_STARTWITH_PROFILE_HIGH 1
/* ---------------------------------------------------
 * UTOX win7
 */
#endif


#ifdef HW_CODEC_CONFIG_UTOX_UB81
/* ---------------------------------------------------
 * UTOX win7
 */
#undef ACTIVE_HW_CODEC_CONFIG_NAME
//#undef H264_WANT_ENCODER_NAME
//#undef H264_WANT_DECODER_NAME
#undef H264_DECODER_THREADS
#undef H264_DECODER_THREAD_FRAME_ACTIVE
#undef X264_ENCODER_THREADS
#undef X264_ENCODER_SLICES
#undef H264_ENCODER_STARTWITH_PROFILE_HIGH
// --
#define ACTIVE_HW_CODEC_CONFIG_NAME "HW_CODEC_CONFIG_UTOX_UB81"
#define H264_DECODER_THREADS 2
#define H264_DECODER_THREAD_FRAME_ACTIVE 1
#define X264_ENCODER_THREADS 6
#define X264_ENCODER_SLICES 6
#define H264_ENCODER_STARTWITH_PROFILE_HIGH 1
/* ---------------------------------------------------
 * UTOX win7
 */
#endif


void my_log_callback(void *ptr, int level, const char *fmt, va_list vargs)
{
    // !!WARNING!! ffmpeg somehow gives back bad strings, calling "strlen" will crash
    //             so no printf type of function will work!!
}

#ifdef X264_ENCODE_USED
#else
static int exists_encoder_codec_by_name(char *codec_name)
{
#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(58, 9, 100)
    avcodec_register_all();
#endif

    AVCodec *codec = NULL;
    codec = avcodec_find_encoder_by_name(codec_name);
    if (codec)
    {
        return 1;
    }

    return 0;
}
#endif

#ifdef X264_ENCODE_USED
#else
static int works_encoder_codec_by_name(char *codec_name)
{
#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(58, 9, 100)
    avcodec_register_all();
#endif

    AVCodec *codec = NULL;
    codec = avcodec_find_encoder_by_name(codec_name);
    if (codec)
    {
        AVCodecContext *avctx = avcodec_alloc_context3(codec);

        // -------- wanted (and also needed settings) --------
        av_opt_set(avctx->priv_data, "profile", "baseline", 0);
        avctx->profile = FF_PROFILE_H264_BASELINE;

        av_opt_set(avctx->priv_data, "annex_b", "1", 0);
        av_opt_set(avctx->priv_data, "repeat_headers", "1", 0);
        av_opt_set_int(avctx->priv_data, "b", 200 * 1000, 0);
        av_opt_set_int(avctx->priv_data, "bitrate", 200 * 1000, 0);

        av_opt_set_int(avctx->priv_data, "cbr", true, 0);
        av_opt_set(avctx->priv_data, "rc", "cbr_ld_hq", 0);
        av_opt_set_int(avctx->priv_data, "delay", 0, 0);

        if (strncmp(codec_name, "h264_nvenc", strlen("h264_nvenc")) == 0)
        {
            // av_opt_set(avctx->priv_data, "preset", "llhq", 0);
            av_opt_set(avctx->priv_data, "preset", "p3", 0);
            av_opt_set(avctx->priv_data, "rc", "cbr", 0);
            av_opt_set(avctx->priv_data, "tune", "ll", 0);
            av_opt_set(avctx->priv_data, "zerolatency", "true", 0);
        }
        else
        {
            av_opt_set(avctx->priv_data, "preset", "ultrafast", 0);
        }

        // HINT: needed for newer 264_nvenc versions
        av_opt_set(avctx->priv_data, "2pass", "false", 0);

        av_opt_set_int(avctx->priv_data, "bf", 0, 0);
        av_opt_set_int(avctx->priv_data, "qmin", 3, 0);
        av_opt_set_int(avctx->priv_data, "qmax", 51, 0);
        av_opt_set(avctx->priv_data, "forced-idr", "false", 0);
        av_opt_set_int(avctx->priv_data, "zerolatency", 1, AV_OPT_SEARCH_CHILDREN);
        av_opt_set(avctx->priv_data, "no-scenecut", "true", 0);
        av_opt_set(avctx->priv_data, "strict_gop", "true", 0);
        avctx->bit_rate = 200 * 1000;
        avctx->width = 1920;
        avctx->height = 1080;
        avctx->gop_size = 60;
        avctx->max_b_frames = 0;
        avctx->pix_fmt = AV_PIX_FMT_YUV420P;
        avctx->time_base.num = 1;
        avctx->time_base.den = 1000;

        avctx->time_base = (AVRational) {
            25, 1000
        };
        avctx->framerate = (AVRational) {
            1000, 25
        };
        // -------- wanted (and also needed settings) --------


        AVDictionary *opts = NULL;
        if (avcodec_open2(avctx, codec, &opts) < 0)
        {
            av_free(avctx);
            return 0;
        }

        av_dict_free(&opts);
        avcodec_free_context(&avctx);

        return 1;
    }

    return 0;
}
#endif

VCSession *vc_new_h264(Logger *log, ToxAV *av, uint32_t friend_number, toxav_video_receive_frame_cb *cb, void *cb_data,
                       VCSession *vc)
{

    // ENCODER -------

    LOGGER_API_WARNING(av->tox, "HW CODEC CONFIG ACTIVE: %s", ACTIVE_HW_CODEC_CONFIG_NAME);

#ifdef X264_ENCODE_USED
    vc->x264_software_encoder_used = 1;
    LOGGER_API_WARNING(av->tox, "x264_software_encoder_used:true:%d", vc->x264_software_encoder_used);
#else
    // ----- detect H264 encoder -----
    vc->x264_software_encoder_used = 0;
    LOGGER_API_WARNING(av->tox, "x264_software_encoder_used:false:%d", vc->x264_software_encoder_used);
    int res_detect = 0;

    res_detect = exists_encoder_codec_by_name("h264_omx");
    LOGGER_API_WARNING(av->tox, "h264_omx:e:%d", res_detect);
    res_detect = works_encoder_codec_by_name("h264_omx");
    LOGGER_API_WARNING(av->tox, "h264_omx:w:%d", res_detect);

    if (res_detect == 1)
    {
        strncpy(vc->encoder_codec_used_name, "h264_omx", strlen("h264_omx"));
        LOGGER_API_WARNING(av->tox, "using_encoder:%s", vc->encoder_codec_used_name);
    }
    else
    {
        res_detect = exists_encoder_codec_by_name("h264_nvenc");
        LOGGER_API_WARNING(av->tox, "h264_nvenc:e:%d", res_detect);
        res_detect = works_encoder_codec_by_name("h264_nvenc");
        LOGGER_API_WARNING(av->tox, "h264_nvenc:w:%d", res_detect);

        if (res_detect == 1)
        {
            strncpy(vc->encoder_codec_used_name, "h264_nvenc", strlen("h264_nvenc"));
            LOGGER_API_WARNING(av->tox, "using_encoder:%s", vc->encoder_codec_used_name);
        }
        else
        {
            res_detect = 0;
            //res_detect = exists_encoder_codec_by_name("h264_vaapi");
            //LOGGER_API_WARNING(av->tox, "h264_vaapi:e:%d", res_detect);
            //res_detect = works_encoder_codec_by_name("h264_vaapi");
            //LOGGER_API_WARNING(av->tox, "h264_vaapi:w:%d", res_detect);

            if (res_detect == 1)
            {
                strncpy(vc->encoder_codec_used_name, "h264_vaapi", strlen("h264_vaapi"));
                LOGGER_API_WARNING(av->tox, "using_encoder:%s", vc->encoder_codec_used_name);
            }
            else
            {
                res_detect = exists_encoder_codec_by_name("libx264");
                LOGGER_API_WARNING(av->tox, "libx264:e:%d", res_detect);
                res_detect = works_encoder_codec_by_name("libx264");
                LOGGER_API_WARNING(av->tox, "libx264:w:%d", res_detect);

                strncpy(vc->encoder_codec_used_name, "libx264", strlen("libx264"));
                LOGGER_API_WARNING(av->tox, "using_fallback_encoder:%s", vc->encoder_codec_used_name);

                vc->x264_software_encoder_used = 1;
            }
        }
    }
    // ----- detect H264 encoder -----
#endif


    if (vc->x264_software_encoder_used == 1)
    {

        LOGGER_API_WARNING(av->tox, "x264_software_encoder_used:02");

        x264_param_t param;

        // "ultrafast", "superfast", "veryfast", "faster", "fast", "medium", "slow", "slower", "veryslow", "placebo"

        if ((int)(H264_ENCODER_STARTWITH_PROFILE_HIGH) == 1) {
            if (x264_param_default_preset(&param, "superfast", "zerolatency,fastdecode") < 0) {
                // goto fail;
            }
        } else {
            if (x264_param_default_preset(&param, "ultrafast", "zerolatency,fastdecode") < 0) {
                // goto fail;
            }
        }

        /* Configure non-default params */
        // param.i_bitdepth = 8;
        param.i_csp = X264_CSP_I420;
        param.i_width  = 1920;
        param.i_height = 1080;
        vc->h264_enc_width = param.i_width;
        vc->h264_enc_height = param.i_height;

        param.i_threads = X264_ENCODER_THREADS;
        param.b_sliced_threads = true;
        param.i_slice_count = X264_ENCODER_SLICES;

        param.b_deterministic = false;
        //#// param.i_sync_lookahead = 0;
        //#// param.i_lookahead_threads = 0;
        param.b_intra_refresh = 16;
        param.rc.i_lookahead = 0;
        // param.b_cabac = 0;
        param.i_bframe = 0;
        // param.b_open_gop = 4;
        param.i_keyint_max = VIDEO_MAX_KF_H264;
        // param.rc.i_rc_method = X264_RC_CRF; // X264_RC_ABR;
        // param.i_nal_hrd = X264_NAL_HRD_CBR;

        //#// param.i_frame_reference = 1;

        param.b_vfr_input = 1; /* VFR input.  If 1, use timebase and timestamps for ratecontrol purposes.
                                * If 0, use fps only. */
        param.i_timebase_num = 1;       // 1 ms = timebase units = (1/1000)s
        param.i_timebase_den = 1000;   // 1 ms = timebase units = (1/1000)s
        param.b_repeat_headers = 1;
        param.b_annexb = 1;

        param.rc.f_rate_tolerance = VIDEO_F_RATE_TOLERANCE_H264;
        param.rc.i_vbv_buffer_size = VIDEO_BITRATE_INITIAL_VALUE_H264 * VIDEO_BUF_FACTOR_H264;
        param.rc.i_vbv_max_bitrate = VIDEO_BITRATE_INITIAL_VALUE_H264 * 1;
        // param.rc.i_bitrate = VIDEO_BITRATE_INITIAL_VALUE_H264 * VIDEO_BITRATE_FACTOR_H264;

        param.rc.i_qp_min = 3;
        param.rc.i_qp_max = 51; // max quantizer for x264

        vc->h264_enc_bitrate = VIDEO_BITRATE_INITIAL_VALUE_H264 * 1000;

        param.rc.b_stat_read = 0;
        param.rc.b_stat_write = 0;

#if MIN_LOGGER_LEVEL >= LOGGER_LEVEL_INFO
        param.i_log_level = X264_LOG_ERROR; // X264_LOG_NONE;
#endif

        /* Apply profile restrictions. */

        if ((int)(H264_ENCODER_STARTWITH_PROFILE_HIGH) == 1) {
            if (x264_param_apply_profile(&param,
                                         "high") < 0) { // "baseline", "main", "high", "high10", "high422", "high444"
                // goto fail;
                LOGGER_API_WARNING(av->tox, "h264: setting high encoder failed");
            } else {
                LOGGER_API_WARNING(av->tox, "h264: setting high encoder OK");
            }
        } else {
            if (x264_param_apply_profile(&param,
                                         "baseline") < 0) { // "baseline", "main", "high", "high10", "high422", "high444"
                // goto fail;
                LOGGER_API_WARNING(av->tox, "h264: setting BASELINE encoder failed");
            } else {
                LOGGER_API_WARNING(av->tox, "h264: setting BASELINE encoder OK");
            }
        }

        if (x264_picture_alloc(&(vc->h264_in_pic), param.i_csp, param.i_width, param.i_height) < 0) {
            // goto fail;
        }

        // vc->h264_in_pic.img.plane[0] --> Y
        // vc->h264_in_pic.img.plane[1] --> U
        // vc->h264_in_pic.img.plane[2] --> V

        vc->h264_encoder = x264_encoder_open(&param);

    }
    else
    {

        LOGGER_API_WARNING(av->tox, "x264_software_encoder_used:03");

        vc->h264_encoder = NULL;

        // ------ ffmpeg encoder --------------------------------------------------------------
        // ------ ffmpeg encoder --------------------------------------------------------------
        // ------ ffmpeg encoder --------------------------------------------------------------
        // ------ ffmpeg encoder --------------------------------------------------------------
        // ------ ffmpeg encoder --------------------------------------------------------------

        AVCodec *codec2 = NULL;
        vc->h264_encoder2 = NULL;


    // https://github.com/FFmpeg/FFmpeg/blob/70d25268c21cbee5f08304da95be1f647c630c15/doc/APIchanges#L86
    // Deprecate use of av_register_all()
#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(58, 9, 100)
        avcodec_register_all();
#endif

        codec2 = NULL;
        codec2 = avcodec_find_encoder_by_name(vc->encoder_codec_used_name); //(H264_WANT_ENCODER_NAME);

        if (!codec2) {
            LOGGER_API_WARNING(av->tox, "codec not found HW Accel H264 on encoder, trying software decoder ...");
            codec2 = avcodec_find_encoder_by_name("libx264");
        } else {
            LOGGER_API_ERROR(av->tox, "FOUND: *HW Accel* H264 encoder: %s", vc->encoder_codec_used_name);
        }

        vc->h264_encoder2 = avcodec_alloc_context3(codec2);

        vc->h264_out_pic2 = av_packet_alloc();

        if ((int)(H264_ENCODER_STARTWITH_PROFILE_HIGH) == 1) {
            av_opt_set(vc->h264_encoder2->priv_data, "profile", "high", 0);
            vc->h264_encoder2->profile               = FF_PROFILE_H264_HIGH; // FF_PROFILE_H264_HIGH;
            // av_opt_set(vc->h264_encoder2->priv_data, "level", "4.0", AV_OPT_SEARCH_CHILDREN);
            // vc->h264_encoder2->level = 40; // 4.0
        } else {
            av_opt_set(vc->h264_encoder2->priv_data, "profile", "baseline", 0);
            vc->h264_encoder2->profile               = FF_PROFILE_H264_BASELINE; // FF_PROFILE_H264_HIGH;
            // av_opt_set(vc->h264_encoder2->priv_data, "level", "4.0", AV_OPT_SEARCH_CHILDREN);
            // vc->h264_encoder2->level = 40; // 4.0
        }

        av_opt_set(vc->h264_encoder2->priv_data, "annex_b", "1", 0);
        av_opt_set(vc->h264_encoder2->priv_data, "repeat_headers", "1", 0);
        // **11** // av_opt_set(vc->h264_encoder2->priv_data, "tune", "zerolatency", 0);
        av_opt_set_int(vc->h264_encoder2->priv_data, "b", VIDEO_BITRATE_INITIAL_VALUE_H264 * 1000, 0);
        av_opt_set_int(vc->h264_encoder2->priv_data, "bitrate", VIDEO_BITRATE_INITIAL_VALUE_H264 * 1000, 0);
        // av_opt_set_int(vc->h264_encoder2->priv_data, "minrate", 100000, 0);
        // av_opt_set_int(vc->h264_encoder2->priv_data, "maxrate", (int)((float)100000 * H264_ENCODE_MAX_BITRATE_OVER_ALLOW), 0);

        av_opt_set_int(vc->h264_encoder2->priv_data, "cbr", true, 0);
        av_opt_set(vc->h264_encoder2->priv_data, "rc", "cbr_ld_hq", 0);
        av_opt_set_int(vc->h264_encoder2->priv_data, "delay", 0, 0);
        // av_opt_set_int(vc->h264_encoder2->priv_data, "rc-lookahead", 0, 0);

        if (strncmp(vc->encoder_codec_used_name, "h264_nvenc", strlen("h264_nvenc")) == 0)
        {
            // av_opt_set(vc->h264_encoder2->priv_data, "preset", "llhq", 0);
            av_opt_set(vc->h264_encoder2->priv_data, "preset", "p3", 0);
            av_opt_set(vc->h264_encoder2->priv_data, "rc", "cbr", 0);
            av_opt_set(vc->h264_encoder2->priv_data, "tune", "ll", 0);
            av_opt_set(vc->h264_encoder2->priv_data, "zerolatency", "true", 0);
        }
        else
        {
            av_opt_set(vc->h264_encoder2->priv_data, "preset", "ultrafast", 0);
        }

        av_opt_set_int(vc->h264_encoder2->priv_data, "bf", 0, 0);
        av_opt_set_int(vc->h264_encoder2->priv_data, "qmin", 3, 0);
        av_opt_set_int(vc->h264_encoder2->priv_data, "qmax", 51, 0);
        av_opt_set(vc->h264_encoder2->priv_data, "forced-idr", "false", 0);
        av_opt_set_int(vc->h264_encoder2->priv_data, "zerolatency", 1, AV_OPT_SEARCH_CHILDREN);
        //y// av_opt_set_int(vc->h264_encoder2->priv_data, "refs", 0, 0);
        av_opt_set(vc->h264_encoder2->priv_data, "no-scenecut", "true", 0);
        av_opt_set(vc->h264_encoder2->priv_data, "strict_gop", "true", 0);

        // HINT: needed for newer 264_nvenc versions
        av_opt_set(vc->h264_encoder2->priv_data, "2pass", "false", 0);

        av_opt_set_int(vc->h264_encoder2->priv_data, "threads", X264_ENCODER_THREADS, 0);

        if (X264_ENCODER_SLICES > 0) {
            av_opt_set(vc->h264_encoder2->priv_data, "sliced_threads", "1", 0);
        } else {
            av_opt_set(vc->h264_encoder2->priv_data, "sliced_threads", "0", 0);
        }

        av_opt_set_int(vc->h264_encoder2->priv_data, "slice_count", X264_ENCODER_SLICES, 0);

        /* put sample parameters */
        vc->h264_encoder2->bit_rate = VIDEO_BITRATE_INITIAL_VALUE_H264 * 1000;
        vc->h264_enc_bitrate = VIDEO_BITRATE_INITIAL_VALUE_H264 * 1000;

        /* resolution must be a multiple of two */
        vc->h264_encoder2->width = 1920;
        vc->h264_encoder2->height = 1080;

        vc->h264_enc_width = vc->h264_encoder2->width;
        vc->h264_enc_height = vc->h264_encoder2->height;

        vc->h264_encoder2->gop_size = VIDEO_MAX_KF_H264;
        // vc->h264_encoder2->keyint_min = VIDEO_MAX_KF_H264;
        vc->h264_encoder2->max_b_frames = 0;
        vc->h264_encoder2->pix_fmt = AV_PIX_FMT_YUV420P;

        vc->h264_encoder2->time_base.num = 1;
        vc->h264_encoder2->time_base.den = 1000;

        // without these it won't work !! ---------------------
        vc->h264_encoder2->time_base = (AVRational) {
            1, 30
        };
        vc->h264_encoder2->framerate = (AVRational) {
            30, 1
        };
        // without these it won't work !! ---------------------

        // vc->h264_encoder2->flags2 |= AV_CODEC_FLAG2_LOCAL_HEADER;
        // vc->h264_encoder2->flags2 |= AV_CODEC_FLAG2_FAST;

        AVDictionary *opts = NULL;

        if (avcodec_open2(vc->h264_encoder2, codec2, &opts) < 0) {
            LOGGER_API_ERROR(av->tox, "could not open codec H264 on encoder");
        }

        av_dict_free(&opts);


        // ------ ffmpeg encoder --------------------------------------------------------------
        // ------ ffmpeg encoder --------------------------------------------------------------
        // ------ ffmpeg encoder --------------------------------------------------------------
        // ------ ffmpeg encoder --------------------------------------------------------------
        // ------ ffmpeg encoder --------------------------------------------------------------

    }



//    goto good;

//fail:
//    vc->h264_encoder = NULL;

//good:

    // ENCODER -------


    // DECODER -------
    AVCodec *codec = NULL;
    vc->h264_decoder = NULL;

// https://github.com/FFmpeg/FFmpeg/blob/70d25268c21cbee5f08304da95be1f647c630c15/doc/APIchanges#L86
// Deprecate use of av_register_all()
#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(58, 9, 100)
    avcodec_register_all();
#endif

    codec = NULL;

#ifdef RAPI_HWACCEL_DEC

    codec = avcodec_find_decoder_by_name(H264_WANT_DECODER_NAME);

    if (!codec) {
        LOGGER_API_WARNING(av->tox, "codec not found HW Accel H264 on decoder, trying software decoder ...");
        codec = avcodec_find_decoder(AV_CODEC_ID_H264);
    } else {
        LOGGER_API_WARNING(av->tox, "FOUND: *HW Accel* H264 on decoder");
    }

#else
    codec = avcodec_find_decoder(AV_CODEC_ID_H264);
#endif


    if (!codec) {
        LOGGER_API_WARNING(av->tox, "codec not found H264 on decoder");
        assert(!"codec not found H264 on decoder");
    }

    vc->h264_decoder = avcodec_alloc_context3(codec);

    if (codec) {
#if LIBAVCODEC_VERSION_MAJOR < 60
        if (codec->capabilities & AV_CODEC_CAP_TRUNCATED) {
            vc->h264_decoder->flags |= AV_CODEC_FLAG_TRUNCATED; /* we do not send complete frames */
        }
#endif
        if (codec->capabilities & AV_CODEC_FLAG_LOW_DELAY) {
            vc->h264_decoder->flags |= AV_CODEC_FLAG_LOW_DELAY;
        }

        // vc->h264_decoder->flags |= AV_CODEC_FLAG_OUTPUT_CORRUPT;

#ifdef AV_CODEC_FLAG2_SHOW_ALL
        vc->h264_decoder->flags |= AV_CODEC_FLAG2_SHOW_ALL;
#else
        LOGGER_API_WARNING(av->tox, "!! AV_CODEC_FLAG2_SHOW_ALL not defined by ffmpeg version !!");
#endif
        // vc->h264_decoder->flags2 |= AV_CODEC_FLAG2_FAST;
        // vc->h264_decoder->flags |= AV_CODEC_FLAG_TRUNCATED;
        // vc->h264_decoder->flags2 |= AV_CODEC_FLAG2_CHUNKS;

        if (H264_DECODER_THREADS > 0) {
            if (codec->capabilities & AV_CODEC_CAP_SLICE_THREADS) {
                vc->h264_decoder->thread_count = H264_DECODER_THREADS;
                vc->h264_decoder->thread_type = FF_THREAD_SLICE;
                vc->h264_decoder->active_thread_type = FF_THREAD_SLICE;
            }

            if (H264_DECODER_THREAD_FRAME_ACTIVE == 1) {
                if (codec->capabilities & AV_CODEC_CAP_FRAME_THREADS) {
                    vc->h264_decoder->thread_count = H264_DECODER_THREADS;
                    vc->h264_decoder->thread_type |= FF_THREAD_FRAME;
                    vc->h264_decoder->active_thread_type |= FF_THREAD_FRAME;
                }
            }
        }

#if (defined (HW_CODEC_CONFIG_RPI3_TBW_TV) || defined (HW_CODEC_CONFIG_RPI3_TBW_BIDI)) && defined (RAPI_HWACCEL_DEC)
        LOGGER_API_WARNING(av->tox, "setting up h264_mmal decoder ...");
        av_opt_set_int(vc->h264_decoder->priv_data, "extra_buffers", 1, AV_OPT_SEARCH_CHILDREN);
        av_opt_set_int(vc->h264_decoder->priv_data, "extra_decoder_buffers", 1, AV_OPT_SEARCH_CHILDREN);
        LOGGER_API_WARNING(av->tox, "extra_buffers, extra_decoder_buffers");
#endif

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(59, 0, 0)
        vc->h264_decoder->refcounted_frames = 0;
#endif
        /*   When AVCodecContext.refcounted_frames is set to 0, the returned
        *             reference belongs to the decoder and is valid only until the
        *             next call to this function or until closing or flushing the
        *             decoder. The caller may not write to it.
        */
#pragma GCC diagnostic pop

        vc->h264_decoder->delay = 0;
        av_opt_set_int(vc->h264_decoder->priv_data, "delay", 0, AV_OPT_SEARCH_CHILDREN);

        vc->h264_decoder->time_base = (AVRational) {
            1, 30
        };
        vc->h264_decoder->framerate = (AVRational) {
            30, 1
        };




#ifdef _TRIFA_CODEC_DECODER_

        LOGGER_API_WARNING(av->tox, "setting up h264_mediacodec decoder ...");


        const uint8_t sps[] = {0x00, 0x00, 0x00, 0x01,      0x67, 0x42, 0xC0, 0x1E, 0xA6, 0x81, 0xE0, 0x51, 0xA1};
        // const uint8_t sps[] = {0x00, 0x00, 0x00, 0x01, 0x67, 0x42, 0x80, 0x0C, 0xE4, 0x40, 0xA0, 0xFD, 0x00, 0xDA, 0x14, 0x26, 0xA0};
        const uint8_t pps[] = {0x00, 0x00, 0x00, 0x01,      0x68, 0xCE, 0x38, 0x80};
        const size_t sps_pps_size = sizeof(sps) + sizeof(pps);

        vc->h264_decoder->extradata = (uint8_t *)av_mallocz(sps_pps_size + AV_INPUT_BUFFER_PADDING_SIZE);
        vc->h264_decoder->extradata_size = sps_pps_size;
        // memset(&vc->h264_decoder->extradata[vc->h264_decoder->extradata_size], 0, AV_INPUT_BUFFER_PADDING_SIZE);
        memcpy(vc->h264_decoder->extradata, sps, sizeof(sps));
        memcpy(vc->h264_decoder->extradata + sizeof(sps), pps, sizeof(pps));


        vc->h264_decoder->codec_type = AVMEDIA_TYPE_VIDEO;
        vc->h264_decoder->codec_id   = AV_CODEC_ID_H264;

        if (codec->capabilities & AV_CODEC_CAP_SLICE_THREADS) {
            vc->h264_decoder->thread_count = 1;
            vc->h264_decoder->thread_type = FF_THREAD_SLICE;
            vc->h264_decoder->active_thread_type = FF_THREAD_SLICE;
        }

        //if (codec->capabilities & AV_CODEC_CAP_FRAME_THREADS) {
        //    vc->h264_decoder->thread_count = 1;
        //    vc->h264_decoder->thread_type |= FF_THREAD_FRAME;
        //    vc->h264_decoder->active_thread_type |= FF_THREAD_FRAME;
        //}

        /*
            vc->h264_decoder->codec_tag  = 0x31637661; // ('1'<<24) + ('c'<<16) + ('v'<<8) + 'a';
            vc->h264_decoder->bit_rate              = 2500 * 1000;
            // codec->bits_per_coded_sample = par->bits_per_coded_sample;
            vc->h264_decoder->bits_per_raw_sample   = 8;
            vc->h264_decoder->profile               = FF_PROFILE_H264_HIGH;
            vc->h264_decoder->level                 = 40;
            vc->h264_decoder->has_b_frames          = 2;
        */


        vc->h264_decoder->pix_fmt                = AV_PIX_FMT_YUV420P;
        vc->h264_decoder->width                  = 480;
        vc->h264_decoder->height                 = 640;

        /*
            codec->field_order            = par->field_order;
            codec->color_range            = par->color_range;
            codec->color_primaries        = par->color_primaries;
            codec->color_trc              = par->color_trc;
            codec->colorspace             = par->color_space;
            codec->chroma_sample_location = par->chroma_location;
            codec->sample_aspect_ratio    = par->sample_aspect_ratio;
            codec->has_b_frames           = par->video_delay;
        */

        LOGGER_API_WARNING(av->tox, "setting up h264_mediacodec decoder ... DONE");

        av_log_set_level(AV_LOG_ERROR);

#endif



        if (avcodec_open2(vc->h264_decoder, codec, NULL) < 0) {
            LOGGER_API_WARNING(av->tox, "could not open codec H264 on decoder");
            assert(!"could not open codec H264 on decoder");
        }

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(59, 0, 0)
        vc->h264_decoder->refcounted_frames = 0;
#endif
#pragma GCC diagnostic pop
        /*   When AVCodecContext.refcounted_frames is set to 0, the returned
        *             reference belongs to the decoder and is valid only until the
        *             next call to this function or until closing or flushing the
        *             decoder. The caller may not write to it.
        */
    }


    // DECODER -------

    return vc;
}

int vc_reconfigure_encoder_h264(Logger *log, VCSession *vc, uint32_t bit_rate,
                                uint16_t width, uint16_t height,
                                int16_t kf_max_dist)
{
    if (!vc) {
        return -1;
    }

    if ((vc->h264_enc_width == width) &&
            (vc->h264_enc_height == height) &&
            (vc->video_rc_max_quantizer == vc->video_rc_max_quantizer_prev) &&
            (vc->video_rc_min_quantizer == vc->video_rc_min_quantizer_prev) &&
            (vc->video_encoder_coded_used == vc->video_encoder_coded_used_prev) &&
            (vc->h264_enc_bitrate != bit_rate) &&
            (kf_max_dist != -2)) {
        // only bit rate changed

        if (vc->h264_encoder) {

            x264_param_t param;
            x264_encoder_parameters(vc->h264_encoder, &param);

            // LOGGER_DEBUG(log, "vc_reconfigure_encoder_h264:vb=%d [bitrate only]", (int)(bit_rate / 1000));

            param.rc.f_rate_tolerance = VIDEO_F_RATE_TOLERANCE_H264;
            param.rc.i_vbv_buffer_size = (bit_rate / 1000) * VIDEO_BUF_FACTOR_H264;
            param.rc.i_vbv_max_bitrate = (bit_rate / 1000) * 1;

            // param.rc.i_bitrate = (bit_rate / 1000) * VIDEO_BITRATE_FACTOR_H264;
            vc->h264_enc_bitrate = bit_rate;

            int res = x264_encoder_reconfig(vc->h264_encoder, &param);
        } else {

            if (vc->x264_software_encoder_used == 0)
            {
                vc->h264_encoder2->bit_rate = bit_rate;
                vc->h264_enc_bitrate = bit_rate;

                av_opt_set_int(vc->h264_encoder2->priv_data, "b", bit_rate, 0);
                av_opt_set_int(vc->h264_encoder2->priv_data, "bitrate", bit_rate, 0);
                // av_opt_set_int(vc->h264_encoder2->priv_data, "minrate", bit_rate, 0);
                // av_opt_set_int(vc->h264_encoder2->priv_data, "maxrate", (int)((float)bit_rate * H264_ENCODE_MAX_BITRATE_OVER_ALLOW), 0);
            }
        }


    } else {
        if ((vc->h264_enc_width != width) ||
                (vc->h264_enc_height != height) ||
                (vc->h264_enc_bitrate != bit_rate) ||
                (vc->video_rc_max_quantizer != vc->video_rc_max_quantizer_prev) ||
                (vc->video_rc_min_quantizer != vc->video_rc_min_quantizer_prev) ||
                (vc->video_encoder_coded_used != vc->video_encoder_coded_used_prev) ||
                (kf_max_dist == -2)
           ) {
            // input image size changed

            if (vc->x264_software_encoder_used == 1) {
                if (vc->h264_encoder) {

                    x264_param_t param;

                    if ((int)(H264_ENCODER_STARTWITH_PROFILE_HIGH) == 1) {
                        if (x264_param_default_preset(&param, "superfast", "zerolatency,fastdecode") < 0) {
                            // goto fail;
                        }
                    } else {
                        if (x264_param_default_preset(&param, "ultrafast", "zerolatency,fastdecode") < 0) {
                            // goto fail;
                        }
                    }

                    /* Configure non-default params */
                    // param.i_bitdepth = 8;
                    param.i_csp = X264_CSP_I420;
                    param.i_width  = width;
                    param.i_height = height;
                    vc->h264_enc_width = param.i_width;
                    vc->h264_enc_height = param.i_height;
                    param.i_threads = X264_ENCODER_THREADS;
                    param.b_sliced_threads = true;
                    param.i_slice_count = X264_ENCODER_SLICES;

                    param.b_deterministic = false;
                    //#// param.i_sync_lookahead = 0;
                    //#// param.i_lookahead_threads = 0;
                    param.b_intra_refresh = 16;
                    param.rc.i_lookahead = 0;
                    // param.b_cabac = 0;
                    param.i_bframe = 0;
                    // param.b_open_gop = 4;
                    param.i_keyint_max = VIDEO_MAX_KF_H264;
                    // param.rc.i_rc_method = X264_RC_ABR;
                    //#// param.i_frame_reference = 1;

                    param.b_vfr_input = 1; /* VFR input.  If 1, use timebase and timestamps for ratecontrol purposes.
                                * If 0, use fps only. */
                    param.i_timebase_num = 1;       // 1 ms = timebase units = (1/1000)s
                    param.i_timebase_den = 1000;   // 1 ms = timebase units = (1/1000)s
                    param.b_repeat_headers = 1;
                    param.b_annexb = 1;

                    // LOGGER_ERROR(log, "vc_reconfigure_encoder_h264:vb=%d", (int)(bit_rate / 1000));

                    param.rc.f_rate_tolerance = VIDEO_F_RATE_TOLERANCE_H264;
                    param.rc.i_vbv_buffer_size = (bit_rate / 1000) * VIDEO_BUF_FACTOR_H264;
                    param.rc.i_vbv_max_bitrate = (bit_rate / 1000) * 1;

                    if ((vc->video_rc_min_quantizer >= 0) &&
                            (vc->video_rc_min_quantizer < vc->video_rc_max_quantizer) &&
                            (vc->video_rc_min_quantizer < 51)) {
                        param.rc.i_qp_min = vc->video_rc_min_quantizer;
                    }

                    if ((vc->video_rc_max_quantizer >= 0) &&
                            (vc->video_rc_min_quantizer < vc->video_rc_max_quantizer) &&
                            (vc->video_rc_max_quantizer < 51)) {
                        param.rc.i_qp_max = vc->video_rc_max_quantizer;
                    }

                    // param.rc.i_bitrate = (bit_rate / 1000) * VIDEO_BITRATE_FACTOR_H264;
                    vc->h264_enc_bitrate = bit_rate;

                    param.rc.b_stat_read = 0;
                    param.rc.b_stat_write = 0;

#if MIN_LOGGER_LEVEL >= LOGGER_LEVEL_INFO
                    param.i_log_level = X264_LOG_ERROR; // X264_LOG_NONE;
#endif

                    /* Apply profile restrictions. */
                    if ((int)(H264_ENCODER_STARTWITH_PROFILE_HIGH) == 1) {
                        if (x264_param_apply_profile(&param,
                                                     "high") < 0) { // "baseline", "main", "high", "high10", "high422", "high444"
                            // goto fail;
                            // LOGGER_WARNING(log, "h264: setting high encoder failed (2)");
                        } else {
                            // LOGGER_WARNING(log, "h264: setting high encoder OK (2)");
                        }
                    } else {
                        if (x264_param_apply_profile(&param,
                                                     "baseline") < 0) { // "baseline", "main", "high", "high10", "high422", "high444"
                            // goto fail;
                            // LOGGER_WARNING(log, "h264: setting BASELINE encoder failed (2)");
                        } else {
                            // LOGGER_WARNING(log, "h264: setting BASELINE encoder OK (2)");
                        }
                    }

                    // LOGGER_ERROR(log, "H264: reconfigure encoder:001: w:%d h:%d w_new:%d h_new:%d BR:%d\n",
                    //              vc->h264_enc_width,
                    //              vc->h264_enc_height,
                    //              width,
                    //              height,
                    //              (int)bit_rate);

                    // free old stuff ---------
                    x264_encoder_close(vc->h264_encoder);
                    x264_picture_clean(&(vc->h264_in_pic));
                    // free old stuff ---------

                    // alloc with new values -------
                    if (x264_picture_alloc(&(vc->h264_in_pic), param.i_csp, param.i_width, param.i_height) < 0) {
                        // goto fail;
                    }

                    vc->h264_encoder = x264_encoder_open(&param);
                    // alloc with new values -------

                    vc->video_rc_max_quantizer_prev = vc->video_rc_max_quantizer;
                    vc->video_rc_min_quantizer_prev = vc->video_rc_min_quantizer;

                }

            } else {

                // --- ffmpeg encoder ---
                avcodec_free_context(&vc->h264_encoder2);


                AVCodec *codec2 = NULL;
                vc->h264_encoder2 = NULL;

// https://github.com/FFmpeg/FFmpeg/blob/70d25268c21cbee5f08304da95be1f647c630c15/doc/APIchanges#L86
// Deprecate use of av_register_all()
#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(58, 9, 100)
                avcodec_register_all();
#endif

                codec2 = NULL;
                codec2 = avcodec_find_encoder_by_name(vc->encoder_codec_used_name); //(H264_WANT_ENCODER_NAME);

                if (!codec2) {
                    // LOGGER_WARNING(log, "codec not found HW Accel H264 on encoder, trying software decoder ...");
                    codec2 = avcodec_find_encoder_by_name("libx264");
                } else {
                    // LOGGER_ERROR(log, "FOUND: *HW Accel* H264 encoder: %s", vc->encoder_codec_used_name);
                }

                vc->h264_encoder2 = avcodec_alloc_context3(codec2);

                if ((int)(H264_ENCODER_STARTWITH_PROFILE_HIGH) == 1) {
                    av_opt_set(vc->h264_encoder2->priv_data, "profile", "high", 0);
                    vc->h264_encoder2->profile               = FF_PROFILE_H264_HIGH; // FF_PROFILE_H264_HIGH;
                    // av_opt_set(vc->h264_encoder2->priv_data, "level", "4.0", AV_OPT_SEARCH_CHILDREN);
                    // vc->h264_encoder2->level = 40; // 4.0
                    // LOGGER_WARNING(log, "switching H264 encoder profile ... HIGH");

                } else {
                    av_opt_set(vc->h264_encoder2->priv_data, "profile", "baseline", 0);
                    vc->h264_encoder2->profile               = FF_PROFILE_H264_BASELINE; // FF_PROFILE_H264_HIGH;
                    // av_opt_set(vc->h264_encoder2->priv_data, "level", "4.0", AV_OPT_SEARCH_CHILDREN);
                    // vc->h264_encoder2->level = 40; // 4.0
                    // LOGGER_WARNING(log, "switching H264 encoder profile ... baseline");
                }

                av_opt_set(vc->h264_encoder2->priv_data, "annex_b", "1", 0);
                av_opt_set(vc->h264_encoder2->priv_data, "repeat_headers", "1", 0);
                // **11** // av_opt_set(vc->h264_encoder2->priv_data, "tune", "zerolatency", 0);
                av_opt_set_int(vc->h264_encoder2->priv_data, "b", bit_rate, 0);
                av_opt_set_int(vc->h264_encoder2->priv_data, "bitrate", bit_rate, 0);
                // av_opt_set_int(vc->h264_encoder2->priv_data, "minrate", bit_rate, 0);
                // av_opt_set_int(vc->h264_encoder2->priv_data, "maxrate", (int)((float)bit_rate * H264_ENCODE_MAX_BITRATE_OVER_ALLOW), 0);

                av_opt_set_int(vc->h264_encoder2->priv_data, "cbr", true, 0);
                av_opt_set(vc->h264_encoder2->priv_data, "rc", "cbr_ld_hq", 0);
                av_opt_set_int(vc->h264_encoder2->priv_data, "delay", 0, 0);
                // av_opt_set_int(vc->h264_encoder2->priv_data, "rc-lookahead", 0, 0);

                if (strncmp(vc->encoder_codec_used_name, "h264_nvenc", strlen("h264_nvenc")) == 0)
                {
                    // av_opt_set(vc->h264_encoder2->priv_data, "preset", "llhq", 0);
                    av_opt_set(vc->h264_encoder2->priv_data, "preset", "p3", 0);
                    av_opt_set(vc->h264_encoder2->priv_data, "rc", "cbr", 0);
                    av_opt_set(vc->h264_encoder2->priv_data, "tune", "ll", 0);
                    av_opt_set(vc->h264_encoder2->priv_data, "zerolatency", "true", 0);
                }
                else
                {
                    av_opt_set(vc->h264_encoder2->priv_data, "preset", "ultrafast", 0);
                }

                av_opt_set_int(vc->h264_encoder2->priv_data, "bf", 0, 0);
                av_opt_set_int(vc->h264_encoder2->priv_data, "qmin", 3, 0);
                av_opt_set_int(vc->h264_encoder2->priv_data, "qmax", 51, 0);
                av_opt_set(vc->h264_encoder2->priv_data, "forced-idr", "false", 0);
                av_opt_set_int(vc->h264_encoder2->priv_data, "zerolatency", 1, AV_OPT_SEARCH_CHILDREN);
                //y// av_opt_set_int(vc->h264_encoder2->priv_data, "refs", 1, 0);
                av_opt_set(vc->h264_encoder2->priv_data, "no-scenecut", "true", 0);
                av_opt_set(vc->h264_encoder2->priv_data, "strict_gop", "true", 0);

                // HINT: needed for newer 264_nvenc versions
                av_opt_set(vc->h264_encoder2->priv_data, "2pass", "false", 0);

                av_opt_set_int(vc->h264_encoder2->priv_data, "threads", X264_ENCODER_THREADS, 0);

                if (X264_ENCODER_SLICES > 0) {
                    av_opt_set(vc->h264_encoder2->priv_data, "sliced_threads", "1", 0);
                } else {
                    av_opt_set(vc->h264_encoder2->priv_data, "sliced_threads", "0", 0);
                }

                av_opt_set_int(vc->h264_encoder2->priv_data, "slice_count", X264_ENCODER_SLICES, 0);

                /* put sample parameters */
                vc->h264_encoder2->bit_rate = bit_rate;
                vc->h264_enc_bitrate = bit_rate;

                /* resolution must be a multiple of two */
                vc->h264_encoder2->width = width;
                vc->h264_encoder2->height = height;

                vc->h264_enc_width = vc->h264_encoder2->width;
                vc->h264_enc_height = vc->h264_encoder2->height;

                vc->h264_encoder2->gop_size = VIDEO_MAX_KF_H264;
                // vc->h264_encoder2->keyint_min = VIDEO_MAX_KF_H264;
                vc->h264_encoder2->max_b_frames = 0;
                vc->h264_encoder2->pix_fmt = AV_PIX_FMT_YUV420P;

                vc->h264_encoder2->time_base.num = 1;
                vc->h264_encoder2->time_base.den = 1000;

                // without these it won't work !! ---------------------
                vc->h264_encoder2->time_base = (AVRational) {
                    1, 30
                };
                vc->h264_encoder2->framerate = (AVRational) {
                    30, 1
                };
                // without these it won't work !! ---------------------

                /*
                av_opt_get(pCodecCtx->priv_data,"preset",0,(uint8_t **)&val_str);
                        printf("preset val: %s\n",val_str);
                        av_opt_get(pCodecCtx->priv_data,"tune",0,(uint8_t **)&val_str);
                        printf("tune val: %s\n",val_str);
                        av_opt_get(pCodecCtx->priv_data,"profile",0,(uint8_t **)&val_str);
                        printf("profile val: %s\n",val_str);
                av_free(val_str);
                */

                // vc->h264_encoder2->flags2 |= AV_CODEC_FLAG2_LOCAL_HEADER;
                // vc->h264_encoder2->flags2 |= AV_CODEC_FLAG2_FAST;

                AVDictionary *opts = NULL;

                if (avcodec_open2(vc->h264_encoder2, codec2, NULL) < 0) {
                    // LOGGER_ERROR(log, "could not open codec H264 on encoder");
                }

                av_dict_free(&opts);

                // --- ffmpeg encoder ---
            }
        }
    }

    return 0;
}

void get_info_from_sps(const Tox *tox, VCSession *vc, const Logger *log,
                       const uint8_t data[], const uint32_t data_len)
{

    if (data_len > 7) {
        // LOGGER_DEBUG(log, "SPS:len=%d bytes:%d %d %d %d %d %d %d %d", data_len, data[0], data[1], data[2], data[3], data[4],
        //              data[5], data[6], data[7]);

        if (
            (data[0] == 0x00)
            &&
            (data[1] == 0x00)
            &&
            (data[2] == 0x00)
            &&
            (data[3] == 0x01)
            &&
            ((data[4] & 0x1F) == 7) // only the lower 5bits of the 4th byte denote the NAL type
            // 7 --> SPS
            // 8 --> PPS
            // (data[4] == 0x67)
        ) {
            // parse only every 5 seconds
            if ((vc->last_parsed_h264_sps_ts + 5000) < current_time_monotonic(vc->av->toxav_mono_time)) {
                vc->last_parsed_h264_sps_ts = current_time_monotonic(vc->av->toxav_mono_time);

                // we found a NAL unit containing the SPS
                uint8_t h264_profile = data[5];
                uint8_t h264_constraint_set0_flag = ((data[6] >> 3)  & 0x01);
                uint8_t h264_constraint_set3_flag = (data[6]  & 0x01);
                uint8_t h264_level = data[7];

                if ((h264_profile == 66) && (h264_constraint_set3_flag = 0)) {
                    // LOGGER_DEBUG(log, "profile=%s level=%d", "baseline", h264_level);
                    vc->parsed_h264_sps_profile_i = h264_profile;
                } else if ((h264_profile == 66) && (h264_constraint_set3_flag = 1)) {
                    // LOGGER_DEBUG(log, "profile=%s level=%d", "contrained baseline", h264_level);
                    vc->parsed_h264_sps_profile_i = h264_profile;
                } else if ((h264_profile == 77) && (h264_constraint_set0_flag = 0)) {
                    // LOGGER_DEBUG(log, "profile=%s level=%d", "main", h264_level);
                    vc->parsed_h264_sps_profile_i = h264_profile;
                } else if ((h264_profile == 77) && (h264_constraint_set0_flag = 1)) {
                    // LOGGER_DEBUG(log, "profile=%s level=%d", "extended", h264_level);
                    vc->parsed_h264_sps_profile_i = h264_profile;
                } else if (h264_profile == 100) {
                    // LOGGER_DEBUG(log, "profile=%s level=%d", "high", h264_level);
                    vc->parsed_h264_sps_profile_i = h264_profile;
                } else if (h264_profile == 110) {
                    // LOGGER_DEBUG(log, "profile=%s level=%d", "high10", h264_level);
                    vc->parsed_h264_sps_profile_i = h264_profile;
                } else if (h264_profile == 122) {
                    // LOGGER_DEBUG(log, "profile=%s level=%d", "high422", h264_level);
                    vc->parsed_h264_sps_profile_i = h264_profile;
                } else if (h264_profile == 244) {
                    // LOGGER_DEBUG(log, "profile=%s level=%d", "high444", h264_level);
                    vc->parsed_h264_sps_profile_i = h264_profile;
                } else {
                    // LOGGER_DEBUG(log, "profile=%s level=%d", "unkwn", h264_level);
                    vc->parsed_h264_sps_profile_i = 0;
                }

                vc->parsed_h264_sps_level_i = h264_level;
            }
        }
    }
}

//static int32_t global_first_video_frame_data = 0;
//static int32_t global_decoder_delay_counter = 0;

void decode_frame_h264(VCSession *vc, Tox *tox, uint8_t skip_video_flag, uint64_t *a_r_timestamp,
                       uint64_t *a_l_timestamp,
                       uint64_t *v_r_timestamp, uint64_t *v_l_timestamp,
                       const struct RTPHeader *header_v3,
                       struct RTPMessage *p, vpx_codec_err_t rc,
                       uint32_t full_data_len,
                       uint8_t *ret_value)
{

    LOGGER_API_DEBUG(vc->av->tox, "decode_frame_h264:fnum=%d,len=%d", vc->friend_number, full_data_len);

    if (p == NULL) {
        LOGGER_API_DEBUG(vc->av->tox, "decode_frame_h264:NO data");
        return;
    }

    if (full_data_len < 1) {
        LOGGER_API_DEBUG(vc->av->tox, "decode_frame_h264:not enough data");
        free(p);
        p = NULL;
        return;
    }

    if (vc->h264_decoder == NULL) {
        LOGGER_API_DEBUG(vc->av->tox, "vc->h264_decoder:not ready");
        free(p);
        p = NULL;
        return;
    }


    if (vc->vcb_h264 != NULL) {
        // call callback function to give H264 buffer directly to the client
        vc->vcb_h264(vc->av, vc->friend_number, p->data, full_data_len, vc->vcb_h264_user_data);

        free(p);
        p = NULL;
        return;
    }

    if (vc->global_decode_first_frame_got == 0)
    {
        if (vc->global_decode_first_frame_delayed_by == 0)
        {
            vc->global_decode_first_frame_delayed_ms = current_time_monotonic(vc->av->toxav_mono_time);
        }
        vc->global_decode_first_frame_delayed_by++;
    }

    if (p) {
        get_info_from_sps(tox, vc, vc->log, p->data, full_data_len);
    }

    /*
     For decoding, call avcodec_send_packet() to give the decoder raw
          compressed data in an AVPacket.


          For decoding, call avcodec_receive_frame(). On success, it will return
          an AVFrame containing uncompressed audio or video data.


     *   Repeat this call until it returns AVERROR(EAGAIN) or an error. The
     *   AVERROR(EAGAIN) return value means that new input data is required to
     *   return new output. In this case, continue with sending input. For each
     *   input frame/packet, the codec will typically return 1 output frame/packet,
     *   but it can also be 0 or more than 1.

     */

    AVPacket *compr_data = NULL;
    compr_data = av_packet_alloc();

    if (compr_data == NULL) {
        LOGGER_API_DEBUG(vc->av->tox, "av_packet_alloc:ERROR");
        free(p);
        p = NULL;
        return;
    }

    uint64_t h_frame_record_timestamp = header_v3->frame_record_timestamp;

#if 0
    compr_data->pts = AV_NOPTS_VALUE;
    compr_data->dts = AV_NOPTS_VALUE;

    compr_data->duration = 0;
    compr_data->post = -1;
#endif

    compr_data->data = p->data;
    compr_data->size = (int)full_data_len; // hmm, "int" again

    if (header_v3->frame_record_timestamp > 0) {
        LOGGER_API_DEBUG(vc->av->tox, "in_pts:%lu", header_v3->frame_record_timestamp);
        compr_data->dts = (int64_t)(header_v3->frame_record_timestamp) - 1;
        compr_data->pts = (int64_t)(header_v3->frame_record_timestamp);
        compr_data->duration = 0; // (int64_t)(header_v3->frame_record_timestamp) + 1; // 0;
    }

    /* ------------------------------------------------------- */
    /* ------------------------------------------------------- */
    /* HINT: this is the only part that takes all the time !!! */
    /* HINT: this is the only part that takes all the time !!! */
    /* HINT: this is the only part that takes all the time !!! */


    /* ------------------------------------------------------- */
    /* ------------------------------------------------------- */
    // The input buffer, avpkt->data must be AV_INPUT_BUFFER_PADDING_SIZE larger than the actual
    // read bytes because some optimized bitstream readers read 32 or 64 bits at once and
    // could read over the end.
    /* ------------------------------------------------------- */
    /* ------------------------------------------------------- */

    int result_send_packet = avcodec_send_packet(vc->h264_decoder, compr_data);

    if (result_send_packet != 0) {
        LOGGER_API_DEBUG(vc->av->tox, "avcodec_send_packet:ERROR=%d", result_send_packet);
        av_packet_free(&compr_data);
        free(p);
        p = NULL;
        return;
    }

    /* HINT: this is the only part that takes all the time !!! */
    /* HINT: this is the only part that takes all the time !!! */
    /* HINT: this is the only part that takes all the time !!! */
    /* ------------------------------------------------------- */
    /* ------------------------------------------------------- */


    int ret_ = 0;

    while (ret_ >= 0) {

        // start_time_ms = current_time_monotonic(vc->av->toxav_mono_time);
        AVFrame *frame = av_frame_alloc();

        if (frame == NULL) {
            // stop decoding
            break;
        }

        ret_ = avcodec_receive_frame(vc->h264_decoder, frame);

        if (ret_ == AVERROR(EAGAIN) || ret_ == AVERROR_EOF) {
            // error
            av_frame_free(&frame);
            break;
        } else if (ret_ < 0) {
            // Error during decoding
            av_frame_free(&frame);
            break;
        } else if (ret_ == 0) {

            /*
                pkt_pts
                PTS copied from the AVPacket that was decoded to produce this frame.

                pkt_dts
                DTS copied from the AVPacket that triggered returning this frame.
            */

        if (vc->global_decode_first_frame_got == 0)
        {
            vc->global_decode_first_frame_got = 1;
            vc->global_decode_first_frame_delayed_ms =
                current_time_monotonic(vc->av->toxav_mono_time) - vc->global_decode_first_frame_delayed_ms;
            LOGGER_API_DEBUG(vc->av->tox, "X264 decoder delay: %d f, %d ms",
                    (vc->global_decode_first_frame_delayed_by - 1),
                    (int)vc->global_decode_first_frame_delayed_ms);
        }


            // calculate the real play delay (from toxcore-in to toxcore-out)
            // this seems to give incorrect values :-(
            if (header_v3->frame_record_timestamp > 0) {

                /*

                MMAL H264 Decoder - problem ?
                =============================

                 fps    ms delay    ms between frames   frames cached
                ---------------------------------------------------------
                 10     450         100                 ~4.5
                 20     230         50                  ~4.6
                 25     190         40                  ~4.75

                */

                // give back h264 decoder delay value to vc_iterate()

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#if LIBAVCODEC_VERSION_INT > AV_VERSION_INT(59, 0, 0)
                int32_t delta_value = (int32_t)(h_frame_record_timestamp - frame->pts);
#else
                int32_t delta_value = (int32_t)(h_frame_record_timestamp - frame->pkt_pts);
#endif

#if LIBAVCODEC_VERSION_INT > AV_VERSION_INT(59, 0, 0)
                LOGGER_API_DEBUG(vc->av->tox, "out_pts:%lu %lu %ld %ld",
                        frame->pts, frame->pkt_dts, frame->best_effort_timestamp, frame->pkt_pos);
#endif

                LOGGER_API_DEBUG(vc->av->tox, "dec:XX:03:%d %d %d %d %d",
                        delta_value,
                        (int)h_frame_record_timestamp,

#if LIBAVCODEC_VERSION_INT > AV_VERSION_INT(59, 0, 0)
                        (int)frame->pts,
#else
                        (int)frame->pkt_pts,
#endif

                        (int)frame->pkt_dts,
                        (int)frame->pts);
#pragma GCC diagnostic pop

                if ((delta_value >= 0) && (delta_value <= 1000))
                {
                    vc->video_decoder_caused_delay_ms = delta_value;
                    LOGGER_API_DEBUG(vc->av->tox, "dec:1:delta_value=%d", vc->video_decoder_caused_delay_ms);
                }
                else if (delta_value == -1)
                {
                    // since we do NOT have any idea how long the decoder delays frames,
                    // and the decoder will lie to us, we just assume some random value
                    // that works for our use cases (decoding on andriod via MediaCodec)
                    vc->video_decoder_caused_delay_ms = 1;
                    LOGGER_API_DEBUG(vc->av->tox, "dec:2:delta_value=%d", vc->video_decoder_caused_delay_ms);
                }

                // calc mean value
                vc->video_decoder_caused_delay_ms_array[vc->video_decoder_caused_delay_ms_array_index] = vc->video_decoder_caused_delay_ms;
                vc->video_decoder_caused_delay_ms_array_index = (vc->video_decoder_caused_delay_ms_array_index + 1) %
                        VIDEO_DECODER_CAUSED_DELAY_MS_ENTRIES;

                uint32_t mean_value = 0;

                for (int k = 0; k < VIDEO_DECODER_CAUSED_DELAY_MS_ENTRIES; k++) {
                    mean_value = mean_value + vc->video_decoder_caused_delay_ms_array[k];
                }

                if (mean_value == 0) {
                    vc->video_decoder_caused_delay_ms_mean_value = 0;
                } else {
                    vc->video_decoder_caused_delay_ms_mean_value = (mean_value * 10) / (VIDEO_DECODER_CAUSED_DELAY_MS_ENTRIES * 10);
                }

                LOGGER_API_DEBUG(vc->av->tox, "dec:video_decoder_caused_delay_ms_mean_value=%d",
                        vc->video_decoder_caused_delay_ms_mean_value);

            }

            // start_time_ms = current_time_monotonic(vc->av->toxav_mono_time);
            if ((frame->data[0] != NULL) && (frame->data[1] != NULL) && (frame->data[2] != NULL)) {

// -------- DEBUG:AUDIO/VIDEO DELAY/LATENCY --------
// -------- DEBUG:AUDIO/VIDEO DELAY/LATENCY --------
// -------- DEBUG:AUDIO/VIDEO DELAY/LATENCY --------
                *v_r_timestamp = h_frame_record_timestamp;
                *v_l_timestamp = current_time_monotonic(vc->av->toxav_mono_time);
// -------- DEBUG:AUDIO/VIDEO DELAY/LATENCY --------
// -------- DEBUG:AUDIO/VIDEO DELAY/LATENCY --------
// -------- DEBUG:AUDIO/VIDEO DELAY/LATENCY --------

                if (vc->vcb_pts)
                {
                    uint64_t pts_for_client = h_frame_record_timestamp;
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if LIBAVCODEC_VERSION_INT > AV_VERSION_INT(59, 0, 0)
                    int32_t delta_check = (int32_t)(h_frame_record_timestamp - frame->pts);
#else
                    int32_t delta_check = (int32_t)(h_frame_record_timestamp - frame->pkt_pts);
#endif

                    if ((delta_check >= 0) && (delta_check <= 600))
                    {

#if LIBAVCODEC_VERSION_INT > AV_VERSION_INT(59, 0, 0)
                        pts_for_client = frame->pts;
#else
                        pts_for_client = frame->pkt_pts;
#endif
                    }
#pragma GCC diagnostic pop

                    LOGGER_API_DEBUG(vc->av->tox, "DDDDDDDDDD:%lu", pts_for_client);
                    vc->vcb_pts(vc->av, vc->friend_number, frame->width, frame->height,
                            (const uint8_t *)frame->data[0],
                            (const uint8_t *)frame->data[1],
                            (const uint8_t *)frame->data[2],
                            frame->linesize[0], frame->linesize[1],
                            frame->linesize[2], vc->vcb_pts_user_data,
                            pts_for_client);
                }
                else
                {
                    vc->vcb(vc->av, vc->friend_number, frame->width, frame->height,
                            (const uint8_t *)frame->data[0],
                            (const uint8_t *)frame->data[1],
                            (const uint8_t *)frame->data[2],
                            frame->linesize[0], frame->linesize[1],
                            frame->linesize[2], vc->vcb_user_data);
                }
            }

        } else {
            // some other error
        }

        av_frame_free(&frame);
    }

    av_packet_free(&compr_data);
    free(p);
}

uint32_t encode_frame_h264(ToxAV *av, uint32_t friend_number, uint16_t width, uint16_t height,
                           const uint8_t *y,
                           const uint8_t *u, const uint8_t *v, ToxAVCall *call,
                           uint64_t *video_frame_record_timestamp,
                           int vpx_encode_flags,
                           x264_nal_t **nal,
                           int *i_frame_size)
{

    if (call->video->x264_software_encoder_used == 1) {

        memcpy(call->video->h264_in_pic.img.plane[0], y, width * height);
        memcpy(call->video->h264_in_pic.img.plane[1], u, (width / 2) * (height / 2));
        memcpy(call->video->h264_in_pic.img.plane[2], v, (width / 2) * (height / 2));

        int i_nal;

        call->video->h264_in_pic.i_pts = (int64_t)(*video_frame_record_timestamp);
        LOGGER_API_DEBUG(av->tox, "X264:in_ts:%lu", (*video_frame_record_timestamp));

        if ((vpx_encode_flags & VPX_EFLAG_FORCE_KF) > 0) {
            call->video->h264_in_pic.i_type = X264_TYPE_IDR; // real full i-frame
            call->video->last_sent_keyframe_ts = current_time_monotonic(av->toxav_mono_time);
        } else {
            call->video->h264_in_pic.i_type = X264_TYPE_AUTO;
        }

        LOGGER_API_DEBUG(av->tox, "X264 IN frame type=%d", (int)call->video->h264_in_pic.i_type);

        *i_frame_size = x264_encoder_encode(call->video->h264_encoder,
                                            nal,
                                            &i_nal,
                                            &(call->video->h264_in_pic),
                                            &(call->video->h264_out_pic));


        *video_frame_record_timestamp = (uint64_t)call->video->h264_out_pic.i_pts;
        LOGGER_API_DEBUG(av->tox, "X264:out_ts:%lu", (*video_frame_record_timestamp));




        if (IS_X264_TYPE_I(call->video->h264_out_pic.i_type)) {
            LOGGER_API_DEBUG(av->tox, "X264 out frame type=%d", (int)call->video->h264_out_pic.i_type);
        }


        if (*i_frame_size < 0) {
            // some error
        } else if (*i_frame_size == 0) {
            // zero size output
        }

        if (*nal == NULL) {
            return 1;
        }

        if ((*nal)->p_payload == NULL) {
            return 1;
        }

        return 0;

    } else {

        AVFrame *frame;
        int ret;
        uint32_t result = 1;

        frame = av_frame_alloc();

        frame->format = call->video->h264_encoder2->pix_fmt;
        frame->width  = width;
        frame->height = height;

        ret = av_frame_get_buffer(frame, 32);

        if (ret < 0) {
            LOGGER_API_ERROR(av->tox, "av_frame_get_buffer:Could not allocate the video frame data");
        }

        /* make sure the frame data is writable */
        ret = av_frame_make_writable(frame);

        if (ret < 0) {
            LOGGER_API_ERROR(av->tox, "av_frame_make_writable:ERROR");
        }

        LOGGER_API_DEBUG(av->tox, "video packet record time[ECN:4a]: %d mtime=%d", (int)(*video_frame_record_timestamp),
                     (int)current_time_monotonic(av->toxav_mono_time));
        frame->pts = (int64_t)(*video_frame_record_timestamp);

        // copy YUV frame data into buffers
        memcpy(frame->data[0], y, width * height);
        memcpy(frame->data[1], u, (width / 2) * (height / 2));
        memcpy(frame->data[2], v, (width / 2) * (height / 2));

        // encode the frame
        ret = avcodec_send_frame(call->video->h264_encoder2, frame);

        if (ret < 0) {
            LOGGER_API_ERROR(av->tox, "Error sending a frame for encoding:ERROR");
        }

        ret = avcodec_receive_packet(call->video->h264_encoder2, call->video->h264_out_pic2);

        if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF) {
            *i_frame_size = 0;
        } else if (ret < 0) {
            *i_frame_size = 0;
            // Error during encoding
        } else {

            LOGGER_API_DEBUG(av->tox, "video packet record time[ECN:4b]: %d mtime=%d", (int)(*video_frame_record_timestamp),
                         (int)current_time_monotonic(av->toxav_mono_time));
            *video_frame_record_timestamp = (uint64_t)call->video->h264_out_pic2->pts;
            LOGGER_API_DEBUG(av->tox, "video packet record time[ECN:4c]: %d mtime=%d", (int)(*video_frame_record_timestamp),
                         (int)current_time_monotonic(av->toxav_mono_time));

            *i_frame_size = call->video->h264_out_pic2->size;

            result = 0;
        }

        av_frame_free(&frame);

        return result;

    }

}

uint32_t send_frames_h264(ToxAV *av, uint32_t friend_number, uint16_t width, uint16_t height,
                          const uint8_t *y,
                          const uint8_t *u, const uint8_t *v, ToxAVCall *call,
                          uint64_t *video_frame_record_timestamp,
                          int vpx_encode_flags,
                          x264_nal_t **nal,
                          int *i_frame_size,
                          TOXAV_ERR_SEND_FRAME *rc)
{

    if (call->video->x264_software_encoder_used == 1) {
        if (*i_frame_size > 0) {

            LOGGER_API_DEBUG(av->tox, "X264:send_ts:%lu", (*video_frame_record_timestamp));
            const uint32_t frame_length_in_bytes = *i_frame_size;
            const int keyframe = (int)call->video->h264_out_pic.b_keyframe;

            int res = rtp_send_data
                      (
                          call->video_rtp,
                          (const uint8_t *)((*nal)->p_payload),
                          frame_length_in_bytes,
                          keyframe,
                          *video_frame_record_timestamp,
                          (int32_t)0,
                          TOXAV_ENCODER_CODEC_USED_H264,
                          call->video_bit_rate,
                          call->video->client_video_capture_delay_ms,
                          call->video->video_encoder_frame_orientation_angle,
                          nullptr
                      );

            (*video_frame_record_timestamp)++;

            if (res < 0) {
                LOGGER_API_WARNING(av->tox, "Could not send video frame: %s", strerror(errno));
                *rc = TOXAV_ERR_SEND_FRAME_RTP_FAILED;
                return 1;
            }

            return 0;
        } else {
            *rc = TOXAV_ERR_SEND_FRAME_RTP_FAILED;
            return 1;
        }

    } else {

        if (*i_frame_size > 0) {

            LOGGER_API_DEBUG(av->tox, "video packet record time[1b]: %d mtime=%d", (int)(*video_frame_record_timestamp),
                         (int)current_time_monotonic(av->toxav_mono_time));
            const uint32_t frame_length_in_bytes = *i_frame_size;
            const int keyframe = (int)1;

            LOGGER_API_DEBUG(av->tox, "call->video->video_encoder_frame_orientation_angle==%d",
                         call->video->video_encoder_frame_orientation_angle);

            int res = rtp_send_data
                      (
                          call->video_rtp,
                          (const uint8_t *)(call->video->h264_out_pic2->data),
                          frame_length_in_bytes,
                          keyframe,
                          *video_frame_record_timestamp,
                          (int32_t)0,
                          TOXAV_ENCODER_CODEC_USED_H264,
                          call->video_bit_rate,
                          call->video->client_video_capture_delay_ms,
                          call->video->video_encoder_frame_orientation_angle,
                          nullptr
                      );

            (*video_frame_record_timestamp)++;


            av_packet_unref(call->video->h264_out_pic2);

            if (res < 0) {
                LOGGER_API_WARNING(av->tox, "Could not send video frame: %s", strerror(errno));
                *rc = TOXAV_ERR_SEND_FRAME_RTP_FAILED;
                return 1;
            }

            return 0;

        } else {
            *rc = TOXAV_ERR_SEND_FRAME_RTP_FAILED;
            return 1;
        }

    }

}

void vc_kill_h264(VCSession *vc)
{
    // encoder
    if (vc->x264_software_encoder_used == 1) {
        if (vc->h264_encoder) {
            x264_encoder_close(vc->h264_encoder);
            x264_picture_clean(&(vc->h264_in_pic));
        }
    } else {
        // --- ffmpeg encoder ---
        av_packet_free(&(vc->h264_out_pic2));
        avcodec_free_context(&(vc->h264_encoder2));
        // --- ffmpeg encoder ---
    }

    // decoder
    if (vc->h264_decoder->extradata) {
        av_free(vc->h264_decoder->extradata);
        vc->h264_decoder->extradata = NULL;
    }

    avcodec_free_context(&vc->h264_decoder);
}





// --------- H265 ---------
// --------- H265 ---------
// --------- H265 ---------

#ifdef HAVE_H265_ENCODER
static void vc_init_encoder_h265(Logger *log, VCSession *vc, uint32_t bit_rate,
                                uint16_t width, uint16_t height)
{
    // HINT: vc->av may be NULL here
    // LOGGER_API_WARNING(vc->av->tox, "H265 encoder init");

    x265_param *param = x265_param_alloc();
    if (x265_param_default_preset(param, "ultrafast", "zerolatency") != 0) {
        //LOGGER_API_WARNING(vc->av->tox, "H265 encoder:x265_param_default_preset error");
        // goto fail;
    }

    vc->h265_enc_width = width;
    vc->h265_enc_height = height;

    param->sourceWidth = vc->h265_enc_width;
    param->sourceHeight = vc->h265_enc_height;
    param->fpsNum = 30;
    param->fpsDenom = 1;
    param->internalCsp = X265_CSP_I420;
    param->bframes = 0;
    param->bRepeatHeaders = 1;
    param->bAnnexB = 1;
    param->keyframeMax = 60; // every n-th frame is an I-frame
    param->bIntraRefresh = 1;


    // x265_param_parse(param, "fps", "30");
    x265_param_parse(param, "repeat-headers", "1");
    x265_param_parse(param, "annexb", "1");
    // x265_param_parse(param, "input-res", "1920x1080");
    x265_param_parse(param, "input-csp", "i420");

    vc->h264_enc_bitrate = bit_rate / 1000;
    //******// param->bitrate = 

    vc->h265_in_pic = x265_picture_alloc();
    x265_picture_init(param, vc->h265_in_pic);

    vc->h265_out_pic = x265_picture_alloc();
    x265_picture_init(param, vc->h265_out_pic);

    // Allocate memory for YUV frame
    vc->h265_in_pic->colorSpace = X265_CSP_I420;
    vc->h265_in_pic->stride[0] = vc->h265_enc_width;
    vc->h265_in_pic->stride[1] = vc->h265_enc_width / 2;
    vc->h265_in_pic->stride[2] = vc->h265_enc_width / 2;
    vc->h265_in_pic->planes[0] = (uint8_t *)calloc(1, (vc->h265_enc_width * vc->h265_enc_height));
    vc->h265_in_pic->planes[1] = (uint8_t *)calloc(1, (vc->h265_enc_width * vc->h265_enc_height) / 4);
    vc->h265_in_pic->planes[2] = (uint8_t *)calloc(1, (vc->h265_enc_width * vc->h265_enc_height) / 4);

    vc->h265_encoder = x265_encoder_open(param);
    // LOGGER_API_WARNING(vc->av->tox, "H265 encoder:h265_encoder=%p", (void *)vc->h265_encoder);

    x265_param_free(param);
    // LOGGER_API_WARNING(vc->av->tox, "H265 encoder:h265_encoder:ready");
}
#endif

VCSession *vc_new_h265(Logger *log, ToxAV *av, uint32_t friend_number, toxav_video_receive_frame_cb *cb, void *cb_data,
                       VCSession *vc)
{
#ifdef HAVE_H265_ENCODER
    // ENCODER -------
    vc_init_encoder_h265(log, vc, (VIDEO_BITRATE_INITIAL_VALUE_H264 * 1000), 1920, 1080);
    // ENCODER -------
#endif


    // DECODER -------
    LOGGER_API_INFO(av->tox, "H265 decoder init");

    AVCodec *codec = NULL;
    vc->h265_decoder = NULL;

#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(58, 9, 100)
    avcodec_register_all();
#endif

    codec = NULL;
    codec = avcodec_find_decoder(AV_CODEC_ID_H265);

    if (!codec) {
        LOGGER_API_WARNING(av->tox, "codec not found H265 on decoder");
        vc->h265_decoder = NULL;
    } else {

        vc->h265_decoder = avcodec_alloc_context3(codec);
        LOGGER_API_INFO(av->tox, "H265 decoder:h265_decoder=%p", (void *)vc->h265_decoder);

        if (codec) {

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(59, 0, 0)
            vc->h265_decoder->refcounted_frames = 0;
#endif
            /*   When AVCodecContext.refcounted_frames is set to 0, the returned
            *             reference belongs to the decoder and is valid only until the
            *             next call to this function or until closing or flushing the
            *             decoder. The caller may not write to it.
            */
#pragma GCC diagnostic pop

            vc->h265_decoder->delay = 0;
            av_opt_set_int(vc->h265_decoder->priv_data, "delay", 0, AV_OPT_SEARCH_CHILDREN);

            vc->h265_decoder->time_base = (AVRational) {
                1, 30
            };
            vc->h265_decoder->framerate = (AVRational) {
                30, 1
            };

            if (avcodec_open2(vc->h265_decoder, codec, NULL) < 0) {
                LOGGER_API_WARNING(av->tox, "could not open codec H265 on decoder");
                assert(!"could not open codec H265 on decoder");
            }

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(59, 0, 0)
            vc->h265_decoder->refcounted_frames = 0;
#endif
#pragma GCC diagnostic pop
            /*   When AVCodecContext.refcounted_frames is set to 0, the returned
            *             reference belongs to the decoder and is valid only until the
            *             next call to this function or until closing or flushing the
            *             decoder. The caller may not write to it.
            */

            LOGGER_API_INFO(av->tox, "H265 decoder:h265_decoder:ready");
        }
    }


    // DECODER -------

    return vc;
}

#ifdef HAVE_H265_ENCODER
static void vc_kill_encoder_h265(VCSession *vc)
{
    free(vc->h265_in_pic->planes[0]);
    free(vc->h265_in_pic->planes[1]);
    free(vc->h265_in_pic->planes[2]);
    x265_picture_free(vc->h265_in_pic);
    x265_picture_free(vc->h265_out_pic);
    x265_encoder_close(vc->h265_encoder);
}
#endif

int vc_reconfigure_encoder_h265(Logger *log, VCSession *vc, uint32_t bit_rate,
                                uint16_t width, uint16_t height,
                                int16_t kf_max_dist)
{
#ifdef HAVE_H265_ENCODER
    if (!vc) {
        return -1;
    }

    if ((vc->h265_enc_width == width) &&
            (vc->h265_enc_height == height) &&
            (vc->h264_enc_bitrate == bit_rate))
    {
        // no change
        return 0;
    }

    if ((vc->h265_enc_width == width) &&
            (vc->h265_enc_height == height) &&
            (vc->h264_enc_bitrate != bit_rate))
    {
        // HINT: just bitrate has changed
    }
    else
    {
        // HINT: more has changed do a full encoder shutdown and re-init
        vc_kill_encoder_h265(vc);
        vc->h265_enc_height = height;
        vc->h265_enc_width = width;
        vc_init_encoder_h265(log, vc, bit_rate, width, height);
    }

    vc->h264_enc_bitrate = bit_rate;

#endif
    return 0;
}

void decode_frame_h265(VCSession *vc, Tox *tox, uint8_t skip_video_flag, uint64_t *a_r_timestamp,
                       uint64_t *a_l_timestamp,
                       uint64_t *v_r_timestamp, uint64_t *v_l_timestamp,
                       const struct RTPHeader *header_v3,
                       struct RTPMessage *p, vpx_codec_err_t rc,
                       uint32_t full_data_len,
                       uint8_t *ret_value)
{
    LOGGER_API_DEBUG(vc->av->tox, "decode_frame_h265:fnum=%d,len=%d", vc->friend_number, full_data_len);

    if (p == NULL) {
        LOGGER_API_DEBUG(vc->av->tox, "decode_frame_h265:NO data");
        return;
    }

    if (full_data_len < 1) {
        LOGGER_API_DEBUG(vc->av->tox, "decode_frame_h265:not enough data");
        free(p);
        p = NULL;
        return;
    }

    if (vc->h265_decoder == NULL) {
        LOGGER_API_DEBUG(vc->av->tox, "vc->h265_decoder:not ready");
        free(p);
        p = NULL;
        return;
    }


    if (vc->global_decode_first_frame_got == 0)
    {
        if (vc->global_decode_first_frame_delayed_by == 0)
        {
            vc->global_decode_first_frame_delayed_ms = current_time_monotonic(vc->av->toxav_mono_time);
        }
        vc->global_decode_first_frame_delayed_by++;
    }

    AVPacket *compr_data = NULL;
    compr_data = av_packet_alloc();

    if (compr_data == NULL) {
        LOGGER_API_DEBUG(vc->av->tox, "av_packet_alloc:ERROR");
        free(p);
        p = NULL;
        return;
    }

    uint64_t h_frame_record_timestamp = header_v3->frame_record_timestamp;

    compr_data->data = p->data;
    compr_data->size = (int)full_data_len; // hmm, "int" again

    if (header_v3->frame_record_timestamp > 0) {
        LOGGER_API_DEBUG(vc->av->tox, "in_pts:%lu", header_v3->frame_record_timestamp);
        compr_data->dts = (int64_t)(header_v3->frame_record_timestamp) - 1;
        compr_data->pts = (int64_t)(header_v3->frame_record_timestamp);
        compr_data->duration = 0; // (int64_t)(header_v3->frame_record_timestamp) + 1; // 0;
    }

    int result_send_packet = avcodec_send_packet(vc->h265_decoder, compr_data);

    if (result_send_packet != 0) {
        LOGGER_API_DEBUG(vc->av->tox, "avcodec_send_packet:ERROR=%d", result_send_packet);
        av_packet_free(&compr_data);
        free(p);
        p = NULL;
        return;
    }

    /* HINT: this is the only part that takes all the time !!! */
    /* HINT: this is the only part that takes all the time !!! */
    /* HINT: this is the only part that takes all the time !!! */
    /* ------------------------------------------------------- */
    /* ------------------------------------------------------- */


    int ret_ = 0;

    while (ret_ >= 0) {

        // start_time_ms = current_time_monotonic(vc->av->toxav_mono_time);
        AVFrame *frame = av_frame_alloc();

        if (frame == NULL) {
            // stop decoding
            break;
        }

        ret_ = avcodec_receive_frame(vc->h265_decoder, frame);

        if (ret_ == AVERROR(EAGAIN) || ret_ == AVERROR_EOF) {
            // error
            av_frame_free(&frame);
            break;
        } else if (ret_ < 0) {
            // Error during decoding
            av_frame_free(&frame);
            break;
        } else if (ret_ == 0) {


        if (vc->global_decode_first_frame_got == 0)
        {
            vc->global_decode_first_frame_got = 1;
            vc->global_decode_first_frame_delayed_ms =
                current_time_monotonic(vc->av->toxav_mono_time) - vc->global_decode_first_frame_delayed_ms;
            LOGGER_API_DEBUG(vc->av->tox, "X265 decoder delay: %d f, %d ms",
                    (vc->global_decode_first_frame_delayed_by - 1),
                    (int)vc->global_decode_first_frame_delayed_ms);
        }


            if (header_v3->frame_record_timestamp > 0) {
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#if LIBAVCODEC_VERSION_INT > AV_VERSION_INT(59, 0, 0)
                int32_t delta_value = (int32_t)(h_frame_record_timestamp - frame->pts);
#else
                int32_t delta_value = (int32_t)(h_frame_record_timestamp - frame->pkt_pts);
#endif

#if LIBAVCODEC_VERSION_INT > AV_VERSION_INT(59, 0, 0)
                LOGGER_API_DEBUG(vc->av->tox, "out_pts:%lu %lu %ld %ld",
                        frame->pts, frame->pkt_dts, frame->best_effort_timestamp, frame->pkt_pos);
#endif

                LOGGER_API_DEBUG(vc->av->tox, "dec:XX:03:%d %d %d %d %d",
                        delta_value,
                        (int)h_frame_record_timestamp,

#if LIBAVCODEC_VERSION_INT > AV_VERSION_INT(59, 0, 0)
                        (int)frame->pts,
#else
                        (int)frame->pkt_pts,
#endif

                        (int)frame->pkt_dts,
                        (int)frame->pts);
#pragma GCC diagnostic pop

                if ((delta_value >= 0) && (delta_value <= 1000))
                {
                    vc->video_decoder_caused_delay_ms = delta_value;
                    LOGGER_API_DEBUG(vc->av->tox, "dec:1:delta_value=%d", vc->video_decoder_caused_delay_ms);
                }
                else if (delta_value == -1)
                {
                    // since we do NOT have any idea how long the decoder delays frames,
                    // and the decoder will lie to us, we just assume some random value
                    // that works for our use cases (decoding on andriod via MediaCodec)
                    vc->video_decoder_caused_delay_ms = 1;
                    LOGGER_API_DEBUG(vc->av->tox, "dec:2:delta_value=%d", vc->video_decoder_caused_delay_ms);
                }

                // calc mean value
                vc->video_decoder_caused_delay_ms_array[vc->video_decoder_caused_delay_ms_array_index] = vc->video_decoder_caused_delay_ms;
                vc->video_decoder_caused_delay_ms_array_index = (vc->video_decoder_caused_delay_ms_array_index + 1) %
                        VIDEO_DECODER_CAUSED_DELAY_MS_ENTRIES;

                uint32_t mean_value = 0;

                for (int k = 0; k < VIDEO_DECODER_CAUSED_DELAY_MS_ENTRIES; k++) {
                    mean_value = mean_value + vc->video_decoder_caused_delay_ms_array[k];
                }

                if (mean_value == 0) {
                    vc->video_decoder_caused_delay_ms_mean_value = 0;
                } else {
                    vc->video_decoder_caused_delay_ms_mean_value = (mean_value * 10) / (VIDEO_DECODER_CAUSED_DELAY_MS_ENTRIES * 10);
                }

                LOGGER_API_DEBUG(vc->av->tox, "dec:video_decoder_caused_delay_ms_mean_value=%d",
                        vc->video_decoder_caused_delay_ms_mean_value);

            }

            // start_time_ms = current_time_monotonic(vc->av->toxav_mono_time);
            if ((frame->data[0] != NULL) && (frame->data[1] != NULL) && (frame->data[2] != NULL)) {

// -------- DEBUG:AUDIO/VIDEO DELAY/LATENCY --------
// -------- DEBUG:AUDIO/VIDEO DELAY/LATENCY --------
// -------- DEBUG:AUDIO/VIDEO DELAY/LATENCY --------
                *v_r_timestamp = h_frame_record_timestamp;
                *v_l_timestamp = current_time_monotonic(vc->av->toxav_mono_time);
// -------- DEBUG:AUDIO/VIDEO DELAY/LATENCY --------
// -------- DEBUG:AUDIO/VIDEO DELAY/LATENCY --------
// -------- DEBUG:AUDIO/VIDEO DELAY/LATENCY --------

                if (vc->vcb_pts)
                {
                    uint64_t pts_for_client = h_frame_record_timestamp;
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if LIBAVCODEC_VERSION_INT > AV_VERSION_INT(59, 0, 0)
                    int32_t delta_check = (int32_t)(h_frame_record_timestamp - frame->pts);
#else
                    int32_t delta_check = (int32_t)(h_frame_record_timestamp - frame->pkt_pts);
#endif

                    if ((delta_check >= 0) && (delta_check <= 600))
                    {

#if LIBAVCODEC_VERSION_INT > AV_VERSION_INT(59, 0, 0)
                        pts_for_client = frame->pts;
#else
                        pts_for_client = frame->pkt_pts;
#endif
                    }
#pragma GCC diagnostic pop

                    LOGGER_API_DEBUG(vc->av->tox, "DDDDDDDDDD:%lu", pts_for_client);
                    vc->vcb_pts(vc->av, vc->friend_number, frame->width, frame->height,
                            (const uint8_t *)frame->data[0],
                            (const uint8_t *)frame->data[1],
                            (const uint8_t *)frame->data[2],
                            frame->linesize[0], frame->linesize[1],
                            frame->linesize[2], vc->vcb_pts_user_data,
                            pts_for_client);
                }
                else
                {
                    vc->vcb(vc->av, vc->friend_number, frame->width, frame->height,
                            (const uint8_t *)frame->data[0],
                            (const uint8_t *)frame->data[1],
                            (const uint8_t *)frame->data[2],
                            frame->linesize[0], frame->linesize[1],
                            frame->linesize[2], vc->vcb_user_data);
                }
            }

        } else {
            // some other error
        }

        av_frame_free(&frame);
    }

    av_packet_free(&compr_data);
    free(p);

    return;
}

#ifdef HAVE_H265_ENCODER
uint32_t encode_frame_h265(ToxAV *av, uint32_t friend_number, uint16_t width, uint16_t height,
                           const uint8_t *y,
                           const uint8_t *u, const uint8_t *v, ToxAVCall *call,
                           uint64_t *video_frame_record_timestamp,
                           int vpx_encode_flags,
                           int *x265_num_nals,
                           x264_nal_t **nal,
                           int *i_frame_size, x265_nal** h265_nals)
{
    uint32_t i_nal;

    LOGGER_API_DEBUG(av->tox, "encode_frame_h265:start");

    call->video->h265_in_pic->pts = (int64_t)(*video_frame_record_timestamp);
    LOGGER_API_DEBUG(av->tox, "X265:in_ts:%lu", (*video_frame_record_timestamp));


    memcpy(call->video->h265_in_pic->planes[0], y, (width * height));
    memcpy(call->video->h265_in_pic->planes[1], u, (width / 2) * (height / 2));
    memcpy(call->video->h265_in_pic->planes[2], v, (width / 2) * (height / 2));
    x265_encoder_encode(call->video->h265_encoder, h265_nals, &i_nal, call->video->h265_in_pic, call->video->h265_out_pic);

    *video_frame_record_timestamp = (uint64_t)call->video->h265_out_pic->pts;
    LOGGER_API_DEBUG(av->tox, "X265:out_ts:%lu", (*video_frame_record_timestamp));
    LOGGER_API_DEBUG(av->tox, "X265:out_ts:dts:%d", (int)call->video->h265_out_pic->dts);
    LOGGER_API_DEBUG(av->tox, "X265:out_ts:pts:%d", (int)call->video->h265_out_pic->pts);

    *x265_num_nals = 0;

    if (*h265_nals == NULL) {
        return 1;
    }

    if (i_nal < 1) {
        return 1;
    }

    *x265_num_nals = (int)i_nal;
    *i_frame_size = (*h265_nals)[0].sizeBytes;

    if (*i_frame_size < 0) {
        // some error
    } else if (*i_frame_size == 0) {
        // zero size output
    }

    if ((*h265_nals)[0].payload == NULL) {
        LOGGER_API_WARNING(av->tox, "X265:ERR:099");
        return 1;
    }

    LOGGER_API_DEBUG(av->tox, "X265:done");
    return 0;
}
#endif

#ifdef HAVE_H265_ENCODER
uint32_t send_frames_h265(ToxAV *av, uint32_t friend_number, uint16_t width, uint16_t height,
                          const uint8_t *y,
                          const uint8_t *u, const uint8_t *v, ToxAVCall *call,
                          uint64_t *video_frame_record_timestamp,
                          int vpx_encode_flags,
                          x264_nal_t **nal,
                          int *i_frame_size,
                          int x265_num_nals,
                          x265_nal** h265_nals,
                          TOXAV_ERR_SEND_FRAME *rc)
{

    // Process the encoded data (NAL units)
    uint32_t need_buffer_bytes = 0;
    for (uint32_t i = 0; i < x265_num_nals; i++) {
        LOGGER_API_DEBUG(av->tox, "nal #%d", i);
        LOGGER_API_DEBUG(av->tox, "bytes: %d", (int)(*h265_nals)[i].sizeBytes);
        need_buffer_bytes = need_buffer_bytes + (*h265_nals)[i].sizeBytes;
    }

    if (need_buffer_bytes > 0) {
        uint8_t *needed_buffer = malloc(need_buffer_bytes);
        if (needed_buffer == nullptr) {
            *rc = TOXAV_ERR_SEND_FRAME_RTP_FAILED;
            return 1;
        }

        uint8_t *p1 = needed_buffer;
        for (uint32_t i = 0; i < x265_num_nals; i++) {
            memcpy(p1, (const uint8_t *)(*h265_nals)[i].payload, (*h265_nals)[i].sizeBytes);
            p1 = p1 + (*h265_nals)[i].sizeBytes;
        }

        LOGGER_API_DEBUG(av->tox, "X265:send_ts:%lu", (*video_frame_record_timestamp));
        const uint32_t frame_length_in_bytes = need_buffer_bytes;
        LOGGER_API_DEBUG(av->tox, "X265:sizebytes:%d", need_buffer_bytes);

        int res = rtp_send_data
                  (
                      call->video_rtp,
                      needed_buffer,
                      need_buffer_bytes,
                      0,
                      *video_frame_record_timestamp,
                      (int32_t)0,
                      TOXAV_ENCODER_CODEC_USED_H265,
                      call->video_bit_rate,
                      call->video->client_video_capture_delay_ms,
                      call->video->video_encoder_frame_orientation_angle,
                      nullptr
                  );
        (*video_frame_record_timestamp)++;

        free(needed_buffer);

        if (res < 0) {
            LOGGER_API_WARNING(av->tox, "Could not send video frame: %s", strerror(errno));
            *rc = TOXAV_ERR_SEND_FRAME_RTP_FAILED;
            return 1;
        } else {
            LOGGER_API_DEBUG(av->tox, "send video frame OK");
        }

        return 0;
    } else {
        *rc = TOXAV_ERR_SEND_FRAME_RTP_FAILED;
        return 1;
    }
}
#endif

void vc_kill_h265(VCSession *vc)
{
#ifdef HAVE_H265_ENCODER
    // encoder
    vc_kill_encoder_h265(vc);
#endif

    // decoder
    if (vc->h265_decoder != nullptr) {
        if (vc->h265_decoder->extradata) {
            av_free(vc->h265_decoder->extradata);
            vc->h265_decoder->extradata = NULL;
        }
        avcodec_free_context(&vc->h265_decoder);
        vc->h265_decoder = NULL;
    }
}

/*
 * Copyright © 2018 zoff@zoff.cc and mail@strfry.org
 *
 * This file is part of Tox, the free peer to peer instant messenger.
 *
 * Tox is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Tox is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Tox.  If not, see <http://www.gnu.org/licenses/>.
 */



static void vc__init_encoder_cfg(Logger *log, vpx_codec_enc_cfg_t *cfg, int16_t kf_max_dist, int32_t quality,
                                 int32_t rc_max_quantizer, int32_t rc_min_quantizer, int32_t encoder_codec,
                                 int32_t video_keyframe_method)
{

    vpx_codec_err_t rc;

    if (encoder_codec != TOXAV_ENCODER_CODEC_USED_VP9) {
        // LOGGER_WARNING(log, "Using VP8 codec for encoder (1)");
        rc = vpx_codec_enc_config_default(VIDEO_CODEC_ENCODER_INTERFACE_VP8, cfg, 0);
    } else {
        // LOGGER_WARNING(log, "Using VP9 codec for encoder (1)");
        rc = vpx_codec_enc_config_default(VIDEO_CODEC_ENCODER_INTERFACE_VP9, cfg, 0);
    }

    if (rc != VPX_CODEC_OK) {
        // LOGGER_ERROR(log, "vc__init_encoder_cfg:Failed to get config: %s", vpx_codec_err_to_string(rc));
    }

    if (encoder_codec == TOXAV_ENCODER_CODEC_USED_VP9) {
        cfg->rc_target_bitrate = VIDEO_BITRATE_INITIAL_VALUE_VP9;
    } else {
        cfg->rc_target_bitrate =
            VIDEO_BITRATE_INITIAL_VALUE; /* Target bandwidth to use for this stream, in kilobits per second */
    }

    cfg->g_w = VIDEO_CODEC_DECODER_MAX_WIDTH;
    cfg->g_h = VIDEO_CODEC_DECODER_MAX_HEIGHT;
    cfg->g_pass = VPX_RC_ONE_PASS;



    /* zoff (in 2017) */
    cfg->g_error_resilient = VPX_ERROR_RESILIENT_DEFAULT; // | VPX_ERROR_RESILIENT_PARTITIONS;
    cfg->g_lag_in_frames = 0;
    /* Allow lagged encoding
     *
     * If set, this value allows the encoder to consume a number of input
     * frames before producing output frames. This allows the encoder to
     * base decisions for the current frame on future frames. This does
     * increase the latency of the encoding pipeline, so it is not appropriate
     * in all situations (ex: realtime encoding).
     *
     * Note that this is a maximum value -- the encoder may produce frames
     * sooner than the given limit. Set this value to 0 to disable this
     * feature.
     */

    if (video_keyframe_method == TOXAV_ENCODER_KF_METHOD_PATTERN) {
        cfg->kf_min_dist = 0;
        cfg->kf_mode = VPX_KF_DISABLED;
    } else {
        cfg->kf_min_dist = 0;
        cfg->kf_mode = VPX_KF_AUTO; // Encoder determines optimal placement automatically
    }

    cfg->rc_end_usage = VPX_CBR; // VPX_VBR; // what quality mode?
    /*
     VPX_VBR    Variable Bit Rate (VBR) mode
     VPX_CBR    Constant Bit Rate (CBR) mode
     VPX_CQ     Constrained Quality (CQ) mode -> give codec a hint that we may be on low bandwidth connection
     VPX_Q      Constant Quality (Q) mode
     */

    if (kf_max_dist > 1) {
        cfg->kf_max_dist = kf_max_dist; // a full frame every x frames minimum (can be more often, codec decides automatically)
        // LOGGER_WARNING(log, "kf_max_dist=%d (1)", cfg->kf_max_dist);
    } else {
        cfg->kf_max_dist = VPX_MAX_DIST_START;
        // LOGGER_WARNING(log, "kf_max_dist=%d (2)", cfg->kf_max_dist);
    }

    if (encoder_codec == TOXAV_ENCODER_CODEC_USED_VP9) {
        cfg->kf_max_dist = VIDEO__VP9_KF_MAX_DIST;
        // LOGGER_WARNING(log, "kf_max_dist=%d (3)", cfg->kf_max_dist);
    }

    cfg->g_threads = VPX_MAX_ENCODER_THREADS; // Maximum number of threads to use

    cfg->g_timebase.num = 1; // 0.1 ms = timebase units = (1/10000)s
    cfg->g_timebase.den = 10000; // 0.1 ms = timebase units = (1/10000)s

    if (encoder_codec == TOXAV_ENCODER_CODEC_USED_VP9) {
        cfg->rc_dropframe_thresh = 0;
        cfg->rc_resize_allowed = 0;
    } else {
        if (quality == TOXAV_ENCODER_VP8_QUALITY_HIGH) {
            /* Highest-resolution encoder settings */
            cfg->rc_dropframe_thresh = 0; // 0
            cfg->rc_resize_allowed = 0; // 0
            cfg->rc_min_quantizer = rc_min_quantizer; // 0
            cfg->rc_max_quantizer = rc_max_quantizer; // 40
            cfg->rc_resize_up_thresh = 29;
            cfg->rc_resize_down_thresh = 5;
            cfg->rc_undershoot_pct = 100; // 100
            cfg->rc_overshoot_pct = 10; // 15
            cfg->rc_buf_initial_sz = 500; // 500 in ms
            cfg->rc_buf_optimal_sz = 600; // 600 in ms
            cfg->rc_buf_sz = 1000; // 1000 in ms
        } else { // TOXAV_ENCODER_VP8_QUALITY_NORMAL
            cfg->rc_dropframe_thresh = 0;
            cfg->rc_resize_allowed = 0; // allow encoder to resize to smaller resolution
            cfg->rc_min_quantizer = rc_min_quantizer; // 2
            cfg->rc_max_quantizer = rc_max_quantizer; // 63
            cfg->rc_resize_up_thresh = TOXAV_ENCODER_VP_RC_RESIZE_UP_THRESH;
            cfg->rc_resize_down_thresh = TOXAV_ENCODER_VP_RC_RESIZE_DOWN_THRESH;
            cfg->rc_undershoot_pct = 100; // 100
            cfg->rc_overshoot_pct = 10; // 15
            cfg->rc_buf_initial_sz = 500; // 500 in ms
            cfg->rc_buf_optimal_sz = 600; // 600 in ms
            cfg->rc_buf_sz = 1000; // 1000 in ms
        }

    }
}


VCSession *vc_new_vpx(Logger *log, ToxAV *av, uint32_t friend_number, toxav_video_receive_frame_cb *cb, void *cb_data,
                      VCSession *vc)
{

    vpx_codec_err_t rc;

    /*
    VPX_CODEC_USE_FRAME_THREADING
       Enable frame-based multi-threading

    VPX_CODEC_USE_ERROR_CONCEALMENT
       Conceal errors in decoded frames
    */
    vpx_codec_dec_cfg_t  dec_cfg;
    dec_cfg.threads = VPX_MAX_DECODER_THREADS; // Maximum number of threads to use
    dec_cfg.w = VIDEO_CODEC_DECODER_MAX_WIDTH;
    dec_cfg.h = VIDEO_CODEC_DECODER_MAX_HEIGHT;

    if (VPX_DECODER_USED != TOXAV_ENCODER_CODEC_USED_VP9) {
        // LOGGER_WARNING(log, "Using VP8 codec for decoder (0)");

        vpx_codec_flags_t dec_flags_ = 0;

        if (vc->video_decoder_error_concealment == 1) {
            vpx_codec_caps_t decoder_caps = vpx_codec_get_caps(VIDEO_CODEC_DECODER_INTERFACE_VP8);

            if (decoder_caps & VPX_CODEC_CAP_ERROR_CONCEALMENT) {
                dec_flags_ = VPX_CODEC_USE_ERROR_CONCEALMENT;
                // LOGGER_WARNING(log, "Using VP8 VPX_CODEC_USE_ERROR_CONCEALMENT (0)");
            }
        }

#ifdef VIDEO_CODEC_ENCODER_USE_FRAGMENTS
        rc = vpx_codec_dec_init(vc->decoder, VIDEO_CODEC_DECODER_INTERFACE_VP8, &dec_cfg,
                                dec_flags_ | VPX_CODEC_USE_FRAME_THREADING
                                | VPX_CODEC_USE_POSTPROC | VPX_CODEC_USE_INPUT_FRAGMENTS);
        // LOGGER_WARNING(log, "Using VP8 using input fragments (0) rc=%d", (int)rc);
#else
        rc = vpx_codec_dec_init(vc->decoder, VIDEO_CODEC_DECODER_INTERFACE_VP8, &dec_cfg,
                                dec_flags_ | VPX_CODEC_USE_FRAME_THREADING
                                | VPX_CODEC_USE_POSTPROC);
#endif

        if (rc == VPX_CODEC_INCAPABLE) {
            // LOGGER_WARNING(log, "Postproc not supported by this decoder (0)");
            rc = vpx_codec_dec_init(vc->decoder, VIDEO_CODEC_DECODER_INTERFACE_VP8, &dec_cfg,
                                    dec_flags_ | VPX_CODEC_USE_FRAME_THREADING);
        }

    } else {
        // LOGGER_WARNING(log, "Using VP9 codec for decoder (0)");
        rc = vpx_codec_dec_init(vc->decoder, VIDEO_CODEC_DECODER_INTERFACE_VP9, &dec_cfg,
                                VPX_CODEC_USE_FRAME_THREADING);
    }

    if (rc != VPX_CODEC_OK) {
        // LOGGER_ERROR(log, "Init video_decoder failed: %s", vpx_codec_err_to_string(rc));
        goto BASE_CLEANUP;
    }


    if (VPX_DECODER_USED != TOXAV_ENCODER_CODEC_USED_VP9) {
        if (VIDEO__VP8_DECODER_POST_PROCESSING_ENABLED == 1) {
            // LOGGER_WARNING(log, "turn on postproc: OK");
        } else if (VIDEO__VP8_DECODER_POST_PROCESSING_ENABLED == 2) {
            vp8_postproc_cfg_t pp = {VP8_MFQE, 1, 0};
            vpx_codec_err_t cc_res = vpx_codec_control(vc->decoder, VP8_SET_POSTPROC, &pp);

            if (cc_res != VPX_CODEC_OK) {
                // LOGGER_WARNING(log, "Failed to turn on postproc");
            } else {
                // LOGGER_WARNING(log, "turn on postproc: OK");
            }
        } else if (VIDEO__VP8_DECODER_POST_PROCESSING_ENABLED == 3) {
            vp8_postproc_cfg_t pp = {VP8_DEBLOCK | VP8_DEMACROBLOCK | VP8_MFQE, 1, 0};
            vpx_codec_err_t cc_res = vpx_codec_control(vc->decoder, VP8_SET_POSTPROC, &pp);

            if (cc_res != VPX_CODEC_OK) {
                // LOGGER_WARNING(log, "Failed to turn on postproc");
            } else {
                // LOGGER_WARNING(log, "turn on postproc: OK");
            }
        } else {
            vp8_postproc_cfg_t pp = {0, 0, 0};
            vpx_codec_err_t cc_res = vpx_codec_control(vc->decoder, VP8_SET_POSTPROC, &pp);

            if (cc_res != VPX_CODEC_OK) {
                // LOGGER_WARNING(log, "Failed to turn OFF postproc");
            } else {
                // LOGGER_WARNING(log, "Disable postproc: OK");
            }
        }
    }







    /* Set encoder to some initial values
     */
    vpx_codec_enc_cfg_t  cfg;
    vc__init_encoder_cfg(log, &cfg, 1,
                         vc->video_encoder_vp8_quality,
                         vc->video_rc_max_quantizer,
                         vc->video_rc_min_quantizer,
                         vc->video_encoder_coded_used,
                         vc->video_keyframe_method);

    if (vc->video_encoder_coded_used != TOXAV_ENCODER_CODEC_USED_VP9) {
        // LOGGER_WARNING(log, "Using VP8 codec for encoder (0.1)");

#ifdef VIDEO_CODEC_ENCODER_USE_FRAGMENTS
        rc = vpx_codec_enc_init(vc->encoder, VIDEO_CODEC_ENCODER_INTERFACE_VP8, &cfg,
                                VPX_CODEC_USE_FRAME_THREADING | VPX_CODEC_USE_OUTPUT_PARTITION);
#else
        rc = vpx_codec_enc_init(vc->encoder, VIDEO_CODEC_ENCODER_INTERFACE_VP8, &cfg,
                                VPX_CODEC_USE_FRAME_THREADING);
#endif

    } else {
        // LOGGER_WARNING(log, "Using VP9 codec for encoder (0.1)");
        rc = vpx_codec_enc_init(vc->encoder, VIDEO_CODEC_ENCODER_INTERFACE_VP9, &cfg, VPX_CODEC_USE_FRAME_THREADING);
    }

    if (rc != VPX_CODEC_OK) {
        // LOGGER_ERROR(log, "Failed to initialize encoder: %s", vpx_codec_err_to_string(rc));
        goto BASE_CLEANUP_1;
    }


    rc = vpx_codec_control(vc->encoder, VP8E_SET_ENABLEAUTOALTREF, 0);

    if (rc != VPX_CODEC_OK) {
        // LOGGER_ERROR(log, "Failed to set encoder VP8E_SET_ENABLEAUTOALTREF setting: %s value=%d", vpx_codec_err_to_string(rc), (int)0);
        vpx_codec_destroy(vc->encoder);
        goto BASE_CLEANUP_1;
    } else {
        // LOGGER_WARNING(log, "set encoder VP8E_SET_ENABLEAUTOALTREF setting: %s value=%d", vpx_codec_err_to_string(rc), (int)0);
    }


    uint32_t rc_max_intra_target; // = MaxIntraTarget(250);
    rc_max_intra_target = 200;
    rc = vpx_codec_control(vc->encoder, VP8E_SET_MAX_INTRA_BITRATE_PCT, rc_max_intra_target);

    if (rc != VPX_CODEC_OK) {
        // LOGGER_ERROR(log, "Failed to set encoder VP8E_SET_MAX_INTRA_BITRATE_PCT setting: %s value=%d",
        //              vpx_codec_err_to_string(rc),
        //              (int)rc_max_intra_target);
        vpx_codec_destroy(vc->encoder);
        goto BASE_CLEANUP_1;
    } else {
        // LOGGER_WARNING(log, "set encoder VP8E_SET_MAX_INTRA_BITRATE_PCT setting: %s value=%d", vpx_codec_err_to_string(rc),
        //                (int)rc_max_intra_target);
    }



    /*
    Codec control function to set encoder internal speed settings.
    Changes in this value influences, among others, the encoder's selection of motion estimation methods.
    Values greater than 0 will increase encoder speed at the expense of quality.

    Note:
      Valid range for VP8: -16..16
      Valid range for VP9: -8..8
    */

    int cpu_used_value = vc->video_encoder_cpu_used;

    if (vc->video_encoder_coded_used == TOXAV_ENCODER_CODEC_USED_VP9) {
        if (cpu_used_value < -8) {
            cpu_used_value = -8;
        } else if (cpu_used_value > 8) {
            cpu_used_value = 8; // set to default (fastest) value
        }
    }

    rc = vpx_codec_control(vc->encoder, VP8E_SET_CPUUSED, cpu_used_value);

    if (rc != VPX_CODEC_OK) {
        // LOGGER_ERROR(log, "Failed to set encoder VP8E_SET_CPUUSED setting: %s value=%d", vpx_codec_err_to_string(rc),
        //              (int)cpu_used_value);
        vpx_codec_destroy(vc->encoder);
        goto BASE_CLEANUP_1;
    } else {
        // LOGGER_WARNING(log, "set encoder VP8E_SET_CPUUSED setting: %s value=%d", vpx_codec_err_to_string(rc),
        //                (int)cpu_used_value);
    }

    vc->video_encoder_cpu_used = cpu_used_value;
    vc->video_encoder_cpu_used_prev = cpu_used_value;

#ifdef VIDEO_CODEC_ENCODER_USE_FRAGMENTS

    if (vc->video_encoder_coded_used != TOXAV_ENCODER_CODEC_USED_VP9) {
        rc = vpx_codec_control(vc->encoder, VP8E_SET_TOKEN_PARTITIONS, VIDEO_CODEC_FRAGMENT_VPX_NUMS);

        if (rc != VPX_CODEC_OK) {
            // LOGGER_ERROR(log, "Failed to set encoder token partitions: %s", vpx_codec_err_to_string(rc));
        }
    }

#endif

    /*
    VP9E_SET_TILE_COLUMNS

    Codec control function to set number of tile columns.

    In encoding and decoding, VP9 allows an input image frame be partitioned
    into separated vertical tile columns, which can be encoded or decoded independently.
    This enables easy implementation of parallel encoding and decoding. This control requests
    the encoder to use column tiles in encoding an input frame, with number of tile columns
    (in Log2 unit) as the parameter: 0 = 1 tile column 1 = 2 tile columns
    2 = 4 tile columns ..... n = 2**n tile columns The requested tile columns will
    be capped by encoder based on image size limitation (The minimum width of a
    tile column is 256 pixel, the maximum is 4096).

    By default, the value is 0, i.e. one single column tile for entire image.

    Supported in codecs: VP9
     */

    if (vc->video_encoder_coded_used == TOXAV_ENCODER_CODEC_USED_VP9) {
        rc = vpx_codec_control(vc->encoder, VP9E_SET_TILE_COLUMNS, VIDEO__VP9E_SET_TILE_COLUMNS);

        if (rc != VPX_CODEC_OK) {
            // LOGGER_ERROR(log, "Failed to set encoder control setting: %s", vpx_codec_err_to_string(rc));
            vpx_codec_destroy(vc->encoder);
            goto BASE_CLEANUP_1;
        }

        rc = vpx_codec_control(vc->encoder, VP9E_SET_TILE_ROWS, VIDEO__VP9E_SET_TILE_ROWS);

        if (rc != VPX_CODEC_OK) {
            // LOGGER_ERROR(log, "Failed to set encoder control setting: %s", vpx_codec_err_to_string(rc));
            vpx_codec_destroy(vc->encoder);
            goto BASE_CLEANUP_1;
        }
    }

    /*
    VPX_CTRL_USE_TYPE(VP8E_SET_NOISE_SENSITIVITY,  unsigned int)
    control function to set noise sensitivity
      0: off, 1: OnYOnly, 2: OnYUV, 3: OnYUVAggressive, 4: Adaptive
    */
    /*
      rc = vpx_codec_control(vc->encoder, VP8E_SET_NOISE_SENSITIVITY, 2);

      if (rc != VPX_CODEC_OK) {
          // LOGGER_ERROR(log, "Failed to set encoder control setting: %s", vpx_codec_err_to_string(rc));
          vpx_codec_destroy(vc->encoder);
          goto BASE_CLEANUP_1;
      }
     */

    // VP8E_SET_STATIC_THRESHOLD


    vc->linfts = current_time_monotonic(av->toxav_mono_time);
    vc->lcfd = 10; // initial value in ms for av_iterate sleep
    vc->vcb = cb;
    vc->vcb_user_data = cb_data;
    vc->friend_number = friend_number;
    vc->av = av;
    vc->log = log;
    vc->last_decoded_frame_ts = 0;
    vc->last_encoded_frame_ts = 0;
    vc->flag_end_video_fragment = 0;
    vc->last_seen_fragment_num = 0;
    vc->count_old_video_frames_seen = 0;
    vc->last_seen_fragment_seqnum = -1;
    vc->fragment_buf_counter = 0;

    for (int k = 0; k < VIDEO_DECODER_SOFT_DEADLINE_AUTOTUNE_ENTRIES; k++) {
        vc->decoder_soft_deadline[k] = MAX_DECODE_TIME_US;
    }

    vc->decoder_soft_deadline_index = 0;

    for (int k = 0; k < VIDEO_ENCODER_SOFT_DEADLINE_AUTOTUNE_ENTRIES; k++) {
        vc->encoder_soft_deadline[k] = MAX_ENCODE_TIME_US;
    }

    vc->encoder_soft_deadline_index = 0;

    uint16_t jk = 0;

    for (jk = 0; jk < (uint16_t)VIDEO_MAX_FRAGMENT_BUFFER_COUNT; jk++) {
        vc->vpx_frames_buf_list[jk] = NULL;
    }

    return vc;

BASE_CLEANUP_1:
    vpx_codec_destroy(vc->decoder);
BASE_CLEANUP:
    pthread_mutex_destroy(vc->queue_mutex);
    rb_kill((RingBuffer *)vc->vbuf_raw);
    free(vc);
    return NULL;
}


int vc_reconfigure_encoder_vpx(Logger *log, VCSession *vc, uint32_t bit_rate,
                               uint16_t width, uint16_t height,
                               int16_t kf_max_dist)
{
    if (!vc) {
        return -1;
    }

    vpx_codec_enc_cfg_t cfg2 = *vc->encoder->config.enc;
    vpx_codec_err_t rc;

    if (cfg2.rc_target_bitrate == (bit_rate / 1000) && cfg2.g_w == width && cfg2.g_h == height && kf_max_dist == -1
            && vc->video_encoder_cpu_used == vc->video_encoder_cpu_used_prev
            && vc->video_encoder_vp8_quality == vc->video_encoder_vp8_quality_prev
            && vc->video_rc_max_quantizer == vc->video_rc_max_quantizer_prev
            && vc->video_rc_min_quantizer == vc->video_rc_min_quantizer_prev
            && vc->video_encoder_coded_used == vc->video_encoder_coded_used_prev
            && vc->video_keyframe_method == vc->video_keyframe_method_prev
       ) {
        return 0; /* Nothing changed */
    }

    if (cfg2.g_w == width && cfg2.g_h == height && kf_max_dist == -1
            && vc->video_encoder_cpu_used == vc->video_encoder_cpu_used_prev
            && vc->video_encoder_vp8_quality == vc->video_encoder_vp8_quality_prev
            && vc->video_rc_max_quantizer == vc->video_rc_max_quantizer_prev
            && vc->video_rc_min_quantizer == vc->video_rc_min_quantizer_prev
            && vc->video_encoder_coded_used == vc->video_encoder_coded_used_prev
            && vc->video_keyframe_method == vc->video_keyframe_method_prev
       ) {
        /* Only bit rate changed */

        // LOGGER_DEBUG(vc->log, "bitrate change from: %u to: %u", (uint32_t)(cfg2.rc_target_bitrate / 1000),
        //              (uint32_t)(bit_rate / 1000));

        // VP8 needs this in kilobits per second!
        cfg2.rc_target_bitrate = (bit_rate / 1000);

        rc = vpx_codec_enc_config_set(vc->encoder, &cfg2);

        if (rc != VPX_CODEC_OK) {
            // LOGGER_ERROR(vc->log, "Failed to set encoder control setting: %s", vpx_codec_err_to_string(rc));
            return -1;
        }
    } else {
        /* Resolution is changed, must reinitialize encoder since libvpx v1.4 doesn't support
         * reconfiguring encoder to use resolutions greater than initially set.
         */
        /*
         * TODO: Zoff in 2018: i wonder if this is still the case with libvpx 1.7.x ?
         */

        // LOGGER_DEBUG(vc->log, "Have to reinitialize vpx encoder on session %p", (void *)vc);

        vpx_codec_ctx_t new_c;
        vpx_codec_enc_cfg_t  cfg;
        vc__init_encoder_cfg(vc->log, &cfg, kf_max_dist,
                             vc->video_encoder_vp8_quality,
                             vc->video_rc_max_quantizer,
                             vc->video_rc_min_quantizer,
                             vc->video_encoder_coded_used,
                             vc->video_keyframe_method);

        vc->video_encoder_coded_used_prev = vc->video_encoder_coded_used;
        vc->video_encoder_vp8_quality_prev = vc->video_encoder_vp8_quality;
        vc->video_rc_max_quantizer_prev = vc->video_rc_max_quantizer;
        vc->video_rc_min_quantizer_prev = vc->video_rc_min_quantizer;
        vc->video_keyframe_method_prev = vc->video_keyframe_method;

        // VP8 needs this in kilobits per second!
        cfg.rc_target_bitrate = (bit_rate / 1000);
        cfg.g_w = width;
        cfg.g_h = height;


        if (vc->video_encoder_coded_used != TOXAV_ENCODER_CODEC_USED_VP9) {
            // LOGGER_WARNING(vc->log, "Using VP8 codec for encoder");

#ifdef VIDEO_CODEC_ENCODER_USE_FRAGMENTS
            rc = vpx_codec_enc_init(&new_c, VIDEO_CODEC_ENCODER_INTERFACE_VP8, &cfg,
                                    VPX_CODEC_USE_FRAME_THREADING | VPX_CODEC_USE_OUTPUT_PARTITION);
#else
            rc = vpx_codec_enc_init(&new_c, VIDEO_CODEC_ENCODER_INTERFACE_VP8, &cfg,
                                    VPX_CODEC_USE_FRAME_THREADING);
#endif
        } else {
            // LOGGER_WARNING(vc->log, "Using VP9 codec for encoder");
            rc = vpx_codec_enc_init(&new_c, VIDEO_CODEC_ENCODER_INTERFACE_VP9, &cfg, VPX_CODEC_USE_FRAME_THREADING);
        }

        if (rc != VPX_CODEC_OK) {
            // LOGGER_ERROR(vc->log, "Failed to initialize encoder: %s", vpx_codec_err_to_string(rc));
            return -1;
        }


#if 0
        rc = vpx_codec_control(&new_c, VP8E_SET_ENABLEAUTOALTREF, 0);

        if (rc != VPX_CODEC_OK) {
            // LOGGER_ERROR(vc->log, "(b)Failed to set encoder VP8E_SET_ENABLEAUTOALTREF setting: %s value=%d",
            //              vpx_codec_err_to_string(rc),
            //              (int)1);
            vpx_codec_destroy(&new_c);
            return -1;
        } else {
            // LOGGER_WARNING(vc->log, "(b)set encoder VP8E_SET_ENABLEAUTOALTREF setting: %s value=%d", vpx_codec_err_to_string(rc),
            //                (int)1);
        }

#endif

        /*
        encoder->Control(VP8E_SET_ARNR_MAXFRAMES, 7);
        encoder->Control(VP8E_SET_ARNR_STRENGTH, 5);
        encoder->Control(VP8E_SET_ARNR_TYPE, 3);
        */

        /*
        Codec control function to set Max data rate for Intra frames.
        This value controls additional clamping on the maximum size of a keyframe. It is expressed as a percentage of the average per-frame bitrate, with the special (and default) value 0 meaning unlimited, or no additional clamping beyond the codec's built-in algorithm.
        For example, to allocate no more than 4.5 frames worth of bitrate to a keyframe, set this to 450.
        Supported in codecs: VP8, VP9
        */
        uint32_t rc_max_intra_target; // = MaxIntraTarget(250);
        rc_max_intra_target = 200;
        rc = vpx_codec_control(&new_c, VP8E_SET_MAX_INTRA_BITRATE_PCT, rc_max_intra_target);

        if (rc != VPX_CODEC_OK) {
            // LOGGER_ERROR(vc->log, "(b)Failed to set encoder VP8E_SET_MAX_INTRA_BITRATE_PCT setting: %s value=%d",
            //              vpx_codec_err_to_string(rc),
            //              (int)rc_max_intra_target);
            vpx_codec_destroy(&new_c);
            return -1;
        } else {
            // LOGGER_WARNING(vc->log, "(b)set encoder VP8E_SET_MAX_INTRA_BITRATE_PCT setting: %s value=%d",
            //                vpx_codec_err_to_string(rc),
            //                (int)rc_max_intra_target);
        }


        /*
        Codec control function to set max data rate for Inter frames.
        This value controls additional clamping on the maximum size of an inter frame. It is expressed as a percentage of the average per-frame bitrate, with the special (and default) value 0 meaning unlimited, or no additional clamping beyond the codec's built-in algorithm.
        For example, to allow no more than 4.5 frames worth of bitrate to an inter frame, set this to 450.
        Supported in codecs: VP9

        VP9E_SET_MAX_INTER_BITRATE_PCT
        */


        int cpu_used_value = vc->video_encoder_cpu_used;

        if (vc->video_encoder_coded_used == TOXAV_ENCODER_CODEC_USED_VP9) {
            if (cpu_used_value < -8) {
                cpu_used_value = -8;
            } else if (cpu_used_value > 8) {
                cpu_used_value = 8; // set to default (fastest) value
            }
        }

        rc = vpx_codec_control(&new_c, VP8E_SET_CPUUSED, cpu_used_value);

        if (rc != VPX_CODEC_OK) {
            // LOGGER_ERROR(vc->log, "(b)Failed to set encoder VP8E_SET_CPUUSED setting: %s value=%d", vpx_codec_err_to_string(rc),
            //              (int)cpu_used_value);
            vpx_codec_destroy(&new_c);
            return -1;
        } else {
            // LOGGER_WARNING(vc->log, "(b)set encoder VP8E_SET_CPUUSED setting: %s value=%d", vpx_codec_err_to_string(rc),
            //                (int)cpu_used_value);
        }

        vc->video_encoder_cpu_used = cpu_used_value;
        vc->video_encoder_cpu_used_prev = cpu_used_value;

#ifdef VIDEO_CODEC_ENCODER_USE_FRAGMENTS

        if (vc->video_encoder_coded_used != TOXAV_ENCODER_CODEC_USED_VP9) {
            rc = vpx_codec_control(&new_c, VP8E_SET_TOKEN_PARTITIONS, VIDEO_CODEC_FRAGMENT_VPX_NUMS);

            if (rc != VPX_CODEC_OK) {
                // LOGGER_ERROR(vc->log, "Failed to set encoder token partitions: %s", vpx_codec_err_to_string(rc));
            }
        }

#endif

        if (vc->video_encoder_coded_used == TOXAV_ENCODER_CODEC_USED_VP9) {
            rc = vpx_codec_control(&new_c, VP9E_SET_TILE_COLUMNS, VIDEO__VP9E_SET_TILE_COLUMNS);

            if (rc != VPX_CODEC_OK) {
                // LOGGER_ERROR(vc->log, "Failed to set encoder control setting: %s", vpx_codec_err_to_string(rc));
                vpx_codec_destroy(&new_c);
                return -1;
            }

            rc = vpx_codec_control(&new_c, VP9E_SET_TILE_ROWS, VIDEO__VP9E_SET_TILE_ROWS);

            if (rc != VPX_CODEC_OK) {
                // LOGGER_ERROR(vc->log, "Failed to set encoder control setting: %s", vpx_codec_err_to_string(rc));
                vpx_codec_destroy(&new_c);
                return -1;
            }
        }

        vpx_codec_destroy(vc->encoder);
        memcpy(vc->encoder, &new_c, sizeof(new_c));
    }

    return 0;
}



void decode_frame_vpx(VCSession *vc, Tox *tox, uint8_t skip_video_flag, uint64_t *a_r_timestamp,
                      uint64_t *a_l_timestamp,
                      uint64_t *v_r_timestamp, uint64_t *v_l_timestamp,
                      const struct RTPHeader *header_v3,
                      struct RTPMessage *p, vpx_codec_err_t rc,
                      uint32_t full_data_len,
                      uint8_t *ret_value)
{



    long decoder_soft_dealine_value_used = VPX_DL_REALTIME;
    void *user_priv = NULL;

    if (header_v3->frame_record_timestamp > 0) {

        // TODO: calculate real play delay for VPX codec also!!
        // vc->video_play_delay_real = vc->video_play_delay;

#ifdef VIDEO_CODEC_ENCODER_USE_FRAGMENTS
        // --- //
#else

#ifdef VIDEO_PTS_TIMESTAMPS
        struct vpx_frame_user_data *vpx_u_data = calloc(1, sizeof(struct vpx_frame_user_data));
        vpx_u_data->record_timestamp = header_v3->frame_record_timestamp;
        user_priv = vpx_u_data;
#endif

#endif
    }

    if ((int)rb_size((RingBuffer *)vc->vbuf_raw) > (int)VIDEO_RINGBUFFER_FILL_THRESHOLD) {
        rc = vpx_codec_decode(vc->decoder, p->data, full_data_len, user_priv, VPX_DL_REALTIME);
        LOGGER_API_DEBUG(tox, "skipping:REALTIME");
    }

#ifdef VIDEO_DECODER_SOFT_DEADLINE_AUTOTUNE
    else {
        long decode_time_auto_tune = MAX_DECODE_TIME_US;

        if (vc->last_decoded_frame_ts > 0) {

            // calc mean value
            decode_time_auto_tune = 0;

            for (int k = 0; k < VIDEO_DECODER_SOFT_DEADLINE_AUTOTUNE_ENTRIES; k++) {
                decode_time_auto_tune = decode_time_auto_tune + vc->decoder_soft_deadline[k];
            }

            decode_time_auto_tune = decode_time_auto_tune / VIDEO_DECODER_SOFT_DEADLINE_AUTOTUNE_ENTRIES;

            if (decode_time_auto_tune > (1000000 / VIDEO_DECODER_MINFPS_AUTOTUNE)) {
                decode_time_auto_tune = (1000000 / VIDEO_DECODER_MINFPS_AUTOTUNE);
            }

            if (decode_time_auto_tune > (VIDEO_DECODER_LEEWAY_IN_MS_AUTOTUNE * 1000)) {
                decode_time_auto_tune = decode_time_auto_tune - (VIDEO_DECODER_LEEWAY_IN_MS_AUTOTUNE * 1000); // give x ms more room
            }
        }

        decoder_soft_dealine_value_used = decode_time_auto_tune;
        rc = vpx_codec_decode(vc->decoder, p->data, full_data_len, user_priv, (long)decode_time_auto_tune);

        LOGGER_API_DEBUG(tox, "AUTOTUNE:MAX_DECODE_TIME_US=%ld us = %.1f fps", (long)decode_time_auto_tune,
                     (double)(1000000.0f / decode_time_auto_tune));
    }

#else
    else {
        decoder_soft_dealine_value_used = MAX_DECODE_TIME_US;
        rc = vpx_codec_decode(vc->decoder, p->data, full_data_len, user_priv, MAX_DECODE_TIME_US);
    }

#endif



#ifdef VIDEO_DECODER_AUTOSWITCH_CODEC

    if (rc != VPX_CODEC_OK) {
        if ((rc == VPX_CODEC_CORRUPT_FRAME) || (rc == VPX_CODEC_UNSUP_BITSTREAM)) {
            // LOGGER_ERROR(vc->log, "Error decoding video: VPX_CODEC_CORRUPT_FRAME or VPX_CODEC_UNSUP_BITSTREAM");
        } else {
            // LOGGER_ERROR(vc->log, "Error decoding video: err-num=%d err-str=%s", (int)rc, vpx_codec_err_to_string(rc));
        }
    }

#else

    if (rc != VPX_CODEC_OK) {
        if (rc == VPX_CODEC_CORRUPT_FRAME) {
            LOGGER_API_WARNING(tox, "Corrupt frame detected: data size=%d start byte=%d end byte=%d",
                           (int)full_data_len, (int)p->data[0], (int)p->data[full_data_len - 1]);
        }
    }

#endif

    if (rc == VPX_CODEC_OK) {

#ifdef VIDEO_CODEC_ENCODER_USE_FRAGMENTS

        int save_current_buf = 0;

        if (header_v3->fragment_num < vc->last_seen_fragment_num) {
            if (vc->flag_end_video_fragment == 0) {
                vc->flag_end_video_fragment = 1;
                save_current_buf = 1;
                vpx_codec_decode(vc->decoder, NULL, 0, user_priv, decoder_soft_dealine_value_used);
            } else {
                vc->flag_end_video_fragment = 0;
            }
        } else {
            if ((long)header_v3->fragment_num == (long)(VIDEO_CODEC_FRAGMENT_NUMS - 1)) {
                vc->flag_end_video_fragment = 1;
                vpx_codec_decode(vc->decoder, NULL, 0, user_priv, decoder_soft_dealine_value_used);
            }
        }

        // push buffer to list
        if (vc->fragment_buf_counter < (uint16_t)(VIDEO_MAX_FRAGMENT_BUFFER_COUNT - 1)) {
            vc->vpx_frames_buf_list[vc->fragment_buf_counter] = p;
            vc->fragment_buf_counter++;
        } else {
            LOGGER_API_WARNING(tox, "mem leak: VIDEO_MAX_FRAGMENT_BUFFER_COUNT");
        }

        vc->last_seen_fragment_num = header_v3->fragment_num;
#endif

        /* Play decoded images */
        vpx_codec_iter_t iter = NULL;
        vpx_image_t *dest = NULL;

        while ((dest = vpx_codec_get_frame(vc->decoder, &iter)) != NULL) {
            // we have a frame, set return code
            *ret_value = 1;

            if (vc->vcb) {

                // what is the audio to video latency?
                //
                if (dest->user_priv != NULL) {
                    uint64_t frame_record_timestamp_vpx = ((struct vpx_frame_user_data *)(dest->user_priv))->record_timestamp;

                    if (frame_record_timestamp_vpx > 0) {
                        *ret_value = 1;

                        if (*v_r_timestamp < frame_record_timestamp_vpx) {
                            *v_r_timestamp = frame_record_timestamp_vpx;
                            *v_l_timestamp = current_time_monotonic(vc->av->toxav_mono_time);
                        }
                    }

                    //
                    // what is the audio to video latency?
                    free(dest->user_priv);
                }

                LOGGER_API_DEBUG(tox, "VIDEO: -FRAME OUT- %p %p %p",
                             (void *)dest->planes[0],
                             (void *)dest->planes[1],
                             (void *)dest->planes[2]);

                vc->vcb(vc->av, vc->friend_number, dest->d_w, dest->d_h,
                        (const uint8_t *)dest->planes[0],
                        (const uint8_t *)dest->planes[1],
                        (const uint8_t *)dest->planes[2],
                        dest->stride[0], dest->stride[1], dest->stride[2], vc->vcb_user_data);
            }

            vpx_img_free(dest); // is this needed? none of the VPx examples show that
        }

#ifdef VIDEO_CODEC_ENCODER_USE_FRAGMENTS

        if (vc->flag_end_video_fragment == 1) {
            uint16_t jk = 0;

            if (save_current_buf == 1) {
                for (jk = 0; jk < (vc->fragment_buf_counter - 1); jk++) {
                    free(vc->vpx_frames_buf_list[jk]);
                    vc->vpx_frames_buf_list[jk] = NULL;
                }

                vc->vpx_frames_buf_list[0] = vc->vpx_frames_buf_list[vc->fragment_buf_counter];
                vc->vpx_frames_buf_list[vc->fragment_buf_counter] = NULL;
                vc->fragment_buf_counter = 1;
            } else {
                for (jk = 0; jk < vc->fragment_buf_counter; jk++) {
                    free(vc->vpx_frames_buf_list[jk]);
                    vc->vpx_frames_buf_list[jk] = NULL;
                }

                vc->fragment_buf_counter = 0;
            }
        }

#else
        free(p);
#endif

    } else {
        free(p);
    }

}


uint32_t encode_frame_vpx(ToxAV *av, uint32_t friend_number, uint16_t width, uint16_t height,
                          const uint8_t *y,
                          const uint8_t *u, const uint8_t *v, ToxAVCall *call,
                          uint64_t *video_frame_record_timestamp,
                          int vpx_encode_flags,
                          x264_nal_t **nal,
                          int *i_frame_size)
{

    vpx_image_t img;
    img.w = img.h = img.d_w = img.d_h = 0;
    vpx_img_alloc(&img, VPX_IMG_FMT_I420, width, height, 0);

    /* I420 "It comprises an NxM Y plane followed by (N/2)x(M/2) V and U planes."
     * http://fourcc.org/yuv.php#IYUV
     */
    memcpy(img.planes[VPX_PLANE_Y], y, width * height);
    memcpy(img.planes[VPX_PLANE_U], u, (width / 2) * (height / 2));
    memcpy(img.planes[VPX_PLANE_V], v, (width / 2) * (height / 2));

#if 0
    uint32_t duration = (ms_to_last_frame * 10) + 1;

    if (duration > 10000) {
        duration = 10000;
    }

#else
    // set to hardcoded 24fps (this is only for vpx internal calculations!!)
    uint32_t duration = (41 * 10); // HINT: 24fps ~= 41ms
#endif

    vpx_codec_err_t vrc = vpx_codec_encode(call->video->encoder, &img,
                                           (int64_t) * video_frame_record_timestamp, duration,
                                           vpx_encode_flags,
                                           VPX_DL_REALTIME);

    vpx_img_free(&img);

    if (vrc != VPX_CODEC_OK) {
        // LOGGER_API_ERROR(tox, "Could not encode video frame: %s\n", vpx_codec_err_to_string(vrc));
        return 1;
    }

    return 0;

}

uint32_t send_frames_vpx(ToxAV *av, uint32_t friend_number, uint16_t width, uint16_t height,
                         const uint8_t *y,
                         const uint8_t *u, const uint8_t *v, ToxAVCall *call,
                         uint64_t *video_frame_record_timestamp,
                         int vpx_encode_flags,
                         x264_nal_t **nal,
                         int *i_frame_size,
                         TOXAV_ERR_SEND_FRAME *rc)
{
    vpx_codec_iter_t iter = NULL;
    const vpx_codec_cx_pkt_t *pkt;

    while ((pkt = vpx_codec_get_cx_data(call->video->encoder, &iter)) != NULL) {
        if (pkt->kind == VPX_CODEC_CX_FRAME_PKT) {
            const int keyframe = (pkt->data.frame.flags & VPX_FRAME_IS_KEY) != 0;

            if (keyframe) {
                call->video->last_sent_keyframe_ts = current_time_monotonic(av->toxav_mono_time);
            }

            if ((pkt->data.frame.flags & VPX_FRAME_IS_FRAGMENT) != 0) {
                // LOGGER_DEBUG(av->m->log, "VPXENC:VPX_FRAME_IS_FRAGMENT:*yes* size=%lld pid=%d\n",
                //              (long long)pkt->data.frame.sz, (int)pkt->data.frame.partition_id);
            } else {
                // LOGGER_DEBUG(av->m->log, "VPXENC:VPX_FRAME_IS_FRAGMENT:-no- size=%lld pid=%d\n",
                //              (long long)pkt->data.frame.sz, (int)pkt->data.frame.partition_id);
            }

            // use the record timestamp that was actually used for this frame
            *video_frame_record_timestamp = (uint64_t)pkt->data.frame.pts;
            // LOGGER_DEBUG(av->m->log, "video packet record time: %llu", *video_frame_record_timestamp);

            // https://www.webmproject.org/docs/webm-sdk/structvpx__codec__cx__pkt.html
            // pkt->data.frame.sz -> size_t
            const uint32_t frame_length_in_bytes = pkt->data.frame.sz;


            int res = rtp_send_data
                      (
                          call->video_rtp,
                          (const uint8_t *)pkt->data.frame.buf,
                          frame_length_in_bytes,
                          keyframe,
                          *video_frame_record_timestamp,
                          (int32_t)pkt->data.frame.partition_id,
                          TOXAV_ENCODER_CODEC_USED_VP8,
                          call->video_bit_rate,
                          call->video->client_video_capture_delay_ms,
                          call->video->video_encoder_frame_orientation_angle,
                          nullptr
                      );

            // LOGGER_DEBUG(av->m->log, "+ _sending_FRAME_TYPE_==%s bytes=%d frame_len=%d", keyframe ? "K" : ".",
            //              (int)pkt->data.frame.sz, (int)frame_length_in_bytes);
            // LOGGER_DEBUG(av->m->log, "+ _sending_FRAME_ b0=%d b1=%d", ((const uint8_t *)pkt->data.frame.buf)[0],
            //              ((const uint8_t *)pkt->data.frame.buf)[1]);

            (*video_frame_record_timestamp)++;

            if (res < 0) {
                // LOGGER_WARNING(av->m->log, "Could not send video frame: %s", strerror(errno));
                *rc = TOXAV_ERR_SEND_FRAME_RTP_FAILED;
                return 1;
            }
        }
    }

    return 0;
}


void vc_kill_vpx(VCSession *vc)
{
    int jk;

    for (jk = 0; jk < vc->fragment_buf_counter; jk++) {
        free(vc->vpx_frames_buf_list[jk]);
        vc->vpx_frames_buf_list[jk] = NULL;
    }

    vc->fragment_buf_counter = 0;

    vpx_codec_destroy(vc->encoder);
    vpx_codec_destroy(vc->decoder);
}

/* SPDX-License-Identifier: MIT
 * Copyright © 2020-2024 Charles Gunyon.
 */

#ifdef __cplusplus
#define CMP_NULL nullptr
#else
#define CMP_NULL NULL
#endif /* __cplusplus */

static const uint32_t cmp_version_ = 20;
static const uint32_t cmp_mp_version_ = 5;

enum {
  POSITIVE_FIXNUM_MARKER = 0x00,
  FIXMAP_MARKER          = 0x80,
  FIXARRAY_MARKER        = 0x90,
  FIXSTR_MARKER          = 0xA0,
  NIL_MARKER             = 0xC0,
  FALSE_MARKER           = 0xC2,
  TRUE_MARKER            = 0xC3,
  BIN8_MARKER            = 0xC4,
  BIN16_MARKER           = 0xC5,
  BIN32_MARKER           = 0xC6,
  EXT8_MARKER            = 0xC7,
  EXT16_MARKER           = 0xC8,
  EXT32_MARKER           = 0xC9,
  FLOAT_MARKER           = 0xCA,
  DOUBLE_MARKER          = 0xCB,
  U8_MARKER              = 0xCC,
  U16_MARKER             = 0xCD,
  U32_MARKER             = 0xCE,
  U64_MARKER             = 0xCF,
  S8_MARKER              = 0xD0,
  S16_MARKER             = 0xD1,
  S32_MARKER             = 0xD2,
  S64_MARKER             = 0xD3,
  FIXEXT1_MARKER         = 0xD4,
  FIXEXT2_MARKER         = 0xD5,
  FIXEXT4_MARKER         = 0xD6,
  FIXEXT8_MARKER         = 0xD7,
  FIXEXT16_MARKER        = 0xD8,
  STR8_MARKER            = 0xD9,
  STR16_MARKER           = 0xDA,
  STR32_MARKER           = 0xDB,
  ARRAY16_MARKER         = 0xDC,
  ARRAY32_MARKER         = 0xDD,
  MAP16_MARKER           = 0xDE,
  MAP32_MARKER           = 0xDF,
  NEGATIVE_FIXNUM_MARKER = 0xE0
};

enum {
  FIXARRAY_SIZE = 0xF,
  FIXMAP_SIZE   = 0xF,
  FIXSTR_SIZE   = 0x1F
};

typedef enum cmp_error_t {
  CMP_ERROR_NONE,
  CMP_ERROR_STR_DATA_LENGTH_TOO_LONG,
  CMP_ERROR_BIN_DATA_LENGTH_TOO_LONG,
  CMP_ERROR_ARRAY_LENGTH_TOO_LONG,
  CMP_ERROR_MAP_LENGTH_TOO_LONG,
  CMP_ERROR_INPUT_VALUE_TOO_LARGE,
  CMP_ERROR_FIXED_VALUE_WRITING,
  CMP_ERROR_TYPE_MARKER_READING,
  CMP_ERROR_TYPE_MARKER_WRITING,
  CMP_ERROR_DATA_READING,
  CMP_ERROR_DATA_WRITING,
  CMP_ERROR_EXT_TYPE_READING,
  CMP_ERROR_EXT_TYPE_WRITING,
  CMP_ERROR_INVALID_TYPE,
  CMP_ERROR_LENGTH_READING,
  CMP_ERROR_LENGTH_WRITING,
  CMP_ERROR_SKIP_DEPTH_LIMIT_EXCEEDED,
  CMP_ERROR_INTERNAL,
  CMP_ERROR_DISABLED_FLOATING_POINT,
  CMP_ERROR_MAX
} cmp_error_t;

static const char *cmp_error_message(cmp_error_t error) {
  switch (error) {
    case CMP_ERROR_NONE:                      return "No Error";
    case CMP_ERROR_STR_DATA_LENGTH_TOO_LONG:  return "Specified string data length is too long (> 0xFFFFFFFF)";
    case CMP_ERROR_BIN_DATA_LENGTH_TOO_LONG:  return "Specified binary data length is too long (> 0xFFFFFFFF)";
    case CMP_ERROR_ARRAY_LENGTH_TOO_LONG:     return "Specified array length is too long (> 0xFFFFFFFF)";
    case CMP_ERROR_MAP_LENGTH_TOO_LONG:       return "Specified map length is too long (> 0xFFFFFFFF)";
    case CMP_ERROR_INPUT_VALUE_TOO_LARGE:     return "Input value is too large";
    case CMP_ERROR_FIXED_VALUE_WRITING:       return "Error writing fixed value";
    case CMP_ERROR_TYPE_MARKER_READING:       return "Error reading type marker";
    case CMP_ERROR_TYPE_MARKER_WRITING:       return "Error writing type marker";
    case CMP_ERROR_DATA_READING:              return "Error reading packed data";
    case CMP_ERROR_DATA_WRITING:              return "Error writing packed data";
    case CMP_ERROR_EXT_TYPE_READING:          return "Error reading ext type";
    case CMP_ERROR_EXT_TYPE_WRITING:          return "Error writing ext type";
    case CMP_ERROR_INVALID_TYPE:              return "Invalid type";
    case CMP_ERROR_LENGTH_READING:            return "Error reading size";
    case CMP_ERROR_LENGTH_WRITING:            return "Error writing size";
    case CMP_ERROR_SKIP_DEPTH_LIMIT_EXCEEDED: return "Depth limit exceeded while skipping";
    case CMP_ERROR_INTERNAL:                  return "Internal error";
    case CMP_ERROR_DISABLED_FLOATING_POINT:   return "Floating point operations disabled";
    case CMP_ERROR_MAX:                       return "Max Error";
  }
  return "";
}

static bool is_bigendian(void) {
#ifdef WORDS_BIGENDIAN
  return WORDS_BIGENDIAN;
#else
  const int32_t i_ = 1;
  const char *i_bytes = (const char *)&i_;
  return *i_bytes == 0;
#endif /* WORDS_BIGENDIAN */
}

static uint16_t be16(uint16_t x) {
  if (!is_bigendian())
    return ((x >> 8) & 0x00ff)
         | ((x << 8) & 0xff00);

  return x;
}

static int16_t sbe16(int16_t x) {
  return (int16_t)be16((uint16_t)x);
}

static uint32_t be32(uint32_t x) {
  if (!is_bigendian())
    return ((uint32_t)be16((uint16_t)(x & 0xffff)) << 16) | (uint32_t)be16((uint16_t)(x >> 16));

  return x;
}

static int32_t sbe32(int32_t x) {
  return (int32_t)be32((uint32_t)x);
}

static uint64_t be64(uint64_t x) {
  if (!is_bigendian())
    return ((uint64_t)be32((uint32_t)(x & 0xffffffff)) << 32) | (uint64_t)be32((uint32_t)(x >> 32));

  return x;
}

static int64_t sbe64(int64_t x) {
  return (int64_t)be64((uint64_t)x);
}

#ifndef CMP_NO_FLOAT
static float decode_befloat(const char *b) {
  float f = 0.0;
  char *fb = (char *)&f;

  if (!is_bigendian()) {
    fb[0] = b[3];
    fb[1] = b[2];
    fb[2] = b[1];
    fb[3] = b[0];
  }
  else {
    fb[0] = b[0];
    fb[1] = b[1];
    fb[2] = b[2];
    fb[3] = b[3];
  }

  return f;
}

static double decode_bedouble(const char *b) {
  double d = 0.0;
  char *db = (char *)&d;

  if (!is_bigendian()) {
    db[0] = b[7];
    db[1] = b[6];
    db[2] = b[5];
    db[3] = b[4];
    db[4] = b[3];
    db[5] = b[2];
    db[6] = b[1];
    db[7] = b[0];
  }
  else {
    db[0] = b[0];
    db[1] = b[1];
    db[2] = b[2];
    db[3] = b[3];
    db[4] = b[4];
    db[5] = b[5];
    db[6] = b[6];
    db[7] = b[7];
  }

  return d;
}
#endif /* CMP_NO_FLOAT */

static bool read_byte(cmp_ctx_t *ctx, uint8_t *x) {
  return ctx->read(ctx, x, sizeof(uint8_t));
}

static bool write_byte(cmp_ctx_t *ctx, uint8_t x) {
  return ctx->write(ctx, &x, sizeof(uint8_t)) == sizeof(uint8_t);
}

static bool skip_bytes(cmp_ctx_t *ctx, size_t count) {
  if (ctx->skip != CMP_NULL) {
    return ctx->skip(ctx, count);
  }
  else {
    size_t i;
    for (i = 0; i < count; ++i) {
      uint8_t floor;
      if (!ctx->read(ctx, &floor, sizeof(uint8_t))) {
        return false;
      }
    }

    return true;
  }
}

static bool read_type_marker(cmp_ctx_t *ctx, uint8_t *marker) {
  if (read_byte(ctx, marker)) {
    return true;
  }

  ctx->error = CMP_ERROR_TYPE_MARKER_READING;
  return false;
}

static bool write_type_marker(cmp_ctx_t *ctx, uint8_t marker) {
  if (write_byte(ctx, marker))
    return true;

  ctx->error = CMP_ERROR_TYPE_MARKER_WRITING;
  return false;
}

static bool write_fixed_value(cmp_ctx_t *ctx, uint8_t value) {
  if (write_byte(ctx, value))
    return true;

  ctx->error = CMP_ERROR_FIXED_VALUE_WRITING;
  return false;
}

static bool type_marker_to_cmp_type(uint8_t type_marker, uint8_t *cmp_type) {
  if (type_marker <= 0x7F) {
    *cmp_type = CMP_TYPE_POSITIVE_FIXNUM;
    return true;
  }

  if (type_marker <= 0x8F) {
    *cmp_type = CMP_TYPE_FIXMAP;
    return true;
  }

  if (type_marker <= 0x9F) {
    *cmp_type = CMP_TYPE_FIXARRAY;
    return true;
  }

  if (type_marker <= 0xBF) {
    *cmp_type = CMP_TYPE_FIXSTR;
    return true;
  }

  if (type_marker >= 0xE0) {
    *cmp_type = CMP_TYPE_NEGATIVE_FIXNUM;
    return true;
  }

  switch (type_marker) {
    case NIL_MARKER: {
      *cmp_type = CMP_TYPE_NIL;
      return true;
    }
    case FALSE_MARKER: {
      *cmp_type = CMP_TYPE_BOOLEAN;
      return true;
    }
    case TRUE_MARKER: {
      *cmp_type = CMP_TYPE_BOOLEAN;
      return true;
    }
    case BIN8_MARKER: {
      *cmp_type = CMP_TYPE_BIN8;
      return true;
    }
    case BIN16_MARKER: {
      *cmp_type = CMP_TYPE_BIN16;
      return true;
    }
    case BIN32_MARKER: {
      *cmp_type = CMP_TYPE_BIN32;
      return true;
    }
    case EXT8_MARKER: {
      *cmp_type = CMP_TYPE_EXT8;
      return true;
    }
    case EXT16_MARKER: {
      *cmp_type = CMP_TYPE_EXT16;
      return true;
    }
    case EXT32_MARKER: {
      *cmp_type = CMP_TYPE_EXT32;
      return true;
    }
    case FLOAT_MARKER: {
      *cmp_type = CMP_TYPE_FLOAT;
      return true;
    }
    case DOUBLE_MARKER: {
      *cmp_type = CMP_TYPE_DOUBLE;
      return true;
    }
    case U8_MARKER: {
      *cmp_type = CMP_TYPE_UINT8;
      return true;
    }
    case U16_MARKER: {
      *cmp_type = CMP_TYPE_UINT16;
      return true;
    }
    case U32_MARKER: {
      *cmp_type = CMP_TYPE_UINT32;
      return true;
    }
    case U64_MARKER: {
      *cmp_type = CMP_TYPE_UINT64;
      return true;
    }
    case S8_MARKER: {
      *cmp_type = CMP_TYPE_SINT8;
      return true;
    }
    case S16_MARKER: {
      *cmp_type = CMP_TYPE_SINT16;
      return true;
    }
    case S32_MARKER: {
      *cmp_type = CMP_TYPE_SINT32;
      return true;
    }
    case S64_MARKER: {
      *cmp_type = CMP_TYPE_SINT64;
      return true;
    }
    case FIXEXT1_MARKER: {
      *cmp_type = CMP_TYPE_FIXEXT1;
      return true;
    }
    case FIXEXT2_MARKER: {
      *cmp_type = CMP_TYPE_FIXEXT2;
      return true;
    }
    case FIXEXT4_MARKER: {
      *cmp_type = CMP_TYPE_FIXEXT4;
      return true;
    }
    case FIXEXT8_MARKER: {
      *cmp_type = CMP_TYPE_FIXEXT8;
      return true;
    }
    case FIXEXT16_MARKER: {
      *cmp_type = CMP_TYPE_FIXEXT16;
      return true;
    }
    case STR8_MARKER: {
      *cmp_type = CMP_TYPE_STR8;
      return true;
    }
    case STR16_MARKER: {
      *cmp_type = CMP_TYPE_STR16;
      return true;
    }
    case STR32_MARKER: {
      *cmp_type = CMP_TYPE_STR32;
      return true;
    }
    case ARRAY16_MARKER: {
      *cmp_type = CMP_TYPE_ARRAY16;
      return true;
    }
    case ARRAY32_MARKER: {
      *cmp_type = CMP_TYPE_ARRAY32;
      return true;
    }
    case MAP16_MARKER: {
      *cmp_type = CMP_TYPE_MAP16;
      return true;
    }
    case MAP32_MARKER: {
      *cmp_type = CMP_TYPE_MAP32;
      return true;
    }
    default: {
      return false;
    }
  }
}

static bool read_type_size(cmp_ctx_t *ctx, uint8_t type_marker,
                                           uint8_t cmp_type,
                                           uint32_t *size) {
  uint8_t u8temp = 0;
  uint16_t u16temp = 0;
  uint32_t u32temp = 0;

  switch (cmp_type) {
    case CMP_TYPE_POSITIVE_FIXNUM: {
      *size = 0;
      return true;
    }
    case CMP_TYPE_FIXMAP: {
      *size = type_marker & FIXMAP_SIZE;
      return true;
    }
    case CMP_TYPE_FIXARRAY: {
      *size = type_marker & FIXARRAY_SIZE;
      return true;
    }
    case CMP_TYPE_FIXSTR: {
      *size = type_marker & FIXSTR_SIZE;
      return true;
    }
    case CMP_TYPE_NIL: {
      *size = 0;
      return true;
    }
    case CMP_TYPE_BOOLEAN: {
      *size = 0;
      return true;
    }
    case CMP_TYPE_BIN8: {
      if (!ctx->read(ctx, &u8temp, sizeof(uint8_t))) {
        ctx->error = CMP_ERROR_LENGTH_READING;
        return false;
      }
      *size = u8temp;
      return true;
    }
    case CMP_TYPE_BIN16: {
      if (!ctx->read(ctx, &u16temp, sizeof(uint16_t))) {
        ctx->error = CMP_ERROR_LENGTH_READING;
        return false;
      }
      *size = be16(u16temp);
      return true;
    }
    case CMP_TYPE_BIN32: {
      if (!ctx->read(ctx, &u32temp, sizeof(uint32_t))) {
        ctx->error = CMP_ERROR_LENGTH_READING;
        return false;
      }
      *size = be32(u32temp);
      return true;
    }
    case CMP_TYPE_EXT8: {
      if (!ctx->read(ctx, &u8temp, sizeof(uint8_t))) {
        ctx->error = CMP_ERROR_LENGTH_READING;
        return false;
      }
      *size = u8temp;
      return true;
    }
    case CMP_TYPE_EXT16: {
      if (!ctx->read(ctx, &u16temp, sizeof(uint16_t))) {
        ctx->error = CMP_ERROR_LENGTH_READING;
        return false;
      }
      *size = be16(u16temp);
      return true;
    }
    case CMP_TYPE_EXT32: {
      if (!ctx->read(ctx, &u32temp, sizeof(uint32_t))) {
        ctx->error = CMP_ERROR_LENGTH_READING;
        return false;
      }
      *size = be32(u32temp);
      return true;
    }
    case CMP_TYPE_FLOAT: {
      *size = 4;
      return true;
    }
    case CMP_TYPE_DOUBLE: {
      *size = 8;
      return true;
    }
    case CMP_TYPE_UINT8: {
      *size = 1;
      return true;
    }
    case CMP_TYPE_UINT16: {
      *size = 2;
      return true;
    }
    case CMP_TYPE_UINT32: {
      *size = 4;
      return true;
    }
    case CMP_TYPE_UINT64: {
      *size = 8;
      return true;
    }
    case CMP_TYPE_SINT8: {
      *size = 1;
      return true;
    }
    case CMP_TYPE_SINT16: {
      *size = 2;
      return true;
    }
    case CMP_TYPE_SINT32: {
      *size = 4;
      return true;
    }
    case CMP_TYPE_SINT64: {
      *size = 8;
      return true;
    }
    case CMP_TYPE_FIXEXT1: {
      *size = 1;
      return true;
    }
    case CMP_TYPE_FIXEXT2: {
      *size = 2;
      return true;
    }
    case CMP_TYPE_FIXEXT4: {
      *size = 4;
      return true;
    }
    case CMP_TYPE_FIXEXT8: {
      *size = 8;
      return true;
    }
    case CMP_TYPE_FIXEXT16: {
      *size = 16;
      return true;
    }
    case CMP_TYPE_STR8: {
      if (!ctx->read(ctx, &u8temp, sizeof(uint8_t))) {
        ctx->error = CMP_ERROR_DATA_READING;
        return false;
      }
      *size = u8temp;
      return true;
    }
    case CMP_TYPE_STR16: {
      if (!ctx->read(ctx, &u16temp, sizeof(uint16_t))) {
        ctx->error = CMP_ERROR_DATA_READING;
        return false;
      }
      *size = be16(u16temp);
      return true;
    }
    case CMP_TYPE_STR32: {
      if (!ctx->read(ctx, &u32temp, sizeof(uint32_t))) {
        ctx->error = CMP_ERROR_DATA_READING;
        return false;
      }
      *size = be32(u32temp);
      return true;
    }
    case CMP_TYPE_ARRAY16: {
      if (!ctx->read(ctx, &u16temp, sizeof(uint16_t))) {
        ctx->error = CMP_ERROR_DATA_READING;
        return false;
      }
      *size = be16(u16temp);
      return true;
    }
    case CMP_TYPE_ARRAY32: {
      if (!ctx->read(ctx, &u32temp, sizeof(uint32_t))) {
        ctx->error = CMP_ERROR_DATA_READING;
        return false;
      }
      *size = be32(u32temp);
      return true;
    }
    case CMP_TYPE_MAP16: {
      if (!ctx->read(ctx, &u16temp, sizeof(uint16_t))) {
        ctx->error = CMP_ERROR_DATA_READING;
        return false;
      }
      *size = be16(u16temp);
      return true;
    }
    case CMP_TYPE_MAP32: {
      if (!ctx->read(ctx, &u32temp, sizeof(uint32_t))) {
        ctx->error = CMP_ERROR_DATA_READING;
        return false;
      }
      *size = be32(u32temp);
      return true;
    }
    case CMP_TYPE_NEGATIVE_FIXNUM: {
      *size = 0;
      return true;
    }
    default: {
      ctx->error = CMP_ERROR_INVALID_TYPE;
      return false;
    }
  }
}

static bool read_obj_data(cmp_ctx_t *ctx, uint8_t type_marker,
                                          cmp_object_t *obj) {
  switch (obj->type) {
    case CMP_TYPE_POSITIVE_FIXNUM: {
      obj->as.u8 = type_marker;
      return true;
    }
    case CMP_TYPE_NEGATIVE_FIXNUM: {
      obj->as.s8 = (int8_t)type_marker;
      return true;
    }
    case CMP_TYPE_NIL: {
      obj->as.u8 = 0;
      return true;
    }
    case CMP_TYPE_BOOLEAN: {
      switch (type_marker) {
        case TRUE_MARKER: {
          obj->as.boolean = true;
          return true;
        }
        case FALSE_MARKER: {
          obj->as.boolean = false;
          return true;
        }
        default:
          break;
      }
      ctx->error = CMP_ERROR_INTERNAL;
      return false;
    }
    case CMP_TYPE_UINT8: {
      if (!ctx->read(ctx, &obj->as.u8, sizeof(uint8_t))) {
        ctx->error = CMP_ERROR_DATA_READING;
        return false;
      }
      return true;
    }
    case CMP_TYPE_UINT16: {
      if (!ctx->read(ctx, &obj->as.u16, sizeof(uint16_t))) {
        ctx->error = CMP_ERROR_DATA_READING;
        return false;
      }
      obj->as.u16 = be16(obj->as.u16);
      return true;
    }
    case CMP_TYPE_UINT32: {
      if (!ctx->read(ctx, &obj->as.u32, sizeof(uint32_t))) {
        ctx->error = CMP_ERROR_DATA_READING;
        return false;
      }
      obj->as.u32 = be32(obj->as.u32);
      return true;
    }
    case CMP_TYPE_UINT64: {
      if (!ctx->read(ctx, &obj->as.u64, sizeof(uint64_t))) {
        ctx->error = CMP_ERROR_DATA_READING;
        return false;
      }
      obj->as.u64 = be64(obj->as.u64);
      return true;
    }
    case CMP_TYPE_SINT8: {
      if (!ctx->read(ctx, &obj->as.s8, sizeof(int8_t))) {
        ctx->error = CMP_ERROR_DATA_READING;
        return false;
      }
      return true;
    }
    case CMP_TYPE_SINT16: {
      if (!ctx->read(ctx, &obj->as.s16, sizeof(int16_t))) {
        ctx->error = CMP_ERROR_DATA_READING;
        return false;
      }
      obj->as.s16 = sbe16(obj->as.s16);
      return true;
    }
    case CMP_TYPE_SINT32: {
      if (!ctx->read(ctx, &obj->as.s32, sizeof(int32_t))) {
        ctx->error = CMP_ERROR_DATA_READING;
        return false;
      }
      obj->as.s32 = sbe32(obj->as.s32);
      return true;
    }
    case CMP_TYPE_SINT64: {
      if (!ctx->read(ctx, &obj->as.s64, sizeof(int64_t))) {
        ctx->error = CMP_ERROR_DATA_READING;
        return false;
      }
      obj->as.s64 = sbe64(obj->as.s64);
      return true;
    }
    case CMP_TYPE_FLOAT: {
#ifndef CMP_NO_FLOAT
      char bytes[4];

      if (!ctx->read(ctx, bytes, 4)) {
        ctx->error = CMP_ERROR_DATA_READING;
        return false;
      }
      obj->as.flt = decode_befloat(bytes);
      return true;
#else /* CMP_NO_FLOAT */
      ctx->error = CMP_ERROR_DISABLED_FLOATING_POINT;
      return false;
#endif /* CMP_NO_FLOAT */
    }
    case CMP_TYPE_DOUBLE: {
#ifndef CMP_NO_FLOAT
      char bytes[8];

      if (!ctx->read(ctx, bytes, 8)) {
        ctx->error = CMP_ERROR_DATA_READING;
        return false;
      }
      obj->as.dbl = decode_bedouble(bytes);
      return true;
#else /* CMP_NO_FLOAT */
      ctx->error = CMP_ERROR_DISABLED_FLOATING_POINT;
      return false;
#endif /* CMP_NO_FLOAT */
    }
    case CMP_TYPE_BIN8:
    case CMP_TYPE_BIN16:
    case CMP_TYPE_BIN32:
      return read_type_size(ctx, type_marker, obj->type, &obj->as.bin_size);
    case CMP_TYPE_FIXSTR:
    case CMP_TYPE_STR8:
    case CMP_TYPE_STR16:
    case CMP_TYPE_STR32:
      return read_type_size(ctx, type_marker, obj->type, &obj->as.str_size);
    case CMP_TYPE_FIXARRAY:
    case CMP_TYPE_ARRAY16:
    case CMP_TYPE_ARRAY32:
      return read_type_size(ctx, type_marker, obj->type, &obj->as.array_size);
    case CMP_TYPE_FIXMAP:
    case CMP_TYPE_MAP16:
    case CMP_TYPE_MAP32:
      return read_type_size(ctx, type_marker, obj->type, &obj->as.map_size);
    case CMP_TYPE_FIXEXT1: {
      if (!ctx->read(ctx, &obj->as.ext.type, sizeof(int8_t))) {
        ctx->error = CMP_ERROR_EXT_TYPE_READING;
        return false;
      }
      obj->as.ext.size = 1;
      return true;
    }
    case CMP_TYPE_FIXEXT2: {
      if (!ctx->read(ctx, &obj->as.ext.type, sizeof(int8_t))) {
        ctx->error = CMP_ERROR_EXT_TYPE_READING;
        return false;
      }
      obj->as.ext.size = 2;
      return true;
    }
    case CMP_TYPE_FIXEXT4: {
      if (!ctx->read(ctx, &obj->as.ext.type, sizeof(int8_t))) {
        ctx->error = CMP_ERROR_EXT_TYPE_READING;
        return false;
      }
      obj->as.ext.size = 4;
      return true;
    }
    case CMP_TYPE_FIXEXT8: {
      if (!ctx->read(ctx, &obj->as.ext.type, sizeof(int8_t))) {
        ctx->error = CMP_ERROR_EXT_TYPE_READING;
        return false;
      }
      obj->as.ext.size = 8;
      return true;
    }
    case CMP_TYPE_FIXEXT16: {
      if (!ctx->read(ctx, &obj->as.ext.type, sizeof(int8_t))) {
        ctx->error = CMP_ERROR_EXT_TYPE_READING;
        return false;
      }
      obj->as.ext.size = 16;
      return true;
    }
    case CMP_TYPE_EXT8: {
      if (!read_type_size(ctx, type_marker, obj->type, &obj->as.ext.size)) {
        return false;
      }
      if (!ctx->read(ctx, &obj->as.ext.type, sizeof(int8_t))) {
        ctx->error = CMP_ERROR_EXT_TYPE_READING;
        return false;
      }
      return true;
    }
    case CMP_TYPE_EXT16: {
      if (!read_type_size(ctx, type_marker, obj->type, &obj->as.ext.size)) {
        return false;
      }
      if (!ctx->read(ctx, &obj->as.ext.type, sizeof(int8_t))) {
        ctx->error = CMP_ERROR_EXT_TYPE_READING;
        return false;
      }
      return true;
    }
    case CMP_TYPE_EXT32: {
      if (!read_type_size(ctx, type_marker, obj->type, &obj->as.ext.size)) {
        return false;
      }
      if (!ctx->read(ctx, &obj->as.ext.type, sizeof(int8_t))) {
        ctx->error = CMP_ERROR_EXT_TYPE_READING;
        return false;
      }
      return true;
    }
    default:
      break;
  }

  ctx->error = CMP_ERROR_INVALID_TYPE;
  return false;
}

void cmp_init(cmp_ctx_t *ctx, void *buf, cmp_reader *read,
                                         cmp_skipper *skip,
                                         cmp_writer *write) {
  ctx->error = CMP_ERROR_NONE;
  ctx->buf = buf;
  ctx->read = read;
  ctx->skip = skip;
  ctx->write = write;
}

uint32_t cmp_version(void) {
  return cmp_version_;
}

uint32_t cmp_mp_version(void) {
  return cmp_mp_version_;
}

const char* cmp_strerror(const cmp_ctx_t *ctx) {
  if (ctx->error > CMP_ERROR_NONE && ctx->error < CMP_ERROR_MAX)
    return cmp_error_message((cmp_error_t)ctx->error);
  return "";
}

bool cmp_write_pfix(cmp_ctx_t *ctx, uint8_t c) {
  if (c <= 0x7F)
    return write_fixed_value(ctx, c);

  ctx->error = CMP_ERROR_INPUT_VALUE_TOO_LARGE;
  return false;
}

bool cmp_write_nfix(cmp_ctx_t *ctx, int8_t c) {
  if (c >= -32 && c <= -1)
    return write_fixed_value(ctx, (uint8_t)c);

  ctx->error = CMP_ERROR_INPUT_VALUE_TOO_LARGE;
  return false;
}

bool cmp_write_sfix(cmp_ctx_t *ctx, int8_t c) {
  if (c >= 0)
    return cmp_write_pfix(ctx, (uint8_t)c);
  if (c >= -32 && c <= -1)
    return cmp_write_nfix(ctx, c);

  ctx->error = CMP_ERROR_INPUT_VALUE_TOO_LARGE;
  return false;
}

bool cmp_write_s8(cmp_ctx_t *ctx, int8_t c) {
  if (!write_type_marker(ctx, S8_MARKER))
    return false;

  return ctx->write(ctx, &c, sizeof(int8_t)) == sizeof(int8_t);
}

bool cmp_write_s16(cmp_ctx_t *ctx, int16_t s) {
  if (!write_type_marker(ctx, S16_MARKER))
    return false;

  s = sbe16(s);

  return ctx->write(ctx, &s, sizeof(int16_t)) == sizeof(int16_t);
}

bool cmp_write_s32(cmp_ctx_t *ctx, int32_t i) {
  if (!write_type_marker(ctx, S32_MARKER))
    return false;

  i = sbe32(i);

  return ctx->write(ctx, &i, sizeof(int32_t)) == sizeof(int32_t);
}

bool cmp_write_s64(cmp_ctx_t *ctx, int64_t l) {
  if (!write_type_marker(ctx, S64_MARKER))
    return false;

  l = sbe64(l);

  return ctx->write(ctx, &l, sizeof(int64_t)) == sizeof(int64_t);
}

bool cmp_write_integer(cmp_ctx_t *ctx, int64_t d) {
  if (d >= 0)
    return cmp_write_uinteger(ctx, (uint64_t)d);
  if (d >= -0x20)
    return cmp_write_nfix(ctx, (int8_t)d);
  if (d >= -0x80)
    return cmp_write_s8(ctx, (int8_t)d);
  if (d >= -0x8000)
    return cmp_write_s16(ctx, (int16_t)d);
  if (d >= -INT64_C(0x80000000))
    return cmp_write_s32(ctx, (int32_t)d);

  return cmp_write_s64(ctx, d);
}

bool cmp_write_ufix(cmp_ctx_t *ctx, uint8_t c) {
  return cmp_write_pfix(ctx, c);
}

bool cmp_write_u8(cmp_ctx_t *ctx, uint8_t c) {
  if (!write_type_marker(ctx, U8_MARKER))
    return false;

  return ctx->write(ctx, &c, sizeof(uint8_t)) == sizeof(uint8_t);
}

bool cmp_write_u16(cmp_ctx_t *ctx, uint16_t s) {
  if (!write_type_marker(ctx, U16_MARKER))
    return false;

  s = be16(s);

  return ctx->write(ctx, &s, sizeof(uint16_t)) == sizeof(uint16_t);
}

bool cmp_write_u32(cmp_ctx_t *ctx, uint32_t i) {
  if (!write_type_marker(ctx, U32_MARKER))
    return false;

  i = be32(i);

  return ctx->write(ctx, &i, sizeof(uint32_t)) == sizeof(uint32_t);
}

bool cmp_write_u64(cmp_ctx_t *ctx, uint64_t l) {
  if (!write_type_marker(ctx, U64_MARKER))
    return false;

  l = be64(l);

  return ctx->write(ctx, &l, sizeof(uint64_t)) == sizeof(uint64_t);
}

bool cmp_write_uinteger(cmp_ctx_t *ctx, uint64_t u) {
  if (u <= 0x7F)
    return cmp_write_pfix(ctx, (uint8_t)u);
  if (u <= 0xFF)
    return cmp_write_u8(ctx, (uint8_t)u);
  if (u <= 0xFFFF)
    return cmp_write_u16(ctx, (uint16_t)u);
  if (u <= 0xFFFFFFFF)
    return cmp_write_u32(ctx, (uint32_t)u);

  return cmp_write_u64(ctx, u);
}

#ifndef CMP_NO_FLOAT
bool cmp_write_float(cmp_ctx_t *ctx, float f) {
  if (!write_type_marker(ctx, FLOAT_MARKER))
    return false;

  /*
   * We may need to swap the float's bytes, but we can't just swap them inside
   * the float because the swapped bytes may not constitute a valid float.
   * Therefore, we have to create a buffer and swap the bytes there.
   */
  if (!is_bigendian()) {
    char swapped[sizeof(float)];
    char *fbuf = (char *)&f;

    size_t i;
    for (i = 0; i < sizeof(float); ++i) {
      swapped[i] = fbuf[sizeof(float) - i - 1];
    }

    return ctx->write(ctx, swapped, sizeof(float)) == sizeof(float);
  }

  return ctx->write(ctx, &f, sizeof(float)) == sizeof(float);
}

bool cmp_write_double(cmp_ctx_t *ctx, double d) {
  if (!write_type_marker(ctx, DOUBLE_MARKER))
    return false;

  /* Same deal for doubles */
  if (!is_bigendian()) {
    char swapped[sizeof(double)];
    char *dbuf = (char *)&d;

    size_t i;
    for (i = 0; i < sizeof(double); ++i) {
      swapped[i] = dbuf[sizeof(double) - i - 1];
    }

    return ctx->write(ctx, swapped, sizeof(double)) == sizeof(double);
  }

  return ctx->write(ctx, &d, sizeof(double)) == sizeof(double);
}

bool cmp_write_decimal(cmp_ctx_t *ctx, double d) {
  const float f = (float)d;
  const double df = (double)f;

  if (df == d)
    return cmp_write_float(ctx, f);
  else
    return cmp_write_double(ctx, d);
}
#endif /* CMP_NO_FLOAT */

bool cmp_write_nil(cmp_ctx_t *ctx) {
  return write_type_marker(ctx, NIL_MARKER);
}

bool cmp_write_true(cmp_ctx_t *ctx) {
  return write_type_marker(ctx, TRUE_MARKER);
}

bool cmp_write_false(cmp_ctx_t *ctx) {
  return write_type_marker(ctx, FALSE_MARKER);
}

bool cmp_write_bool(cmp_ctx_t *ctx, bool b) {
  if (b)
    return cmp_write_true(ctx);

  return cmp_write_false(ctx);
}

bool cmp_write_u8_as_bool(cmp_ctx_t *ctx, uint8_t b) {
  return cmp_write_bool(ctx, b != 0);
}

bool cmp_write_fixstr_marker(cmp_ctx_t *ctx, uint8_t size) {
  if (size <= FIXSTR_SIZE)
    return write_fixed_value(ctx, FIXSTR_MARKER | size);

  ctx->error = CMP_ERROR_INPUT_VALUE_TOO_LARGE;
  return false;
}

bool cmp_write_fixstr(cmp_ctx_t *ctx, const char *data, uint8_t size) {
  if (!cmp_write_fixstr_marker(ctx, size))
    return false;

  if (size == 0)
    return true;

  if (ctx->write(ctx, data, size) == size)
    return true;

  ctx->error = CMP_ERROR_DATA_WRITING;
  return false;
}

bool cmp_write_str8_marker(cmp_ctx_t *ctx, uint8_t size) {
  if (!write_type_marker(ctx, STR8_MARKER))
    return false;

  if (ctx->write(ctx, &size, sizeof(uint8_t)) == sizeof(uint8_t))
    return true;

  ctx->error = CMP_ERROR_LENGTH_WRITING;
  return false;
}

bool cmp_write_str8(cmp_ctx_t *ctx, const char *data, uint8_t size) {
  if (!cmp_write_str8_marker(ctx, size))
    return false;

  if (size == 0)
    return true;

  if (ctx->write(ctx, data, size) == size)
    return true;

  ctx->error = CMP_ERROR_DATA_WRITING;
  return false;
}

bool cmp_write_str16_marker(cmp_ctx_t *ctx, uint16_t size) {
  if (!write_type_marker(ctx, STR16_MARKER))
    return false;

  size = be16(size);

  if (ctx->write(ctx, &size, sizeof(uint16_t)) == sizeof(uint16_t))
    return true;

  ctx->error = CMP_ERROR_LENGTH_WRITING;
  return false;
}

bool cmp_write_str16(cmp_ctx_t *ctx, const char *data, uint16_t size) {
  if (!cmp_write_str16_marker(ctx, size))
    return false;

  if (size == 0)
    return true;

  if (ctx->write(ctx, data, size) == size)
    return true;

  ctx->error = CMP_ERROR_DATA_WRITING;
  return false;
}

bool cmp_write_str32_marker(cmp_ctx_t *ctx, uint32_t size) {
  if (!write_type_marker(ctx, STR32_MARKER))
    return false;

  size = be32(size);

  if (ctx->write(ctx, &size, sizeof(uint32_t)) == sizeof(uint32_t))
    return true;

  ctx->error = CMP_ERROR_LENGTH_WRITING;
  return false;
}

bool cmp_write_str32(cmp_ctx_t *ctx, const char *data, uint32_t size) {
  if (!cmp_write_str32_marker(ctx, size))
    return false;

  if (size == 0)
    return true;

  if (ctx->write(ctx, data, size) == size)
    return true;

  ctx->error = CMP_ERROR_DATA_WRITING;
  return false;
}

bool cmp_write_str_marker(cmp_ctx_t *ctx, uint32_t size) {
  if (size <= FIXSTR_SIZE)
    return cmp_write_fixstr_marker(ctx, (uint8_t)size);
  if (size <= 0xFF)
    return cmp_write_str8_marker(ctx, (uint8_t)size);
  if (size <= 0xFFFF)
    return cmp_write_str16_marker(ctx, (uint16_t)size);

  return cmp_write_str32_marker(ctx, size);
}

bool cmp_write_str_marker_v4(cmp_ctx_t *ctx, uint32_t size) {
  if (size <= FIXSTR_SIZE)
    return cmp_write_fixstr_marker(ctx, (uint8_t)size);
  if (size <= 0xFFFF)
    return cmp_write_str16_marker(ctx, (uint16_t)size);

  return cmp_write_str32_marker(ctx, size);
}

bool cmp_write_str(cmp_ctx_t *ctx, const char *data, uint32_t size) {
  if (size <= FIXSTR_SIZE)
    return cmp_write_fixstr(ctx, data, (uint8_t)size);
  if (size <= 0xFF)
    return cmp_write_str8(ctx, data, (uint8_t)size);
  if (size <= 0xFFFF)
    return cmp_write_str16(ctx, data, (uint16_t)size);

  return cmp_write_str32(ctx, data, size);
}

bool cmp_write_str_v4(cmp_ctx_t *ctx, const char *data, uint32_t size) {
  if (size <= FIXSTR_SIZE)
    return cmp_write_fixstr(ctx, data, (uint8_t)size);
  if (size <= 0xFFFF)
    return cmp_write_str16(ctx, data, (uint16_t)size);

  return cmp_write_str32(ctx, data, size);
}

bool cmp_write_bin8_marker(cmp_ctx_t *ctx, uint8_t size) {
  if (!write_type_marker(ctx, BIN8_MARKER))
    return false;

  if (ctx->write(ctx, &size, sizeof(uint8_t)) == sizeof(uint8_t))
    return true;

  ctx->error = CMP_ERROR_LENGTH_WRITING;
  return false;
}

bool cmp_write_bin8(cmp_ctx_t *ctx, const void *data, uint8_t size) {
  if (!cmp_write_bin8_marker(ctx, size))
    return false;

  if (size == 0)
    return true;

  if (ctx->write(ctx, data, size) == size)
    return true;

  ctx->error = CMP_ERROR_DATA_WRITING;
  return false;
}

bool cmp_write_bin16_marker(cmp_ctx_t *ctx, uint16_t size) {
  if (!write_type_marker(ctx, BIN16_MARKER))
    return false;

  size = be16(size);

  if (ctx->write(ctx, &size, sizeof(uint16_t)) == sizeof(uint16_t))
    return true;

  ctx->error = CMP_ERROR_LENGTH_WRITING;
  return false;
}

bool cmp_write_bin16(cmp_ctx_t *ctx, const void *data, uint16_t size) {
  if (!cmp_write_bin16_marker(ctx, size))
    return false;

  if (size == 0)
    return true;

  if (ctx->write(ctx, data, size) == size)
    return true;

  ctx->error = CMP_ERROR_DATA_WRITING;
  return false;
}

bool cmp_write_bin32_marker(cmp_ctx_t *ctx, uint32_t size) {
  if (!write_type_marker(ctx, BIN32_MARKER))
    return false;

  size = be32(size);

  if (ctx->write(ctx, &size, sizeof(uint32_t)) == sizeof(uint32_t))
    return true;

  ctx->error = CMP_ERROR_LENGTH_WRITING;
  return false;
}

bool cmp_write_bin32(cmp_ctx_t *ctx, const void *data, uint32_t size) {
  if (!cmp_write_bin32_marker(ctx, size))
    return false;

  if (size == 0)
    return true;

  if (ctx->write(ctx, data, size) == size)
    return true;

  ctx->error = CMP_ERROR_DATA_WRITING;
  return false;
}

bool cmp_write_bin_marker(cmp_ctx_t *ctx, uint32_t size) {
  if (size <= 0xFF)
    return cmp_write_bin8_marker(ctx, (uint8_t)size);
  if (size <= 0xFFFF)
    return cmp_write_bin16_marker(ctx, (uint16_t)size);

  return cmp_write_bin32_marker(ctx, size);
}

bool cmp_write_bin(cmp_ctx_t *ctx, const void *data, uint32_t size) {
  if (size <= 0xFF)
    return cmp_write_bin8(ctx, data, (uint8_t)size);
  if (size <= 0xFFFF)
    return cmp_write_bin16(ctx, data, (uint16_t)size);

  return cmp_write_bin32(ctx, data, size);
}

bool cmp_write_fixarray(cmp_ctx_t *ctx, uint8_t size) {
  if (size <= FIXARRAY_SIZE)
    return write_fixed_value(ctx, FIXARRAY_MARKER | size);

  ctx->error = CMP_ERROR_INPUT_VALUE_TOO_LARGE;
  return false;
}

bool cmp_write_array16(cmp_ctx_t *ctx, uint16_t size) {
  if (!write_type_marker(ctx, ARRAY16_MARKER))
    return false;

  size = be16(size);

  if (ctx->write(ctx, &size, sizeof(uint16_t)) == sizeof(uint16_t))
    return true;

  ctx->error = CMP_ERROR_LENGTH_WRITING;
  return false;
}

bool cmp_write_array32(cmp_ctx_t *ctx, uint32_t size) {
  if (!write_type_marker(ctx, ARRAY32_MARKER))
    return false;

  size = be32(size);

  if (ctx->write(ctx, &size, sizeof(uint32_t)) == sizeof(uint32_t))
    return true;

  ctx->error = CMP_ERROR_LENGTH_WRITING;
  return false;
}

bool cmp_write_array(cmp_ctx_t *ctx, uint32_t size) {
  if (size <= FIXARRAY_SIZE)
    return cmp_write_fixarray(ctx, (uint8_t)size);
  if (size <= 0xFFFF)
    return cmp_write_array16(ctx, (uint16_t)size);

  return cmp_write_array32(ctx, size);
}

bool cmp_write_fixmap(cmp_ctx_t *ctx, uint8_t size) {
  if (size <= FIXMAP_SIZE)
    return write_fixed_value(ctx, FIXMAP_MARKER | size);

  ctx->error = CMP_ERROR_INPUT_VALUE_TOO_LARGE;
  return false;
}

bool cmp_write_map16(cmp_ctx_t *ctx, uint16_t size) {
  if (!write_type_marker(ctx, MAP16_MARKER))
    return false;

  size = be16(size);

  if (ctx->write(ctx, &size, sizeof(uint16_t)) == sizeof(uint16_t))
    return true;

  ctx->error = CMP_ERROR_LENGTH_WRITING;
  return false;
}

bool cmp_write_map32(cmp_ctx_t *ctx, uint32_t size) {
  if (!write_type_marker(ctx, MAP32_MARKER))
    return false;

  size = be32(size);

  if (ctx->write(ctx, &size, sizeof(uint32_t)) == sizeof(uint32_t))
    return true;

  ctx->error = CMP_ERROR_LENGTH_WRITING;
  return false;
}

bool cmp_write_map(cmp_ctx_t *ctx, uint32_t size) {
  if (size <= FIXMAP_SIZE)
    return cmp_write_fixmap(ctx, (uint8_t)size);
  if (size <= 0xFFFF)
    return cmp_write_map16(ctx, (uint16_t)size);

  return cmp_write_map32(ctx, size);
}

bool cmp_write_fixext1_marker(cmp_ctx_t *ctx, int8_t type) {
  if (!write_type_marker(ctx, FIXEXT1_MARKER))
    return false;

  if (ctx->write(ctx, &type, sizeof(int8_t)) == sizeof(int8_t))
    return true;

  ctx->error = CMP_ERROR_EXT_TYPE_WRITING;
  return false;
}

bool cmp_write_fixext1(cmp_ctx_t *ctx, int8_t type, const void *data) {
  if (!cmp_write_fixext1_marker(ctx, type))
    return false;

  if (ctx->write(ctx, data, 1) == 1)
    return true;

  ctx->error = CMP_ERROR_DATA_WRITING;
  return false;
}

bool cmp_write_fixext2_marker(cmp_ctx_t *ctx, int8_t type) {
  if (!write_type_marker(ctx, FIXEXT2_MARKER))
    return false;

  if (ctx->write(ctx, &type, sizeof(int8_t)) == sizeof(int8_t))
    return true;

  ctx->error = CMP_ERROR_EXT_TYPE_WRITING;
  return false;
}

bool cmp_write_fixext2(cmp_ctx_t *ctx, int8_t type, const void *data) {
  if (!cmp_write_fixext2_marker(ctx, type))
    return false;

  if (ctx->write(ctx, data, 2) == 2)
    return true;

  ctx->error = CMP_ERROR_DATA_WRITING;
  return false;
}

bool cmp_write_fixext4_marker(cmp_ctx_t *ctx, int8_t type) {
  if (!write_type_marker(ctx, FIXEXT4_MARKER))
    return false;

  if (ctx->write(ctx, &type, sizeof(int8_t)) == sizeof(int8_t))
    return true;

  ctx->error = CMP_ERROR_EXT_TYPE_WRITING;
  return false;
}

bool cmp_write_fixext4(cmp_ctx_t *ctx, int8_t type, const void *data) {
  if (!cmp_write_fixext4_marker(ctx, type))
    return false;

  if (ctx->write(ctx, data, 4) == 4)
    return true;

  ctx->error = CMP_ERROR_DATA_WRITING;
  return false;
}

bool cmp_write_fixext8_marker(cmp_ctx_t *ctx, int8_t type) {
  if (!write_type_marker(ctx, FIXEXT8_MARKER))
    return false;

  if (ctx->write(ctx, &type, sizeof(int8_t)) == sizeof(int8_t))
    return true;

  ctx->error = CMP_ERROR_EXT_TYPE_WRITING;
  return false;
}

bool cmp_write_fixext8(cmp_ctx_t *ctx, int8_t type, const void *data) {
  if (!cmp_write_fixext8_marker(ctx, type))
    return false;

  if (ctx->write(ctx, data, 8) == 8)
    return true;

  ctx->error = CMP_ERROR_DATA_WRITING;
  return false;
}

bool cmp_write_fixext16_marker(cmp_ctx_t *ctx, int8_t type) {
  if (!write_type_marker(ctx, FIXEXT16_MARKER))
    return false;

  if (ctx->write(ctx, &type, sizeof(int8_t)) == sizeof(int8_t))
    return true;

  ctx->error = CMP_ERROR_EXT_TYPE_WRITING;
  return false;
}

bool cmp_write_fixext16(cmp_ctx_t *ctx, int8_t type, const void *data) {
  if (!cmp_write_fixext16_marker(ctx, type))
    return false;

  if (ctx->write(ctx, data, 16) == 16)
    return true;

  ctx->error = CMP_ERROR_DATA_WRITING;
  return false;
}

bool cmp_write_ext8_marker(cmp_ctx_t *ctx, int8_t type, uint8_t size) {
  if (!write_type_marker(ctx, EXT8_MARKER))
    return false;

  if (ctx->write(ctx, &size, sizeof(uint8_t)) != sizeof(uint8_t)) {
    ctx->error = CMP_ERROR_LENGTH_WRITING;
    return false;
  }

  if (ctx->write(ctx, &type, sizeof(int8_t)) == sizeof(int8_t))
    return true;

  ctx->error = CMP_ERROR_EXT_TYPE_WRITING;
  return false;
}

bool cmp_write_ext8(cmp_ctx_t *ctx, int8_t type, uint8_t size, const void *data) {
  if (!cmp_write_ext8_marker(ctx, type, size))
    return false;

  if (ctx->write(ctx, data, size) == size)
    return true;

  ctx->error = CMP_ERROR_DATA_WRITING;
  return false;
}

bool cmp_write_ext16_marker(cmp_ctx_t *ctx, int8_t type, uint16_t size) {
  if (!write_type_marker(ctx, EXT16_MARKER))
    return false;

  size = be16(size);

  if (ctx->write(ctx, &size, sizeof(uint16_t)) != sizeof(uint16_t)) {
    ctx->error = CMP_ERROR_LENGTH_WRITING;
    return false;
  }

  if (ctx->write(ctx, &type, sizeof(int8_t)) == sizeof(int8_t))
    return true;

  ctx->error = CMP_ERROR_EXT_TYPE_WRITING;
  return false;
}

bool cmp_write_ext16(cmp_ctx_t *ctx, int8_t type, uint16_t size, const void *data) {
  if (!cmp_write_ext16_marker(ctx, type, size))
    return false;

  if (ctx->write(ctx, data, size) == size)
    return true;

  ctx->error = CMP_ERROR_DATA_WRITING;
  return false;
}

bool cmp_write_ext32_marker(cmp_ctx_t *ctx, int8_t type, uint32_t size) {
  if (!write_type_marker(ctx, EXT32_MARKER))
    return false;

  size = be32(size);

  if (ctx->write(ctx, &size, sizeof(uint32_t)) != sizeof(uint32_t)) {
    ctx->error = CMP_ERROR_LENGTH_WRITING;
    return false;
  }

  if (ctx->write(ctx, &type, sizeof(int8_t)) == sizeof(int8_t))
    return true;

  ctx->error = CMP_ERROR_EXT_TYPE_WRITING;
  return false;
}

bool cmp_write_ext32(cmp_ctx_t *ctx, int8_t type, uint32_t size, const void *data) {
  if (!cmp_write_ext32_marker(ctx, type, size))
    return false;

  if (ctx->write(ctx, data, size) == size)
    return true;

  ctx->error = CMP_ERROR_DATA_WRITING;
  return false;
}

bool cmp_write_ext_marker(cmp_ctx_t *ctx, int8_t type, uint32_t size) {
  if (size == 1)
    return cmp_write_fixext1_marker(ctx, type);
  if (size == 2)
    return cmp_write_fixext2_marker(ctx, type);
  if (size == 4)
    return cmp_write_fixext4_marker(ctx, type);
  if (size == 8)
    return cmp_write_fixext8_marker(ctx, type);
  if (size == 16)
    return cmp_write_fixext16_marker(ctx, type);
  if (size <= 0xFF)
    return cmp_write_ext8_marker(ctx, type, (uint8_t)size);
  if (size <= 0xFFFF)
    return cmp_write_ext16_marker(ctx, type, (uint16_t)size);

  return cmp_write_ext32_marker(ctx, type, size);
}

bool cmp_write_ext(cmp_ctx_t *ctx, int8_t type, uint32_t size, const void *data) {
  if (size == 1)
    return cmp_write_fixext1(ctx, type, data);
  if (size == 2)
    return cmp_write_fixext2(ctx, type, data);
  if (size == 4)
    return cmp_write_fixext4(ctx, type, data);
  if (size == 8)
    return cmp_write_fixext8(ctx, type, data);
  if (size == 16)
    return cmp_write_fixext16(ctx, type, data);
  if (size <= 0xFF)
    return cmp_write_ext8(ctx, type, (uint8_t)size, data);
  if (size <= 0xFFFF)
    return cmp_write_ext16(ctx, type, (uint16_t)size, data);

  return cmp_write_ext32(ctx, type, size, data);
}

bool cmp_write_object(cmp_ctx_t *ctx, const cmp_object_t *obj) {
  switch(obj->type) {
    case CMP_TYPE_POSITIVE_FIXNUM:
      return cmp_write_pfix(ctx, obj->as.u8);
    case CMP_TYPE_FIXMAP:
      return cmp_write_fixmap(ctx, (uint8_t)obj->as.map_size);
    case CMP_TYPE_FIXARRAY:
      return cmp_write_fixarray(ctx, (uint8_t)obj->as.array_size);
    case CMP_TYPE_FIXSTR:
      return cmp_write_fixstr_marker(ctx, (uint8_t)obj->as.str_size);
    case CMP_TYPE_NIL:
      return cmp_write_nil(ctx);
    case CMP_TYPE_BOOLEAN: {
      if (obj->as.boolean)
        return cmp_write_true(ctx);
      return cmp_write_false(ctx);
    }
    case CMP_TYPE_BIN8:
      return cmp_write_bin8_marker(ctx, (uint8_t)obj->as.bin_size);
    case CMP_TYPE_BIN16:
      return cmp_write_bin16_marker(ctx, (uint16_t)obj->as.bin_size);
    case CMP_TYPE_BIN32:
      return cmp_write_bin32_marker(ctx, obj->as.bin_size);
    case CMP_TYPE_EXT8:
      return cmp_write_ext8_marker(
        ctx, obj->as.ext.type, (uint8_t)obj->as.ext.size
      );
    case CMP_TYPE_EXT16:
      return cmp_write_ext16_marker(
        ctx, obj->as.ext.type, (uint16_t)obj->as.ext.size
      );
    case CMP_TYPE_EXT32:
      return cmp_write_ext32_marker(ctx, obj->as.ext.type, obj->as.ext.size);
    case CMP_TYPE_FLOAT: {
#ifndef CMP_NO_FLOAT
      return cmp_write_float(ctx, obj->as.flt);
#else /* CMP_NO_FLOAT */
      ctx->error = CMP_ERROR_DISABLED_FLOATING_POINT;
      return false;
#endif /* CMP_NO_FLOAT */
    }
    case CMP_TYPE_DOUBLE: {
#ifndef CMP_NO_FLOAT
      return cmp_write_double(ctx, obj->as.dbl);
#else /* CMP_NO_FLOAT */
      ctx->error = CMP_ERROR_DISABLED_FLOATING_POINT;
      return false;
#endif /* CMP_NO_FLOAT */
    }
    case CMP_TYPE_UINT8:
      return cmp_write_u8(ctx, obj->as.u8);
    case CMP_TYPE_UINT16:
      return cmp_write_u16(ctx, obj->as.u16);
    case CMP_TYPE_UINT32:
      return cmp_write_u32(ctx, obj->as.u32);
    case CMP_TYPE_UINT64:
      return cmp_write_u64(ctx, obj->as.u64);
    case CMP_TYPE_SINT8:
      return cmp_write_s8(ctx, obj->as.s8);
    case CMP_TYPE_SINT16:
      return cmp_write_s16(ctx, obj->as.s16);
    case CMP_TYPE_SINT32:
      return cmp_write_s32(ctx, obj->as.s32);
    case CMP_TYPE_SINT64:
      return cmp_write_s64(ctx, obj->as.s64);
    case CMP_TYPE_FIXEXT1:
      return cmp_write_fixext1_marker(ctx, obj->as.ext.type);
    case CMP_TYPE_FIXEXT2:
      return cmp_write_fixext2_marker(ctx, obj->as.ext.type);
    case CMP_TYPE_FIXEXT4:
      return cmp_write_fixext4_marker(ctx, obj->as.ext.type);
    case CMP_TYPE_FIXEXT8:
      return cmp_write_fixext8_marker(ctx, obj->as.ext.type);
    case CMP_TYPE_FIXEXT16:
      return cmp_write_fixext16_marker(ctx, obj->as.ext.type);
    case CMP_TYPE_STR8:
      return cmp_write_str8_marker(ctx, (uint8_t)obj->as.str_size);
    case CMP_TYPE_STR16:
      return cmp_write_str16_marker(ctx, (uint16_t)obj->as.str_size);
    case CMP_TYPE_STR32:
      return cmp_write_str32_marker(ctx, obj->as.str_size);
    case CMP_TYPE_ARRAY16:
      return cmp_write_array16(ctx, (uint16_t)obj->as.array_size);
    case CMP_TYPE_ARRAY32:
      return cmp_write_array32(ctx, obj->as.array_size);
    case CMP_TYPE_MAP16:
      return cmp_write_map16(ctx, (uint16_t)obj->as.map_size);
    case CMP_TYPE_MAP32:
      return cmp_write_map32(ctx, obj->as.map_size);
    case CMP_TYPE_NEGATIVE_FIXNUM:
      return cmp_write_nfix(ctx, obj->as.s8);
    default: {
      ctx->error = CMP_ERROR_INVALID_TYPE;
      return false;
    }
  }
}

bool cmp_write_object_v4(cmp_ctx_t *ctx, const cmp_object_t *obj) {
  switch(obj->type) {
    case CMP_TYPE_POSITIVE_FIXNUM:
      return cmp_write_pfix(ctx, obj->as.u8);
    case CMP_TYPE_FIXMAP:
      return cmp_write_fixmap(ctx, (uint8_t)obj->as.map_size);
    case CMP_TYPE_FIXARRAY:
      return cmp_write_fixarray(ctx, (uint8_t)obj->as.array_size);
    case CMP_TYPE_FIXSTR:
      return cmp_write_fixstr_marker(ctx, (uint8_t)obj->as.str_size);
    case CMP_TYPE_NIL:
      return cmp_write_nil(ctx);
    case CMP_TYPE_BOOLEAN: {
      if (obj->as.boolean)
        return cmp_write_true(ctx);
      return cmp_write_false(ctx);
    }
    case CMP_TYPE_EXT8:
      return cmp_write_ext8_marker(ctx, obj->as.ext.type, (uint8_t)obj->as.ext.size);
    case CMP_TYPE_EXT16:
      return cmp_write_ext16_marker(
        ctx, obj->as.ext.type, (uint16_t)obj->as.ext.size
      );
    case CMP_TYPE_EXT32:
      return cmp_write_ext32_marker(ctx, obj->as.ext.type, obj->as.ext.size);
    case CMP_TYPE_FLOAT: {
#ifndef CMP_NO_FLOAT
      return cmp_write_float(ctx, obj->as.flt);
#else /* CMP_NO_FLOAT */
      ctx->error = CMP_ERROR_DISABLED_FLOATING_POINT;
      return false;
#endif /* CMP_NO_FLOAT */
    }
    case CMP_TYPE_DOUBLE: {
#ifndef CMP_NO_FLOAT
      return cmp_write_double(ctx, obj->as.dbl);
#else
      ctx->error = CMP_ERROR_DISABLED_FLOATING_POINT;
      return false;
#endif /* CMP_NO_FLOAT */
    }
    case CMP_TYPE_UINT8:
      return cmp_write_u8(ctx, obj->as.u8);
    case CMP_TYPE_UINT16:
      return cmp_write_u16(ctx, obj->as.u16);
    case CMP_TYPE_UINT32:
      return cmp_write_u32(ctx, obj->as.u32);
    case CMP_TYPE_UINT64:
      return cmp_write_u64(ctx, obj->as.u64);
    case CMP_TYPE_SINT8:
      return cmp_write_s8(ctx, obj->as.s8);
    case CMP_TYPE_SINT16:
      return cmp_write_s16(ctx, obj->as.s16);
    case CMP_TYPE_SINT32:
      return cmp_write_s32(ctx, obj->as.s32);
    case CMP_TYPE_SINT64:
      return cmp_write_s64(ctx, obj->as.s64);
    case CMP_TYPE_FIXEXT1:
      return cmp_write_fixext1_marker(ctx, obj->as.ext.type);
    case CMP_TYPE_FIXEXT2:
      return cmp_write_fixext2_marker(ctx, obj->as.ext.type);
    case CMP_TYPE_FIXEXT4:
      return cmp_write_fixext4_marker(ctx, obj->as.ext.type);
    case CMP_TYPE_FIXEXT8:
      return cmp_write_fixext8_marker(ctx, obj->as.ext.type);
    case CMP_TYPE_FIXEXT16:
      return cmp_write_fixext16_marker(ctx, obj->as.ext.type);
    case CMP_TYPE_STR16:
      return cmp_write_str16_marker(ctx, (uint16_t)obj->as.str_size);
    case CMP_TYPE_STR32:
      return cmp_write_str32_marker(ctx, obj->as.str_size);
    case CMP_TYPE_ARRAY16:
      return cmp_write_array16(ctx, (uint16_t)obj->as.array_size);
    case CMP_TYPE_ARRAY32:
      return cmp_write_array32(ctx, obj->as.array_size);
    case CMP_TYPE_MAP16:
      return cmp_write_map16(ctx, (uint16_t)obj->as.map_size);
    case CMP_TYPE_MAP32:
      return cmp_write_map32(ctx, obj->as.map_size);
    case CMP_TYPE_NEGATIVE_FIXNUM:
      return cmp_write_nfix(ctx, obj->as.s8);
    default: {
      ctx->error = CMP_ERROR_INVALID_TYPE;
      return false;
    }
  }
}

bool cmp_read_pfix(cmp_ctx_t *ctx, uint8_t *c) {
  cmp_object_t obj;

  if (!cmp_read_object(ctx, &obj))
    return false;

  if (obj.type != CMP_TYPE_POSITIVE_FIXNUM) {
    ctx->error = CMP_ERROR_INVALID_TYPE;
    return false;
  }

  *c = obj.as.u8;
  return true;
}

bool cmp_read_nfix(cmp_ctx_t *ctx, int8_t *c) {
  cmp_object_t obj;

  if (!cmp_read_object(ctx, &obj))
    return false;

  if (obj.type != CMP_TYPE_NEGATIVE_FIXNUM) {
    ctx->error = CMP_ERROR_INVALID_TYPE;
    return false;
  }

  *c = obj.as.s8;
  return true;
}

bool cmp_read_sfix(cmp_ctx_t *ctx, int8_t *c) {
  cmp_object_t obj;

  if (!cmp_read_object(ctx, &obj))
    return false;

  switch (obj.type) {
    case CMP_TYPE_POSITIVE_FIXNUM:
    case CMP_TYPE_NEGATIVE_FIXNUM: {
      *c = obj.as.s8;
      return true;
    }
    default: {
      ctx->error = CMP_ERROR_INVALID_TYPE;
      return false;
    }
  }
}

bool cmp_read_s8(cmp_ctx_t *ctx, int8_t *c) {
  cmp_object_t obj;

  if (!cmp_read_object(ctx, &obj))
    return false;

  if (obj.type != CMP_TYPE_SINT8) {
    ctx->error = CMP_ERROR_INVALID_TYPE;
    return false;
  }

  *c = obj.as.s8;
  return true;
}

bool cmp_read_s16(cmp_ctx_t *ctx, int16_t *s) {
  cmp_object_t obj;

  if (!cmp_read_object(ctx, &obj))
    return false;

  if (obj.type != CMP_TYPE_SINT16) {
    ctx->error = CMP_ERROR_INVALID_TYPE;
    return false;
  }

  *s = obj.as.s16;
  return true;
}

bool cmp_read_s32(cmp_ctx_t *ctx, int32_t *i) {
  cmp_object_t obj;

  if (!cmp_read_object(ctx, &obj))
    return false;

  if (obj.type != CMP_TYPE_SINT32) {
    ctx->error = CMP_ERROR_INVALID_TYPE;
    return false;
  }

  *i = obj.as.s32;
  return true;
}

bool cmp_read_s64(cmp_ctx_t *ctx, int64_t *l) {
  cmp_object_t obj;

  if (!cmp_read_object(ctx, &obj))
    return false;

  if (obj.type != CMP_TYPE_SINT64) {
    ctx->error = CMP_ERROR_INVALID_TYPE;
    return false;
  }

  *l = obj.as.s64;
  return true;
}

bool cmp_read_char(cmp_ctx_t *ctx, int8_t *c) {
  cmp_object_t obj;

  if (!cmp_read_object(ctx, &obj))
    return false;

  switch (obj.type) {
    case CMP_TYPE_POSITIVE_FIXNUM:
    case CMP_TYPE_NEGATIVE_FIXNUM:
    case CMP_TYPE_SINT8: {
      *c = obj.as.s8;
      return true;
    }
    case CMP_TYPE_UINT8: {
      if (obj.as.u8 <= 127) {
        *c = (int8_t)obj.as.u8;
        return true;
      }
      break;
    }
    default:
      break;
  }

  ctx->error = CMP_ERROR_INVALID_TYPE;
  return false;
}

bool cmp_read_short(cmp_ctx_t *ctx, int16_t *s) {
  cmp_object_t obj;

  if (!cmp_read_object(ctx, &obj))
    return false;

  switch (obj.type) {
    case CMP_TYPE_POSITIVE_FIXNUM:
    case CMP_TYPE_NEGATIVE_FIXNUM:
    case CMP_TYPE_SINT8: {
      *s = obj.as.s8;
      return true;
    }
    case CMP_TYPE_UINT8: {
      *s = obj.as.u8;
      return true;
    }
    case CMP_TYPE_SINT16: {
      *s = obj.as.s16;
      return true;
    }
    case CMP_TYPE_UINT16: {
      if (obj.as.u16 <= 0x7fff) {
        *s = (int16_t)obj.as.u16;
        return true;
      }
      break;
    }
    default:
      break;
  }

  ctx->error = CMP_ERROR_INVALID_TYPE;
  return false;
}

bool cmp_read_int(cmp_ctx_t *ctx, int32_t *i) {
  cmp_object_t obj;

  if (!cmp_read_object(ctx, &obj))
    return false;

  switch (obj.type) {
    case CMP_TYPE_POSITIVE_FIXNUM:
    case CMP_TYPE_NEGATIVE_FIXNUM:
    case CMP_TYPE_SINT8: {
      *i = obj.as.s8;
      return true;
    }
    case CMP_TYPE_UINT8: {
      *i = obj.as.u8;
      return true;
    }
    case CMP_TYPE_SINT16: {
      *i = obj.as.s16;
      return true;
    }
    case CMP_TYPE_UINT16: {
      *i = obj.as.u16;
      return true;
    }
    case CMP_TYPE_SINT32: {
      *i = obj.as.s32;
      return true;
    }
    case CMP_TYPE_UINT32: {
      if (obj.as.u32 <= 0x7fffffff) {
        *i = (int32_t)obj.as.u32;
        return true;
      }
      break;
    }
    default:
      break;
  }

  ctx->error = CMP_ERROR_INVALID_TYPE;
  return false;
}

bool cmp_read_long(cmp_ctx_t *ctx, int64_t *d) {
  cmp_object_t obj;

  if (!cmp_read_object(ctx, &obj))
    return false;

  switch (obj.type) {
    case CMP_TYPE_POSITIVE_FIXNUM:
    case CMP_TYPE_NEGATIVE_FIXNUM:
    case CMP_TYPE_SINT8: {
      *d = obj.as.s8;
      return true;
    }
    case CMP_TYPE_UINT8: {
      *d = obj.as.u8;
      return true;
    }
    case CMP_TYPE_SINT16: {
      *d = obj.as.s16;
      return true;
    }
    case CMP_TYPE_UINT16: {
      *d = obj.as.u16;
      return true;
    }
    case CMP_TYPE_SINT32: {
      *d = obj.as.s32;
      return true;
    }
    case CMP_TYPE_UINT32: {
      *d = obj.as.u32;
      return true;
    }
    case CMP_TYPE_SINT64: {
      *d = obj.as.s64;
      return true;
    }
    case CMP_TYPE_UINT64: {
      if (obj.as.u64 <= UINT64_C(0x7fffffffffffffff)) {
        *d = (int64_t)obj.as.u64;
        return true;
      }
      break;
    }
    default:
      break;
  }

  ctx->error = CMP_ERROR_INVALID_TYPE;
  return false;
}

bool cmp_read_integer(cmp_ctx_t *ctx, int64_t *d) {
  return cmp_read_long(ctx, d);
}

bool cmp_read_ufix(cmp_ctx_t *ctx, uint8_t *c) {
  return cmp_read_pfix(ctx, c);
}

bool cmp_read_u8(cmp_ctx_t *ctx, uint8_t *c) {
  cmp_object_t obj;

  if (!cmp_read_object(ctx, &obj))
    return false;

  if (obj.type != CMP_TYPE_UINT8) {
    ctx->error = CMP_ERROR_INVALID_TYPE;
    return false;
  }

  *c = obj.as.u8;
  return true;
}

bool cmp_read_u16(cmp_ctx_t *ctx, uint16_t *s) {
  cmp_object_t obj;

  if (!cmp_read_object(ctx, &obj))
    return false;

  if (obj.type != CMP_TYPE_UINT16) {
    ctx->error = CMP_ERROR_INVALID_TYPE;
    return false;
  }

  *s = obj.as.u16;
  return true;
}

bool cmp_read_u32(cmp_ctx_t *ctx, uint32_t *i) {
  cmp_object_t obj;

  if (!cmp_read_object(ctx, &obj))
    return false;

  if (obj.type != CMP_TYPE_UINT32) {
    ctx->error = CMP_ERROR_INVALID_TYPE;
    return false;
  }

  *i = obj.as.u32;
  return true;
}

bool cmp_read_u64(cmp_ctx_t *ctx, uint64_t *l) {
  cmp_object_t obj;

  if (!cmp_read_object(ctx, &obj))
    return false;

  if (obj.type != CMP_TYPE_UINT64) {
    ctx->error = CMP_ERROR_INVALID_TYPE;
    return false;
  }

  *l = obj.as.u64;
  return true;
}

bool cmp_read_uchar(cmp_ctx_t *ctx, uint8_t *c) {
  cmp_object_t obj;

  if (!cmp_read_object(ctx, &obj))
    return false;

  switch (obj.type) {
    case CMP_TYPE_POSITIVE_FIXNUM:
    case CMP_TYPE_UINT8: {
      *c = obj.as.u8;
      return true;
    }
    case CMP_TYPE_NEGATIVE_FIXNUM:
    case CMP_TYPE_SINT8: {
      if (obj.as.s8 >= 0) {
        *c = (uint8_t)obj.as.s8;
        return true;
      }
      break;
    }
    default:
      break;
  }

  ctx->error = CMP_ERROR_INVALID_TYPE;
  return false;
}

bool cmp_read_ushort(cmp_ctx_t *ctx, uint16_t *s) {
  cmp_object_t obj;

  if (!cmp_read_object(ctx, &obj))
    return false;

  switch (obj.type) {
    case CMP_TYPE_POSITIVE_FIXNUM:
    case CMP_TYPE_UINT8: {
      *s = obj.as.u8;
      return true;
    }
    case CMP_TYPE_UINT16: {
      *s = obj.as.u16;
      return true;
    }
    case CMP_TYPE_NEGATIVE_FIXNUM:
    case CMP_TYPE_SINT8: {
      if (obj.as.s8 >= 0) {
        *s = (uint8_t)obj.as.s8;
        return true;
      }
      break;
    }
    case CMP_TYPE_SINT16: {
      if (obj.as.s16 >= 0) {
        *s = (uint16_t)obj.as.s16;
        return true;
      }
      break;
    }
    default:
      break;
  }

  ctx->error = CMP_ERROR_INVALID_TYPE;
  return false;
}

bool cmp_read_uint(cmp_ctx_t *ctx, uint32_t *i) {
  cmp_object_t obj;

  if (!cmp_read_object(ctx, &obj))
    return false;

  switch (obj.type) {
    case CMP_TYPE_POSITIVE_FIXNUM:
    case CMP_TYPE_UINT8: {
      *i = obj.as.u8;
      return true;
    }
    case CMP_TYPE_UINT16: {
      *i = obj.as.u16;
      return true;
    }
    case CMP_TYPE_UINT32: {
      *i = obj.as.u32;
      return true;
    }
    case CMP_TYPE_NEGATIVE_FIXNUM:
    case CMP_TYPE_SINT8: {
      if (obj.as.s8 >= 0) {
        *i = (uint8_t)obj.as.s8;
        return true;
      }
      break;
    }
    case CMP_TYPE_SINT16: {
      if (obj.as.s16 >= 0) {
        *i = (uint16_t)obj.as.s16;
        return true;
      }
      break;
    }
    case CMP_TYPE_SINT32: {
      if (obj.as.s32 >= 0) {
        *i = (uint32_t)obj.as.s32;
        return true;
      }
      break;
    }
    default:
      break;
  }

  ctx->error = CMP_ERROR_INVALID_TYPE;
  return false;
}

bool cmp_read_ulong(cmp_ctx_t *ctx, uint64_t *u) {
  cmp_object_t obj;

  if (!cmp_read_object(ctx, &obj))
    return false;

  switch (obj.type) {
    case CMP_TYPE_POSITIVE_FIXNUM:
    case CMP_TYPE_UINT8: {
      *u = obj.as.u8;
      return true;
    }
    case CMP_TYPE_UINT16: {
      *u = obj.as.u16;
      return true;
    }
    case CMP_TYPE_UINT32: {
      *u = obj.as.u32;
      return true;
    }
    case CMP_TYPE_UINT64: {
      *u = obj.as.u64;
      return true;
    }
    case CMP_TYPE_NEGATIVE_FIXNUM:
    case CMP_TYPE_SINT8: {
      if (obj.as.s8 >= 0) {
        *u = (uint8_t)obj.as.s8;
        return true;
      }
      break;
    }
    case CMP_TYPE_SINT16: {
      if (obj.as.s16 >= 0) {
        *u = (uint16_t)obj.as.s16;
        return true;
      }
      break;
    }
    case CMP_TYPE_SINT32: {
      if (obj.as.s32 >= 0) {
        *u = (uint32_t)obj.as.s32;
        return true;
      }
      break;
    }
    case CMP_TYPE_SINT64: {
      if (obj.as.s64 >= 0) {
        *u = (uint64_t)obj.as.s64;
        return true;
      }
      break;
    }
    default:
      break;
  }

  ctx->error = CMP_ERROR_INVALID_TYPE;
  return false;
}

bool cmp_read_uinteger(cmp_ctx_t *ctx, uint64_t *u) {
  return cmp_read_ulong(ctx, u);
}

#ifndef CMP_NO_FLOAT
bool cmp_read_float(cmp_ctx_t *ctx, float *f) {
  cmp_object_t obj;

  if (!cmp_read_object(ctx, &obj))
    return false;

  if (obj.type != CMP_TYPE_FLOAT) {
    ctx->error = CMP_ERROR_INVALID_TYPE;
    return false;
  }

  *f = obj.as.flt;

  return true;
}

bool cmp_read_double(cmp_ctx_t *ctx, double *d) {
  cmp_object_t obj;

  if (!cmp_read_object(ctx, &obj))
    return false;

  if (obj.type != CMP_TYPE_DOUBLE) {
    ctx->error = CMP_ERROR_INVALID_TYPE;
    return false;
  }

  *d = obj.as.dbl;

  return true;
}

bool cmp_read_decimal(cmp_ctx_t *ctx, double *d) {
  cmp_object_t obj;

  if (!cmp_read_object(ctx, &obj))
    return false;

  switch (obj.type) {
    case CMP_TYPE_FLOAT: {
      *d = (double)obj.as.flt;
      return true;
    }
    case CMP_TYPE_DOUBLE: {
      *d = obj.as.dbl;
      return true;
    }
    default: {
      ctx->error = CMP_ERROR_INVALID_TYPE;
      return false;
    }
  }
}
#endif /* CMP_NO_FLOAT */

bool cmp_read_nil(cmp_ctx_t *ctx) {
  cmp_object_t obj;

  if (!cmp_read_object(ctx, &obj))
    return false;

  if (obj.type == CMP_TYPE_NIL)
    return true;

  ctx->error = CMP_ERROR_INVALID_TYPE;
  return false;
}

bool cmp_read_bool(cmp_ctx_t *ctx, bool *b) {
  cmp_object_t obj;

  if (!cmp_read_object(ctx, &obj))
    return false;

  if (obj.type != CMP_TYPE_BOOLEAN) {
    ctx->error = CMP_ERROR_INVALID_TYPE;
    return false;
  }

  if (obj.as.boolean) {
    *b = true;
  } else {
    *b = false;
  }

  return true;
}

bool cmp_read_bool_as_u8(cmp_ctx_t *ctx, uint8_t *b) {
  cmp_object_t obj;

  if (!cmp_read_object(ctx, &obj))
    return false;

  if (obj.type != CMP_TYPE_BOOLEAN) {
    ctx->error = CMP_ERROR_INVALID_TYPE;
    return false;
  }

  if (obj.as.boolean) {
    *b = 1;
  } else {
    *b = 0;
  }

  return true;
}

bool cmp_read_str_size(cmp_ctx_t *ctx, uint32_t *size) {
  cmp_object_t obj;

  if (!cmp_read_object(ctx, &obj))
    return false;

  switch (obj.type) {
    case CMP_TYPE_FIXSTR:
    case CMP_TYPE_STR8:
    case CMP_TYPE_STR16:
    case CMP_TYPE_STR32: {
      *size = obj.as.str_size;
      return true;
    }
    default: {
      ctx->error = CMP_ERROR_INVALID_TYPE;
      return false;
    }
  }
}

bool cmp_read_str(cmp_ctx_t *ctx, char *data, uint32_t *size) {
  uint32_t str_size = 0;

  if (!cmp_read_str_size(ctx, &str_size))
    return false;

  if (str_size >= *size) {
    *size = str_size;
    ctx->error = CMP_ERROR_STR_DATA_LENGTH_TOO_LONG;
    return false;
  }

  if (!ctx->read(ctx, data, str_size)) {
    ctx->error = CMP_ERROR_DATA_READING;
    return false;
  }

  data[str_size] = 0;

  *size = str_size;
  return true;
}

bool cmp_read_bin_size(cmp_ctx_t *ctx, uint32_t *size) {
  cmp_object_t obj;

  if (!cmp_read_object(ctx, &obj))
    return false;

  switch (obj.type) {
    case CMP_TYPE_BIN8:
    case CMP_TYPE_BIN16:
    case CMP_TYPE_BIN32: {
      *size = obj.as.bin_size;
      return true;
    }
    default: {
      ctx->error = CMP_ERROR_INVALID_TYPE;
      return false;
    }
  }
}

bool cmp_read_bin(cmp_ctx_t *ctx, void *data, uint32_t *size) {
  uint32_t bin_size = 0;

  if (!cmp_read_bin_size(ctx, &bin_size))
    return false;

  if (bin_size > *size) {
    ctx->error = CMP_ERROR_BIN_DATA_LENGTH_TOO_LONG;
    return false;
  }

  if (!ctx->read(ctx, data, bin_size)) {
    ctx->error = CMP_ERROR_DATA_READING;
    return false;
  }

  *size = bin_size;
  return true;
}

bool cmp_read_array(cmp_ctx_t *ctx, uint32_t *size) {
  cmp_object_t obj;

  if (!cmp_read_object(ctx, &obj))
    return false;

  switch (obj.type) {
    case CMP_TYPE_FIXARRAY:
    case CMP_TYPE_ARRAY16:
    case CMP_TYPE_ARRAY32: {
      *size = obj.as.array_size;
      return true;
    }
    default: {
      ctx->error = CMP_ERROR_INVALID_TYPE;
      return false;
    }
  }
}

bool cmp_read_map(cmp_ctx_t *ctx, uint32_t *size) {
  cmp_object_t obj;

  if (!cmp_read_object(ctx, &obj))
    return false;

  switch (obj.type) {
    case CMP_TYPE_FIXMAP:
    case CMP_TYPE_MAP16:
    case CMP_TYPE_MAP32: {
      *size = obj.as.map_size;
      return true;
    }
    default: {
      ctx->error = CMP_ERROR_INVALID_TYPE;
      return false;
    }
  }
}

bool cmp_read_fixext1_marker(cmp_ctx_t *ctx, int8_t *type) {
  cmp_object_t obj;

  if (!cmp_read_object(ctx, &obj))
    return false;

  if (obj.type != CMP_TYPE_FIXEXT1) {
    ctx->error = CMP_ERROR_INVALID_TYPE;
    return false;
  }

  *type = obj.as.ext.type;
  return true;
}

bool cmp_read_fixext1(cmp_ctx_t *ctx, int8_t *type, void *data) {
  if (!cmp_read_fixext1_marker(ctx, type))
    return false;

  if (ctx->read(ctx, data, 1))
    return true;

  ctx->error = CMP_ERROR_DATA_READING;
  return false;
}

bool cmp_read_fixext2_marker(cmp_ctx_t *ctx, int8_t *type) {
  cmp_object_t obj;

  if (!cmp_read_object(ctx, &obj))
    return false;

  if (obj.type != CMP_TYPE_FIXEXT2) {
    ctx->error = CMP_ERROR_INVALID_TYPE;
    return false;
  }

  *type = obj.as.ext.type;
  return true;
}

bool cmp_read_fixext2(cmp_ctx_t *ctx, int8_t *type, void *data) {
  if (!cmp_read_fixext2_marker(ctx, type))
    return false;

  if (ctx->read(ctx, data, 2))
    return true;

  ctx->error = CMP_ERROR_DATA_READING;
  return false;
}

bool cmp_read_fixext4_marker(cmp_ctx_t *ctx, int8_t *type) {
  cmp_object_t obj;

  if (!cmp_read_object(ctx, &obj))
    return false;

  if (obj.type != CMP_TYPE_FIXEXT4) {
    ctx->error = CMP_ERROR_INVALID_TYPE;
    return false;
  }

  *type = obj.as.ext.type;
  return true;
}

bool cmp_read_fixext4(cmp_ctx_t *ctx, int8_t *type, void *data) {
  if (!cmp_read_fixext4_marker(ctx, type))
    return false;

  if (ctx->read(ctx, data, 4))
    return true;

  ctx->error = CMP_ERROR_DATA_READING;
  return false;
}

bool cmp_read_fixext8_marker(cmp_ctx_t *ctx, int8_t *type) {
  cmp_object_t obj;

  if (!cmp_read_object(ctx, &obj))
    return false;

  if (obj.type != CMP_TYPE_FIXEXT8) {
    ctx->error = CMP_ERROR_INVALID_TYPE;
    return false;
  }

  *type = obj.as.ext.type;
  return true;
}

bool cmp_read_fixext8(cmp_ctx_t *ctx, int8_t *type, void *data) {
  if (!cmp_read_fixext8_marker(ctx, type))
    return false;

  if (ctx->read(ctx, data, 8))
    return true;

  ctx->error = CMP_ERROR_DATA_READING;
  return false;
}

bool cmp_read_fixext16_marker(cmp_ctx_t *ctx, int8_t *type) {
  cmp_object_t obj;

  if (!cmp_read_object(ctx, &obj))
    return false;

  if (obj.type != CMP_TYPE_FIXEXT16) {
    ctx->error = CMP_ERROR_INVALID_TYPE;
    return false;
  }

  *type = obj.as.ext.type;
  return true;
}

bool cmp_read_fixext16(cmp_ctx_t *ctx, int8_t *type, void *data) {
  if (!cmp_read_fixext16_marker(ctx, type))
    return false;

  if (ctx->read(ctx, data, 16))
    return true;

  ctx->error = CMP_ERROR_DATA_READING;
  return false;
}

bool cmp_read_ext8_marker(cmp_ctx_t *ctx, int8_t *type, uint8_t *size) {
  cmp_object_t obj;

  if (!cmp_read_object(ctx, &obj))
    return false;

  if (obj.type != CMP_TYPE_EXT8) {
    ctx->error = CMP_ERROR_INVALID_TYPE;
    return false;
  }

  *type = obj.as.ext.type;
  *size = (uint8_t)obj.as.ext.size;

  return true;
}

bool cmp_read_ext8(cmp_ctx_t *ctx, int8_t *type, uint8_t *size, void *data) {
  if (!cmp_read_ext8_marker(ctx, type, size))
    return false;

  if (ctx->read(ctx, data, *size))
    return true;

  ctx->error = CMP_ERROR_DATA_READING;
  return false;
}

bool cmp_read_ext16_marker(cmp_ctx_t *ctx, int8_t *type, uint16_t *size) {
  cmp_object_t obj;

  if (!cmp_read_object(ctx, &obj))
    return false;

  if (obj.type != CMP_TYPE_EXT16) {
    ctx->error = CMP_ERROR_INVALID_TYPE;
    return false;
  }

  *type = obj.as.ext.type;
  *size = (uint16_t)obj.as.ext.size;

  return true;
}

bool cmp_read_ext16(cmp_ctx_t *ctx, int8_t *type, uint16_t *size, void *data) {
  if (!cmp_read_ext16_marker(ctx, type, size))
    return false;

  if (ctx->read(ctx, data, *size))
    return true;

  ctx->error = CMP_ERROR_DATA_READING;
  return false;
}

bool cmp_read_ext32_marker(cmp_ctx_t *ctx, int8_t *type, uint32_t *size) {
  cmp_object_t obj;

  if (!cmp_read_object(ctx, &obj))
    return false;

  if (obj.type != CMP_TYPE_EXT32) {
    ctx->error = CMP_ERROR_INVALID_TYPE;
    return false;
  }

  *type = obj.as.ext.type;
  *size = obj.as.ext.size;

  return true;
}

bool cmp_read_ext32(cmp_ctx_t *ctx, int8_t *type, uint32_t *size, void *data) {
  if (!cmp_read_ext32_marker(ctx, type, size))
    return false;

  if (ctx->read(ctx, data, *size))
    return true;

  ctx->error = CMP_ERROR_DATA_READING;
  return false;
}

bool cmp_read_ext_marker(cmp_ctx_t *ctx, int8_t *type, uint32_t *size) {
  cmp_object_t obj;

  if (!cmp_read_object(ctx, &obj))
    return false;

  switch (obj.type) {
    case CMP_TYPE_FIXEXT1:
    case CMP_TYPE_FIXEXT2:
    case CMP_TYPE_FIXEXT4:
    case CMP_TYPE_FIXEXT8:
    case CMP_TYPE_FIXEXT16:
    case CMP_TYPE_EXT8:
    case CMP_TYPE_EXT16:
    case CMP_TYPE_EXT32: {
      *type = obj.as.ext.type;
      *size = obj.as.ext.size;
      return true;
    }
    default: {
      ctx->error = CMP_ERROR_INVALID_TYPE;
      return false;
    }
  }
}

bool cmp_read_ext(cmp_ctx_t *ctx, int8_t *type, uint32_t *size, void *data) {
  if (!cmp_read_ext_marker(ctx, type, size))
    return false;

  if (ctx->read(ctx, data, *size))
    return true;

  ctx->error = CMP_ERROR_DATA_READING;
  return false;
}

bool cmp_read_object(cmp_ctx_t *ctx, cmp_object_t *obj) {
  uint8_t type_marker = 0;

  if (!read_type_marker(ctx, &type_marker))
    return false;

  if (!type_marker_to_cmp_type(type_marker, &obj->type)) {
    ctx->error = CMP_ERROR_INVALID_TYPE;
    return false;
  }

  return read_obj_data(ctx, type_marker, obj);
}

bool cmp_skip_object(cmp_ctx_t *ctx, cmp_object_t *obj) {
  uint8_t type_marker = 0;
  uint8_t cmp_type;
  uint32_t size = 0;

  if (!read_type_marker(ctx, &type_marker)) {
    return false;
  }

  if (!type_marker_to_cmp_type(type_marker, &cmp_type)) {
    ctx->error = CMP_ERROR_INVALID_TYPE;
    return false;
  }

  switch (cmp_type) {
    case CMP_TYPE_FIXARRAY:
    case CMP_TYPE_ARRAY16:
    case CMP_TYPE_ARRAY32:
    case CMP_TYPE_FIXMAP:
    case CMP_TYPE_MAP16:
    case CMP_TYPE_MAP32: {
      obj->type = cmp_type;

      if (!read_obj_data(ctx, type_marker, obj)) {
        return false;
      }

      ctx->error = CMP_ERROR_SKIP_DEPTH_LIMIT_EXCEEDED;

      return false;
    }
    default: {
      if (!read_type_size(ctx, type_marker, cmp_type, &size)) {
        return false;
      }

      if (size != 0) {
        switch (cmp_type) {
          case CMP_TYPE_FIXEXT1:
          case CMP_TYPE_FIXEXT2:
          case CMP_TYPE_FIXEXT4:
          case CMP_TYPE_FIXEXT8:
          case CMP_TYPE_FIXEXT16:
          case CMP_TYPE_EXT8:
          case CMP_TYPE_EXT16:
          case CMP_TYPE_EXT32: {
            ++size;
            break;
          }
          default:
            break;
        }

        skip_bytes(ctx, size);
      }
    }
  }

  return true;
}

bool cmp_skip_object_flat(cmp_ctx_t *ctx, cmp_object_t *obj) {
  size_t element_count = 1;
  bool in_container = false;

  while (element_count != 0) {
    uint8_t type_marker = 0;
    uint8_t cmp_type;
    uint32_t size = 0;

    if (!read_type_marker(ctx, &type_marker)) {
      return false;
    }

    if (!type_marker_to_cmp_type(type_marker, &cmp_type)) {
      ctx->error = CMP_ERROR_INVALID_TYPE;
      return false;
    }

    switch (cmp_type) {
      case CMP_TYPE_FIXARRAY:
      case CMP_TYPE_ARRAY16:
      case CMP_TYPE_ARRAY32:
      case CMP_TYPE_FIXMAP:
      case CMP_TYPE_MAP16:
      case CMP_TYPE_MAP32: {
        if (in_container) {
          obj->type = cmp_type;

          if (!read_obj_data(ctx, type_marker, obj)) {
            return false;
          }

          ctx->error = CMP_ERROR_SKIP_DEPTH_LIMIT_EXCEEDED;
          return false;
        }

        in_container = true;

        break;
      }
      default: {
        if (!read_type_size(ctx, type_marker, cmp_type, &size)) {
          return false;
        }

        if (size != 0) {
          switch (cmp_type) {
            case CMP_TYPE_FIXEXT1:
            case CMP_TYPE_FIXEXT2:
            case CMP_TYPE_FIXEXT4:
            case CMP_TYPE_FIXEXT8:
            case CMP_TYPE_FIXEXT16:
            case CMP_TYPE_EXT8:
            case CMP_TYPE_EXT16:
            case CMP_TYPE_EXT32: {
              ++size;
              break;
            }
            default:
              break;
          }

          skip_bytes(ctx, size);
        }
      }
    }

    --element_count;

    switch (cmp_type) {
      case CMP_TYPE_FIXARRAY:
      case CMP_TYPE_ARRAY16:
      case CMP_TYPE_ARRAY32: {
        if (!read_type_size(ctx, type_marker, cmp_type, &size)) {
          return false;
        }
        element_count += size;
        break;
      }
      case CMP_TYPE_FIXMAP:
      case CMP_TYPE_MAP16:
      case CMP_TYPE_MAP32: {
        if (!read_type_size(ctx, type_marker, cmp_type, &size)) {
          return false;
        }
        element_count += ((size_t)size) * 2;
        break;
      }
      default:
        break;
    }
  }

  return true;
}

bool cmp_skip_object_no_limit(cmp_ctx_t *ctx) {
  size_t element_count = 1;

  while (element_count != 0) {
    uint8_t type_marker = 0;
    uint8_t cmp_type = 0;
    uint32_t size = 0;

    if (!read_type_marker(ctx, &type_marker)) {
      return false;
    }

    if (!type_marker_to_cmp_type(type_marker, &cmp_type)) {
      ctx->error = CMP_ERROR_INVALID_TYPE;
      return false;
    }

    switch (cmp_type) {
      case CMP_TYPE_FIXARRAY:
      case CMP_TYPE_ARRAY16:
      case CMP_TYPE_ARRAY32:
      case CMP_TYPE_FIXMAP:
      case CMP_TYPE_MAP16:
      case CMP_TYPE_MAP32:
        break;
      default: {
        if (!read_type_size(ctx, type_marker, cmp_type, &size)) {
          return false;
        }

        if (size != 0) {
          switch (cmp_type) {
            case CMP_TYPE_FIXEXT1:
            case CMP_TYPE_FIXEXT2:
            case CMP_TYPE_FIXEXT4:
            case CMP_TYPE_FIXEXT8:
            case CMP_TYPE_FIXEXT16:
            case CMP_TYPE_EXT8:
            case CMP_TYPE_EXT16:
            case CMP_TYPE_EXT32: {
              ++size;
              break;
            }
            default:
              break;
          }

          skip_bytes(ctx, size);
        }
      }
    }

    --element_count;

    switch (cmp_type) {
      case CMP_TYPE_FIXARRAY:
      case CMP_TYPE_ARRAY16:
      case CMP_TYPE_ARRAY32: {
        if (!read_type_size(ctx, type_marker, cmp_type, &size)) {
          return false;
        }
        element_count += size;
        break;
      }
      case CMP_TYPE_FIXMAP:
      case CMP_TYPE_MAP16:
      case CMP_TYPE_MAP32: {
        if (!read_type_size(ctx, type_marker, cmp_type, &size)) {
          return false;
        }
        element_count += ((size_t)size) * 2;
        break;
      }
      default:
        break;
    }
  }

  return true;
}

bool cmp_object_is_char(const cmp_object_t *obj) {
  switch (obj->type) {
    case CMP_TYPE_NEGATIVE_FIXNUM:
    case CMP_TYPE_SINT8:
      return true;
    default:
      return false;
  }
}

bool cmp_object_is_short(const cmp_object_t *obj) {
  switch (obj->type) {
    case CMP_TYPE_NEGATIVE_FIXNUM:
    case CMP_TYPE_SINT8:
    case CMP_TYPE_SINT16:
      return true;
    default:
      return false;
  }
}

bool cmp_object_is_int(const cmp_object_t *obj) {
  switch (obj->type) {
    case CMP_TYPE_NEGATIVE_FIXNUM:
    case CMP_TYPE_SINT8:
    case CMP_TYPE_SINT16:
    case CMP_TYPE_SINT32:
      return true;
    default:
      return false;
  }
}

bool cmp_object_is_long(const cmp_object_t *obj) {
  switch (obj->type) {
    case CMP_TYPE_NEGATIVE_FIXNUM:
    case CMP_TYPE_SINT8:
    case CMP_TYPE_SINT16:
    case CMP_TYPE_SINT32:
    case CMP_TYPE_SINT64:
      return true;
    default:
      return false;
  }
}

bool cmp_object_is_sinteger(const cmp_object_t *obj) {
  return cmp_object_is_long(obj);
}

bool cmp_object_is_uchar(const cmp_object_t *obj) {
  switch (obj->type) {
    case CMP_TYPE_POSITIVE_FIXNUM:
    case CMP_TYPE_UINT8:
      return true;
    default:
      return false;
  }
}

bool cmp_object_is_ushort(const cmp_object_t *obj) {
  switch (obj->type) {
    case CMP_TYPE_POSITIVE_FIXNUM:
    case CMP_TYPE_UINT8:
      return true;
    case CMP_TYPE_UINT16:
      return true;
    default:
      return false;
  }
}

bool cmp_object_is_uint(const cmp_object_t *obj) {
  switch (obj->type) {
    case CMP_TYPE_POSITIVE_FIXNUM:
    case CMP_TYPE_UINT8:
    case CMP_TYPE_UINT16:
    case CMP_TYPE_UINT32:
      return true;
    default:
      return false;
  }
}

bool cmp_object_is_ulong(const cmp_object_t *obj) {
  switch (obj->type) {
    case CMP_TYPE_POSITIVE_FIXNUM:
    case CMP_TYPE_UINT8:
    case CMP_TYPE_UINT16:
    case CMP_TYPE_UINT32:
    case CMP_TYPE_UINT64:
      return true;
    default:
      return false;
  }
}

bool cmp_object_is_uinteger(const cmp_object_t *obj) {
  return cmp_object_is_ulong(obj);
}

bool cmp_object_is_float(const cmp_object_t *obj) {
  if (obj->type == CMP_TYPE_FLOAT)
    return true;

  return false;
}

bool cmp_object_is_double(const cmp_object_t *obj) {
  if (obj->type == CMP_TYPE_DOUBLE)
    return true;

  return false;
}

bool cmp_object_is_nil(const cmp_object_t *obj) {
  if (obj->type == CMP_TYPE_NIL)
    return true;

  return false;
}

bool cmp_object_is_bool(const cmp_object_t *obj) {
  if (obj->type == CMP_TYPE_BOOLEAN)
    return true;

  return false;
}

bool cmp_object_is_str(const cmp_object_t *obj) {
  switch (obj->type) {
    case CMP_TYPE_FIXSTR:
    case CMP_TYPE_STR8:
    case CMP_TYPE_STR16:
    case CMP_TYPE_STR32:
      return true;
    default:
      return false;
  }
}

bool cmp_object_is_bin(const cmp_object_t *obj) {
  switch (obj->type) {
    case CMP_TYPE_BIN8:
    case CMP_TYPE_BIN16:
    case CMP_TYPE_BIN32:
      return true;
    default:
      return false;
  }
}

bool cmp_object_is_array(const cmp_object_t *obj) {
  switch (obj->type) {
    case CMP_TYPE_FIXARRAY:
    case CMP_TYPE_ARRAY16:
    case CMP_TYPE_ARRAY32:
      return true;
    default:
      return false;
  }
}

bool cmp_object_is_map(const cmp_object_t *obj) {
  switch (obj->type) {
    case CMP_TYPE_FIXMAP:
    case CMP_TYPE_MAP16:
    case CMP_TYPE_MAP32:
      return true;
    default:
      return false;
  }
}

bool cmp_object_is_ext(const cmp_object_t *obj) {
  switch (obj->type) {
    case CMP_TYPE_FIXEXT1:
    case CMP_TYPE_FIXEXT2:
    case CMP_TYPE_FIXEXT4:
    case CMP_TYPE_FIXEXT8:
    case CMP_TYPE_FIXEXT16:
    case CMP_TYPE_EXT8:
    case CMP_TYPE_EXT16:
    case CMP_TYPE_EXT32:
      return true;
    default:
      return false;
  }
}

bool cmp_object_as_char(const cmp_object_t *obj, int8_t *c) {
  switch (obj->type) {
    case CMP_TYPE_POSITIVE_FIXNUM:
    case CMP_TYPE_NEGATIVE_FIXNUM:
    case CMP_TYPE_SINT8: {
      *c = obj->as.s8;
      return true;
    }
    case CMP_TYPE_UINT8: {
      if (obj->as.u8 <= 127) {
        *c = obj->as.s8;
        return true;
      }
      else {
        return false;
      }
    }
    default:
      return false;
  }
}

bool cmp_object_as_short(const cmp_object_t *obj, int16_t *s) {
  switch (obj->type) {
    case CMP_TYPE_POSITIVE_FIXNUM:
    case CMP_TYPE_NEGATIVE_FIXNUM:
    case CMP_TYPE_SINT8: {
      *s = obj->as.s8;
      return true;
    }
    case CMP_TYPE_UINT8: {
      *s = obj->as.u8;
      return true;
    }
    case CMP_TYPE_SINT16: {
      *s = obj->as.s16;
      return true;
    }
    case CMP_TYPE_UINT16: {
      if (obj->as.u16 <= 0x7fff) {
        *s = (int16_t)obj->as.u16;
        return true;
      }
      else {
        return false;
      }
    }
    default:
      return false;
  }
}

bool cmp_object_as_int(const cmp_object_t *obj, int32_t *i) {
  switch (obj->type) {
    case CMP_TYPE_POSITIVE_FIXNUM:
    case CMP_TYPE_NEGATIVE_FIXNUM:
    case CMP_TYPE_SINT8: {
      *i = obj->as.s8;
      return true;
    }
    case CMP_TYPE_UINT8: {
      *i = obj->as.u8;
      return true;
    }
    case CMP_TYPE_SINT16: {
      *i = obj->as.s16;
      return true;
    }
    case CMP_TYPE_UINT16: {
      *i = obj->as.u16;
      return true;
    }
    case CMP_TYPE_SINT32: {
      *i = obj->as.s32;
      return true;
    }
    case CMP_TYPE_UINT32: {
      if (obj->as.u32 <= 0x7fffffff) {
        *i = (int32_t)obj->as.u32;
        return true;
      }
      else {
        return false;
      }
    }
    default:
      return false;
  }
}

bool cmp_object_as_long(const cmp_object_t *obj, int64_t *d) {
  switch (obj->type) {
    case CMP_TYPE_POSITIVE_FIXNUM:
    case CMP_TYPE_NEGATIVE_FIXNUM:
    case CMP_TYPE_SINT8: {
      *d = obj->as.s8;
      return true;
    }
    case CMP_TYPE_UINT8: {
      *d = obj->as.u8;
      return true;
    }
    case CMP_TYPE_SINT16: {
      *d = obj->as.s16;
      return true;
    }
    case CMP_TYPE_UINT16: {
      *d = obj->as.u16;
      return true;
    }
    case CMP_TYPE_SINT32: {
      *d = obj->as.s32;
      return true;
    }
    case CMP_TYPE_UINT32: {
      *d = obj->as.u32;
      return true;
    }
    case CMP_TYPE_SINT64: {
      *d = obj->as.s64;
      return true;
    }
    case CMP_TYPE_UINT64: {
      if (obj->as.u64 <= UINT64_C(0x7fffffffffffffff)) {
        *d = (int64_t)obj->as.u64;
        return true;
      }
      else {
        return false;
      }
    }
    default:
      return false;
  }
}

bool cmp_object_as_sinteger(const cmp_object_t *obj, int64_t *d) {
  return cmp_object_as_long(obj, d);
}

bool cmp_object_as_uchar(const cmp_object_t *obj, uint8_t *c) {
  switch (obj->type) {
    case CMP_TYPE_POSITIVE_FIXNUM:
    case CMP_TYPE_UINT8: {
      *c = obj->as.u8;
      return true;
    }
    default:
      return false;
  }
}

bool cmp_object_as_ushort(const cmp_object_t *obj, uint16_t *s) {
  switch (obj->type) {
    case CMP_TYPE_POSITIVE_FIXNUM:
    case CMP_TYPE_UINT8: {
      *s = obj->as.u8;
      return true;
    }
    case CMP_TYPE_UINT16: {
      *s = obj->as.u16;
      return true;
    }
    default:
      return false;
  }
}

bool cmp_object_as_uint(const cmp_object_t *obj, uint32_t *i) {
  switch (obj->type) {
    case CMP_TYPE_POSITIVE_FIXNUM:
    case CMP_TYPE_UINT8: {
      *i = obj->as.u8;
      return true;
    }
    case CMP_TYPE_UINT16: {
      *i = obj->as.u16;
      return true;
    }
    case CMP_TYPE_UINT32: {
      *i = obj->as.u32;
      return true;
    }
    default:
      return false;
  }
}

bool cmp_object_as_ulong(const cmp_object_t *obj, uint64_t *u) {
  switch (obj->type) {
    case CMP_TYPE_POSITIVE_FIXNUM:
    case CMP_TYPE_UINT8: {
      *u = obj->as.u8;
      return true;
    }
    case CMP_TYPE_UINT16: {
      *u = obj->as.u16;
      return true;
    }
    case CMP_TYPE_UINT32: {
      *u = obj->as.u32;
      return true;
    }
    case CMP_TYPE_UINT64: {
      *u = obj->as.u64;
      return true;
    }
    default:
      return false;
  }
}

bool cmp_object_as_uinteger(const cmp_object_t *obj, uint64_t *u) {
  return cmp_object_as_ulong(obj, u);
}

#ifndef CMP_NO_FLOAT
bool cmp_object_as_float(const cmp_object_t *obj, float *f) {
  if (obj->type == CMP_TYPE_FLOAT) {
    *f = obj->as.flt;
    return true;
  }

  return false;
}

bool cmp_object_as_double(const cmp_object_t *obj, double *d) {
  if (obj->type == CMP_TYPE_DOUBLE) {
    *d = obj->as.dbl;
    return true;
  }

  return false;
}
#endif /* CMP_NO_FLOAT */

bool cmp_object_as_bool(const cmp_object_t *obj, bool *b) {
  if (obj->type == CMP_TYPE_BOOLEAN) {
    if (obj->as.boolean) {
      *b = true;
    } else {
      *b = false;
    }

    return true;
  }

  return false;
}

bool cmp_object_as_str(const cmp_object_t *obj, uint32_t *size) {
  switch (obj->type) {
    case CMP_TYPE_FIXSTR:
    case CMP_TYPE_STR8:
    case CMP_TYPE_STR16:
    case CMP_TYPE_STR32: {
      *size = obj->as.str_size;
      return true;
    }
    default:
      return false;
  }
}

bool cmp_object_as_bin(const cmp_object_t *obj, uint32_t *size) {
  switch (obj->type) {
    case CMP_TYPE_BIN8:
    case CMP_TYPE_BIN16:
    case CMP_TYPE_BIN32: {
      *size = obj->as.bin_size;
      return true;
    }
    default:
      return false;
  }
}

bool cmp_object_as_array(const cmp_object_t *obj, uint32_t *size) {
  switch (obj->type) {
    case CMP_TYPE_FIXARRAY:
    case CMP_TYPE_ARRAY16:
    case CMP_TYPE_ARRAY32: {
      *size = obj->as.array_size;
      return true;
    }
    default:
      return false;
  }
}

bool cmp_object_as_map(const cmp_object_t *obj, uint32_t *size) {
  switch (obj->type) {
    case CMP_TYPE_FIXMAP:
    case CMP_TYPE_MAP16:
    case CMP_TYPE_MAP32: {
      *size = obj->as.map_size;
      return true;
    }
    default:
      return false;
  }
}

bool cmp_object_as_ext(const cmp_object_t *obj, int8_t *type, uint32_t *size) {
  switch (obj->type) {
    case CMP_TYPE_FIXEXT1:
    case CMP_TYPE_FIXEXT2:
    case CMP_TYPE_FIXEXT4:
    case CMP_TYPE_FIXEXT8:
    case CMP_TYPE_FIXEXT16:
    case CMP_TYPE_EXT8:
    case CMP_TYPE_EXT16:
    case CMP_TYPE_EXT32: {
      *type = obj->as.ext.type;
      *size = obj->as.ext.size;
      return true;
    }
    default:
      return false;
  }
}

bool cmp_object_to_str(cmp_ctx_t *ctx, const cmp_object_t *obj, char *data,
                                                          uint32_t buf_size) {
  switch (obj->type) {
    case CMP_TYPE_FIXSTR:
    case CMP_TYPE_STR8:
    case CMP_TYPE_STR16:
    case CMP_TYPE_STR32: {
      const uint32_t str_size = obj->as.str_size;
      if (str_size >= buf_size) {
        ctx->error = CMP_ERROR_STR_DATA_LENGTH_TOO_LONG;
        return false;
      }

      if (!ctx->read(ctx, data, str_size)) {
        ctx->error = CMP_ERROR_DATA_READING;
        return false;
      }

      data[str_size] = 0;
      return true;
    }
    default:
      return false;
  }
}

bool cmp_object_to_bin(cmp_ctx_t *ctx, const cmp_object_t *obj, void *data,
                                                          uint32_t buf_size) {
  switch (obj->type) {
    case CMP_TYPE_BIN8:
    case CMP_TYPE_BIN16:
    case CMP_TYPE_BIN32: {
      const uint32_t bin_size = obj->as.bin_size;
      if (bin_size > buf_size) {
        ctx->error = CMP_ERROR_BIN_DATA_LENGTH_TOO_LONG;
        return false;
      }

      if (!ctx->read(ctx, data, bin_size)) {
        ctx->error = CMP_ERROR_DATA_READING;
        return false;
      }
      return true;
    }
    default:
      return false;
  }
}

/* vi: set et ts=2 sw=2: */
/*
 * Copyright © 2018 Zoff
 *
 * This file is part of Tox, the free peer to peer instant messenger.
 *
 * Tox is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Tox is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Tox.  If not, see <http://www.gnu.org/licenses/>.
 */

#ifdef HAVE_CONFIG_H
#endif

//!TOKSTYLE-

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wpragmas"
#pragma GCC diagnostic ignored "-Wunused-variable"
#pragma GCC diagnostic ignored "-Wmissing-variable-declarations"

#include <time.h>



#include <assert.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>


#define CAP_PACKET_ID 170
#define CAP_BYTE_0 33
#define CAP_BYTE_1 44

// #define TOX_UTIL_EXPIRE_FT_MS 50000 // msgV2 FTs should expire after 50 seconds

typedef struct tox_utils_Node {
    uint8_t key[TOX_PUBLIC_KEY_SIZE];
    uint32_t key2;
    void *data;
    struct tox_utils_Node *next;
} tox_utils_Node;

typedef struct tox_utils_List {
    uint32_t size;
    tox_utils_Node *head;
} tox_utils_List;


static tox_utils_List global_friend_capability_list;

typedef struct global_friend_capability_entry {
    bool msgv2_cap;
} global_friend_capability_entry;


static tox_utils_List global_msgv2_incoming_ft_list;

typedef struct global_msgv2_incoming_ft_entry {
    uint32_t friend_number;
    uint32_t file_number;
    uint32_t kind;
    uint64_t file_size;
    uint32_t timestamp;
    uint8_t msg_data[TOX_MAX_FILETRANSFER_SIZE_MSGV2];
} global_msgv2_incoming_ft_entry;


static tox_utils_List global_msgv2_outgoing_ft_list;

typedef struct global_msgv2_outgoing_ft_entry {
    uint32_t friend_number;
    uint32_t file_number;
    uint32_t kind;
    uint64_t file_size;
    uint32_t timestamp;
    uint8_t msg_data[TOX_MAX_FILETRANSFER_SIZE_MSGV2];
} global_msgv2_outgoing_ft_entry;

static uint16_t global_ts_ms = 0;
static pthread_mutex_t mutex_tox_util[1];

// ------------ UTILS ------------

#if 0
static time_t get_unix_time(void)
{
    return time(NULL);
}
#endif

#if 0
/* Returns 1 if timed out, 0 otherwise */
static int timed_out(time_t timestamp, time_t timeout)
{
    return timestamp + timeout <= get_unix_time();
}
#endif

/* compares 2 items of length len (e.g.: Tox Pubkeys)
   Returns 0 if they are the same, 1 if they differ
 */
static int check_file_signature(const uint8_t *pubkey1, const uint8_t *pubkey2, size_t len)
{
    int ret = memcmp(pubkey1, pubkey2, len);
    return ret == 0 ? 0 : 1;
}


#if 0
/**
 * @fn
 * get_hex
 *
 * @brief
 * Converts a char into binary string
 *
 * @param[in]
 *     buf Value to be converted to hex string
 * @param[in]
 *     buf_len Length of the buffer
 * @param[in]
 *     hex_ Pointer to space to put Hex string into
 * @param[in]
 *     hex_len Length of the hex string space
 * @param[in]
 *     num_col Number of columns in display hex string
 */
static inline void
get_hex(char *buf, int buf_len, char *hex_, int hex_len, int num_col)
{
    int i;
#define ONE_BYTE_HEX_STRING_SIZE   3
    unsigned int byte_no = 0;

    if (buf_len <= 0) {
        if (hex_len > 0) {
            hex_[0] = '\0';
        }

        return;
    }

    if (hex_len < ONE_BYTE_HEX_STRING_SIZE + 1) {
        return;
    }

    do {
        for (i = 0; ((i < num_col) && (buf_len > 0) && (hex_len > 0)); ++i) {
            snprintf(hex_, hex_len, "%02X ", buf[byte_no++] & 0xff);
            hex_ += ONE_BYTE_HEX_STRING_SIZE;
            hex_len -= ONE_BYTE_HEX_STRING_SIZE;
            buf_len--;
        }

        if (buf_len > 1) {
            snprintf(hex_, hex_len, "\n");
            hex_ += 1;
        }
    } while ((buf_len) > 0 && (hex_len > 0));

}
#endif



static void tox_utils_list_init(tox_utils_List *l)
{
    pthread_mutex_lock(mutex_tox_util);
    l->size = 0;
    l->head = NULL;
    pthread_mutex_unlock(mutex_tox_util);
}

static void tox_utils_list_clear(tox_utils_List *l)
{
    pthread_mutex_lock(mutex_tox_util);

    tox_utils_Node *head = l->head;
    tox_utils_Node *next_ = NULL;

    while (head) {
        next_ = head->next;

        l->size--;
        l->head = next_;

        if (head->data) {
            free(head->data);
        }

        free(head);
        head = next_;
    }

    l->size = 0;
    l->head = NULL;

    pthread_mutex_unlock(mutex_tox_util);
}


static void tox_utils_list_add(tox_utils_List *l, uint8_t *key, uint32_t key2, void *data)
{
    pthread_mutex_lock(mutex_tox_util);

    tox_utils_Node *n = (tox_utils_Node *)calloc(1, sizeof(tox_utils_Node));

    memcpy(n->key, key, TOX_PUBLIC_KEY_SIZE);
    n->key2 = key2;
    n->data = data;

    if (l->head == NULL) {
        n->next = NULL;
    } else {
        n->next = l->head;
    }

    l->head = n;
    l->size++;

    pthread_mutex_unlock(mutex_tox_util);
}

static tox_utils_Node *tox_utils_list_get(tox_utils_List *l, uint8_t *key, uint32_t key2)
{
    pthread_mutex_lock(mutex_tox_util);

    tox_utils_Node *head = l->head;

    while (head) {
        if (head->key2 == key2) {
            if (check_file_signature(head->key, key, TOX_PUBLIC_KEY_SIZE) == 0) {
                pthread_mutex_unlock(mutex_tox_util);
                return head;
            }
        }

        head = head->next;
    }

    pthread_mutex_unlock(mutex_tox_util);
    return NULL;
}

static void tox_utils_list_remove_single_node(tox_utils_List *l, tox_utils_Node *n, tox_utils_Node *n_minus_1)
{
    if (!l) {
        return;
    }

    if (!n) {
        return;
    }

    if (n_minus_1 == NULL) {
        // want to delete the first node
        l->head = n->next;

        if (n->data) {
            free(n->data);
        }

        free(n);
        l->size--;
        n = NULL;
        return;
    } else {
        n_minus_1->next = n->next;

        if (n->data) {
            free(n->data);
        }

        free(n);
        l->size--;
        n = NULL;
    }

}

static void tox_utils_list_remove(tox_utils_List *l, uint8_t *key, uint32_t key2)
{
    pthread_mutex_lock(mutex_tox_util);

    tox_utils_Node *head = l->head;
    tox_utils_Node *prev_ = NULL;
    tox_utils_Node *next_ = NULL;

    while (head) {
        next_ = head->next;

        if (head->key2 == key2) {
            if (check_file_signature(head->key, key, TOX_PUBLIC_KEY_SIZE) == 0) {
                tox_utils_list_remove_single_node(l, head, prev_);
                // start from beginning of the list
                head = l->head;
                prev_ = NULL;
                next_ = NULL;
                continue;
            }
        }

        prev_ = head;
        head = next_;
    }

    pthread_mutex_unlock(mutex_tox_util);
}

static void tox_utils_list_remove_2(tox_utils_List *l, uint8_t *key)
{
    pthread_mutex_lock(mutex_tox_util);

    tox_utils_Node *head = l->head;
    tox_utils_Node *prev_ = NULL;
    tox_utils_Node *next_ = NULL;

    while (head) {
        next_ = head->next;

        if (check_file_signature(head->key, key, TOX_PUBLIC_KEY_SIZE) == 0) {
            tox_utils_list_remove_single_node(l, head, prev_);
            // start from beginning of the list
            head = l->head;
            prev_ = NULL;
            next_ = NULL;
            continue;
        }

        prev_ = head;
        head = next_;
    }

    pthread_mutex_unlock(mutex_tox_util);
}

// ------------ UTILS ------------













// ----------- FUNCS -----------
#if 0
static int64_t tox_utils_pubkey_to_friendnum(Tox *tox, const uint8_t *public_key)
{
    TOX_ERR_FRIEND_BY_PUBLIC_KEY error;
    uint32_t fnum = tox_friend_by_public_key(tox, public_key, &error);

    if (error == 0) {
        return (int64_t)fnum;
    } else {
        return -1;
    }
}
#endif

static bool tox_utils_friendnum_to_pubkey(Tox *tox, uint8_t *public_key, uint32_t friend_number)
{
    TOX_ERR_FRIEND_GET_PUBLIC_KEY error;
    return tox_friend_get_public_key(tox, friend_number, public_key, &error);
}

static bool tox_utils_get_capabilities(Tox *tox, uint32_t friendnumber)
{

    uint64_t capabilities = tox_friend_get_capabilities(tox, friendnumber);
    if ((capabilities & TOX_CAPABILITY_MSGV2) == TOX_CAPABILITY_MSGV2)
    {
        // Messenger *m;
        // m = *(Messenger **)tox;
        // LOGGER_WARNING(m->log, "toxutil:get_capabilities(from online packet)");
        return true;
    }

    uint8_t *friend_pubkey = (uint8_t *)calloc(1, TOX_PUBLIC_KEY_SIZE);

    if (friend_pubkey) {
        bool res = tox_utils_friendnum_to_pubkey(tox, friend_pubkey, friendnumber);

        if (res == true) {
            tox_utils_Node *n = tox_utils_list_get(&global_friend_capability_list, friend_pubkey, 0);

            if (n != NULL) {
                free(friend_pubkey);
                return ((global_friend_capability_entry *)(n->data))->msgv2_cap;
            }
        }

        free(friend_pubkey);
    }

    return false;
}

static void tox_utils_set_capabilities(Tox *tox, uint32_t friendnumber, bool cap)
{
    uint8_t *friend_pubkey = (uint8_t *)calloc(1, TOX_PUBLIC_KEY_SIZE);

    if (friend_pubkey) {
        bool res = tox_utils_friendnum_to_pubkey(tox, friend_pubkey, friendnumber);

        if (res == true) {
            global_friend_capability_entry *data = (global_friend_capability_entry *)calloc(1, sizeof(global_friend_capability_entry));
            data->msgv2_cap = cap;

            tox_utils_Node *n = tox_utils_list_get(&global_friend_capability_list, friend_pubkey, 0);

            if (n == NULL) {
                if (cap == true) {
                    tox_utils_list_add(&global_friend_capability_list, friend_pubkey, 0, data);
                    // TODO(iphydf): Don't rely on toxcore internals.
                    Messenger *m;
                    m = *(Messenger **)tox;
                    LOGGER_WARNING(m->log, "toxutil:set_capabilities(add:1)");
                }
            } else {
                tox_utils_list_remove(&global_friend_capability_list, friend_pubkey, 0);
                Messenger *m = *(Messenger **)tox;
                LOGGER_WARNING(m->log, "toxutil:set_capabilities(rm)");

                if (cap == true) {
                    tox_utils_list_add(&global_friend_capability_list, friend_pubkey, 0, data);
                    Messenger *m2 = *(Messenger **)tox;
                    LOGGER_WARNING(m2->log, "toxutil:set_capabilities(add:2)");
                }
            }
        }

        free(friend_pubkey);
    }
}

static void tox_utils_send_capabilities(Tox *tox, uint32_t friendnumber)
{
    uint8_t data[3];
    data[0] = CAP_PACKET_ID; // packet ID
    data[1] = CAP_BYTE_0;
    data[2] = CAP_BYTE_1;
    TOX_ERR_FRIEND_CUSTOM_PACKET error;
    tox_friend_send_lossless_packet(tox, friendnumber, data, 3, &error);

    if (error == TOX_ERR_FRIEND_CUSTOM_PACKET_SENDQ) {
        Messenger *m = *(Messenger **)tox;
        LOGGER_WARNING(m->log, "toxutil:tox_utils_send_capabilities fnum=%d error:TOX_ERR_FRIEND_CUSTOM_PACKET_SENDQ",
                       (int)friendnumber);
    } else if (error != 0) {
        Messenger *m = *(Messenger **)tox;
        LOGGER_WARNING(m->log, "toxutil:tox_utils_send_capabilities fnum=%d errnum:%d",
                       (int)friendnumber, (int)error);
    }
}

static void tox_utils_receive_capabilities(Tox *tox, uint32_t friendnumber, const uint8_t *data,
        size_t length)
{
    if (length == 3) {
        if ((data[0] == CAP_PACKET_ID) && (data[1] == CAP_BYTE_0) && (data[2] == CAP_BYTE_1)) {
            Messenger *m = *(Messenger **)tox;
            LOGGER_WARNING(m->log, "toxutil:receive_capabilities fnum=%d data=%d% d %d",
                           (int)friendnumber, (int)data[0], (int)data[1], (int)data[2]);

            // friend has message V2 capability
            tox_utils_set_capabilities(tox, friendnumber, true);
        }
    }
}

static void tox_utils_housekeeping(Tox *tox)
{
#if 0

    pthread_mutex_lock(mutex_tox_util);

    // cancel and clear old outgoing FTs ----------------
    tox_utils_List *l = &global_msgv2_outgoing_ft_list;

    tox_utils_Node *head = l->head;
    tox_utils_Node *next_ = NULL;

    while (head) {
        next_ = head->next;

        if (head->data) {
            global_msgv2_outgoing_ft_entry *e = ((global_msgv2_outgoing_ft_entry *)(head->data));

            Messenger *m = *(Messenger **)tox;

            if ((e->timestamp + TOX_UTIL_EXPIRE_FT_MS) < current_time_monotonic(m->mono_time)) {
                // cancel FT
                uint32_t friend_number = e->friend_number;
                uint32_t file_number = e->file_number;

                bool res = tox_file_control(tox, friend_number, file_number,
                                            (TOX_FILE_CONTROL)TOX_FILE_CONTROL_CANCEL, NULL);

                if (res == true) {
                    // remove FT from list
                    if (head->data) {
                        free(head->data);
                    }

                    l->size--;
                    l->head = next_;
                    free(head);

                    break;
                }
            }
        }

        l->head = next_;
        head = next_;
    }

    // cancel and clear old outgoing FTs ----------------



    // cancel and clear old incoming FTs ----------------
    l = &global_msgv2_incoming_ft_list;

    head = l->head;
    next_ = NULL;

    while (head) {
        next_ = head->next;

        if (head->data) {
            global_msgv2_incoming_ft_entry *e = ((global_msgv2_incoming_ft_entry *)(head->data));

            Messenger *m = *(Messenger **)tox;

            if ((e->timestamp + TOX_UTIL_EXPIRE_FT_MS) < current_time_monotonic(m->mono_time)) {
                // cancel FT
                uint32_t friend_number = e->friend_number;
                uint32_t file_number = e->file_number;

                bool res = tox_file_control(tox, friend_number, file_number,
                                            (TOX_FILE_CONTROL)TOX_FILE_CONTROL_CANCEL, NULL);

                if (res == true) {
                    // remove FT from list
                    if (head->data) {
                        free(head->data);
                    }

                    l->size--;
                    l->head = next_;
                    free(head);

                    break;
                }
            }
        }

        l->head = next_;
        head = next_;
    }

    pthread_mutex_unlock(mutex_tox_util);

    // cancel and clear old incoming FTs ----------------
#endif
}

// ----------- FUNCS -----------




// --- set callbacks ---
void (*tox_utils_selfconnectionstatus)(struct Tox *tox, unsigned int, void *);

void tox_utils_callback_self_connection_status(Tox *tox, tox_self_connection_status_cb *callback)
{
    tox_utils_selfconnectionstatus = (void (*)(Tox * tox,
                                      unsigned int, void *))callback;
}


void (*tox_utils_friend_connectionstatuschange)(struct Tox *tox, uint32_t,
        unsigned int, void *);

void tox_utils_callback_friend_connection_status(Tox *tox, tox_friend_connection_status_cb *callback)
{
    tox_utils_friend_connectionstatuschange = (void (*)(Tox * tox, uint32_t,
            unsigned int, void *))callback;
    Messenger *m = *(Messenger **)tox;
    LOGGER_WARNING(m->log, "toxutil:set callback");
}


void (*tox_utils_friend_losslesspacket)(struct Tox *tox, uint32_t, const uint8_t *,
                                        size_t, void *);

void tox_utils_callback_friend_lossless_packet(Tox *tox, tox_friend_lossless_packet_cb *callback)
{
    tox_utils_friend_losslesspacket = (void (*)(Tox * tox, uint32_t,
                                       const uint8_t *, size_t, void *))callback;
}


void (*tox_utils_filerecvcontrol)(struct Tox *tox, uint32_t, uint32_t,
                                  unsigned int, void *);

void tox_utils_callback_file_recv_control(Tox *tox, tox_file_recv_control_cb *callback)
{
    tox_utils_filerecvcontrol = (void (*)(Tox * tox, uint32_t, uint32_t,
                                          unsigned int, void *))callback;
}

void (*tox_utils_filechunkrequest)(struct Tox *tox, uint32_t, uint32_t,
                                   uint64_t, size_t, void *);

void tox_utils_callback_file_chunk_request(Tox *tox, tox_file_chunk_request_cb *callback)
{
    tox_utils_filechunkrequest = (void (*)(Tox * tox, uint32_t, uint32_t,
                                           uint64_t, size_t, void *))callback;
}

void (*tox_utils_filerecv)(struct Tox *tox, uint32_t, uint32_t,
                           uint32_t, uint64_t, const uint8_t *, size_t, void *) = NULL;

void tox_utils_callback_file_recv(Tox *tox, tox_file_recv_cb *callback)
{
    tox_utils_filerecv = (void (*)(Tox * tox, uint32_t, uint32_t,
                                   uint32_t, uint64_t, const uint8_t *, size_t, void *))callback;
}

void (*tox_utils_filerecvchunk)(struct Tox *tox, uint32_t, uint32_t, uint64_t,
                                const uint8_t *, size_t, void *);


void tox_utils_callback_file_recv_chunk(Tox *tox, tox_file_recv_chunk_cb *callback)
{
    tox_utils_filerecvchunk = (void (*)(Tox * tox, uint32_t, uint32_t, uint64_t,
                                        const uint8_t *, size_t, void *))callback;
}

void (*tox_utils_friend_message_v2)(struct Tox *tox, uint32_t, const uint8_t *,
                                    size_t);

void tox_utils_callback_friend_message_v2(Tox *tox, tox_util_friend_message_v2_cb *callback)
{
    tox_utils_friend_message_v2 = (void (*)(Tox * tox, uint32_t, const uint8_t *,
                                            size_t))callback;
}

void (*tox_utils_friend_sync_message_v2)(struct Tox *tox, uint32_t, const uint8_t *,
        size_t);

void tox_utils_callback_friend_sync_message_v2(Tox *tox, tox_util_friend_sync_message_v2_cb *callback)
{
    tox_utils_friend_sync_message_v2 = (void (*)(Tox * tox, uint32_t, const uint8_t *,
                                        size_t))callback;
}

void (*tox_utils_friend_read_receipt_message_v2)(struct Tox *tox, uint32_t, uint32_t,
        const uint8_t *);

void tox_utils_callback_friend_read_receipt_message_v2(Tox *tox,
        tox_utils_friend_read_receipt_message_v2_cb *callback)
{
    tox_utils_friend_read_receipt_message_v2 = (void (*)(Tox * tox, uint32_t, uint32_t,
            const uint8_t *))callback;
}


Tox *tox_utils_new(const struct Tox_Options *options, TOX_ERR_NEW *error)
{
    if (pthread_mutex_init(mutex_tox_util, NULL) != 0) {
        if (error) {
            // TODO: find a better error code, use malloc error for now
            *error = TOX_ERR_NEW_MALLOC;
        }

        return NULL;
    }

    tox_utils_list_init(&global_friend_capability_list);
    tox_utils_list_init(&global_msgv2_incoming_ft_list);
    tox_utils_list_init(&global_msgv2_outgoing_ft_list);

    // ATTENTION: we only have a mono_time instance after this call returns!!
    return tox_new(options, error);
}

void tox_utils_kill(Tox *tox)
{
    tox_utils_list_clear(&global_friend_capability_list);
    tox_utils_list_clear(&global_msgv2_incoming_ft_list);
    tox_utils_list_clear(&global_msgv2_outgoing_ft_list);

    tox_kill(tox);

    pthread_mutex_destroy(mutex_tox_util);
}

bool tox_utils_friend_delete(Tox *tox, uint32_t friend_number, TOX_ERR_FRIEND_DELETE *error)
{
    // clear all FTs of this friend from incmoning/outgoing FT lists
    uint8_t *friend_pubkey = (uint8_t *)calloc(1, TOX_PUBLIC_KEY_SIZE);

    if (friend_pubkey) {
        bool res = tox_utils_friendnum_to_pubkey(tox, friend_pubkey, friend_number);

        if (res == true) {
            tox_utils_list_remove_2(&global_msgv2_incoming_ft_list, friend_pubkey);
            tox_utils_list_remove_2(&global_msgv2_outgoing_ft_list, friend_pubkey);
        }

        free(friend_pubkey);
    }

    return tox_friend_delete(tox, friend_number, error);
}

// --- set callbacks ---



void tox_utils_friend_lossless_packet_cb(Tox *tox, uint32_t friend_number, const uint8_t *data,
        size_t length, void *user_data)
{
    // ------- do messageV2 stuff -------
    tox_utils_receive_capabilities(tox, friend_number, data, length);
    // ------- do messageV2 stuff -------

    // ------- call the real CB function -------
    if (tox_utils_friend_losslesspacket) {
        tox_utils_friend_losslesspacket(tox, friend_number, data, length, user_data);
    }

    // ------- call the real CB function -------
}


void tox_utils_self_connection_status_cb(Tox *tox,
        TOX_CONNECTION connection_status, void *user_data)
{
    // ------- do messageV2 stuff -------
    if (connection_status == TOX_CONNECTION_NONE) {
        // if we go offline ourselves, remove all FT data
        tox_utils_list_clear(&global_msgv2_incoming_ft_list);
        tox_utils_list_clear(&global_msgv2_outgoing_ft_list);
    }

    // ------- do messageV2 stuff -------

    // ------- call the real CB function -------
    if (tox_utils_selfconnectionstatus) {
        tox_utils_selfconnectionstatus(tox, connection_status, user_data);
        // Messenger *m = (Messenger *)tox;
        // LOGGER_WARNING(m->log, "toxutil:selfconnectionstatus");
    }

    // ------- call the real CB function -------
}


void tox_utils_friend_connection_status_cb(Tox *tox, uint32_t friendnumber,
        TOX_CONNECTION connection_status, void *user_data)
{
    // ------- do messageV2 stuff -------
    if (connection_status == TOX_CONNECTION_NONE) {
        tox_utils_set_capabilities(tox, friendnumber, false);

        // remove FT data from list
        uint8_t *friend_pubkey = (uint8_t *)calloc(1, TOX_PUBLIC_KEY_SIZE);

        if (friend_pubkey) {
            bool res = tox_utils_friendnum_to_pubkey(tox, friend_pubkey, friendnumber);

            if (res == true) {
                tox_utils_list_remove_2(&global_msgv2_incoming_ft_list, friend_pubkey);
                tox_utils_list_remove_2(&global_msgv2_outgoing_ft_list, friend_pubkey);
            }

            free(friend_pubkey);
        }
    } else {
        tox_utils_send_capabilities(tox, friendnumber);
    }

    // ------- do messageV2 stuff -------

    // ------- call the real CB function -------
    if (tox_utils_friend_connectionstatuschange) {
        tox_utils_friend_connectionstatuschange(tox, friendnumber, connection_status, user_data);
        // Messenger *m = (Messenger *)tox;
        // LOGGER_WARNING(m->log, "toxutil:friend_connectionstatuschange");
    }

    // ------- call the real CB function -------
}


void tox_utils_file_recv_control_cb(Tox *tox, uint32_t friend_number, uint32_t file_number,
                                    TOX_FILE_CONTROL control, void *user_data)
{
    // ------- do messageV2 stuff -------
    if (control == TOX_FILE_CONTROL_CANCEL) {
        uint8_t *friend_pubkey = (uint8_t *)calloc(1, TOX_PUBLIC_KEY_SIZE);

        if (friend_pubkey) {
            bool res = tox_utils_friendnum_to_pubkey(tox, friend_pubkey, friend_number);

            if (res == true) {
                tox_utils_Node *n = tox_utils_list_get(&global_msgv2_outgoing_ft_list,
                                                       friend_pubkey, file_number);

                if (n != NULL) {
                    if (
                        (((global_msgv2_outgoing_ft_entry *)(n->data))->kind == TOX_FILE_KIND_MESSAGEV2_SEND)
                        ||
                        (((global_msgv2_outgoing_ft_entry *)(n->data))->kind == TOX_FILE_KIND_MESSAGEV2_ANSWER)
                        ||
                        (((global_msgv2_outgoing_ft_entry *)(n->data))->kind == TOX_FILE_KIND_MESSAGEV2_SYNC)
                    ) {
                        // remove FT data from list
                        tox_utils_list_remove(&global_msgv2_outgoing_ft_list,
                                              friend_pubkey, file_number);

                        free(friend_pubkey);
                        return;
                    }
                }

                n = tox_utils_list_get(&global_msgv2_incoming_ft_list,
                                       friend_pubkey, file_number);

                if (n != NULL) {
                    if (
                        (((global_msgv2_incoming_ft_entry *)(n->data))->kind == TOX_FILE_KIND_MESSAGEV2_SEND)
                        ||
                        (((global_msgv2_incoming_ft_entry *)(n->data))->kind == TOX_FILE_KIND_MESSAGEV2_ANSWER)
                        ||
                        (((global_msgv2_incoming_ft_entry *)(n->data))->kind == TOX_FILE_KIND_MESSAGEV2_SYNC)
                    ) {
                        // remove FT data from list
                        tox_utils_list_remove(&global_msgv2_incoming_ft_list,
                                              friend_pubkey, file_number);

                        free(friend_pubkey);
                        return;
                    }
                }

            }

            free(friend_pubkey);
        }
    }

    // ------- do messageV2 stuff -------

    // ------- call the real CB function -------
    if (tox_utils_filerecvcontrol) {
        tox_utils_filerecvcontrol(tox, friend_number, file_number, control, user_data);
        // Messenger *m = (Messenger *)tox;
        // LOGGER_WARNING(m->log, "toxutil:file_recv_control_cb");
    }

    // ------- call the real CB function -------
}


void tox_utils_file_chunk_request_cb(Tox *tox, uint32_t friend_number, uint32_t file_number,
                                     uint64_t position, size_t length, void *user_data)
{
    // ------- do messageV2 stuff -------
    uint8_t *friend_pubkey = (uint8_t *)calloc(1, TOX_PUBLIC_KEY_SIZE);

    if (friend_pubkey) {
        bool res = tox_utils_friendnum_to_pubkey(tox, friend_pubkey, friend_number);

        if (res == true) {
            tox_utils_Node *n = tox_utils_list_get(&global_msgv2_outgoing_ft_list,
                                                   friend_pubkey, file_number);

            if (n != NULL) {
                if (
                    (((global_msgv2_outgoing_ft_entry *)(n->data))->kind == TOX_FILE_KIND_MESSAGEV2_SEND)
                    ||
                    (((global_msgv2_outgoing_ft_entry *)(n->data))->kind == TOX_FILE_KIND_MESSAGEV2_ANSWER)
                    ||
                    (((global_msgv2_outgoing_ft_entry *)(n->data))->kind == TOX_FILE_KIND_MESSAGEV2_SYNC)
                ) {
                    if (length == 0) {
                        // FT finished
                        // remove FT data from list
                        tox_utils_list_remove(&global_msgv2_outgoing_ft_list,
                                              friend_pubkey, file_number);
                    } else {
                        uint8_t *data_ = ((uint8_t *)((global_msgv2_outgoing_ft_entry *)(n->data))->msg_data);
                        uint64_t filesize = ((global_msgv2_outgoing_ft_entry *)(n->data))->file_size;
                        const uint8_t *data = (const uint8_t *)(data_ + position);

                        if (position >= filesize) {
                            free(friend_pubkey);
                            return;
                        }

                        TOX_ERR_FILE_SEND_CHUNK error_send_chunk;
                        bool result = tox_file_send_chunk(tox, friend_number,
                                                          file_number,
                                                          position, data,
                                                          length, &error_send_chunk);
                    }

                    free(friend_pubkey);
                    return;
                }
            }
        }

        free(friend_pubkey);
    }

    // ------- do messageV2 stuff -------

    // ------- call the real CB function -------
    if (tox_utils_filechunkrequest) {
        tox_utils_filechunkrequest(tox, friend_number, file_number, position, length, user_data);
        // Messenger *m = (Messenger *)tox;
        // LOGGER_WARNING(m->log, "toxutil:file_recv_control_cb");
    }

    // ------- call the real CB function -------
}

void tox_utils_file_recv_cb(Tox *tox, uint32_t friend_number, uint32_t file_number,
                            uint32_t kind, uint64_t file_size,
                            const uint8_t *filename, size_t filename_length, void *user_data)
{
    // ------- do messageV2 stuff -------
    if (
        (kind == TOX_FILE_KIND_MESSAGEV2_SEND)
        ||
        (kind == TOX_FILE_KIND_MESSAGEV2_ANSWER)
        ||
        (kind == TOX_FILE_KIND_MESSAGEV2_SYNC)
    ) {
        global_msgv2_incoming_ft_entry *data = (global_msgv2_incoming_ft_entry *)calloc(1, sizeof(global_msgv2_incoming_ft_entry));

        if (data) {
            data->friend_number = friend_number;
            data->file_number = file_number;
            data->kind = kind;
            data->file_size = file_size;
            Messenger *m = *(Messenger **)tox;
            data->timestamp = current_time_monotonic(m->mono_time);

            uint8_t *friend_pubkey = (uint8_t *)calloc(1, TOX_PUBLIC_KEY_SIZE);

            if (friend_pubkey) {
                bool res = tox_utils_friendnum_to_pubkey(tox, friend_pubkey, friend_number);

                if (res == true) {
                    tox_utils_housekeeping(tox);
                    tox_utils_list_add(&global_msgv2_incoming_ft_list, friend_pubkey,
                                       file_number, data);
                    // Messenger *m = (Messenger *)tox;
                    // LOGGER_WARNING(m->log, "toxutil:file_recv_cb:TOX_FILE_KIND_MESSAGEV2_SEND:%d:%d",
                    //               (int)friend_number, (int)file_number);
                }

                free(friend_pubkey);
            } else {
                free(data);
            }
        }

        return;
    } else if (kind == TOX_FILE_KIND_MESSAGEV2_ALTER) {
    } else {
        // ------- do messageV2 stuff -------

        // ------- call the real CB function -------
        if (tox_utils_filerecv) {
            tox_utils_filerecv(tox, friend_number, file_number, kind, file_size,
                               filename, filename_length, user_data);
            // Messenger *m = (Messenger *)tox;
            // LOGGER_WARNING(m->log, "toxutil:file_recv_cb");
        }

        // ------- call the real CB function -------
    }
}

void tox_utils_file_recv_chunk_cb(Tox *tox, uint32_t friend_number, uint32_t file_number,
                                  uint64_t position, const uint8_t *data, size_t length,
                                  void *user_data)
{
    // ------- do messageV2 stuff -------
    uint8_t *friend_pubkey = (uint8_t *)calloc(1, TOX_PUBLIC_KEY_SIZE);

    if (friend_pubkey) {
        bool res = tox_utils_friendnum_to_pubkey(tox, friend_pubkey, friend_number);

        if (res == true) {
            tox_utils_Node *n = tox_utils_list_get(&global_msgv2_incoming_ft_list,
                                                   friend_pubkey, file_number);

            if (n != NULL) {
                if (((global_msgv2_incoming_ft_entry *)(n->data))->kind == TOX_FILE_KIND_MESSAGEV2_SEND) {
                    if (length == 0) {
                        // FT finished
                        if (tox_utils_friend_message_v2) {
                            const uint8_t *data_ = ((uint8_t *)((global_msgv2_incoming_ft_entry *)
                                                                (n->data))->msg_data);
                            const uint64_t size_ = ((global_msgv2_incoming_ft_entry *)
                                                    (n->data))->file_size;
                            tox_utils_friend_message_v2(tox, friend_number, data_, (size_t)size_);
                        }

                        // remove FT data from list
                        tox_utils_list_remove(&global_msgv2_incoming_ft_list,
                                              friend_pubkey, file_number);
                    } else {
                        // copy chunk into buffer
                        uint8_t *data_ = ((uint8_t *)((global_msgv2_incoming_ft_entry *)(n->data))->msg_data);
                        memcpy((data_ + position), data, length);
                    }

                    free(friend_pubkey);
                    return;
                } else if (((global_msgv2_incoming_ft_entry *)(n->data))->kind == TOX_FILE_KIND_MESSAGEV2_SYNC) {
                    if (length == 0) {
                        // FT finished
                        if (tox_utils_friend_sync_message_v2) {
                            const uint8_t *data_ = ((uint8_t *)((global_msgv2_incoming_ft_entry *)
                                                                (n->data))->msg_data);
                            const uint64_t size_ = ((global_msgv2_incoming_ft_entry *)
                                                    (n->data))->file_size;
                            tox_utils_friend_sync_message_v2(tox, friend_number, data_, (size_t)size_);
                        }

                        // remove FT data from list
                        tox_utils_list_remove(&global_msgv2_incoming_ft_list,
                                              friend_pubkey, file_number);
                    } else {
                        // copy chunk into buffer
                        uint8_t *data_ = ((uint8_t *)((global_msgv2_incoming_ft_entry *)(n->data))->msg_data);
                        memcpy((data_ + position), data, length);
                    }

                    free(friend_pubkey);
                    return;
                } else if (((global_msgv2_incoming_ft_entry *)(n->data))->kind == TOX_FILE_KIND_MESSAGEV2_ANSWER) {
                    if (length == 0) {
                        // FT finished
                        if (tox_utils_friend_read_receipt_message_v2) {
                            const uint8_t *data_ = ((uint8_t *)((global_msgv2_incoming_ft_entry *)
                                                                (n->data))->msg_data);
                            const uint64_t size_ = ((global_msgv2_incoming_ft_entry *)
                                                    (n->data))->file_size;

                            uint32_t answer_raw_size = tox_messagev2_size(0,
                                                       TOX_FILE_KIND_MESSAGEV2_ANSWER,
                                                       0);

                            if (size_ >= answer_raw_size) {

                                const uint32_t ts_sec_ = tox_messagev2_get_ts_sec(data_);
                                uint8_t *msgid_ = (uint8_t *)calloc(1, TOX_PUBLIC_KEY_SIZE);

                                if (msgid_) {
                                    bool res1 = tox_messagev2_get_message_id(data_, msgid_);

                                    if (res1 == true) {
                                        tox_utils_friend_read_receipt_message_v2(tox, friend_number,
                                                ts_sec_, (const uint8_t *)msgid_);
                                    }

                                    free(msgid_);
                                }
                            }

                        }

                        // remove FT data from list
                        tox_utils_list_remove(&global_msgv2_incoming_ft_list,
                                              friend_pubkey, file_number);
                    } else {
                        // copy chunk into buffer
                        uint8_t *data_ = ((uint8_t *)((global_msgv2_incoming_ft_entry *)(n->data))->msg_data);
                        memcpy((data_ + position), data, length);
                    }

                    free(friend_pubkey);
                    return;
                }


            }
        }

        free(friend_pubkey);
    }

    // ------- do messageV2 stuff -------

    // ------- call the real CB function -------
    if (tox_utils_filerecvchunk) {
        tox_utils_filerecvchunk(tox, friend_number, file_number,
                                position, data, length, user_data);
        // Messenger *m = (Messenger *)tox;
        // LOGGER_WARNING(m->log, "toxutil:file_recv_chunk_cb");
    }

    // ------- call the real CB function -------
}


bool tox_util_friend_send_msg_receipt_v2(Tox *tox, uint32_t friend_number, uint8_t *msgid, uint32_t ts_sec)
{
    if (msgid) {
        bool friend_has_msgv2 = tox_utils_get_capabilities(tox, friend_number);

        // DEBUG ==========================
        // DEBUG ==========================
        // friend_has_msgv2 = true;
        // DEBUG ==========================
        // DEBUG ==========================

        if (friend_has_msgv2 == true) {
            uint32_t raw_msg_len = tox_messagev2_size(0, (uint32_t)TOX_FILE_KIND_MESSAGEV2_ANSWER, 0);
            uint8_t *raw_message = (uint8_t *)calloc(1, (size_t)raw_msg_len);

            if (!raw_message) {
                return false;
            }

            bool result = tox_messagev2_wrap(0,
                                             (uint32_t)TOX_FILE_KIND_MESSAGEV2_ANSWER,
                                             0,
                                             NULL, ts_sec,
                                             0,
                                             raw_message,
                                             msgid);

            if (result == true) {
                // ok we have our raw message in "raw_message" and the length in "raw_msg_len"
                // now send it
                const char *filename = "messagev2ack.txt";
                TOX_ERR_FILE_SEND error_send;
                uint32_t file_num_new = tox_file_send(tox, friend_number,
                                                      (uint32_t)TOX_FILE_KIND_MESSAGEV2_ANSWER,
                                                      (uint64_t)raw_msg_len, (const uint8_t *)msgid,
                                                      (const uint8_t *)filename, (size_t)strlen(filename),
                                                      &error_send);

                if ((file_num_new == UINT32_MAX) || (error_send != TOX_ERR_FILE_SEND_OK)) {
                    free(raw_message);
                    return false;
                }

                global_msgv2_outgoing_ft_entry *data = (global_msgv2_outgoing_ft_entry *)calloc(1, sizeof(global_msgv2_outgoing_ft_entry));

                if (data) {
                    data->friend_number = friend_number;
                    data->file_number = file_num_new;
                    data->kind = TOX_FILE_KIND_MESSAGEV2_ANSWER;
                    data->file_size = raw_msg_len;
                    Messenger *m = *(Messenger **)tox;
                    data->timestamp = current_time_monotonic(m->mono_time);

                    if (raw_msg_len <= TOX_MAX_FILETRANSFER_SIZE_MSGV2) {
                        memcpy(data->msg_data, raw_message, raw_msg_len);
                    } else {
                        // HINT: this should never happen
                        memcpy(data->msg_data, raw_message, TOX_MAX_FILETRANSFER_SIZE_MSGV2);
                    }

                    uint8_t *friend_pubkey = (uint8_t *)calloc(1, TOX_PUBLIC_KEY_SIZE);

                    if (friend_pubkey) {
                        bool res = tox_utils_friendnum_to_pubkey(tox, friend_pubkey, friend_number);

                        if (res == true) {
                            tox_utils_housekeeping(tox);
                            tox_utils_list_add(&global_msgv2_outgoing_ft_list, friend_pubkey,
                                               file_num_new, data);
                            //Messenger *m = (Messenger *)tox;
                            //LOGGER_WARNING(m->log,
                            //               "toxutil:tox_util_friend_send_message_v2:TOX_FILE_KIND_MESSAGEV2_ANSWER:%d:%d",
                            //               (int)friend_number, (int)file_num_new);
                        }

                        free(friend_pubkey);
                        free(raw_message);
                        return true;

                    } else {
                        free(data);

                        free(raw_message);
                        return false;
                    }
                }

                free(raw_message);
                return false;
            } else {
                free(raw_message);
                return false;
            }
        } else {
            return false;
        }
    } else {
        return false;
    }
}

bool tox_util_friend_resend_message_v2(Tox *tox, uint32_t friend_number,
                                       const uint8_t *raw_message, const uint32_t raw_msg_len,
                                       TOX_ERR_FRIEND_SEND_MESSAGE *error)
{

    if (error) {
        // TODO: make this better
        // use some "random" error value for now
        *error = TOX_ERR_FRIEND_SEND_MESSAGE_SENDQ;
    }

    uint8_t *msgid = (uint8_t *)calloc(1, TOX_PUBLIC_KEY_SIZE);

    if (!msgid) {
        return false;
    }

    bool res2 = tox_messagev2_get_message_id(raw_message, msgid);

    if (res2 == false) {
        free(msgid);
        return false;
    }

    // now send it
    const char *filename = "messagev2.txt";
    TOX_ERR_FILE_SEND error_send;
    uint32_t file_num_new = tox_file_send(tox, friend_number,
                                          (uint32_t)TOX_FILE_KIND_MESSAGEV2_SEND,
                                          (uint64_t)raw_msg_len, (const uint8_t *)msgid,
                                          (const uint8_t *)filename, (size_t)strlen(filename),
                                          &error_send);

    free(msgid);
    if ((file_num_new == UINT32_MAX) || (error_send != TOX_ERR_FILE_SEND_OK)) {
        return false;
    }

    global_msgv2_outgoing_ft_entry *data = (global_msgv2_outgoing_ft_entry *)calloc(1, sizeof(global_msgv2_outgoing_ft_entry));

    if (data) {
        data->friend_number = friend_number;
        data->file_number = file_num_new;
        data->kind = TOX_FILE_KIND_MESSAGEV2_SEND;
        data->file_size = raw_msg_len;
        Messenger *m = *(Messenger **)tox;
        data->timestamp = current_time_monotonic(m->mono_time);

        if (raw_msg_len <= TOX_MAX_FILETRANSFER_SIZE_MSGV2) {
            memcpy(data->msg_data, raw_message, raw_msg_len);
        } else {
            // HINT: this should never happen
            memcpy(data->msg_data, raw_message, TOX_MAX_FILETRANSFER_SIZE_MSGV2);
        }

        uint8_t *friend_pubkey = (uint8_t *)calloc(1, TOX_PUBLIC_KEY_SIZE);

        if (friend_pubkey) {
            bool res = tox_utils_friendnum_to_pubkey(tox, friend_pubkey, friend_number);

            if (res == true) {
                tox_utils_housekeeping(tox);
                tox_utils_list_add(&global_msgv2_outgoing_ft_list, friend_pubkey,
                                   file_num_new, data);
                //Messenger *m = (Messenger *)tox;
                //LOGGER_WARNING(m->log,
                //               "toxutil:tox_util_friend_resend_message_v2:TOX_FILE_KIND_MESSAGEV2_SEND:%d:%d",
                //               (int)friend_number, (int)file_num_new);
            }

            free(friend_pubkey);
        } else {
            free(data);
        }
    }

    if (error) {
        *error = TOX_ERR_FRIEND_SEND_MESSAGE_OK;
    }

    return true;
}

bool tox_util_friend_send_sync_message_v2(Tox *tox, uint32_t friend_number,
        const uint8_t *raw_message, const uint32_t raw_msg_len,
        TOX_ERR_FRIEND_SEND_MESSAGE *error)
{

    if (error) {
        // TODO: make this better
        // use some "random" error value for now
        *error = TOX_ERR_FRIEND_SEND_MESSAGE_SENDQ;
    }

    uint8_t *msgid = (uint8_t *)calloc(1, TOX_PUBLIC_KEY_SIZE);

    if (!msgid) {
        return false;
    }

    bool res2 = tox_messagev2_get_message_id(raw_message, msgid);

    if (res2 == false) {
        free(msgid);
        return false;
    }

    // now send it
    const char *filename = "messagev2.txt"; // TODO: should sync messages have a different filename?
    TOX_ERR_FILE_SEND error_send;
    uint32_t file_num_new = tox_file_send(tox, friend_number,
                                          (uint32_t)TOX_FILE_KIND_MESSAGEV2_SYNC,
                                          (uint64_t)raw_msg_len, (const uint8_t *)msgid,
                                          (const uint8_t *)filename, (size_t)strlen(filename),
                                          &error_send);

    free(msgid);

    if ((file_num_new == UINT32_MAX) || (error_send != TOX_ERR_FILE_SEND_OK)) {
        return false;
    }

    global_msgv2_outgoing_ft_entry *data = (global_msgv2_outgoing_ft_entry *)calloc(1, sizeof(global_msgv2_outgoing_ft_entry));

    if (data) {
        data->friend_number = friend_number;
        data->file_number = file_num_new;
        data->kind = TOX_FILE_KIND_MESSAGEV2_SYNC;
        data->file_size = raw_msg_len;
        Messenger *m = *(Messenger **)tox;
        data->timestamp = current_time_monotonic(m->mono_time);

        if (raw_msg_len <= TOX_MAX_FILETRANSFER_SIZE_MSGV2) {
            memcpy(data->msg_data, raw_message, raw_msg_len);
        } else {
            // HINT: this should never happen
            memcpy(data->msg_data, raw_message, TOX_MAX_FILETRANSFER_SIZE_MSGV2);
        }

        uint8_t *friend_pubkey = (uint8_t *)calloc(1, TOX_PUBLIC_KEY_SIZE);

        if (friend_pubkey) {
            bool res = tox_utils_friendnum_to_pubkey(tox, friend_pubkey, friend_number);

            if (res == true) {
                tox_utils_housekeeping(tox);
                tox_utils_list_add(&global_msgv2_outgoing_ft_list, friend_pubkey,
                                   file_num_new, data);
                //Messenger *m = (Messenger *)tox;
                //LOGGER_WARNING(m->log,
                //               "toxutil:tox_util_friend_resend_message_v2:TOX_FILE_KIND_MESSAGEV2_SEND:%d:%d",
                //               (int)friend_number, (int)file_num_new);
            }

            free(friend_pubkey);
        } else {
            free(data);
        }
    }

    if (error) {
        *error = TOX_ERR_FRIEND_SEND_MESSAGE_OK;
    }

    return true;
}

int64_t tox_util_friend_send_message_v2(Tox *tox, uint32_t friend_number, TOX_MESSAGE_TYPE type,
                                        uint32_t ts_sec, const uint8_t *message, size_t length,
                                        uint8_t *raw_message_back, uint32_t *raw_msg_len_back,
                                        uint8_t *msgid_back,
                                        TOX_ERR_FRIEND_SEND_MESSAGE *error)
{
    if (message) {
        bool friend_has_msgv2 = tox_utils_get_capabilities(tox, friend_number);

        // DEBUG ==========================
        // DEBUG ==========================
        // friend_has_msgv2 = true;
        // DEBUG ==========================
        // DEBUG ==========================

        if (friend_has_msgv2 == true) {
            if (error) {
                // TODO: make this better
                // use some "random" error value for now
                *error = TOX_ERR_FRIEND_SEND_MESSAGE_SENDQ;
            }

            // indicate messageV2 was used to send
            if (length > TOX_MESSAGEV2_MAX_TEXT_LENGTH) {
                return -1;
            }

            uint32_t raw_msg_len = tox_messagev2_size((uint32_t)length,
                                   (uint32_t)TOX_FILE_KIND_MESSAGEV2_SEND, 0);

            uint8_t *raw_message = (uint8_t *)calloc(1, (size_t)raw_msg_len);

            if (!raw_message) {
                return -1;
            }

            uint8_t *msgid = (uint8_t *)calloc(1, TOX_PUBLIC_KEY_SIZE);

            if (!msgid) {
                free(raw_message);
                return -1;
            }

            bool result = tox_messagev2_wrap((uint32_t)length,
                                             (uint32_t)TOX_FILE_KIND_MESSAGEV2_SEND,
                                             0,
                                             message, ts_sec,
                                             global_ts_ms,
                                             raw_message,
                                             msgid);


// --- DEBUG ---
#if 0
            Messenger *m = *(Messenger **)tox;
            char      data_hex_str[5000];
            get_hex((raw_message + 32 + 4 + 2), (raw_msg_len - 32 - 4 - 2), data_hex_str, 5000, 16);
            LOGGER_WARNING(m->log, "%s", data_hex_str);


            LOGGER_WARNING(m->log,
                           "toxutil:tox_util_friend_send_message_v2:0:FT:%d:%d",
                           (int)raw_msg_len, (int)length);
            LOGGER_WARNING(m->log,
                           "toxutil:tox_util_friend_send_message_v2:A:FT:%s",
                           message);
            LOGGER_WARNING(m->log,
                           "toxutil:tox_util_friend_send_message_v2:B:FT:%s",
                           (char *)(raw_message + 32 + 4 + 2));
#endif
// --- DEBUG ---


            // every message should have an increasing "dummy" ms-timestamp part
            global_ts_ms++;

            if (result == true) {
                // ok we have our raw message in "raw_message" and the length in "raw_msg_len"

                // give raw message and the length back to caller
                if (raw_message_back) {
                    memcpy(raw_message_back, raw_message, raw_msg_len);

                    if (raw_msg_len_back) {
                        *raw_msg_len_back = raw_msg_len;
                    }
                }

                // give message id (= message hash) back to caller
                if (msgid_back) {
                    memcpy(msgid_back, msgid, TOX_PUBLIC_KEY_SIZE);
                }

                // now send it
                const char *filename = "messagev2.txt";
                TOX_ERR_FILE_SEND error_send;
                uint32_t file_num_new = tox_file_send(tox, friend_number,
                                                      (uint32_t)TOX_FILE_KIND_MESSAGEV2_SEND,
                                                      (uint64_t)raw_msg_len, (const uint8_t *)msgid,
                                                      (const uint8_t *)filename, (size_t)strlen(filename),
                                                      &error_send);

                if ((file_num_new == UINT32_MAX) || (error_send != TOX_ERR_FILE_SEND_OK)) {
                    free(raw_message);
                    free(msgid);

                    return -1;
                }

                global_msgv2_outgoing_ft_entry *data = (global_msgv2_outgoing_ft_entry *)calloc(1, sizeof(global_msgv2_outgoing_ft_entry));

                if (data) {
                    data->friend_number = friend_number;
                    data->file_number = file_num_new;
                    data->kind = TOX_FILE_KIND_MESSAGEV2_SEND;
                    data->file_size = raw_msg_len;
                    Messenger *m = *(Messenger **)tox;
                    data->timestamp = current_time_monotonic(m->mono_time);

                    if (raw_msg_len <= TOX_MAX_FILETRANSFER_SIZE_MSGV2) {
                        memcpy(data->msg_data, raw_message, raw_msg_len);
                    } else {
                        // HINT: this should never happen
                        memcpy(data->msg_data, raw_message, TOX_MAX_FILETRANSFER_SIZE_MSGV2);
                    }

                    uint8_t *friend_pubkey = (uint8_t *)calloc(1, TOX_PUBLIC_KEY_SIZE);

                    if (friend_pubkey) {
                        bool res = tox_utils_friendnum_to_pubkey(tox, friend_pubkey, friend_number);

                        if (res == true) {
                            tox_utils_housekeeping(tox);
                            tox_utils_list_add(&global_msgv2_outgoing_ft_list, friend_pubkey,
                                               file_num_new, data);
                            //Messenger *m = (Messenger *)tox;
                            //LOGGER_WARNING(m->log,
                            //               "toxutil:tox_util_friend_send_message_v2:TOX_FILE_KIND_MESSAGEV2_SEND:%d:%d",
                            //               (int)friend_number, (int)file_num_new);
                        }

                        free(friend_pubkey);
                    } else {
                        free(data);
                    }
                }

                if (error) {
                    *error = TOX_ERR_FRIEND_SEND_MESSAGE_OK;
                }
            }

            free(raw_message);
            free(msgid);

            return -1;
        } else {
            // wrap old message send function

            //Messenger *m = (Messenger *)tox;
            //LOGGER_WARNING(m->log,
            //               "toxutil:tox_util_friend_send_message_v2:WRAP-OLD:%d",
            //               (int)friend_number);

            return tox_friend_send_message(tox, friend_number, type, message,
                                           length, error);
        }
    } else {
        return -1;
    }
}

#pragma GCC diagnostic pop

//!TOKSTYLE+
